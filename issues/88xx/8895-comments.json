[
   {
      "body" : "Compiling on OS X, with Xcode 8\r\n```\r\n  CXX      test/test_test_bitcoin-cuckoocache_tests.o\r\nIn file included from test/cuckoocache_tests.cpp:4:\r\nIn file included from /usr/local/include/boost/test/unit_test.hpp:18:\r\nIn file included from /usr/local/include/boost/test/test_tools.hpp:46:\r\nIn file included from /usr/local/include/boost/test/tools/old/impl.hpp:19:\r\nIn file included from /usr/local/include/boost/test/unit_test_log.hpp:24:\r\nIn file included from /usr/local/include/boost/test/utils/wrap_stringstream.hpp:26:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/sstream:174:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream:138:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ios:216:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale:18:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex:177:\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:992:39: error: \r\n      type 'float' cannot be used prior to '::' because it has no members\r\n    : public binary_function<typename _Predicate::first_argument_type,\r\n                                      ^\r\n./cuckoocache.h:206:65: note: in instantiation of template class\r\n      'std::__1::binary_negate<float>' requested here\r\n        depth_limit = std::max((uint8_t)1, static_cast<uint8_t>(std::log...\r\n                                                                ^\r\nIn file included from test/cuckoocache_tests.cpp:4:\r\nIn file included from /usr/local/include/boost/test/unit_test.hpp:18:\r\nIn file included from /usr/local/include/boost/test/test_tools.hpp:46:\r\nIn file included from /usr/local/include/boost/test/tools/old/impl.hpp:19:\r\nIn file included from /usr/local/include/boost/test/unit_test_log.hpp:24:\r\nIn file included from /usr/local/include/boost/test/utils/wrap_stringstream.hpp:26:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/sstream:174:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ostream:138:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/ios:216:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__locale:18:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/mutex:177:\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/functional:1002:36: error: \r\n      type 'float' cannot be used prior to '::' because it has no members\r\n    bool operator()(const typename _Predicate::first_argument_type& __x,\r\n                                   ^\r\nIn file included from test/cuckoocache_tests.cpp:5:\r\n./cuckoocache.h:206:70: error: no member named 'log2' in namespace 'std'\r\n        depth_limit = std::max((uint8_t)1, static_cast<uint8_t>(std::log2(static...\r\n                                                                ~~~~~^\r\n3 errors generated.\r\n```",
      "created_at" : "2016-10-09T10:40:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-252478919",
      "id" : 252478919,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-10-09T10:40:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/252478919",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=3",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "body" : "@fanquake should be fixed, <cmath> wasn't included for some reason.",
      "created_at" : "2016-10-09T13:52:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-252487581",
      "id" : 252487581,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-10-09T13:52:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/252487581",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "Concept ACK and code review ACK.\r\n\r\nI still need to read up on the security/performance guarantees to understand better, but the implementation looks sane.",
      "created_at" : "2016-10-10T17:17:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-252683343",
      "id" : 252683343,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-10-10T17:17:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/252683343",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "Concept ACK, if nothing else the increase in entries-per-byte should be a big win for memory usage.",
      "created_at" : "2016-10-16T14:38:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-254050628",
      "id" : 254050628,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-10-16T14:38:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/254050628",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "I just pushed up 4 commits which further improve the cuckoo cache. These commits add epochs/generations for the cache entries which improves the hit rate. Below is a brief description of the changes, for more detail, see the code & code documentation.\r\n\r\nThe first 2 commits are changes to the tests. The first commit simplifies what is checked in the existing tests (it was over specific to that Cache's design). The second adds a new test which fails under the existing code because the code does not prioritize newer entries.\r\n\r\nThe third patch adds generations to cache which work as follows: a bit vector is used to track if the element belongs to the current or prior generation. Once the number of the current generation's non-deleted elements exceeds ~45%, the generation is retired. The previously retired generation is marked deleted. Because the cache deletes lazily, these entries are still present but are more likely to be overwritten than elements in the currently retired generation. Generations are scanned to see if they should be retired using a heuristic of how many inserts would need to occur since the last scan to exceed the generation size.\r\n\r\nThe fourth commit increases the number of hashes used per element from 2 to 8. The benefit of this change is that it permits using a large generation size (e.g., 45%) compared to 2 hashes (30%). A larger generation size is the \"effective size\" of the cache, i.e., new entries stay in the current generation for longer.\r\n\r\nPerformance is markedly better, especially under attack scenarios. @morcos has run several simulations which back up this claim. \r\n\r\nThere is a slight (1-bit per entry) memory overhead to this approach. This does not negatively impact this cache because the trade off is worth it for intelligently deleting older entries. Only one bit is used for simplicity, as we get three represented states (deleted, old, current). Using more generations (lets say, 1 more bit) would allow for more granular freeing of only the oldest quarter and not half per scan. This has advantages, but also an additional memory cost and two generations was sufficient for this use case.\r\n\r\n\r\n\r\n\r\n\r\nOn a slightly separate note, another side benefit of this cache that I failed to mention when I opened the PR (before these added commits) is that inserts are guaranteed to terminate (in the sigcache currently in master, insert may run forever if GetRand is \"unlucky\").",
      "created_at" : "2016-10-20T21:56:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-255239670",
      "id" : 255239670,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-10-20T21:56:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/255239670",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "I've squashed all the commits (unsquashed still available here if you've already looked at this. https://github.com/bitcoin/bitcoin/compare/master...JeremyRubin:cuckoocache-pull-request-not-squashed). I've also edited the PR message.\r\n\r\nThe current Travis failed build seems to be related to the ongoing Dyn DDoS attack, as Travis is telling me variants of \r\n`The repository at JeremyRubin/bitcoin was not found.` and `The repository at bitcoin/bitcoin was not found.`. When that attack eases, I'll make travis retry.",
      "created_at" : "2016-10-21T18:56:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-255441541",
      "id" : 255441541,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-10-21T18:56:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/255441541",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84566874"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84566874"
         }
      },
      "body" : "Instead of size, store the log2 of the size, and use a bitshift or mask here. Modulus operations are very slow.",
      "commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "created_at" : "2016-10-22T01:22:50Z",
      "diff_hunk" : "@@ -0,0 +1,450 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+    static_assert((sizeof(Element) % 32) == 0, \"Invalid Element Size.\");\n+\n+public:\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 60%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {hash_function.template operator()<0>(e) % size,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84566874",
      "id" : 84566874,
      "original_commit_id" : "3ba2bf4ecca453e926754db35fb6ca3b8141c4e7",
      "original_position" : 216,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 5340391,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-11-10T02:39:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84566874",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581083"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581083"
         }
      },
      "body" : "Yes, this is a rather slow operation, but I don't quite fully understand your operation... doesn't that only work if you're at power of two size?",
      "commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "created_at" : "2016-10-22T17:12:03Z",
      "diff_hunk" : "@@ -0,0 +1,450 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+    static_assert((sizeof(Element) % 32) == 0, \"Invalid Element Size.\");\n+\n+public:\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 60%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {hash_function.template operator()<0>(e) % size,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581083",
      "id" : 84581083,
      "original_commit_id" : "3ba2bf4ecca453e926754db35fb6ca3b8141c4e7",
      "original_position" : 216,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 5352833,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-11-10T02:39:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581083",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581146"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581146"
         }
      },
      "body" : "Yes.",
      "commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "created_at" : "2016-10-22T17:15:12Z",
      "diff_hunk" : "@@ -0,0 +1,450 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+    static_assert((sizeof(Element) % 32) == 0, \"Invalid Element Size.\");\n+\n+public:\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 60%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {hash_function.template operator()<0>(e) % size,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581146",
      "id" : 84581146,
      "original_commit_id" : "3ba2bf4ecca453e926754db35fb6ca3b8141c4e7",
      "original_position" : 216,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 5352886,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-11-10T02:39:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581146",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581354"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581354"
         }
      },
      "body" : "Unfortunately the size currently isn't restricted to be a power of two, and by default is not a power of two. Are you suggesting we limit it to be a power of two?",
      "commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "created_at" : "2016-10-22T17:28:25Z",
      "diff_hunk" : "@@ -0,0 +1,450 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+    static_assert((sizeof(Element) % 32) == 0, \"Invalid Element Size.\");\n+\n+public:\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 60%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {hash_function.template operator()<0>(e) % size,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581354",
      "id" : 84581354,
      "original_commit_id" : "3ba2bf4ecca453e926754db35fb6ca3b8141c4e7",
      "original_position" : 216,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 5353078,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-11-10T02:39:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581354",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581401"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581401"
         }
      },
      "body" : "Yes :) Sorry if that wasn't obvious. We could benchmark whether it matters compared to other operations of course, but restricting to a power of two means you at most get something that's a factor sqrt(2) off of your desired size, which seems acceptable for a cache.",
      "commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "created_at" : "2016-10-22T17:31:08Z",
      "diff_hunk" : "@@ -0,0 +1,450 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+    static_assert((sizeof(Element) % 32) == 0, \"Invalid Element Size.\");\n+\n+public:\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 60%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {hash_function.template operator()<0>(e) % size,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581401",
      "id" : 84581401,
      "original_commit_id" : "3ba2bf4ecca453e926754db35fb6ca3b8141c4e7",
      "original_position" : 216,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 5353120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-11-10T02:39:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581401",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581867"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581867"
         }
      },
      "body" : "Apologies, long rambly response below:\r\n\r\nOverall, I think it's a reasonable idea to do this. Modulo is slow. It's not the bottleneck, but it's a low cost way to make this code faster.\r\n\r\nThere are a couple of weird things though. You have currently about 2 bits of bookkeeping overhead per entry (one bit for erasure, one bit for epoch). If you're restricting to a power of two size for the main cache memory, you also may as well do some of the following if the user specifies more space: more generations for finer grained generations; additional fee tracking to preferentially evict low fee items; some kind of mempool pointer/index map to evict signatures on mempool eviction. (preface: I don't like this idea, but for sake of discussion) You could also keep a large and a small cache and look up from both; letting you target size = 2^m + 2^n.\r\n\r\nAlso, power of two works reasonably well low in the series (1,2,4,8,16,32,64,128) but it seems to be kind of uncomfortably that at say a 1GB cache you have to choose between 1 and 2 GB if you want to increase a little bit. Yes, sqrt, but people have fixed memory sizes so it does kind of matter.\r\n\r\nMaybe a better inbetween would be to do as (roughly) follows (should work on GCC, clang, and msvc):\r\n\r\n    DEFAULT_MAX_SIGCACHE_SIZE = 32;\r\n    #ifdef __MSC_VER\r\n    #include <intrin.h>\r\n    #define __builtin_popcount __popcnt\r\n    #endif\r\n    bool fast_mod = __builtin_popcount(size) == 1;\r\n    compute_hash(E e) {\r\n        if (fast_mod)\r\n            // compute hash with masks\r\n        else\r\n           // compute hash with mod\r\n    }\r\n\r\nand by default not count the bookkeeping bits in the size computation. That way if you pass in a power of two megabytes as the parameter, you get this magic boost in performance, and if you pass in a non power of two if you get what you asked for. The branch shouldn't hurt because it should be easily predicted.\r\n",
      "commit_id" : "78f1c92e5c363725ed1d1a9e47a9e27bb0c7c073",
      "created_at" : "2016-10-22T17:57:51Z",
      "diff_hunk" : "@@ -0,0 +1,450 @@\n+// Copyright (c) 2016 Jeremy Rubin\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef _BITCOIN_CUCKOOCACHE_H_\n+#define _BITCOIN_CUCKOOCACHE_H_\n+\n+#include <algorithm>\n+#include <atomic>\n+#include <cstring>\n+#include <cmath>\n+#include <memory>\n+#include <vector>\n+\n+\n+/** namespace CuckooCache provides high performance cache primitives\n+ *\n+ * Summary:\n+ *\n+ * 1) bit_packed_atomic_flags is bit-packed atomic flags for garbage collection\n+ *\n+ * 2) cache is a cache which is performant in memory usage and lookup speed. It\n+ * is lockfree for erase operations. Elements are lazily erased on the next\n+ * insert.\n+ */\n+namespace CuckooCache\n+{\n+/** bit_packed_atomic_flags implements a container for garbage collection flags\n+ * that is only thread unsafe on calls to setup. This class bit-packs collection\n+ * flags for memory efficiency.\n+ *\n+ * All operations are std::memory_order_relaxed so external mechanisms must\n+ * ensure that writes and reads are properly synchronized.\n+ *\n+ * On setup(n), all bits up to n are marked as collected.\n+ *\n+ * Under the hood, because it is an 8-bit type, it makes sense to use a multiple\n+ * of 8 for setup, but it will be safe if that is not the case as well.\n+ *\n+ */\n+class bit_packed_atomic_flags\n+{\n+    std::unique_ptr<std::atomic<uint8_t>[]> mem;\n+\n+public:\n+    /** No default constructor as there must be some size */\n+    bit_packed_atomic_flags() = delete;\n+\n+    /**\n+     * bit_packed_atomic_flags constructor creates memory to sufficiently\n+     * keep track of garbage collection information for size entries.\n+     *\n+     * @param size the number of elements to allocate space for\n+     *\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * size\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    bit_packed_atomic_flags(uint32_t size)\n+    {\n+        // pad out the size if needed\n+        size = (size + 7) / 8;\n+        mem.reset(new std::atomic<uint8_t>[size]);\n+        for (uint32_t i = 0; i < size; ++i)\n+            mem[i].store(0xFF);\n+    };\n+\n+    /** setup marks all entries and ensures that bit_packed_atomic_flags can store\n+     * at least size entries\n+     *\n+     * @param b the number of elements to allocate space for\n+     * @post bit_set, bit_unset, and bit_is_set function properly forall x. x <\n+     * b\n+     * @post All calls to bit_is_set (without subsequent bit_unset) will return\n+     * true.\n+     */\n+    inline void setup(uint32_t b)\n+    {\n+        bit_packed_atomic_flags d(b);\n+        std::swap(mem, d.mem);\n+    }\n+\n+    /** bit_set sets an entry as discardable. \n+     *\n+     * @param s the index of the entry to bit_set.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == true.\n+     *\n+     */\n+    inline void bit_set(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_or(1 << (s & 7), std::memory_order_relaxed);\n+    }\n+\n+    /**  bit_unset marks an entry as something that should not be overwritten  \n+     *\n+     * @param s the index of the entry to bit_unset.\n+     * @post immediately subsequent call (assuming proper external memory\n+     * ordering) to bit_is_set(s) == false.\n+     */\n+    inline void bit_unset(uint32_t s)\n+    {\n+        mem[s >> 3].fetch_and(~(1 << (s & 7)), std::memory_order_relaxed);\n+    }\n+\n+    /** bit_is_set queries the table for discardability at s\n+     *\n+     * @param s the index of the entry to read.\n+     * @returns if the bit at index s was set.\n+     * */\n+    inline bool bit_is_set(uint32_t s) const\n+    {\n+        return (1 << (s & 7)) & mem[s >> 3].load(std::memory_order_relaxed);\n+    }\n+};\n+\n+/** cache implements a cache with properties similar to a cuckoo-set\n+ *\n+ *  The cache is able to hold up to (~(uint32_t) 1) elements.\n+ *\n+ *  Read Operations:\n+ *      - contains(*, false)\n+ *\n+ *  Read/Erase Operations:\n+ *      - contains(*, true)\n+ *      - allow_erase()\n+ *\n+ *  Write Operations:\n+ *      - setup()\n+ *      - setup_bytes()\n+ *      - insert()\n+ *      - please_keep()\n+ *      - rehash()\n+ *\n+ *  Synchronization Free Operations:\n+ *      - invalid()\n+ *      - compute_hashes()\n+ *\n+ * User Must Guarantee:\n+ *\n+ * 1) Write Requires synchronized access (e.g., a lock)\n+ * 2) Read Requires no concurrent Write, synchronized with the last insert.\n+ * 3) Erase requires no concurrent Write, synchronized with last insert.\n+ * 4) An Eraser must release all Erases before allowing a new Writer.\n+ *\n+ *\n+ * Note on function names:\n+ *   - The name \"allow_erase\" is used because the real discard happens later.\n+ *   - The name \"please_keep\" is used because elements may be erased anyways on insert.\n+ *\n+ * @tparam Element should be a POD type that is 32-alignable\n+ * @tparam Hash should be a function/callable which takes a template parameter\n+ * hash_select and an Element and extracts a hash from it. Should return\n+ * high-entropy hashes for `Hash h; h<0>(e) and h<1>(e)`.\n+ */\n+template <typename Element, typename Hash>\n+class cache\n+{\n+    static_assert((sizeof(Element) % 32) == 0, \"Invalid Element Size.\");\n+\n+public:\n+private:\n+    /** table stores all the elements */\n+    std::vector<Element> table;\n+\n+    /** size stores the total available slots in the hash table */\n+    uint32_t size;\n+\n+    /** The bit_packed_atomic_flags array is marked mutable because we want\n+     * garbage collection to be allowed to occur from const methods */\n+    mutable bit_packed_atomic_flags collection_flags;\n+\n+    /** epoch_flags tracks how recently an element was inserted into\n+     * the cache. true denotes recent, false denotes not-recent. See insert()\n+     * method for full semantics.\n+     */\n+    mutable std::vector<bool> epoch_flags;\n+\n+    /** epoch_heuristic_counter is used to determine when a epoch\n+     * might be aged & an expensive scan should be done.\n+     * epoch_heuristic_counter is incremented on insert and reset to the\n+     * new number of inserts which would cause the epoch to reach\n+     * epoch_size when it reaches zero.\n+     */\n+    uint32_t epoch_heuristic_counter;\n+\n+    /** epoch_size is set to be the number of elements supposed to be in a\n+     * epoch. When the number of non-erased elements in a epoch\n+     * exceeds epoch_size, a new epoch should be started and all\n+     * current entries demoted. epoch_size is set to be 45% of size because\n+     * we want to keep load around 60%, and we support 3 epochs at once --\n+     * one \"dead\" which has been erased, one \"dying\" which has been marked to be\n+     * erased next, and one \"living\" which new inserts add to.\n+     */\n+    uint32_t epoch_size;\n+\n+    /** depth_limit determines how many elements insert should try to replace.\n+     * Should be set to log2(n)*/\n+    uint8_t depth_limit;\n+\n+    /** hash_function is a const instance of the hash function. It cannot be\n+     * static or initialized at call time as it may have internal state (such as\n+     * a nonce).\n+     * */\n+    const Hash hash_function;\n+\n+    /** compute_hashes is convenience for not having to write out this\n+     * expression everywhere we use the hash values of an Element.\n+     *\n+     * @param e the element whose hashes will be returned\n+     * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n+     */\n+    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n+    {\n+        return {hash_function.template operator()<0>(e) % size,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#discussion_r84581867",
      "id" : 84581867,
      "original_commit_id" : "3ba2bf4ecca453e926754db35fb6ca3b8141c4e7",
      "original_position" : 216,
      "path" : "src/cuckoocache.h",
      "position" : null,
      "pull_request_review_id" : 5353560,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8895",
      "updated_at" : "2016-11-10T02:39:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84581867",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "Tested ACK either 3ba2bf4ecca453e926754db35fb6ca3b8141c4e7 or 121dfcd798bda9998dda13fa304be2d0afb7ec82 \r\n\r\nI gave some nits about the comments offline.\r\nI am ambivalent about the change to eliminate modulo. \r\n\r\nI have extensively tested the performance of this patch.  Lock contention on the sig cache is a serious bottleneck to ConnectBlock performance with 8 or more cores.  This patch appears to all but eliminate that contention and leads to a 40% improvement in ConnectBlock time for 16 cores.  It also allows for further performance improvements that would not see any benefit until this bottleneck was removed.\r\n\r\nI have also tested the hit rate performance and it is a significant improvement over the existing sigcache in the event of a spam attack, for a long running node, or in the event of a reorg.\r\n\r\nIn addition to reviewing the included tests, I've also run my own tests and done code review to be sure that there are no false positives.\r\n",
      "created_at" : "2016-10-28T14:13:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-256931331",
      "id" : 256931331,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-10-28T14:13:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/256931331",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "body" : "ACK 453aef4",
      "created_at" : "2016-11-01T14:40:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-257583560",
      "id" : 257583560,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-11-01T14:40:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/257583560",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "body" : "Testing this (OSX 10.12, XCode 8.1):\r\nCompiling threw 1 new warning:\r\n```\r\nIn file included from script/sigcache.cpp:14:\r\n./cuckoocache.h:220:17: warning: suggest braces around initialization of subobject [-Wmissing-braces]\r\n        return {hash_function.template operator()<0>(e) & hash_mask,\r\n                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n./cuckoocache.h:438:40: note: in instantiation of member function 'CuckooCache::cache<uint256, (anonymous\r\n      namespace)::SignatureCacheHasher>::compute_hashes' requested here\r\n        std::array<uint32_t, 8> locs = compute_hashes(e);\r\n                                       ^\r\nscript/sigcache.cpp:70:25: note: in instantiation of member function 'CuckooCache::cache<uint256,\r\n      (anonymous namespace)::SignatureCacheHasher>::contains' requested here\r\n        return setValid.contains(entry, erase);\r\n```\r\n\r\nErrors trying to compile the tests:\r\n```\r\nIn file included from test/cuckoocache_tests.cpp:5:\r\n./cuckoocache.h:218:36: error: implicit instantiation of undefined template 'std::__1::array<unsigned int, 8>'\r\n    inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\r\n                                   ^\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple:116:65: note: template is declared here\r\ntemplate <class _Tp, size_t _Size> struct _LIBCPP_TYPE_VIS_ONLY array;\r\n                                                                ^\r\nIn file included from test/cuckoocache_tests.cpp:5:\r\n./cuckoocache.h:368:33: error: implicit instantiation of undefined template 'std::__1::array<unsigned int, 8>'\r\n        std::array<uint32_t, 8> locs = compute_hashes(e);\r\n                                ^\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple:116:65: note: template is declared here\r\ntemplate <class _Tp, size_t _Size> struct _LIBCPP_TYPE_VIS_ONLY array;\r\n                                                                ^\r\nIn file included from test/cuckoocache_tests.cpp:5:\r\n./cuckoocache.h:438:33: error: implicit instantiation of undefined template 'std::__1::array<unsigned int, 8>'\r\n        std::array<uint32_t, 8> locs = compute_hashes(e);\r\n                                ^\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/__tuple:116:65: note: template is declared here\r\ntemplate <class _Tp, size_t _Size> struct _LIBCPP_TYPE_VIS_ONLY array;\r\n```\r\n```\r\n  CXX      test/test_test_bitcoin-key_tests.o\r\nIn file included from test/cuckoocache_tests.cpp:4:\r\nIn file included from /usr/local/include/boost/test/unit_test.hpp:18:\r\nIn file included from /usr/local/include/boost/test/test_tools.hpp:46:\r\nIn file included from /usr/local/include/boost/test/tools/old/impl.hpp:19:\r\nIn file included from /usr/local/include/boost/test/unit_test_log.hpp:18:\r\nIn file included from /usr/local/include/boost/test/tree/observer.hpp:17:\r\nIn file included from /usr/local/include/boost/test/detail/global_typedef.hpp:15:\r\nIn file included from /usr/local/include/boost/test/utils/basic_cstring/basic_cstring.hpp:21:\r\nIn file included from /usr/local/include/boost/test/utils/basic_cstring/bcs_char_traits.hpp:25:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/string:439:\r\nIn file included from /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/algorithm:628:\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory:1740:31: error: no matching constructor\r\n      for initialization of 'block_activity'\r\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\r\n                              ^   ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory:1656:18: note: in instantiation of\r\n      function template specialization 'std::__1::allocator<block_activity>::construct<block_activity, const unsigned int &, CuckooCache::cache<uint256,\r\n      cuckoocache_tests::uint256Hasher> &>' requested here\r\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\r\n                 ^\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/memory:1502:14: note: in instantiation of\r\n      function template specialization 'std::__1::allocator_traits<std::__1::allocator<block_activity> >::__construct<block_activity, const unsigned int\r\n      &, CuckooCache::cache<uint256, cuckoocache_tests::uint256Hasher> &>' requested here\r\n            {__construct(__has_construct<allocator_type, _Tp*, _Args...>(),\r\n             ^\r\n/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/../include/c++/v1/deque:1801:21: note: in instantiation of\r\n      function template specialization 'std::__1::allocator_traits<std::__1::allocator<block_activity> >::construct<block_activity, const unsigned int &,\r\n      CuckooCache::cache<uint256, cuckoocache_tests::uint256Hasher> &>' requested here\r\n    __alloc_traits::construct(__a, _VSTD::addressof(*__base::end()), _VSTD::forward<_Args>(__args)...);\r\n                    ^\r\ntest/cuckoocache_tests.cpp:368:18: note: in instantiation of function template specialization 'std::__1::deque<block_activity,\r\n      std::__1::allocator<block_activity> >::emplace_back<const unsigned int &, CuckooCache::cache<uint256, cuckoocache_tests::uint256Hasher> &>'\r\n      requested here\r\n        last_few.emplace_back(BLOCK_SIZE, set);\r\n                 ^\r\ntest/cuckoocache_tests.cpp:391:5: note: in instantiation of function template specialization\r\n      'cuckoocache_tests::test_cache_generations<CuckooCache::cache<uint256, cuckoocache_tests::uint256Hasher> >' requested here\r\n    test_cache_generations<CuckooCache::cache<uint256, uint256Hasher>>();\r\n    ^\r\ntest/cuckoocache_tests.cpp:324:12: note: candidate constructor (the implicit move constructor) not viable: requires 1 argument, but 2 were provided\r\n    struct block_activity {\r\n           ^\r\ntest/cuckoocache_tests.cpp:324:12: note: candidate constructor (the implicit copy constructor) not viable: requires 1 argument, but 2 were provided\r\n4 errors generated.\r\n```",
      "created_at" : "2016-11-09T14:55:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-259433117",
      "id" : 259433117,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-11-09T14:55:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/259433117",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=3",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "body" : "@fanquake I think I can fix the warnings but I'm curious as to how much that's a goal given that that flag should be deprecated & there are lots of build errors. Happy to push a squashme if you think so.\r\n\r\nThe build errors should be fixable, must be a different include order or something, I need to add a `#include<array>`.",
      "created_at" : "2016-11-09T21:18:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-259529310",
      "id" : 259529310,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-11-09T21:18:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/259529310",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "@JeremyRubin The warning isn't so much of an issue, was just making a note of it.",
      "created_at" : "2016-11-09T23:19:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-259555316",
      "id" : 259555316,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-11-09T23:19:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/259555316",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=3",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "body" : "@fanquake please confirm fix when you have a moment.",
      "created_at" : "2016-11-10T02:39:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-259587267",
      "id" : 259587267,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-11-10T02:39:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/259587267",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "body" : "@JeremyRubin Everything compiling file now. \r\n\r\nCan you suggest tests/benchmarks that reviewers can run to test the performance increase here, or is that going to be hard for anyone without a-lot of cores?",
      "created_at" : "2016-11-10T02:48:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8895#issuecomment-259588355",
      "id" : 259588355,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8895",
      "updated_at" : "2016-11-10T02:48:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/259588355",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=3",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   }
]
