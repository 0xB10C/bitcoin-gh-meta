[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.",
      "created_at" : "2018-09-27T02:37:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#issuecomment-424937472",
      "id" : 424937472,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14336",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyNDkzNzQ3Mg==",
      "updated_at" : "2018-11-02T15:10:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/424937472",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--32850dd3fdea838b4049e64f46995ea2-->\r\n| Coverage  | Change ([pull 14336](https://drahtbot.github.io/reports/coverage/bitcoin/bitcoin/14336/total.coverage/index.html)) | Reference ([master](https://drahtbot.github.io/reports/coverage/bitcoin/bitcoin/master/total.coverage/index.html))   |\r\n|-----------|-------------------------|--------------------|\r\n| Lines     | +0.0606              | 87.0427          |\r\n| Functions | +0.1868              | 84.1130          |\r\n| Branches  | +0.0435              | 51.5441          |\r\n",
      "created_at" : "2018-09-28T00:25:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#issuecomment-425282679",
      "id" : 425282679,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14336",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyNTI4MjY3OQ==",
      "updated_at" : "2018-09-28T00:25:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/425282679",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "It seems that lots of the functional tests have races cause this pull request keeps triggering random seeming failures.",
      "created_at" : "2018-09-29T00:51:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#issuecomment-425601942",
      "id" : 425601942,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14336",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyNTYwMTk0Mg==",
      "updated_at" : "2018-09-29T00:51:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/425601942",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/620611?v=4",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "node_id" : "MDQ6VXNlcjYyMDYxMQ==",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221419247"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221419247"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`struct pollfd pollfd = {}` instead of `memset`?",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-09-29T07:18:27Z",
      "diff_hunk" : "@@ -1153,310 +1153,407 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     }\n }\n \n-void CConnman::ThreadSocketHandler()\n+void CConnman::DisconnectNodes()\n {\n-    unsigned int nPrevNodeCount = 0;\n-    while (!interruptNet)\n     {\n-        //\n-        // Disconnect nodes\n-        //\n-        {\n-            LOCK(cs_vNodes);\n+        LOCK(cs_vNodes);\n \n-            if (!fNetworkActive) {\n-                // Disconnect any connected nodes\n-                for (CNode* pnode : vNodes) {\n-                    if (!pnode->fDisconnect) {\n-                        LogPrint(BCLog::NET, \"Network not active, dropping peer=%d\\n\", pnode->GetId());\n-                        pnode->fDisconnect = true;\n-                    }\n+        if (!fNetworkActive) {\n+            // Disconnect any connected nodes\n+            for (CNode* pnode : vNodes) {\n+                if (!pnode->fDisconnect) {\n+                    LogPrint(BCLog::NET, \"Network not active, dropping peer=%d\\n\", pnode->GetId());\n+                    pnode->fDisconnect = true;\n                 }\n             }\n+        }\n \n-            // Disconnect unused nodes\n-            std::vector<CNode*> vNodesCopy = vNodes;\n-            for (CNode* pnode : vNodesCopy)\n+        // Disconnect unused nodes\n+        std::vector<CNode*> vNodesCopy = vNodes;\n+        for (CNode* pnode : vNodesCopy)\n+        {\n+            if (pnode->fDisconnect)\n             {\n-                if (pnode->fDisconnect)\n-                {\n-                    // remove from vNodes\n-                    vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n+                // remove from vNodes\n+                vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n \n-                    // release outbound grant (if any)\n-                    pnode->grantOutbound.Release();\n+                // release outbound grant (if any)\n+                pnode->grantOutbound.Release();\n \n-                    // close socket and cleanup\n-                    pnode->CloseSocketDisconnect();\n+                // close socket and cleanup\n+                pnode->CloseSocketDisconnect();\n \n-                    // hold in disconnected pool until all refs are released\n-                    pnode->Release();\n-                    vNodesDisconnected.push_back(pnode);\n-                }\n+                // hold in disconnected pool until all refs are released\n+                pnode->Release();\n+                vNodesDisconnected.push_back(pnode);\n             }\n         }\n+    }\n+    {\n+        // Delete disconnected nodes\n+        std::list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n+        for (CNode* pnode : vNodesDisconnectedCopy)\n         {\n-            // Delete disconnected nodes\n-            std::list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n-            for (CNode* pnode : vNodesDisconnectedCopy)\n-            {\n-                // wait until threads are done using it\n-                if (pnode->GetRefCount() <= 0) {\n-                    bool fDelete = false;\n-                    {\n-                        TRY_LOCK(pnode->cs_inventory, lockInv);\n-                        if (lockInv) {\n-                            TRY_LOCK(pnode->cs_vSend, lockSend);\n-                            if (lockSend) {\n-                                fDelete = true;\n-                            }\n+            // wait until threads are done using it\n+            if (pnode->GetRefCount() <= 0) {\n+                bool fDelete = false;\n+                {\n+                    TRY_LOCK(pnode->cs_inventory, lockInv);\n+                    if (lockInv) {\n+                        TRY_LOCK(pnode->cs_vSend, lockSend);\n+                        if (lockSend) {\n+                            fDelete = true;\n                         }\n                     }\n-                    if (fDelete) {\n-                        vNodesDisconnected.remove(pnode);\n-                        DeleteNode(pnode);\n-                    }\n+                }\n+                if (fDelete) {\n+                    vNodesDisconnected.remove(pnode);\n+                    DeleteNode(pnode);\n                 }\n             }\n         }\n-        size_t vNodesSize;\n+    }\n+}\n+\n+void CConnman::NotifyNumConnectionsChanged()\n+{\n+    size_t vNodesSize;\n+    {\n+        LOCK(cs_vNodes);\n+        vNodesSize = vNodes.size();\n+    }\n+    if(vNodesSize != nPrevNodeCount) {\n+        nPrevNodeCount = vNodesSize;\n+        if(clientInterface)\n+            clientInterface->NotifyNumConnectionsChanged(vNodesSize);\n+    }\n+}\n+\n+void CConnman::InactivityCheck(CNode *pnode)\n+{\n+    int64_t nTime = GetSystemTimeInSeconds();\n+    if (nTime - pnode->nTimeConnected > 60)\n+    {\n+        if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n+        {\n+            LogPrint(BCLog::NET, \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->GetId());\n+            pnode->fDisconnect = true;\n+        }\n+        else if (nTime - pnode->nLastSend > TIMEOUT_INTERVAL)\n         {\n-            LOCK(cs_vNodes);\n-            vNodesSize = vNodes.size();\n+            LogPrintf(\"socket sending timeout: %is\\n\", nTime - pnode->nLastSend);\n+            pnode->fDisconnect = true;\n         }\n-        if(vNodesSize != nPrevNodeCount) {\n-            nPrevNodeCount = vNodesSize;\n-            if(clientInterface)\n-                clientInterface->NotifyNumConnectionsChanged(vNodesSize);\n+        else if (nTime - pnode->nLastRecv > (pnode->nVersion > BIP0031_VERSION ? TIMEOUT_INTERVAL : 90*60))\n+        {\n+            LogPrintf(\"socket receive timeout: %is\\n\", nTime - pnode->nLastRecv);\n+            pnode->fDisconnect = true;\n         }\n-\n-        //\n-        // Find which sockets have data to receive\n-        //\n-        struct timeval timeout;\n-        timeout.tv_sec  = 0;\n-        timeout.tv_usec = 50000; // frequency to poll pnode->vSend\n-\n-        fd_set fdsetRecv;\n-        fd_set fdsetSend;\n-        fd_set fdsetError;\n-        FD_ZERO(&fdsetRecv);\n-        FD_ZERO(&fdsetSend);\n-        FD_ZERO(&fdsetError);\n-        SOCKET hSocketMax = 0;\n-        bool have_fds = false;\n-\n-        for (const ListenSocket& hListenSocket : vhListenSocket) {\n-            FD_SET(hListenSocket.socket, &fdsetRecv);\n-            hSocketMax = std::max(hSocketMax, hListenSocket.socket);\n-            have_fds = true;\n+        else if (pnode->nPingNonceSent && pnode->nPingUsecStart + TIMEOUT_INTERVAL * 1000000 < GetTimeMicros())\n+        {\n+            LogPrintf(\"ping timeout: %fs\\n\", 0.000001 * (GetTimeMicros() - pnode->nPingUsecStart));\n+            pnode->fDisconnect = true;\n         }\n+        else if (!pnode->fSuccessfullyConnected)\n+        {\n+            LogPrint(BCLog::NET, \"version handshake timeout from %d\\n\", pnode->GetId());\n+            pnode->fDisconnect = true;\n+        }\n+    }\n+}\n \n+void CConnman::GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    for (const ListenSocket& hListenSocket : vhListenSocket) {\n+        recv_set.insert(hListenSocket.socket);\n+    }\n+\n+    {\n+        LOCK(cs_vNodes);\n+        for (CNode* pnode : vNodes)\n         {\n-            LOCK(cs_vNodes);\n-            for (CNode* pnode : vNodes)\n+            // Implement the following logic:\n+            // * If there is data to send, select() for sending data. As this only\n+            //   happens when optimistic write failed, we choose to first drain the\n+            //   write buffer in this case before receiving more. This avoids\n+            //   needlessly queueing received data, if the remote peer is not themselves\n+            //   receiving data. This means properly utilizing TCP flow control signalling.\n+            // * Otherwise, if there is space left in the receive buffer, select() for\n+            //   receiving data.\n+            // * Hand off all complete messages to the processor, to be handled without\n+            //   blocking here.\n+\n+            bool select_recv = !pnode->fPauseRecv;\n+            bool select_send;\n             {\n-                // Implement the following logic:\n-                // * If there is data to send, select() for sending data. As this only\n-                //   happens when optimistic write failed, we choose to first drain the\n-                //   write buffer in this case before receiving more. This avoids\n-                //   needlessly queueing received data, if the remote peer is not themselves\n-                //   receiving data. This means properly utilizing TCP flow control signalling.\n-                // * Otherwise, if there is space left in the receive buffer, select() for\n-                //   receiving data.\n-                // * Hand off all complete messages to the processor, to be handled without\n-                //   blocking here.\n-\n-                bool select_recv = !pnode->fPauseRecv;\n-                bool select_send;\n-                {\n-                    LOCK(pnode->cs_vSend);\n-                    select_send = !pnode->vSendMsg.empty();\n-                }\n-\n-                LOCK(pnode->cs_hSocket);\n-                if (pnode->hSocket == INVALID_SOCKET)\n-                    continue;\n+                LOCK(pnode->cs_vSend);\n+                select_send = !pnode->vSendMsg.empty();\n+            }\n \n-                FD_SET(pnode->hSocket, &fdsetError);\n-                hSocketMax = std::max(hSocketMax, pnode->hSocket);\n-                have_fds = true;\n+            LOCK(pnode->cs_hSocket);\n+            if (pnode->hSocket == INVALID_SOCKET)\n+                continue;\n \n-                if (select_send) {\n-                    FD_SET(pnode->hSocket, &fdsetSend);\n-                    continue;\n-                }\n-                if (select_recv) {\n-                    FD_SET(pnode->hSocket, &fdsetRecv);\n-                }\n+            error_set.insert(pnode->hSocket);\n+            if (select_send) {\n+                send_set.insert(pnode->hSocket);\n+                continue;\n+            }\n+            if (select_recv) {\n+                recv_set.insert(pnode->hSocket);\n             }\n         }\n+    }\n+}\n \n-        int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n-                             &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n-        if (interruptNet)\n+#ifdef WIN32\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    //\n+    // Find which sockets have data to receive\n+    //\n+    struct timeval timeout;\n+    timeout.tv_sec  = 0;\n+    timeout.tv_usec = 50000; // frequency to poll pnode->vSend\n+\n+    fd_set fdsetRecv;\n+    fd_set fdsetSend;\n+    fd_set fdsetError;\n+    FD_ZERO(&fdsetRecv);\n+    FD_ZERO(&fdsetSend);\n+    FD_ZERO(&fdsetError);\n+    SOCKET hSocketMax = 0;\n+\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n+\n+    if (recv_select_set.empty() && send_select_set.empty() && error_select_set.empty()) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(50));\n+        return;\n+    }\n+\n+    for (SOCKET hSocket : recv_select_set) {\n+        FD_SET(hSocket, &fdsetRecv);\n+        hSocketMax = std::max(hSocketMax, hSocket);\n+    }\n+\n+    for (SOCKET hSocket : send_select_set) {\n+        FD_SET(hSocket, &fdsetSend);\n+        hSocketMax = std::max(hSocketMax, hSocket);\n+    }\n+\n+    for (SOCKET hSocket : error_select_set) {\n+        FD_SET(hSocket, &fdsetError);\n+        hSocketMax = std::max(hSocketMax, hSocket);\n+    }\n+\n+    int nSelect = select(hSocketMax + 1, &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n+\n+    if (nSelect == SOCKET_ERROR)\n+    {\n+        int nErr = WSAGetLastError();\n+        LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n+        for (unsigned int i = 0; i <= hSocketMax; i++)\n+            FD_SET(i, &fdsetRecv);\n+        FD_ZERO(&fdsetSend);\n+        FD_ZERO(&fdsetError);\n+        if (!interruptNet.sleep_for(std::chrono::milliseconds(timeout.tv_usec/1000)))\n             return;\n+    }\n \n-        if (nSelect == SOCKET_ERROR)\n-        {\n-            if (have_fds)\n-            {\n-                int nErr = WSAGetLastError();\n-                LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n-                for (unsigned int i = 0; i <= hSocketMax; i++)\n-                    FD_SET(i, &fdsetRecv);\n-            }\n-            FD_ZERO(&fdsetSend);\n-            FD_ZERO(&fdsetError);\n-            if (!interruptNet.sleep_for(std::chrono::milliseconds(timeout.tv_usec/1000)))\n-                return;\n-        }\n+    for (SOCKET hSocket : recv_select_set)\n+        if(FD_ISSET(hSocket, &fdsetRecv))\n+            recv_set.insert(hSocket);\n \n-        //\n-        // Accept new connections\n-        //\n-        for (const ListenSocket& hListenSocket : vhListenSocket)\n+    for (SOCKET hSocket : send_select_set)\n+        if(FD_ISSET(hSocket, &fdsetSend))\n+            send_set.insert(hSocket);\n+\n+    for (SOCKET hSocket : error_select_set)\n+        if(FD_ISSET(hSocket, &fdsetError))\n+            error_set.insert(hSocket);\n+}\n+#else\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n+\n+    if (recv_select_set.empty() && send_select_set.empty() and error_select_set.empty()) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(50));\n+        return;\n+    }\n+\n+    if (interruptNet)\n+        return;\n+\n+    std::vector<struct pollfd> pollfds;\n+    struct pollfd pollfd;\n+    memset(&pollfd, 0, sizeof(struct pollfd));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221419247",
      "id" : 221419247,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQxOTI0Nw==",
      "original_commit_id" : "7fd976b2f0abab75c81ab8923daba286831d5260",
      "original_position" : 370,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 160070420,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221419247",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221419285"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221419285"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`recvSet = recv_set.count(pnode->hSocket) > 0` to avoid implicit conversion from `unsigned long` to `bool`. Applies also to the following to lines. Explicit is better than implicit :-)",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-09-29T07:20:21Z",
      "diff_hunk" : "@@ -1153,310 +1153,407 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     }\n }\n \n-void CConnman::ThreadSocketHandler()\n+void CConnman::DisconnectNodes()\n {\n-    unsigned int nPrevNodeCount = 0;\n-    while (!interruptNet)\n     {\n-        //\n-        // Disconnect nodes\n-        //\n-        {\n-            LOCK(cs_vNodes);\n+        LOCK(cs_vNodes);\n \n-            if (!fNetworkActive) {\n-                // Disconnect any connected nodes\n-                for (CNode* pnode : vNodes) {\n-                    if (!pnode->fDisconnect) {\n-                        LogPrint(BCLog::NET, \"Network not active, dropping peer=%d\\n\", pnode->GetId());\n-                        pnode->fDisconnect = true;\n-                    }\n+        if (!fNetworkActive) {\n+            // Disconnect any connected nodes\n+            for (CNode* pnode : vNodes) {\n+                if (!pnode->fDisconnect) {\n+                    LogPrint(BCLog::NET, \"Network not active, dropping peer=%d\\n\", pnode->GetId());\n+                    pnode->fDisconnect = true;\n                 }\n             }\n+        }\n \n-            // Disconnect unused nodes\n-            std::vector<CNode*> vNodesCopy = vNodes;\n-            for (CNode* pnode : vNodesCopy)\n+        // Disconnect unused nodes\n+        std::vector<CNode*> vNodesCopy = vNodes;\n+        for (CNode* pnode : vNodesCopy)\n+        {\n+            if (pnode->fDisconnect)\n             {\n-                if (pnode->fDisconnect)\n-                {\n-                    // remove from vNodes\n-                    vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n+                // remove from vNodes\n+                vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n \n-                    // release outbound grant (if any)\n-                    pnode->grantOutbound.Release();\n+                // release outbound grant (if any)\n+                pnode->grantOutbound.Release();\n \n-                    // close socket and cleanup\n-                    pnode->CloseSocketDisconnect();\n+                // close socket and cleanup\n+                pnode->CloseSocketDisconnect();\n \n-                    // hold in disconnected pool until all refs are released\n-                    pnode->Release();\n-                    vNodesDisconnected.push_back(pnode);\n-                }\n+                // hold in disconnected pool until all refs are released\n+                pnode->Release();\n+                vNodesDisconnected.push_back(pnode);\n             }\n         }\n+    }\n+    {\n+        // Delete disconnected nodes\n+        std::list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n+        for (CNode* pnode : vNodesDisconnectedCopy)\n         {\n-            // Delete disconnected nodes\n-            std::list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n-            for (CNode* pnode : vNodesDisconnectedCopy)\n-            {\n-                // wait until threads are done using it\n-                if (pnode->GetRefCount() <= 0) {\n-                    bool fDelete = false;\n-                    {\n-                        TRY_LOCK(pnode->cs_inventory, lockInv);\n-                        if (lockInv) {\n-                            TRY_LOCK(pnode->cs_vSend, lockSend);\n-                            if (lockSend) {\n-                                fDelete = true;\n-                            }\n+            // wait until threads are done using it\n+            if (pnode->GetRefCount() <= 0) {\n+                bool fDelete = false;\n+                {\n+                    TRY_LOCK(pnode->cs_inventory, lockInv);\n+                    if (lockInv) {\n+                        TRY_LOCK(pnode->cs_vSend, lockSend);\n+                        if (lockSend) {\n+                            fDelete = true;\n                         }\n                     }\n-                    if (fDelete) {\n-                        vNodesDisconnected.remove(pnode);\n-                        DeleteNode(pnode);\n-                    }\n+                }\n+                if (fDelete) {\n+                    vNodesDisconnected.remove(pnode);\n+                    DeleteNode(pnode);\n                 }\n             }\n         }\n-        size_t vNodesSize;\n+    }\n+}\n+\n+void CConnman::NotifyNumConnectionsChanged()\n+{\n+    size_t vNodesSize;\n+    {\n+        LOCK(cs_vNodes);\n+        vNodesSize = vNodes.size();\n+    }\n+    if(vNodesSize != nPrevNodeCount) {\n+        nPrevNodeCount = vNodesSize;\n+        if(clientInterface)\n+            clientInterface->NotifyNumConnectionsChanged(vNodesSize);\n+    }\n+}\n+\n+void CConnman::InactivityCheck(CNode *pnode)\n+{\n+    int64_t nTime = GetSystemTimeInSeconds();\n+    if (nTime - pnode->nTimeConnected > 60)\n+    {\n+        if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n+        {\n+            LogPrint(BCLog::NET, \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->GetId());\n+            pnode->fDisconnect = true;\n+        }\n+        else if (nTime - pnode->nLastSend > TIMEOUT_INTERVAL)\n         {\n-            LOCK(cs_vNodes);\n-            vNodesSize = vNodes.size();\n+            LogPrintf(\"socket sending timeout: %is\\n\", nTime - pnode->nLastSend);\n+            pnode->fDisconnect = true;\n         }\n-        if(vNodesSize != nPrevNodeCount) {\n-            nPrevNodeCount = vNodesSize;\n-            if(clientInterface)\n-                clientInterface->NotifyNumConnectionsChanged(vNodesSize);\n+        else if (nTime - pnode->nLastRecv > (pnode->nVersion > BIP0031_VERSION ? TIMEOUT_INTERVAL : 90*60))\n+        {\n+            LogPrintf(\"socket receive timeout: %is\\n\", nTime - pnode->nLastRecv);\n+            pnode->fDisconnect = true;\n         }\n-\n-        //\n-        // Find which sockets have data to receive\n-        //\n-        struct timeval timeout;\n-        timeout.tv_sec  = 0;\n-        timeout.tv_usec = 50000; // frequency to poll pnode->vSend\n-\n-        fd_set fdsetRecv;\n-        fd_set fdsetSend;\n-        fd_set fdsetError;\n-        FD_ZERO(&fdsetRecv);\n-        FD_ZERO(&fdsetSend);\n-        FD_ZERO(&fdsetError);\n-        SOCKET hSocketMax = 0;\n-        bool have_fds = false;\n-\n-        for (const ListenSocket& hListenSocket : vhListenSocket) {\n-            FD_SET(hListenSocket.socket, &fdsetRecv);\n-            hSocketMax = std::max(hSocketMax, hListenSocket.socket);\n-            have_fds = true;\n+        else if (pnode->nPingNonceSent && pnode->nPingUsecStart + TIMEOUT_INTERVAL * 1000000 < GetTimeMicros())\n+        {\n+            LogPrintf(\"ping timeout: %fs\\n\", 0.000001 * (GetTimeMicros() - pnode->nPingUsecStart));\n+            pnode->fDisconnect = true;\n         }\n+        else if (!pnode->fSuccessfullyConnected)\n+        {\n+            LogPrint(BCLog::NET, \"version handshake timeout from %d\\n\", pnode->GetId());\n+            pnode->fDisconnect = true;\n+        }\n+    }\n+}\n \n+void CConnman::GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    for (const ListenSocket& hListenSocket : vhListenSocket) {\n+        recv_set.insert(hListenSocket.socket);\n+    }\n+\n+    {\n+        LOCK(cs_vNodes);\n+        for (CNode* pnode : vNodes)\n         {\n-            LOCK(cs_vNodes);\n-            for (CNode* pnode : vNodes)\n+            // Implement the following logic:\n+            // * If there is data to send, select() for sending data. As this only\n+            //   happens when optimistic write failed, we choose to first drain the\n+            //   write buffer in this case before receiving more. This avoids\n+            //   needlessly queueing received data, if the remote peer is not themselves\n+            //   receiving data. This means properly utilizing TCP flow control signalling.\n+            // * Otherwise, if there is space left in the receive buffer, select() for\n+            //   receiving data.\n+            // * Hand off all complete messages to the processor, to be handled without\n+            //   blocking here.\n+\n+            bool select_recv = !pnode->fPauseRecv;\n+            bool select_send;\n             {\n-                // Implement the following logic:\n-                // * If there is data to send, select() for sending data. As this only\n-                //   happens when optimistic write failed, we choose to first drain the\n-                //   write buffer in this case before receiving more. This avoids\n-                //   needlessly queueing received data, if the remote peer is not themselves\n-                //   receiving data. This means properly utilizing TCP flow control signalling.\n-                // * Otherwise, if there is space left in the receive buffer, select() for\n-                //   receiving data.\n-                // * Hand off all complete messages to the processor, to be handled without\n-                //   blocking here.\n-\n-                bool select_recv = !pnode->fPauseRecv;\n-                bool select_send;\n-                {\n-                    LOCK(pnode->cs_vSend);\n-                    select_send = !pnode->vSendMsg.empty();\n-                }\n-\n-                LOCK(pnode->cs_hSocket);\n-                if (pnode->hSocket == INVALID_SOCKET)\n-                    continue;\n+                LOCK(pnode->cs_vSend);\n+                select_send = !pnode->vSendMsg.empty();\n+            }\n \n-                FD_SET(pnode->hSocket, &fdsetError);\n-                hSocketMax = std::max(hSocketMax, pnode->hSocket);\n-                have_fds = true;\n+            LOCK(pnode->cs_hSocket);\n+            if (pnode->hSocket == INVALID_SOCKET)\n+                continue;\n \n-                if (select_send) {\n-                    FD_SET(pnode->hSocket, &fdsetSend);\n-                    continue;\n-                }\n-                if (select_recv) {\n-                    FD_SET(pnode->hSocket, &fdsetRecv);\n-                }\n+            error_set.insert(pnode->hSocket);\n+            if (select_send) {\n+                send_set.insert(pnode->hSocket);\n+                continue;\n+            }\n+            if (select_recv) {\n+                recv_set.insert(pnode->hSocket);\n             }\n         }\n+    }\n+}\n \n-        int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n-                             &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n-        if (interruptNet)\n+#ifdef WIN32\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    //\n+    // Find which sockets have data to receive\n+    //\n+    struct timeval timeout;\n+    timeout.tv_sec  = 0;\n+    timeout.tv_usec = 50000; // frequency to poll pnode->vSend\n+\n+    fd_set fdsetRecv;\n+    fd_set fdsetSend;\n+    fd_set fdsetError;\n+    FD_ZERO(&fdsetRecv);\n+    FD_ZERO(&fdsetSend);\n+    FD_ZERO(&fdsetError);\n+    SOCKET hSocketMax = 0;\n+\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n+\n+    if (recv_select_set.empty() && send_select_set.empty() && error_select_set.empty()) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(50));\n+        return;\n+    }\n+\n+    for (SOCKET hSocket : recv_select_set) {\n+        FD_SET(hSocket, &fdsetRecv);\n+        hSocketMax = std::max(hSocketMax, hSocket);\n+    }\n+\n+    for (SOCKET hSocket : send_select_set) {\n+        FD_SET(hSocket, &fdsetSend);\n+        hSocketMax = std::max(hSocketMax, hSocket);\n+    }\n+\n+    for (SOCKET hSocket : error_select_set) {\n+        FD_SET(hSocket, &fdsetError);\n+        hSocketMax = std::max(hSocketMax, hSocket);\n+    }\n+\n+    int nSelect = select(hSocketMax + 1, &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n+\n+    if (nSelect == SOCKET_ERROR)\n+    {\n+        int nErr = WSAGetLastError();\n+        LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n+        for (unsigned int i = 0; i <= hSocketMax; i++)\n+            FD_SET(i, &fdsetRecv);\n+        FD_ZERO(&fdsetSend);\n+        FD_ZERO(&fdsetError);\n+        if (!interruptNet.sleep_for(std::chrono::milliseconds(timeout.tv_usec/1000)))\n             return;\n+    }\n \n-        if (nSelect == SOCKET_ERROR)\n-        {\n-            if (have_fds)\n-            {\n-                int nErr = WSAGetLastError();\n-                LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n-                for (unsigned int i = 0; i <= hSocketMax; i++)\n-                    FD_SET(i, &fdsetRecv);\n-            }\n-            FD_ZERO(&fdsetSend);\n-            FD_ZERO(&fdsetError);\n-            if (!interruptNet.sleep_for(std::chrono::milliseconds(timeout.tv_usec/1000)))\n-                return;\n-        }\n+    for (SOCKET hSocket : recv_select_set)\n+        if(FD_ISSET(hSocket, &fdsetRecv))\n+            recv_set.insert(hSocket);\n \n-        //\n-        // Accept new connections\n-        //\n-        for (const ListenSocket& hListenSocket : vhListenSocket)\n+    for (SOCKET hSocket : send_select_set)\n+        if(FD_ISSET(hSocket, &fdsetSend))\n+            send_set.insert(hSocket);\n+\n+    for (SOCKET hSocket : error_select_set)\n+        if(FD_ISSET(hSocket, &fdsetError))\n+            error_set.insert(hSocket);\n+}\n+#else\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n+\n+    if (recv_select_set.empty() && send_select_set.empty() and error_select_set.empty()) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(50));\n+        return;\n+    }\n+\n+    if (interruptNet)\n+        return;\n+\n+    std::vector<struct pollfd> pollfds;\n+    struct pollfd pollfd;\n+    memset(&pollfd, 0, sizeof(struct pollfd));\n+\n+    for (SOCKET hSocket : recv_select_set) {\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLIN;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    for (SOCKET hSocket : send_select_set) {\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLOUT;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    for (SOCKET hSocket : error_select_set) {\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLERR|POLLHUP;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    if(poll(&pollfds[0], pollfds.size(), 50) < 0)\n+        LogPrint(BCLog::NET, \"poll failure %d %s\\n\", errno, strerror(errno));\n+\n+    for (struct pollfd pollfd : pollfds) {\n+        if (pollfd.revents & POLLIN)\n+            recv_set.insert(pollfd.fd);\n+        if (pollfd.revents & POLLOUT)\n+            send_set.insert(pollfd.fd);\n+        if (pollfd.revents & (POLLERR|POLLHUP))\n+            error_set.insert(pollfd.fd);\n+    }\n+}\n+#endif\n+\n+void CConnman::SocketHandler()\n+{\n+    std::set<SOCKET> recv_set, send_set, error_set;\n+    SocketEvents(recv_set, send_set, error_set);\n+\n+    if (interruptNet)\n+        return;\n+\n+    //\n+    // Accept new connections\n+    //\n+    for (const ListenSocket& hListenSocket : vhListenSocket)\n+    {\n+        if (hListenSocket.socket != INVALID_SOCKET && recv_set.count(hListenSocket.socket))\n         {\n-            if (hListenSocket.socket != INVALID_SOCKET && FD_ISSET(hListenSocket.socket, &fdsetRecv))\n-            {\n-                AcceptConnection(hListenSocket);\n-            }\n+            AcceptConnection(hListenSocket);\n         }\n+    }\n+\n+    //\n+    // Service each socket\n+    //\n+    std::vector<CNode*> vNodesCopy;\n+    {\n+        LOCK(cs_vNodes);\n+        vNodesCopy = vNodes;\n+        for (CNode* pnode : vNodesCopy)\n+            pnode->AddRef();\n+    }\n+    for (CNode* pnode : vNodesCopy)\n+    {\n+        if (interruptNet)\n+            return;\n \n         //\n-        // Service each socket\n+        // Receive\n         //\n-        std::vector<CNode*> vNodesCopy;\n+        bool recvSet = false;\n+        bool sendSet = false;\n+        bool errorSet = false;\n         {\n-            LOCK(cs_vNodes);\n-            vNodesCopy = vNodes;\n-            for (CNode* pnode : vNodesCopy)\n-                pnode->AddRef();\n+            LOCK(pnode->cs_hSocket);\n+            if (pnode->hSocket == INVALID_SOCKET)\n+                continue;\n+            recvSet = recv_set.count(pnode->hSocket);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221419285",
      "id" : 221419285,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQxOTI4NQ==",
      "original_commit_id" : "7fd976b2f0abab75c81ab8923daba286831d5260",
      "original_position" : 458,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 160070469,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221419285",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221419345"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221419345"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Use `&&` instead of `and` :-)",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-09-29T07:22:12Z",
      "diff_hunk" : "@@ -1153,310 +1153,407 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     }\n }\n \n-void CConnman::ThreadSocketHandler()\n+void CConnman::DisconnectNodes()\n {\n-    unsigned int nPrevNodeCount = 0;\n-    while (!interruptNet)\n     {\n-        //\n-        // Disconnect nodes\n-        //\n-        {\n-            LOCK(cs_vNodes);\n+        LOCK(cs_vNodes);\n \n-            if (!fNetworkActive) {\n-                // Disconnect any connected nodes\n-                for (CNode* pnode : vNodes) {\n-                    if (!pnode->fDisconnect) {\n-                        LogPrint(BCLog::NET, \"Network not active, dropping peer=%d\\n\", pnode->GetId());\n-                        pnode->fDisconnect = true;\n-                    }\n+        if (!fNetworkActive) {\n+            // Disconnect any connected nodes\n+            for (CNode* pnode : vNodes) {\n+                if (!pnode->fDisconnect) {\n+                    LogPrint(BCLog::NET, \"Network not active, dropping peer=%d\\n\", pnode->GetId());\n+                    pnode->fDisconnect = true;\n                 }\n             }\n+        }\n \n-            // Disconnect unused nodes\n-            std::vector<CNode*> vNodesCopy = vNodes;\n-            for (CNode* pnode : vNodesCopy)\n+        // Disconnect unused nodes\n+        std::vector<CNode*> vNodesCopy = vNodes;\n+        for (CNode* pnode : vNodesCopy)\n+        {\n+            if (pnode->fDisconnect)\n             {\n-                if (pnode->fDisconnect)\n-                {\n-                    // remove from vNodes\n-                    vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n+                // remove from vNodes\n+                vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n \n-                    // release outbound grant (if any)\n-                    pnode->grantOutbound.Release();\n+                // release outbound grant (if any)\n+                pnode->grantOutbound.Release();\n \n-                    // close socket and cleanup\n-                    pnode->CloseSocketDisconnect();\n+                // close socket and cleanup\n+                pnode->CloseSocketDisconnect();\n \n-                    // hold in disconnected pool until all refs are released\n-                    pnode->Release();\n-                    vNodesDisconnected.push_back(pnode);\n-                }\n+                // hold in disconnected pool until all refs are released\n+                pnode->Release();\n+                vNodesDisconnected.push_back(pnode);\n             }\n         }\n+    }\n+    {\n+        // Delete disconnected nodes\n+        std::list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n+        for (CNode* pnode : vNodesDisconnectedCopy)\n         {\n-            // Delete disconnected nodes\n-            std::list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n-            for (CNode* pnode : vNodesDisconnectedCopy)\n-            {\n-                // wait until threads are done using it\n-                if (pnode->GetRefCount() <= 0) {\n-                    bool fDelete = false;\n-                    {\n-                        TRY_LOCK(pnode->cs_inventory, lockInv);\n-                        if (lockInv) {\n-                            TRY_LOCK(pnode->cs_vSend, lockSend);\n-                            if (lockSend) {\n-                                fDelete = true;\n-                            }\n+            // wait until threads are done using it\n+            if (pnode->GetRefCount() <= 0) {\n+                bool fDelete = false;\n+                {\n+                    TRY_LOCK(pnode->cs_inventory, lockInv);\n+                    if (lockInv) {\n+                        TRY_LOCK(pnode->cs_vSend, lockSend);\n+                        if (lockSend) {\n+                            fDelete = true;\n                         }\n                     }\n-                    if (fDelete) {\n-                        vNodesDisconnected.remove(pnode);\n-                        DeleteNode(pnode);\n-                    }\n+                }\n+                if (fDelete) {\n+                    vNodesDisconnected.remove(pnode);\n+                    DeleteNode(pnode);\n                 }\n             }\n         }\n-        size_t vNodesSize;\n+    }\n+}\n+\n+void CConnman::NotifyNumConnectionsChanged()\n+{\n+    size_t vNodesSize;\n+    {\n+        LOCK(cs_vNodes);\n+        vNodesSize = vNodes.size();\n+    }\n+    if(vNodesSize != nPrevNodeCount) {\n+        nPrevNodeCount = vNodesSize;\n+        if(clientInterface)\n+            clientInterface->NotifyNumConnectionsChanged(vNodesSize);\n+    }\n+}\n+\n+void CConnman::InactivityCheck(CNode *pnode)\n+{\n+    int64_t nTime = GetSystemTimeInSeconds();\n+    if (nTime - pnode->nTimeConnected > 60)\n+    {\n+        if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n+        {\n+            LogPrint(BCLog::NET, \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->GetId());\n+            pnode->fDisconnect = true;\n+        }\n+        else if (nTime - pnode->nLastSend > TIMEOUT_INTERVAL)\n         {\n-            LOCK(cs_vNodes);\n-            vNodesSize = vNodes.size();\n+            LogPrintf(\"socket sending timeout: %is\\n\", nTime - pnode->nLastSend);\n+            pnode->fDisconnect = true;\n         }\n-        if(vNodesSize != nPrevNodeCount) {\n-            nPrevNodeCount = vNodesSize;\n-            if(clientInterface)\n-                clientInterface->NotifyNumConnectionsChanged(vNodesSize);\n+        else if (nTime - pnode->nLastRecv > (pnode->nVersion > BIP0031_VERSION ? TIMEOUT_INTERVAL : 90*60))\n+        {\n+            LogPrintf(\"socket receive timeout: %is\\n\", nTime - pnode->nLastRecv);\n+            pnode->fDisconnect = true;\n         }\n-\n-        //\n-        // Find which sockets have data to receive\n-        //\n-        struct timeval timeout;\n-        timeout.tv_sec  = 0;\n-        timeout.tv_usec = 50000; // frequency to poll pnode->vSend\n-\n-        fd_set fdsetRecv;\n-        fd_set fdsetSend;\n-        fd_set fdsetError;\n-        FD_ZERO(&fdsetRecv);\n-        FD_ZERO(&fdsetSend);\n-        FD_ZERO(&fdsetError);\n-        SOCKET hSocketMax = 0;\n-        bool have_fds = false;\n-\n-        for (const ListenSocket& hListenSocket : vhListenSocket) {\n-            FD_SET(hListenSocket.socket, &fdsetRecv);\n-            hSocketMax = std::max(hSocketMax, hListenSocket.socket);\n-            have_fds = true;\n+        else if (pnode->nPingNonceSent && pnode->nPingUsecStart + TIMEOUT_INTERVAL * 1000000 < GetTimeMicros())\n+        {\n+            LogPrintf(\"ping timeout: %fs\\n\", 0.000001 * (GetTimeMicros() - pnode->nPingUsecStart));\n+            pnode->fDisconnect = true;\n         }\n+        else if (!pnode->fSuccessfullyConnected)\n+        {\n+            LogPrint(BCLog::NET, \"version handshake timeout from %d\\n\", pnode->GetId());\n+            pnode->fDisconnect = true;\n+        }\n+    }\n+}\n \n+void CConnman::GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    for (const ListenSocket& hListenSocket : vhListenSocket) {\n+        recv_set.insert(hListenSocket.socket);\n+    }\n+\n+    {\n+        LOCK(cs_vNodes);\n+        for (CNode* pnode : vNodes)\n         {\n-            LOCK(cs_vNodes);\n-            for (CNode* pnode : vNodes)\n+            // Implement the following logic:\n+            // * If there is data to send, select() for sending data. As this only\n+            //   happens when optimistic write failed, we choose to first drain the\n+            //   write buffer in this case before receiving more. This avoids\n+            //   needlessly queueing received data, if the remote peer is not themselves\n+            //   receiving data. This means properly utilizing TCP flow control signalling.\n+            // * Otherwise, if there is space left in the receive buffer, select() for\n+            //   receiving data.\n+            // * Hand off all complete messages to the processor, to be handled without\n+            //   blocking here.\n+\n+            bool select_recv = !pnode->fPauseRecv;\n+            bool select_send;\n             {\n-                // Implement the following logic:\n-                // * If there is data to send, select() for sending data. As this only\n-                //   happens when optimistic write failed, we choose to first drain the\n-                //   write buffer in this case before receiving more. This avoids\n-                //   needlessly queueing received data, if the remote peer is not themselves\n-                //   receiving data. This means properly utilizing TCP flow control signalling.\n-                // * Otherwise, if there is space left in the receive buffer, select() for\n-                //   receiving data.\n-                // * Hand off all complete messages to the processor, to be handled without\n-                //   blocking here.\n-\n-                bool select_recv = !pnode->fPauseRecv;\n-                bool select_send;\n-                {\n-                    LOCK(pnode->cs_vSend);\n-                    select_send = !pnode->vSendMsg.empty();\n-                }\n-\n-                LOCK(pnode->cs_hSocket);\n-                if (pnode->hSocket == INVALID_SOCKET)\n-                    continue;\n+                LOCK(pnode->cs_vSend);\n+                select_send = !pnode->vSendMsg.empty();\n+            }\n \n-                FD_SET(pnode->hSocket, &fdsetError);\n-                hSocketMax = std::max(hSocketMax, pnode->hSocket);\n-                have_fds = true;\n+            LOCK(pnode->cs_hSocket);\n+            if (pnode->hSocket == INVALID_SOCKET)\n+                continue;\n \n-                if (select_send) {\n-                    FD_SET(pnode->hSocket, &fdsetSend);\n-                    continue;\n-                }\n-                if (select_recv) {\n-                    FD_SET(pnode->hSocket, &fdsetRecv);\n-                }\n+            error_set.insert(pnode->hSocket);\n+            if (select_send) {\n+                send_set.insert(pnode->hSocket);\n+                continue;\n+            }\n+            if (select_recv) {\n+                recv_set.insert(pnode->hSocket);\n             }\n         }\n+    }\n+}\n \n-        int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n-                             &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n-        if (interruptNet)\n+#ifdef WIN32\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    //\n+    // Find which sockets have data to receive\n+    //\n+    struct timeval timeout;\n+    timeout.tv_sec  = 0;\n+    timeout.tv_usec = 50000; // frequency to poll pnode->vSend\n+\n+    fd_set fdsetRecv;\n+    fd_set fdsetSend;\n+    fd_set fdsetError;\n+    FD_ZERO(&fdsetRecv);\n+    FD_ZERO(&fdsetSend);\n+    FD_ZERO(&fdsetError);\n+    SOCKET hSocketMax = 0;\n+\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n+\n+    if (recv_select_set.empty() && send_select_set.empty() && error_select_set.empty()) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(50));\n+        return;\n+    }\n+\n+    for (SOCKET hSocket : recv_select_set) {\n+        FD_SET(hSocket, &fdsetRecv);\n+        hSocketMax = std::max(hSocketMax, hSocket);\n+    }\n+\n+    for (SOCKET hSocket : send_select_set) {\n+        FD_SET(hSocket, &fdsetSend);\n+        hSocketMax = std::max(hSocketMax, hSocket);\n+    }\n+\n+    for (SOCKET hSocket : error_select_set) {\n+        FD_SET(hSocket, &fdsetError);\n+        hSocketMax = std::max(hSocketMax, hSocket);\n+    }\n+\n+    int nSelect = select(hSocketMax + 1, &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n+\n+    if (nSelect == SOCKET_ERROR)\n+    {\n+        int nErr = WSAGetLastError();\n+        LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n+        for (unsigned int i = 0; i <= hSocketMax; i++)\n+            FD_SET(i, &fdsetRecv);\n+        FD_ZERO(&fdsetSend);\n+        FD_ZERO(&fdsetError);\n+        if (!interruptNet.sleep_for(std::chrono::milliseconds(timeout.tv_usec/1000)))\n             return;\n+    }\n \n-        if (nSelect == SOCKET_ERROR)\n-        {\n-            if (have_fds)\n-            {\n-                int nErr = WSAGetLastError();\n-                LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n-                for (unsigned int i = 0; i <= hSocketMax; i++)\n-                    FD_SET(i, &fdsetRecv);\n-            }\n-            FD_ZERO(&fdsetSend);\n-            FD_ZERO(&fdsetError);\n-            if (!interruptNet.sleep_for(std::chrono::milliseconds(timeout.tv_usec/1000)))\n-                return;\n-        }\n+    for (SOCKET hSocket : recv_select_set)\n+        if(FD_ISSET(hSocket, &fdsetRecv))\n+            recv_set.insert(hSocket);\n \n-        //\n-        // Accept new connections\n-        //\n-        for (const ListenSocket& hListenSocket : vhListenSocket)\n+    for (SOCKET hSocket : send_select_set)\n+        if(FD_ISSET(hSocket, &fdsetSend))\n+            send_set.insert(hSocket);\n+\n+    for (SOCKET hSocket : error_select_set)\n+        if(FD_ISSET(hSocket, &fdsetError))\n+            error_set.insert(hSocket);\n+}\n+#else\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n+\n+    if (recv_select_set.empty() && send_select_set.empty() and error_select_set.empty()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221419345",
      "id" : 221419345,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQxOTM0NQ==",
      "original_commit_id" : "7fd976b2f0abab75c81ab8923daba286831d5260",
      "original_position" : 360,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 160070544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221419345",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221419392"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221419392"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Use another variable name: `pollfd` shadows the already existing local variable with the same name :-)",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-09-29T07:23:41Z",
      "diff_hunk" : "@@ -1153,310 +1153,407 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     }\n }\n \n-void CConnman::ThreadSocketHandler()\n+void CConnman::DisconnectNodes()\n {\n-    unsigned int nPrevNodeCount = 0;\n-    while (!interruptNet)\n     {\n-        //\n-        // Disconnect nodes\n-        //\n-        {\n-            LOCK(cs_vNodes);\n+        LOCK(cs_vNodes);\n \n-            if (!fNetworkActive) {\n-                // Disconnect any connected nodes\n-                for (CNode* pnode : vNodes) {\n-                    if (!pnode->fDisconnect) {\n-                        LogPrint(BCLog::NET, \"Network not active, dropping peer=%d\\n\", pnode->GetId());\n-                        pnode->fDisconnect = true;\n-                    }\n+        if (!fNetworkActive) {\n+            // Disconnect any connected nodes\n+            for (CNode* pnode : vNodes) {\n+                if (!pnode->fDisconnect) {\n+                    LogPrint(BCLog::NET, \"Network not active, dropping peer=%d\\n\", pnode->GetId());\n+                    pnode->fDisconnect = true;\n                 }\n             }\n+        }\n \n-            // Disconnect unused nodes\n-            std::vector<CNode*> vNodesCopy = vNodes;\n-            for (CNode* pnode : vNodesCopy)\n+        // Disconnect unused nodes\n+        std::vector<CNode*> vNodesCopy = vNodes;\n+        for (CNode* pnode : vNodesCopy)\n+        {\n+            if (pnode->fDisconnect)\n             {\n-                if (pnode->fDisconnect)\n-                {\n-                    // remove from vNodes\n-                    vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n+                // remove from vNodes\n+                vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n \n-                    // release outbound grant (if any)\n-                    pnode->grantOutbound.Release();\n+                // release outbound grant (if any)\n+                pnode->grantOutbound.Release();\n \n-                    // close socket and cleanup\n-                    pnode->CloseSocketDisconnect();\n+                // close socket and cleanup\n+                pnode->CloseSocketDisconnect();\n \n-                    // hold in disconnected pool until all refs are released\n-                    pnode->Release();\n-                    vNodesDisconnected.push_back(pnode);\n-                }\n+                // hold in disconnected pool until all refs are released\n+                pnode->Release();\n+                vNodesDisconnected.push_back(pnode);\n             }\n         }\n+    }\n+    {\n+        // Delete disconnected nodes\n+        std::list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n+        for (CNode* pnode : vNodesDisconnectedCopy)\n         {\n-            // Delete disconnected nodes\n-            std::list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n-            for (CNode* pnode : vNodesDisconnectedCopy)\n-            {\n-                // wait until threads are done using it\n-                if (pnode->GetRefCount() <= 0) {\n-                    bool fDelete = false;\n-                    {\n-                        TRY_LOCK(pnode->cs_inventory, lockInv);\n-                        if (lockInv) {\n-                            TRY_LOCK(pnode->cs_vSend, lockSend);\n-                            if (lockSend) {\n-                                fDelete = true;\n-                            }\n+            // wait until threads are done using it\n+            if (pnode->GetRefCount() <= 0) {\n+                bool fDelete = false;\n+                {\n+                    TRY_LOCK(pnode->cs_inventory, lockInv);\n+                    if (lockInv) {\n+                        TRY_LOCK(pnode->cs_vSend, lockSend);\n+                        if (lockSend) {\n+                            fDelete = true;\n                         }\n                     }\n-                    if (fDelete) {\n-                        vNodesDisconnected.remove(pnode);\n-                        DeleteNode(pnode);\n-                    }\n+                }\n+                if (fDelete) {\n+                    vNodesDisconnected.remove(pnode);\n+                    DeleteNode(pnode);\n                 }\n             }\n         }\n-        size_t vNodesSize;\n+    }\n+}\n+\n+void CConnman::NotifyNumConnectionsChanged()\n+{\n+    size_t vNodesSize;\n+    {\n+        LOCK(cs_vNodes);\n+        vNodesSize = vNodes.size();\n+    }\n+    if(vNodesSize != nPrevNodeCount) {\n+        nPrevNodeCount = vNodesSize;\n+        if(clientInterface)\n+            clientInterface->NotifyNumConnectionsChanged(vNodesSize);\n+    }\n+}\n+\n+void CConnman::InactivityCheck(CNode *pnode)\n+{\n+    int64_t nTime = GetSystemTimeInSeconds();\n+    if (nTime - pnode->nTimeConnected > 60)\n+    {\n+        if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n+        {\n+            LogPrint(BCLog::NET, \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->GetId());\n+            pnode->fDisconnect = true;\n+        }\n+        else if (nTime - pnode->nLastSend > TIMEOUT_INTERVAL)\n         {\n-            LOCK(cs_vNodes);\n-            vNodesSize = vNodes.size();\n+            LogPrintf(\"socket sending timeout: %is\\n\", nTime - pnode->nLastSend);\n+            pnode->fDisconnect = true;\n         }\n-        if(vNodesSize != nPrevNodeCount) {\n-            nPrevNodeCount = vNodesSize;\n-            if(clientInterface)\n-                clientInterface->NotifyNumConnectionsChanged(vNodesSize);\n+        else if (nTime - pnode->nLastRecv > (pnode->nVersion > BIP0031_VERSION ? TIMEOUT_INTERVAL : 90*60))\n+        {\n+            LogPrintf(\"socket receive timeout: %is\\n\", nTime - pnode->nLastRecv);\n+            pnode->fDisconnect = true;\n         }\n-\n-        //\n-        // Find which sockets have data to receive\n-        //\n-        struct timeval timeout;\n-        timeout.tv_sec  = 0;\n-        timeout.tv_usec = 50000; // frequency to poll pnode->vSend\n-\n-        fd_set fdsetRecv;\n-        fd_set fdsetSend;\n-        fd_set fdsetError;\n-        FD_ZERO(&fdsetRecv);\n-        FD_ZERO(&fdsetSend);\n-        FD_ZERO(&fdsetError);\n-        SOCKET hSocketMax = 0;\n-        bool have_fds = false;\n-\n-        for (const ListenSocket& hListenSocket : vhListenSocket) {\n-            FD_SET(hListenSocket.socket, &fdsetRecv);\n-            hSocketMax = std::max(hSocketMax, hListenSocket.socket);\n-            have_fds = true;\n+        else if (pnode->nPingNonceSent && pnode->nPingUsecStart + TIMEOUT_INTERVAL * 1000000 < GetTimeMicros())\n+        {\n+            LogPrintf(\"ping timeout: %fs\\n\", 0.000001 * (GetTimeMicros() - pnode->nPingUsecStart));\n+            pnode->fDisconnect = true;\n         }\n+        else if (!pnode->fSuccessfullyConnected)\n+        {\n+            LogPrint(BCLog::NET, \"version handshake timeout from %d\\n\", pnode->GetId());\n+            pnode->fDisconnect = true;\n+        }\n+    }\n+}\n \n+void CConnman::GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    for (const ListenSocket& hListenSocket : vhListenSocket) {\n+        recv_set.insert(hListenSocket.socket);\n+    }\n+\n+    {\n+        LOCK(cs_vNodes);\n+        for (CNode* pnode : vNodes)\n         {\n-            LOCK(cs_vNodes);\n-            for (CNode* pnode : vNodes)\n+            // Implement the following logic:\n+            // * If there is data to send, select() for sending data. As this only\n+            //   happens when optimistic write failed, we choose to first drain the\n+            //   write buffer in this case before receiving more. This avoids\n+            //   needlessly queueing received data, if the remote peer is not themselves\n+            //   receiving data. This means properly utilizing TCP flow control signalling.\n+            // * Otherwise, if there is space left in the receive buffer, select() for\n+            //   receiving data.\n+            // * Hand off all complete messages to the processor, to be handled without\n+            //   blocking here.\n+\n+            bool select_recv = !pnode->fPauseRecv;\n+            bool select_send;\n             {\n-                // Implement the following logic:\n-                // * If there is data to send, select() for sending data. As this only\n-                //   happens when optimistic write failed, we choose to first drain the\n-                //   write buffer in this case before receiving more. This avoids\n-                //   needlessly queueing received data, if the remote peer is not themselves\n-                //   receiving data. This means properly utilizing TCP flow control signalling.\n-                // * Otherwise, if there is space left in the receive buffer, select() for\n-                //   receiving data.\n-                // * Hand off all complete messages to the processor, to be handled without\n-                //   blocking here.\n-\n-                bool select_recv = !pnode->fPauseRecv;\n-                bool select_send;\n-                {\n-                    LOCK(pnode->cs_vSend);\n-                    select_send = !pnode->vSendMsg.empty();\n-                }\n-\n-                LOCK(pnode->cs_hSocket);\n-                if (pnode->hSocket == INVALID_SOCKET)\n-                    continue;\n+                LOCK(pnode->cs_vSend);\n+                select_send = !pnode->vSendMsg.empty();\n+            }\n \n-                FD_SET(pnode->hSocket, &fdsetError);\n-                hSocketMax = std::max(hSocketMax, pnode->hSocket);\n-                have_fds = true;\n+            LOCK(pnode->cs_hSocket);\n+            if (pnode->hSocket == INVALID_SOCKET)\n+                continue;\n \n-                if (select_send) {\n-                    FD_SET(pnode->hSocket, &fdsetSend);\n-                    continue;\n-                }\n-                if (select_recv) {\n-                    FD_SET(pnode->hSocket, &fdsetRecv);\n-                }\n+            error_set.insert(pnode->hSocket);\n+            if (select_send) {\n+                send_set.insert(pnode->hSocket);\n+                continue;\n+            }\n+            if (select_recv) {\n+                recv_set.insert(pnode->hSocket);\n             }\n         }\n+    }\n+}\n \n-        int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n-                             &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n-        if (interruptNet)\n+#ifdef WIN32\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    //\n+    // Find which sockets have data to receive\n+    //\n+    struct timeval timeout;\n+    timeout.tv_sec  = 0;\n+    timeout.tv_usec = 50000; // frequency to poll pnode->vSend\n+\n+    fd_set fdsetRecv;\n+    fd_set fdsetSend;\n+    fd_set fdsetError;\n+    FD_ZERO(&fdsetRecv);\n+    FD_ZERO(&fdsetSend);\n+    FD_ZERO(&fdsetError);\n+    SOCKET hSocketMax = 0;\n+\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n+\n+    if (recv_select_set.empty() && send_select_set.empty() && error_select_set.empty()) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(50));\n+        return;\n+    }\n+\n+    for (SOCKET hSocket : recv_select_set) {\n+        FD_SET(hSocket, &fdsetRecv);\n+        hSocketMax = std::max(hSocketMax, hSocket);\n+    }\n+\n+    for (SOCKET hSocket : send_select_set) {\n+        FD_SET(hSocket, &fdsetSend);\n+        hSocketMax = std::max(hSocketMax, hSocket);\n+    }\n+\n+    for (SOCKET hSocket : error_select_set) {\n+        FD_SET(hSocket, &fdsetError);\n+        hSocketMax = std::max(hSocketMax, hSocket);\n+    }\n+\n+    int nSelect = select(hSocketMax + 1, &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n+\n+    if (nSelect == SOCKET_ERROR)\n+    {\n+        int nErr = WSAGetLastError();\n+        LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n+        for (unsigned int i = 0; i <= hSocketMax; i++)\n+            FD_SET(i, &fdsetRecv);\n+        FD_ZERO(&fdsetSend);\n+        FD_ZERO(&fdsetError);\n+        if (!interruptNet.sleep_for(std::chrono::milliseconds(timeout.tv_usec/1000)))\n             return;\n+    }\n \n-        if (nSelect == SOCKET_ERROR)\n-        {\n-            if (have_fds)\n-            {\n-                int nErr = WSAGetLastError();\n-                LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n-                for (unsigned int i = 0; i <= hSocketMax; i++)\n-                    FD_SET(i, &fdsetRecv);\n-            }\n-            FD_ZERO(&fdsetSend);\n-            FD_ZERO(&fdsetError);\n-            if (!interruptNet.sleep_for(std::chrono::milliseconds(timeout.tv_usec/1000)))\n-                return;\n-        }\n+    for (SOCKET hSocket : recv_select_set)\n+        if(FD_ISSET(hSocket, &fdsetRecv))\n+            recv_set.insert(hSocket);\n \n-        //\n-        // Accept new connections\n-        //\n-        for (const ListenSocket& hListenSocket : vhListenSocket)\n+    for (SOCKET hSocket : send_select_set)\n+        if(FD_ISSET(hSocket, &fdsetSend))\n+            send_set.insert(hSocket);\n+\n+    for (SOCKET hSocket : error_select_set)\n+        if(FD_ISSET(hSocket, &fdsetError))\n+            error_set.insert(hSocket);\n+}\n+#else\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n+\n+    if (recv_select_set.empty() && send_select_set.empty() and error_select_set.empty()) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(50));\n+        return;\n+    }\n+\n+    if (interruptNet)\n+        return;\n+\n+    std::vector<struct pollfd> pollfds;\n+    struct pollfd pollfd;\n+    memset(&pollfd, 0, sizeof(struct pollfd));\n+\n+    for (SOCKET hSocket : recv_select_set) {\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLIN;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    for (SOCKET hSocket : send_select_set) {\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLOUT;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    for (SOCKET hSocket : error_select_set) {\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLERR|POLLHUP;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    if(poll(&pollfds[0], pollfds.size(), 50) < 0)\n+        LogPrint(BCLog::NET, \"poll failure %d %s\\n\", errno, strerror(errno));\n+\n+    for (struct pollfd pollfd : pollfds) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221419392",
      "id" : 221419392,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQxOTM5Mg==",
      "original_commit_id" : "7fd976b2f0abab75c81ab8923daba286831d5260",
      "original_position" : 393,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 160070594,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221419392",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221442419"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221442419"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "~~Move this into `SocketHandler` after the `SocketEvents` call? Or this method cool return a bool, true if it completes, false if it is interrupted.~~\r\n\r\nNOTE: this was fixed in the commit `maybe fix things?`",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-09-29T23:16:43Z",
      "diff_hunk" : "@@ -1347,8 +1347,6 @@ void CConnman::SocketHandler()\n \n     int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n                          &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n-    if (interruptNet)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221442419",
      "id" : 221442419,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ0MjQxOQ==",
      "original_commit_id" : "d9ae35592cb978a3aef6baa2ae84500790f99ae9",
      "original_position" : 13,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 160096136,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221442419",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221442547"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221442547"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`pollfds.reserve(recv_select_set.size() + send_select_set.size() + error_select_set.size())`",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-09-29T23:25:51Z",
      "diff_hunk" : "@@ -1375,6 +1376,47 @@ void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_s\n         if(FD_ISSET(hSocket, &fdsetError))\n             error_set.insert(hSocket);\n }\n+#else\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n+\n+    std::vector<struct pollfd> pollfds;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221442547",
      "id" : 221442547,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ0MjU0Nw==",
      "original_commit_id" : "5ab601601dd1c494abcfb5a71556e99c3f561bc6",
      "original_position" : 18,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 160096136,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221442547",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221442558"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221442558"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: vectors now have `.data()`, which returns `&pollfds[0]` in a more object-oriented way.",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-09-29T23:26:54Z",
      "diff_hunk" : "@@ -1375,6 +1376,47 @@ void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_s\n         if(FD_ISSET(hSocket, &fdsetError))\n             error_set.insert(hSocket);\n }\n+#else\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n+\n+    std::vector<struct pollfd> pollfds;\n+    struct pollfd pollfd;\n+    memset(&pollfd, 0, sizeof(struct pollfd));\n+\n+    for (SOCKET hSocket : recv_select_set) {\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLIN;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    for (SOCKET hSocket : send_select_set) {\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLOUT;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    for (SOCKET hSocket : error_select_set) {\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLERR|POLLHUP;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    if(poll(&pollfds[0], pollfds.size(), 50) < 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221442558",
      "id" : 221442558,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ0MjU1OA==",
      "original_commit_id" : "5ab601601dd1c494abcfb5a71556e99c3f561bc6",
      "original_position" : 40,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 160096136,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221442558",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221442622"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221442622"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: Make the 50 a named constant along with `timeout.tv_usec` in the `select` impl.",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-09-29T23:31:14Z",
      "diff_hunk" : "@@ -1375,6 +1376,47 @@ void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_s\n         if(FD_ISSET(hSocket, &fdsetError))\n             error_set.insert(hSocket);\n }\n+#else\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n+\n+    std::vector<struct pollfd> pollfds;\n+    struct pollfd pollfd;\n+    memset(&pollfd, 0, sizeof(struct pollfd));\n+\n+    for (SOCKET hSocket : recv_select_set) {\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLIN;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    for (SOCKET hSocket : send_select_set) {\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLOUT;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    for (SOCKET hSocket : error_select_set) {\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLERR|POLLHUP;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    if(poll(&pollfds[0], pollfds.size(), 50) < 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221442622",
      "id" : 221442622,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ0MjYyMg==",
      "original_commit_id" : "5ab601601dd1c494abcfb5a71556e99c3f561bc6",
      "original_position" : 40,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 160096136,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221442622",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221442660"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221442660"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: Replace 50 with `timeout.tv_usec/1000`",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-09-29T23:34:39Z",
      "diff_hunk" : "@@ -1323,41 +1323,38 @@ void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_s\n     FD_ZERO(&fdsetSend);\n     FD_ZERO(&fdsetError);\n     SOCKET hSocketMax = 0;\n-    bool have_fds = false;\n \n     std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n     GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n \n+    if (recv_select_set.empty() && send_select_set.empty() && error_select_set.empty()) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(50));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221442660",
      "id" : 221442660,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ0MjY2MA==",
      "original_commit_id" : "7fd976b2f0abab75c81ab8923daba286831d5260",
      "original_position" : 10,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 160096136,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221442660",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221442700"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221442700"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I see this is the same as the code currently, but it seems like this should be `fdsetError` instead of `fdsetRecv`, even though they are handled exactly the same.",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-09-29T23:37:44Z",
      "diff_hunk" : "@@ -1323,41 +1323,38 @@ void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_s\n     FD_ZERO(&fdsetSend);\n     FD_ZERO(&fdsetError);\n     SOCKET hSocketMax = 0;\n-    bool have_fds = false;\n \n     std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n     GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n \n+    if (recv_select_set.empty() && send_select_set.empty() && error_select_set.empty()) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(50));\n+        return;\n+    }\n+\n     for (SOCKET hSocket : recv_select_set) {\n         FD_SET(hSocket, &fdsetRecv);\n-        have_fds = true;\n         hSocketMax = std::max(hSocketMax, hSocket);\n     }\n \n     for (SOCKET hSocket : send_select_set) {\n         FD_SET(hSocket, &fdsetSend);\n-        have_fds = true;\n         hSocketMax = std::max(hSocketMax, hSocket);\n     }\n \n     for (SOCKET hSocket : error_select_set) {\n         FD_SET(hSocket, &fdsetError);\n-        have_fds = true;\n         hSocketMax = std::max(hSocketMax, hSocket);\n     }\n \n-    int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n-                         &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n+    int nSelect = select(hSocketMax + 1, &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n \n     if (nSelect == SOCKET_ERROR)\n     {\n-        if (have_fds)\n-        {\n-            int nErr = WSAGetLastError();\n-            LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n-            for (unsigned int i = 0; i <= hSocketMax; i++)\n-                FD_SET(i, &fdsetRecv);\n-        }\n+        int nErr = WSAGetLastError();\n+        LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n+        for (unsigned int i = 0; i <= hSocketMax; i++)\n+            FD_SET(i, &fdsetRecv);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221442700",
      "id" : 221442700,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTQ0MjcwMA==",
      "original_commit_id" : "7fd976b2f0abab75c81ab8923daba286831d5260",
      "original_position" : 48,
      "path" : "src/net.cpp",
      "position" : 184,
      "pull_request_review_id" : 160096136,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221442700",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221693842"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221693842"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I don't think it should be there at all really. select() failures dont mean the sockets themselves have failed, but i guess it could mean we made a mistake and called select() with a closed socket?",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-10-01T17:35:12Z",
      "diff_hunk" : "@@ -1323,41 +1323,38 @@ void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_s\n     FD_ZERO(&fdsetSend);\n     FD_ZERO(&fdsetError);\n     SOCKET hSocketMax = 0;\n-    bool have_fds = false;\n \n     std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n     GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n \n+    if (recv_select_set.empty() && send_select_set.empty() && error_select_set.empty()) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(50));\n+        return;\n+    }\n+\n     for (SOCKET hSocket : recv_select_set) {\n         FD_SET(hSocket, &fdsetRecv);\n-        have_fds = true;\n         hSocketMax = std::max(hSocketMax, hSocket);\n     }\n \n     for (SOCKET hSocket : send_select_set) {\n         FD_SET(hSocket, &fdsetSend);\n-        have_fds = true;\n         hSocketMax = std::max(hSocketMax, hSocket);\n     }\n \n     for (SOCKET hSocket : error_select_set) {\n         FD_SET(hSocket, &fdsetError);\n-        have_fds = true;\n         hSocketMax = std::max(hSocketMax, hSocket);\n     }\n \n-    int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n-                         &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n+    int nSelect = select(hSocketMax + 1, &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n \n     if (nSelect == SOCKET_ERROR)\n     {\n-        if (have_fds)\n-        {\n-            int nErr = WSAGetLastError();\n-            LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n-            for (unsigned int i = 0; i <= hSocketMax; i++)\n-                FD_SET(i, &fdsetRecv);\n-        }\n+        int nErr = WSAGetLastError();\n+        LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n+        for (unsigned int i = 0; i <= hSocketMax; i++)\n+            FD_SET(i, &fdsetRecv);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r221693842",
      "id" : 221693842,
      "in_reply_to_id" : 221442700,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMTY5Mzg0Mg==",
      "original_commit_id" : "7fd976b2f0abab75c81ab8923daba286831d5260",
      "original_position" : 48,
      "path" : "src/net.cpp",
      "position" : 184,
      "pull_request_review_id" : 160405153,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/221693842",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/620611?v=4",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "node_id" : "MDQ6VXNlcjYyMDYxMQ==",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, will review in detail when my brain works again.",
      "created_at" : "2018-10-02T19:37:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#issuecomment-426403018",
      "id" : 426403018,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14336",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyNjQwMzAxOA==",
      "updated_at" : "2018-10-02T19:37:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/426403018",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK. Will also review shortly.",
      "created_at" : "2018-10-02T20:19:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#issuecomment-426415581",
      "id" : 426415581,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14336",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyNjQxNTU4MQ==",
      "updated_at" : "2018-10-02T20:19:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/426415581",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/417043?v=4",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "node_id" : "MDQ6VXNlcjQxNzA0Mw==",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r222124763"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/222124763"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yeah, then iterating through each one and calling `recv` would identify which peer to disconnect. Though, if it's `fdsetError` and not `fdsetRecv`, it probably shouldn't disconnect when `nBytes == 0`.",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-10-02T21:53:28Z",
      "diff_hunk" : "@@ -1323,41 +1323,38 @@ void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_s\n     FD_ZERO(&fdsetSend);\n     FD_ZERO(&fdsetError);\n     SOCKET hSocketMax = 0;\n-    bool have_fds = false;\n \n     std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n     GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n \n+    if (recv_select_set.empty() && send_select_set.empty() && error_select_set.empty()) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(50));\n+        return;\n+    }\n+\n     for (SOCKET hSocket : recv_select_set) {\n         FD_SET(hSocket, &fdsetRecv);\n-        have_fds = true;\n         hSocketMax = std::max(hSocketMax, hSocket);\n     }\n \n     for (SOCKET hSocket : send_select_set) {\n         FD_SET(hSocket, &fdsetSend);\n-        have_fds = true;\n         hSocketMax = std::max(hSocketMax, hSocket);\n     }\n \n     for (SOCKET hSocket : error_select_set) {\n         FD_SET(hSocket, &fdsetError);\n-        have_fds = true;\n         hSocketMax = std::max(hSocketMax, hSocket);\n     }\n \n-    int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n-                         &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n+    int nSelect = select(hSocketMax + 1, &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n \n     if (nSelect == SOCKET_ERROR)\n     {\n-        if (have_fds)\n-        {\n-            int nErr = WSAGetLastError();\n-            LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n-            for (unsigned int i = 0; i <= hSocketMax; i++)\n-                FD_SET(i, &fdsetRecv);\n-        }\n+        int nErr = WSAGetLastError();\n+        LogPrintf(\"socket select error %s\\n\", NetworkErrorString(nErr));\n+        for (unsigned int i = 0; i <= hSocketMax; i++)\n+            FD_SET(i, &fdsetRecv);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r222124763",
      "id" : 222124763,
      "in_reply_to_id" : 221442700,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyMjEyNDc2Mw==",
      "original_commit_id" : "7fd976b2f0abab75c81ab8923daba286831d5260",
      "original_position" : 48,
      "path" : "src/net.cpp",
      "position" : 184,
      "pull_request_review_id" : 160939346,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/222124763",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r225690949"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225690949"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could be worth having `GenerateSelectSet` return a bool that indicates whether or not the sets have any content so that we can avoid the `.empty()` checks below (and the repetition necessary for the legacy `select` impl).",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-10-16T20:10:44Z",
      "diff_hunk" : "@@ -1377,6 +1378,58 @@ void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_s\n         if(FD_ISSET(hSocket, &fdsetError))\n             error_set.insert(hSocket);\n }\n+#else\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r225690949",
      "id" : 225690949,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY5MDk0OQ==",
      "original_commit_id" : "5f99a7861c44e7f86292a06c1f9c97dac30b7161",
      "original_position" : 16,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 165345973,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225690949",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r225691877"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225691877"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This is ignored and reported on `revents` in any case, no? I guess no harm in being explicit.",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-10-16T20:13:57Z",
      "diff_hunk" : "@@ -1377,6 +1378,58 @@ void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_s\n         if(FD_ISSET(hSocket, &fdsetError))\n             error_set.insert(hSocket);\n }\n+#else\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n+\n+    if (recv_select_set.empty() && send_select_set.empty() && error_select_set.empty()) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));\n+        return;\n+    }\n+\n+    std::vector<struct pollfd> pollfds;\n+    pollfds.reserve(recv_select_set.size() + send_select_set.size() + error_select_set.size());\n+\n+    {\n+        struct pollfd pollfd = {};\n+\n+        for (SOCKET hSocket : recv_select_set) {\n+            pollfd.fd = hSocket;\n+            pollfd.events = POLLIN;\n+            pollfds.push_back(pollfd);\n+        }\n+\n+        for (SOCKET hSocket : send_select_set) {\n+            pollfd.fd = hSocket;\n+            pollfd.events = POLLOUT;\n+            pollfds.push_back(pollfd);\n+        }\n+\n+        for (SOCKET hSocket : error_select_set) {\n+            pollfd.fd = hSocket;\n+            pollfd.events = POLLERR|POLLHUP;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r225691877",
      "id" : 225691877,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY5MTg3Nw==",
      "original_commit_id" : "5f99a7861c44e7f86292a06c1f9c97dac30b7161",
      "original_position" : 43,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 165345973,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225691877",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r225693517"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225693517"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should we make use of `SELECT_TIMEOUT_MILLISECONDS` here?",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-10-16T20:19:12Z",
      "diff_hunk" : "@@ -1377,6 +1378,58 @@ void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_s\n         if(FD_ISSET(hSocket, &fdsetError))\n             error_set.insert(hSocket);\n }\n+#else\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n+\n+    if (recv_select_set.empty() && send_select_set.empty() && error_select_set.empty()) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));\n+        return;\n+    }\n+\n+    std::vector<struct pollfd> pollfds;\n+    pollfds.reserve(recv_select_set.size() + send_select_set.size() + error_select_set.size());\n+\n+    {\n+        struct pollfd pollfd = {};\n+\n+        for (SOCKET hSocket : recv_select_set) {\n+            pollfd.fd = hSocket;\n+            pollfd.events = POLLIN;\n+            pollfds.push_back(pollfd);\n+        }\n+\n+        for (SOCKET hSocket : send_select_set) {\n+            pollfd.fd = hSocket;\n+            pollfd.events = POLLOUT;\n+            pollfds.push_back(pollfd);\n+        }\n+\n+        for (SOCKET hSocket : error_select_set) {\n+            pollfd.fd = hSocket;\n+            pollfd.events = POLLERR|POLLHUP;\n+            pollfds.push_back(pollfd);\n+        }\n+    }\n+\n+    if(poll(pollfds.data(), pollfds.size(), 50) < 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r225693517",
      "id" : 225693517,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY5MzUxNw==",
      "original_commit_id" : "5f99a7861c44e7f86292a06c1f9c97dac30b7161",
      "original_position" : 48,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 165345973,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225693517",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r225693624"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225693624"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: space after `if` + braces",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-10-16T20:19:32Z",
      "diff_hunk" : "@@ -1377,6 +1378,58 @@ void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_s\n         if(FD_ISSET(hSocket, &fdsetError))\n             error_set.insert(hSocket);\n }\n+#else\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n+\n+    if (recv_select_set.empty() && send_select_set.empty() && error_select_set.empty()) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));\n+        return;\n+    }\n+\n+    std::vector<struct pollfd> pollfds;\n+    pollfds.reserve(recv_select_set.size() + send_select_set.size() + error_select_set.size());\n+\n+    {\n+        struct pollfd pollfd = {};\n+\n+        for (SOCKET hSocket : recv_select_set) {\n+            pollfd.fd = hSocket;\n+            pollfd.events = POLLIN;\n+            pollfds.push_back(pollfd);\n+        }\n+\n+        for (SOCKET hSocket : send_select_set) {\n+            pollfd.fd = hSocket;\n+            pollfd.events = POLLOUT;\n+            pollfds.push_back(pollfd);\n+        }\n+\n+        for (SOCKET hSocket : error_select_set) {\n+            pollfd.fd = hSocket;\n+            pollfd.events = POLLERR|POLLHUP;\n+            pollfds.push_back(pollfd);\n+        }\n+    }\n+\n+    if(poll(pollfds.data(), pollfds.size(), 50) < 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r225693624",
      "id" : 225693624,
      "in_reply_to_id" : 225693517,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY5MzYyNA==",
      "original_commit_id" : "5f99a7861c44e7f86292a06c1f9c97dac30b7161",
      "original_position" : 48,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 165345973,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225693624",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r225695613"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225695613"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Apparently [`poll` has been flaky on previous versions of MacOS](https://daniel.haxx.se/blog/2016/10/11/poll-on-mac-10-12-is-broken/). Do we want to fall back to `select` on Darwin systems just to be safe?",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-10-16T20:26:07Z",
      "diff_hunk" : "@@ -1308,6 +1308,7 @@ void CConnman::GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &s\n     }\n }\n \n+#ifdef WIN32",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r225695613",
      "id" : 225695613,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY5NTYxMw==",
      "original_commit_id" : "5f99a7861c44e7f86292a06c1f9c97dac30b7161",
      "original_position" : 4,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 165345973,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225695613",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r225696650"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225696650"
         }
      },
      "author_association" : "MEMBER",
      "body" : "(from a previous comment on the outdated `#ifdef WIN32`) Apparently [`poll` has been flaky on previous versions of MacOS](https://daniel.haxx.se/blog/2016/10/11/poll-on-mac-10-12-is-broken/). Do we want to fall back to select on Darwin systems just to be safe?",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-10-16T20:29:34Z",
      "diff_hunk" : "@@ -1312,46 +1296,155 @@ void CConnman::SocketHandler()\n             if (pnode->hSocket == INVALID_SOCKET)\n                 continue;\n \n-            FD_SET(pnode->hSocket, &fdsetError);\n-            hSocketMax = std::max(hSocketMax, pnode->hSocket);\n-            have_fds = true;\n-\n+            error_set.insert(pnode->hSocket);\n             if (select_send) {\n-                FD_SET(pnode->hSocket, &fdsetSend);\n+                send_set.insert(pnode->hSocket);\n                 continue;\n             }\n             if (select_recv) {\n-                FD_SET(pnode->hSocket, &fdsetRecv);\n+                recv_set.insert(pnode->hSocket);\n             }\n         }\n     }\n+}\n+\n+#ifndef HAVE_POLL",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r225696650",
      "id" : 225696650,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY5NjY1MA==",
      "original_commit_id" : "84fae8d4cc6a6d9f81644cef706629263e84d353",
      "original_position" : 62,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 165353430,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225696650",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r226500199"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/226500199"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm avoiding using poll() or select() to sleep specifically because of this class of bug.",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-10-18T23:53:59Z",
      "diff_hunk" : "@@ -1308,6 +1308,7 @@ void CConnman::GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &s\n     }\n }\n \n+#ifdef WIN32",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r226500199",
      "id" : 226500199,
      "in_reply_to_id" : 225695613,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNjUwMDE5OQ==",
      "original_commit_id" : "5f99a7861c44e7f86292a06c1f9c97dac30b7161",
      "original_position" : 4,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 166338356,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/226500199",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/620611?v=4",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "node_id" : "MDQ6VXNlcjYyMDYxMQ==",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r226500376"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/226500376"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm reusing the `struct pollfd` so it's necessary to overwrite the previous value.",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-10-18T23:55:06Z",
      "diff_hunk" : "@@ -1377,6 +1378,58 @@ void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_s\n         if(FD_ISSET(hSocket, &fdsetError))\n             error_set.insert(hSocket);\n }\n+#else\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n+\n+    if (recv_select_set.empty() && send_select_set.empty() && error_select_set.empty()) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));\n+        return;\n+    }\n+\n+    std::vector<struct pollfd> pollfds;\n+    pollfds.reserve(recv_select_set.size() + send_select_set.size() + error_select_set.size());\n+\n+    {\n+        struct pollfd pollfd = {};\n+\n+        for (SOCKET hSocket : recv_select_set) {\n+            pollfd.fd = hSocket;\n+            pollfd.events = POLLIN;\n+            pollfds.push_back(pollfd);\n+        }\n+\n+        for (SOCKET hSocket : send_select_set) {\n+            pollfd.fd = hSocket;\n+            pollfd.events = POLLOUT;\n+            pollfds.push_back(pollfd);\n+        }\n+\n+        for (SOCKET hSocket : error_select_set) {\n+            pollfd.fd = hSocket;\n+            pollfd.events = POLLERR|POLLHUP;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r226500376",
      "id" : 226500376,
      "in_reply_to_id" : 225691877,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNjUwMDM3Ng==",
      "original_commit_id" : "5f99a7861c44e7f86292a06c1f9c97dac30b7161",
      "original_position" : 43,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 166338581,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/226500376",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/620611?v=4",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "node_id" : "MDQ6VXNlcjYyMDYxMQ==",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r226500409"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/226500409"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "yeah",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-10-18T23:55:21Z",
      "diff_hunk" : "@@ -1377,6 +1378,58 @@ void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_s\n         if(FD_ISSET(hSocket, &fdsetError))\n             error_set.insert(hSocket);\n }\n+#else\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    GenerateSelectSet(recv_select_set, send_select_set, error_select_set);\n+\n+    if (recv_select_set.empty() && send_select_set.empty() && error_select_set.empty()) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));\n+        return;\n+    }\n+\n+    std::vector<struct pollfd> pollfds;\n+    pollfds.reserve(recv_select_set.size() + send_select_set.size() + error_select_set.size());\n+\n+    {\n+        struct pollfd pollfd = {};\n+\n+        for (SOCKET hSocket : recv_select_set) {\n+            pollfd.fd = hSocket;\n+            pollfd.events = POLLIN;\n+            pollfds.push_back(pollfd);\n+        }\n+\n+        for (SOCKET hSocket : send_select_set) {\n+            pollfd.fd = hSocket;\n+            pollfd.events = POLLOUT;\n+            pollfds.push_back(pollfd);\n+        }\n+\n+        for (SOCKET hSocket : error_select_set) {\n+            pollfd.fd = hSocket;\n+            pollfd.events = POLLERR|POLLHUP;\n+            pollfds.push_back(pollfd);\n+        }\n+    }\n+\n+    if(poll(pollfds.data(), pollfds.size(), 50) < 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r226500409",
      "id" : 226500409,
      "in_reply_to_id" : 225693517,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNjUwMDQwOQ==",
      "original_commit_id" : "5f99a7861c44e7f86292a06c1f9c97dac30b7161",
      "original_position" : 48,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 166338623,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/226500409",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/620611?v=4",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "node_id" : "MDQ6VXNlcjYyMDYxMQ==",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r226838085"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/226838085"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "i'm specifically avoiding calling poll (or select) with nothing to listen for because of that class of bugs, i'll add a comment",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-10-20T19:53:59Z",
      "diff_hunk" : "@@ -1312,46 +1296,155 @@ void CConnman::SocketHandler()\n             if (pnode->hSocket == INVALID_SOCKET)\n                 continue;\n \n-            FD_SET(pnode->hSocket, &fdsetError);\n-            hSocketMax = std::max(hSocketMax, pnode->hSocket);\n-            have_fds = true;\n-\n+            error_set.insert(pnode->hSocket);\n             if (select_send) {\n-                FD_SET(pnode->hSocket, &fdsetSend);\n+                send_set.insert(pnode->hSocket);\n                 continue;\n             }\n             if (select_recv) {\n-                FD_SET(pnode->hSocket, &fdsetRecv);\n+                recv_set.insert(pnode->hSocket);\n             }\n         }\n     }\n+}\n+\n+#ifndef HAVE_POLL",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r226838085",
      "id" : 226838085,
      "in_reply_to_id" : 225696650,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNjgzODA4NQ==",
      "original_commit_id" : "84fae8d4cc6a6d9f81644cef706629263e84d353",
      "original_position" : 62,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 166760627,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/226838085",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/620611?v=4",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "node_id" : "MDQ6VXNlcjYyMDYxMQ==",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r230026550"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230026550"
         }
      },
      "author_association" : "MEMBER",
      "body" : "don't know how long the old code waited, but isn't 50 milliseconds a bit short? if there are no events, why not sleep as long as possible? (saving CPU cycles) can you please add a comment explaining the reasoning for this specific value",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-11-01T12:32:00Z",
      "diff_hunk" : "@@ -1312,46 +1296,153 @@ void CConnman::SocketHandler()\n             if (pnode->hSocket == INVALID_SOCKET)\n                 continue;\n \n-            FD_SET(pnode->hSocket, &fdsetError);\n-            hSocketMax = std::max(hSocketMax, pnode->hSocket);\n-            have_fds = true;\n-\n+            error_set.insert(pnode->hSocket);\n             if (select_send) {\n-                FD_SET(pnode->hSocket, &fdsetSend);\n+                send_set.insert(pnode->hSocket);\n                 continue;\n             }\n             if (select_recv) {\n-                FD_SET(pnode->hSocket, &fdsetRecv);\n+                recv_set.insert(pnode->hSocket);\n             }\n         }\n     }\n \n-    int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n-                         &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n+    return !recv_set.empty() || !send_set.empty() || !error_set.empty();\n+}\n+\n+#ifdef USE_POLL\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    if (!GenerateSelectSet(recv_select_set, send_select_set, error_select_set)) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));\n+        return;\n+    }\n+\n+    std::vector<struct pollfd> pollfds;\n+    pollfds.reserve(recv_select_set.size() + send_select_set.size() + error_select_set.size());\n+\n+    for (SOCKET hSocket : recv_select_set) {\n+        struct pollfd pollfd = {};\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLIN;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    for (SOCKET hSocket : send_select_set) {\n+        struct pollfd pollfd = {};\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLOUT;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    for (SOCKET hSocket : error_select_set) {\n+        struct pollfd pollfd = {};\n+        pollfd.fd = hSocket;\n+        // These flags are ignored, but we set them for clarity\n+        pollfd.events = POLLERR|POLLHUP;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    if(poll(pollfds.data(), pollfds.size(), 50) < 0)\n+        LogPrint(BCLog::NET, \"poll failure %d %s\\n\", errno, strerror(errno));\n+\n+    if (interruptNet)\n+        return;\n+\n+    for (struct pollfd pollfd : pollfds) {\n+        if (pollfd.revents & POLLIN)\n+            recv_set.insert(pollfd.fd);\n+        if (pollfd.revents & POLLOUT)\n+            send_set.insert(pollfd.fd);\n+        if (pollfd.revents & (POLLERR|POLLHUP))\n+            error_set.insert(pollfd.fd);\n+    }\n+}\n+#else\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    if (!GenerateSelectSet(recv_select_set, send_select_set, error_select_set)) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));\n+        return;\n+    }\n+\n+    //\n+    // Find which sockets have data to receive\n+    //\n+    struct timeval timeout;\n+    timeout.tv_sec  = 0;\n+    timeout.tv_usec = SELECT_TIMEOUT_MILLISECONDS * 1000; // frequency to poll pnode->vSend",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r230026550",
      "id" : 230026550,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDAyNjU1MA==",
      "original_commit_id" : "ec652e12ee32878e0f0d378375ffac0f8313c6e5",
      "original_position" : 129,
      "path" : "src/net.cpp",
      "position" : 142,
      "pull_request_review_id" : 170664589,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230026550",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r230031558"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230031558"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I guess we *want* these sets to be sorted by fd, or at least predictably sorted, as it's iterated over--so using `set` over `unordered_set` makes sense",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-11-01T12:52:36Z",
      "diff_hunk" : "@@ -1262,28 +1264,10 @@ void CConnman::InactivityCheck(CNode *pnode)\n     }\n }\n \n-void CConnman::SocketHandler()\n+bool CConnman::GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r230031558",
      "id" : 230031558,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDAzMTU1OA==",
      "original_commit_id" : "ec652e12ee32878e0f0d378375ffac0f8313c6e5",
      "original_position" : 14,
      "path" : "src/net.cpp",
      "position" : 16,
      "pull_request_review_id" : 170671088,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230031558",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "some minor comments but otherwise utACK from me",
      "created_at" : "2018-11-01T13:10:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#issuecomment-435036036",
      "id" : 435036036,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14336",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTAzNjAzNg==",
      "updated_at" : "2018-11-01T13:10:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435036036",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r230135886"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230135886"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I carried over the existing value.\r\n\r\nThere are two reasons for this to be a short value:\r\n\r\n- we cant modify the list of sockets while waiting, so the sleep time is potentially the delay before a new connection is serviced at all\r\n- the disconnectnodes and inactivitychecks are time based and independent of socketevents",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-11-01T17:52:58Z",
      "diff_hunk" : "@@ -1312,46 +1296,153 @@ void CConnman::SocketHandler()\n             if (pnode->hSocket == INVALID_SOCKET)\n                 continue;\n \n-            FD_SET(pnode->hSocket, &fdsetError);\n-            hSocketMax = std::max(hSocketMax, pnode->hSocket);\n-            have_fds = true;\n-\n+            error_set.insert(pnode->hSocket);\n             if (select_send) {\n-                FD_SET(pnode->hSocket, &fdsetSend);\n+                send_set.insert(pnode->hSocket);\n                 continue;\n             }\n             if (select_recv) {\n-                FD_SET(pnode->hSocket, &fdsetRecv);\n+                recv_set.insert(pnode->hSocket);\n             }\n         }\n     }\n \n-    int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n-                         &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n+    return !recv_set.empty() || !send_set.empty() || !error_set.empty();\n+}\n+\n+#ifdef USE_POLL\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    if (!GenerateSelectSet(recv_select_set, send_select_set, error_select_set)) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));\n+        return;\n+    }\n+\n+    std::vector<struct pollfd> pollfds;\n+    pollfds.reserve(recv_select_set.size() + send_select_set.size() + error_select_set.size());\n+\n+    for (SOCKET hSocket : recv_select_set) {\n+        struct pollfd pollfd = {};\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLIN;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    for (SOCKET hSocket : send_select_set) {\n+        struct pollfd pollfd = {};\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLOUT;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    for (SOCKET hSocket : error_select_set) {\n+        struct pollfd pollfd = {};\n+        pollfd.fd = hSocket;\n+        // These flags are ignored, but we set them for clarity\n+        pollfd.events = POLLERR|POLLHUP;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    if(poll(pollfds.data(), pollfds.size(), 50) < 0)\n+        LogPrint(BCLog::NET, \"poll failure %d %s\\n\", errno, strerror(errno));\n+\n+    if (interruptNet)\n+        return;\n+\n+    for (struct pollfd pollfd : pollfds) {\n+        if (pollfd.revents & POLLIN)\n+            recv_set.insert(pollfd.fd);\n+        if (pollfd.revents & POLLOUT)\n+            send_set.insert(pollfd.fd);\n+        if (pollfd.revents & (POLLERR|POLLHUP))\n+            error_set.insert(pollfd.fd);\n+    }\n+}\n+#else\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    if (!GenerateSelectSet(recv_select_set, send_select_set, error_select_set)) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));\n+        return;\n+    }\n+\n+    //\n+    // Find which sockets have data to receive\n+    //\n+    struct timeval timeout;\n+    timeout.tv_sec  = 0;\n+    timeout.tv_usec = SELECT_TIMEOUT_MILLISECONDS * 1000; // frequency to poll pnode->vSend",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r230135886",
      "id" : 230135886,
      "in_reply_to_id" : 230026550,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDEzNTg4Ng==",
      "original_commit_id" : "ec652e12ee32878e0f0d378375ffac0f8313c6e5",
      "original_position" : 129,
      "path" : "src/net.cpp",
      "position" : 142,
      "pull_request_review_id" : 170804814,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230135886",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/620611?v=4",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "node_id" : "MDQ6VXNlcjYyMDYxMQ==",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r230136620"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230136620"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "regardless of iterating i cant imagine we'd see any change in a benchmark here",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-11-01T17:55:06Z",
      "diff_hunk" : "@@ -1262,28 +1264,10 @@ void CConnman::InactivityCheck(CNode *pnode)\n     }\n }\n \n-void CConnman::SocketHandler()\n+bool CConnman::GenerateSelectSet(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r230136620",
      "id" : 230136620,
      "in_reply_to_id" : 230031558,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDEzNjYyMA==",
      "original_commit_id" : "ec652e12ee32878e0f0d378375ffac0f8313c6e5",
      "original_position" : 14,
      "path" : "src/net.cpp",
      "position" : 16,
      "pull_request_review_id" : 170805718,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230136620",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/620611?v=4",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "node_id" : "MDQ6VXNlcjYyMDYxMQ==",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r230137381"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230137381"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "i just checked and this is the value from satoshi, so im sure it was entirely arbitrarily chosen",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-11-01T17:57:02Z",
      "diff_hunk" : "@@ -1312,46 +1296,153 @@ void CConnman::SocketHandler()\n             if (pnode->hSocket == INVALID_SOCKET)\n                 continue;\n \n-            FD_SET(pnode->hSocket, &fdsetError);\n-            hSocketMax = std::max(hSocketMax, pnode->hSocket);\n-            have_fds = true;\n-\n+            error_set.insert(pnode->hSocket);\n             if (select_send) {\n-                FD_SET(pnode->hSocket, &fdsetSend);\n+                send_set.insert(pnode->hSocket);\n                 continue;\n             }\n             if (select_recv) {\n-                FD_SET(pnode->hSocket, &fdsetRecv);\n+                recv_set.insert(pnode->hSocket);\n             }\n         }\n     }\n \n-    int nSelect = select(have_fds ? hSocketMax + 1 : 0,\n-                         &fdsetRecv, &fdsetSend, &fdsetError, &timeout);\n+    return !recv_set.empty() || !send_set.empty() || !error_set.empty();\n+}\n+\n+#ifdef USE_POLL\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    if (!GenerateSelectSet(recv_select_set, send_select_set, error_select_set)) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));\n+        return;\n+    }\n+\n+    std::vector<struct pollfd> pollfds;\n+    pollfds.reserve(recv_select_set.size() + send_select_set.size() + error_select_set.size());\n+\n+    for (SOCKET hSocket : recv_select_set) {\n+        struct pollfd pollfd = {};\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLIN;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    for (SOCKET hSocket : send_select_set) {\n+        struct pollfd pollfd = {};\n+        pollfd.fd = hSocket;\n+        pollfd.events = POLLOUT;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    for (SOCKET hSocket : error_select_set) {\n+        struct pollfd pollfd = {};\n+        pollfd.fd = hSocket;\n+        // These flags are ignored, but we set them for clarity\n+        pollfd.events = POLLERR|POLLHUP;\n+        pollfds.push_back(pollfd);\n+    }\n+\n+    if(poll(pollfds.data(), pollfds.size(), 50) < 0)\n+        LogPrint(BCLog::NET, \"poll failure %d %s\\n\", errno, strerror(errno));\n+\n+    if (interruptNet)\n+        return;\n+\n+    for (struct pollfd pollfd : pollfds) {\n+        if (pollfd.revents & POLLIN)\n+            recv_set.insert(pollfd.fd);\n+        if (pollfd.revents & POLLOUT)\n+            send_set.insert(pollfd.fd);\n+        if (pollfd.revents & (POLLERR|POLLHUP))\n+            error_set.insert(pollfd.fd);\n+    }\n+}\n+#else\n+void CConnman::SocketEvents(std::set<SOCKET> &recv_set, std::set<SOCKET> &send_set, std::set<SOCKET> &error_set)\n+{\n+    std::set<SOCKET> recv_select_set, send_select_set, error_select_set;\n+    if (!GenerateSelectSet(recv_select_set, send_select_set, error_select_set)) {\n+        interruptNet.sleep_for(std::chrono::milliseconds(SELECT_TIMEOUT_MILLISECONDS));\n+        return;\n+    }\n+\n+    //\n+    // Find which sockets have data to receive\n+    //\n+    struct timeval timeout;\n+    timeout.tv_sec  = 0;\n+    timeout.tv_usec = SELECT_TIMEOUT_MILLISECONDS * 1000; // frequency to poll pnode->vSend",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r230137381",
      "id" : 230137381,
      "in_reply_to_id" : 230026550,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDEzNzM4MQ==",
      "original_commit_id" : "ec652e12ee32878e0f0d378375ffac0f8313c6e5",
      "original_position" : 129,
      "path" : "src/net.cpp",
      "position" : 142,
      "pull_request_review_id" : 170806585,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230137381",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/620611?v=4",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "node_id" : "MDQ6VXNlcjYyMDYxMQ==",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r230971331"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230971331"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: MSVC does not like this. I would suggest to use `#ifndef`",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-11-06T01:09:02Z",
      "diff_hunk" : "@@ -102,12 +102,12 @@ typedef void* sockopt_arg_type;\n typedef char* sockopt_arg_type;\n #endif\n \n+#if not defined WIN32",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r230971331",
      "id" : 230971331,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMDk3MTMzMQ==",
      "original_commit_id" : "efb25c0a31aeccd8dbd824ad03991d3a666583b2",
      "original_position" : 4,
      "path" : "src/compat.h",
      "position" : null,
      "pull_request_review_id" : 171830899,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/230971331",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/11154118?v=4",
         "events_url" : "https://api.github.com/users/ken2812221/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ken2812221/followers",
         "following_url" : "https://api.github.com/users/ken2812221/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ken2812221/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ken2812221",
         "id" : 11154118,
         "login" : "ken2812221",
         "node_id" : "MDQ6VXNlcjExMTU0MTE4",
         "organizations_url" : "https://api.github.com/users/ken2812221/orgs",
         "received_events_url" : "https://api.github.com/users/ken2812221/received_events",
         "repos_url" : "https://api.github.com/users/ken2812221/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ken2812221/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ken2812221/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ken2812221"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r231014724"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231014724"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think the official syntax, which works with any C++ compiler, is\r\n```c++\r\n#if !defined(WIN32)\r\n```",
      "commit_id" : "024b4e5ebf1fe424146763fbd8024129f59503e8",
      "created_at" : "2018-11-06T07:02:59Z",
      "diff_hunk" : "@@ -102,12 +102,12 @@ typedef void* sockopt_arg_type;\n typedef char* sockopt_arg_type;\n #endif\n \n+#if not defined WIN32",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#discussion_r231014724",
      "id" : 231014724,
      "in_reply_to_id" : 230971331,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMTAxNDcyNA==",
      "original_commit_id" : "efb25c0a31aeccd8dbd824ad03991d3a666583b2",
      "original_position" : 4,
      "path" : "src/compat.h",
      "position" : null,
      "pull_request_review_id" : 171883088,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14336",
      "updated_at" : "2018-11-06T23:23:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/231014724",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I haven't reviewed the code at all, but this doesn't seem to work on my mac (macos 10.13.3).  It looks like I can't maintain a connection to any peers, here's an example of debug.log output when I grep for a single peer, to show an example:\r\n\r\n```\r\n2018-11-06T18:20:54Z Added connection peer=1788\r\n2018-11-06T18:20:54Z sending version (103 bytes) peer=1788\r\n2018-11-06T18:20:54Z send version message: version 70015, blocks=549011, us=[::]:0, peer=1788\r\n2018-11-06T18:21:55Z socket no message in first 60 seconds, 0 1 from 1788\r\n2018-11-06T18:21:55Z disconnecting peer=1788\r\n2018-11-06T18:21:55Z Cleared nodestate for peer=1788\r\n```\r\n\r\nThis pattern is holding for all my peers: my node is making an outbound connection and then disconnecting after a minute.",
      "created_at" : "2018-11-06T18:25:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#issuecomment-436356628",
      "id" : 436356628,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14336",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjM1NjYyOA==",
      "updated_at" : "2018-11-06T18:25:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436356628",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@sdaftuar the last commit insures that there is a single struct pollfd per fd and adds significantly more logging\r\n\r\ncan you give that a try, i dont have an os x system",
      "created_at" : "2018-11-06T23:25:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14336#issuecomment-436446576",
      "id" : 436446576,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14336",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjQ0NjU3Ng==",
      "updated_at" : "2018-11-06T23:25:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436446576",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/620611?v=4",
         "events_url" : "https://api.github.com/users/pstratem/events{/privacy}",
         "followers_url" : "https://api.github.com/users/pstratem/followers",
         "following_url" : "https://api.github.com/users/pstratem/following{/other_user}",
         "gists_url" : "https://api.github.com/users/pstratem/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/pstratem",
         "id" : 620611,
         "login" : "pstratem",
         "node_id" : "MDQ6VXNlcjYyMDYxMQ==",
         "organizations_url" : "https://api.github.com/users/pstratem/orgs",
         "received_events_url" : "https://api.github.com/users/pstratem/received_events",
         "repos_url" : "https://api.github.com/users/pstratem/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/pstratem/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/pstratem/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/pstratem"
      }
   }
]
