[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r791661778"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791661778"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Would it compile if you remove this and use `::ToString(node.k)` instead?",
      "commit_id" : "74d3f9b58e56c1375bfe7f4c1c1a0fda17124f1d",
      "created_at" : "2022-01-25T12:28:07Z",
      "diff_hunk" : "@@ -0,0 +1,1563 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SCRIPT_MINISCRIPT_H\n+#define BITCOIN_SCRIPT_MINISCRIPT_H\n+\n+#include <algorithm>\n+#include <numeric>\n+#include <memory>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+\n+#include <policy/policy.h>\n+#include <script/script.h>\n+#include <span.h>\n+#include <util/spanparsing.h>\n+#include <util/strencodings.h>\n+#include <util/vector.h>\n+#include <primitives/transaction.h>\n+\n+namespace miniscript {\n+\n+/** This type encapsulates the miniscript type system properties.\n+ *\n+ * Every miniscript expression is one of 4 basic types, and additionally has\n+ * a number of boolean type properties.\n+ *\n+ * The basic types are:\n+ * - \"B\" Base:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfied, pushes a nonzero value of up to 4 bytes onto the stack.\n+ *   - When dissatisfied, pushes a 0 onto the stack.\n+ *   - This is used for most expressions, and required for the top level one.\n+ *   - For example: older(n) = <n> OP_CHECKSEQUENCEVERIFY.\n+ * - \"V\" Verify:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - When satisfactied, pushes nothing.\n+ *   - Cannot be dissatisfied.\n+ *   - This is obtained by adding an OP_VERIFY to a B, modifying the last opcode\n+ *     of a B to its -VERIFY version (only for OP_CHECKSIG, OP_CHECKSIGVERIFY\n+ *     and OP_EQUAL), or using IFs where both branches are also Vs.\n+ *   - For example vc:pk_k(key) = <key> OP_CHECKSIGVERIFY\n+ * - \"K\" Key:\n+ *   - Takes its inputs from the top of the stack.\n+ *   - Becomes a B when followed by OP_CHECKSIG.\n+ *   - Always pushes a public key onto the stack, for which a signature is to be\n+ *     provided to satisfy the expression.\n+ *   - For example pk_h(key) = OP_DUP OP_HASH160 <Hash160(key)> OP_EQUALVERIFY\n+ * - \"W\" Wrapped:\n+ *   - Takes its input from one below the top of the stack.\n+ *   - When satisfied, pushes a nonzero value (like B) on top of the stack, or one below.\n+ *   - When dissatisfied, pushes 0 op top of the stack or one below.\n+ *   - Is always \"OP_SWAP [B]\" or \"OP_TOALTSTACK [B] OP_FROMALTSTACK\".\n+ *   - For example sc:pk_k(key) = OP_SWAP <key> OP_CHECKSIG\n+ *\n+ * There a type properties that help reasoning about correctness:\n+ * - \"z\" Zero-arg:\n+ *   - Is known to always consume exactly 0 stack elements.\n+ *   - For example after(n) = <n> OP_CHECKLOCKTIMEVERIFY\n+ * - \"o\" One-arg:\n+ *   - Is known to always consume exactly 1 stack element.\n+ *   - Conflicts with property 'z'\n+ *   - For example sha256(hash) = OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 <hash> OP_EQUAL\n+ * - \"n\" Nonzero:\n+ *   - For every way this expression can be satisfied, a satisfaction exists that never needs\n+ *     a zero top stack element.\n+ *   - Conflicts with property 'z' and with type 'W'.\n+ * - \"d\" Dissatisfiable:\n+ *   - There is an easy way to construct a dissatisfaction for this expression.\n+ *   - Conflicts with type 'V'.\n+ * - \"u\" Unit:\n+ *   - In case of satisfaction, an exact 1 is put on the stack (rather than just nonzero).\n+ *   - Conflicts with type 'V'.\n+ *\n+ * Additional type properties help reasoning about nonmalleability:\n+ * - \"e\" Expression:\n+ *   - This implies property 'd', but the dissatisfaction is nonmalleable.\n+ *   - This generally requires 'e' for all subexpressions which are invoked for that\n+ *     dissatifsaction, and property 'f' for the unexecuted subexpressions in that case.\n+ *   - Conflicts with type 'V'.\n+ * - \"f\" Forced:\n+ *   - Dissatisfactions (if any) for this expression always involve at least one signature.\n+ *   - Is always true for type 'V'.\n+ * - \"s\" Safe:\n+ *   - Satisfactions for this expression always involve at least one signature.\n+ * - \"m\" Nonmalleable:\n+ *   - For every way this expression can be satisfied (which may be none),\n+ *     a nonmalleable satisfaction exists.\n+ *   - This generally requires 'm' for all subexpressions, and 'e' for all subexpressions\n+ *     which are dissatisfied when satisfying the parent.\n+ *\n+ * One type property is an implementation detail:\n+ * - \"x\" Expensive verify:\n+ *   - Expressions with this property have a script whose last opcode is not EQUAL, CHECKSIG, or CHECKMULTISIG.\n+ *   - Not having this property means that it can be converted to a V at no cost (by switching to the\n+ *     -VERIFY version of the last opcode).\n+ *\n+ * Five more type properties for representing timelock information. Spend paths\n+ * in miniscripts containing conflicting timelocks and heightlocks cannot be spent together.\n+ * This helps users detect if miniscript does not match the semantic behaviour the\n+ * user expects.\n+ * - \"g\" Whether the branch contains a relative time timelock\n+ * - \"h\" Whether the branch contains a relative height timelock\n+ * - \"i\" Whether the branch contains a absolute time timelock\n+ * - \"j\" Whether the branch contains a absolute time heightlock\n+ * - \"k\"\n+ *   - Whether all satisfactions of this expression don't contain a mix of heightlock and timelock\n+ *     of the same type.\n+ *   - If the miniscript does not have the \"k\" property, the miniscript template will not match\n+ *     the user expectation of the corresponding spending policy.\n+ * For each of these properties the subset rule holds: an expression with properties X, Y, and Z, is also\n+ * valid in places where an X, a Y, a Z, an XY, ... is expected.\n+*/\n+class Type {\n+    //! Internal bitmap of properties (see \"\"_mst operator for details).\n+    uint32_t m_flags;\n+\n+    //! Internal constructor used by the \"\"_mst operator.\n+    explicit constexpr Type(uint32_t flags) : m_flags(flags) {}\n+\n+public:\n+    //! The only way to publicly construct a Type is using this literal operator.\n+    friend constexpr Type operator\"\" _mst(const char* c, size_t l);\n+\n+    //! Compute the type with the union of properties.\n+    constexpr Type operator|(Type x) const { return Type(m_flags | x.m_flags); }\n+\n+    //! Compute the type with the intersection of properties.\n+    constexpr Type operator&(Type x) const { return Type(m_flags & x.m_flags); }\n+\n+    //! Check whether the left hand's properties are superset of the right's (= left is a subtype of right).\n+    constexpr bool operator<<(Type x) const { return (x.m_flags & ~m_flags) == 0; }\n+\n+    //! Comparison operator to enable use in sets/maps (total ordering incompatible with <<).\n+    constexpr bool operator<(Type x) const { return m_flags < x.m_flags; }\n+\n+    //! Equality operator.\n+    constexpr bool operator==(Type x) const { return m_flags == x.m_flags; }\n+\n+    //! The empty type if x is false, itself otherwise.\n+    constexpr Type If(bool x) const { return Type(x ? m_flags : 0); }\n+};\n+\n+//! Literal operator to construct Type objects.\n+inline constexpr Type operator\"\" _mst(const char* c, size_t l) {\n+    return l == 0 ? Type(0) : operator\"\" _mst(c + 1, l - 1) | Type(\n+        *c == 'B' ? 1 << 0 : // Base type\n+        *c == 'V' ? 1 << 1 : // Verify type\n+        *c == 'K' ? 1 << 2 : // Key type\n+        *c == 'W' ? 1 << 3 : // Wrapped type\n+        *c == 'z' ? 1 << 4 : // Zero-arg property\n+        *c == 'o' ? 1 << 5 : // One-arg property\n+        *c == 'n' ? 1 << 6 : // Nonzero arg property\n+        *c == 'd' ? 1 << 7 : // Dissatisfiable property\n+        *c == 'u' ? 1 << 8 : // Unit property\n+        *c == 'e' ? 1 << 9 : // Expression property\n+        *c == 'f' ? 1 << 10 : // Forced property\n+        *c == 's' ? 1 << 11 : // Safe property\n+        *c == 'm' ? 1 << 12 : // Nonmalleable property\n+        *c == 'x' ? 1 << 13 : // Expensive verify\n+        *c == 'g' ? 1 << 14 : // older: contains relative time timelock   (csv_time)\n+        *c == 'h' ? 1 << 15 : // older: contains relative height timelock (csv_height)\n+        *c == 'i' ? 1 << 16 : // after: contains time timelock   (cltv_time)\n+        *c == 'j' ? 1 << 17 : // after: contains height timelock   (cltv_height)\n+        *c == 'k' ? 1 << 18 : // does not contain a combination of height and time locks\n+        (throw std::logic_error(\"Unknown character in _mst literal\"), 0)\n+    );\n+}\n+\n+template<typename Key> struct Node;\n+template<typename Key> using NodeRef = std::shared_ptr<const Node<Key>>;\n+\n+//! Construct a miniscript node as a shared_ptr.\n+template<typename Key, typename... Args>\n+NodeRef<Key> MakeNodeRef(Args&&... args) { return std::make_shared<const Node<Key>>(std::forward<Args>(args)...); }\n+\n+//! The different node types in miniscript.\n+enum class NodeType {\n+    JUST_0,    //!< OP_0\n+    JUST_1,    //!< OP_1\n+    PK_K,      //!< [key]\n+    PK_H,      //!< OP_DUP OP_HASH160 [keyhash] OP_EQUALVERIFY\n+    OLDER,     //!< [n] OP_CHECKSEQUENCEVERIFY\n+    AFTER,     //!< [n] OP_CHECKLOCKTIMEVERIFY\n+    SHA256,    //!< OP_SIZE 32 OP_EQUALVERIFY OP_SHA256 [hash] OP_EQUAL\n+    HASH256,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH256 [hash] OP_EQUAL\n+    RIPEMD160, //!< OP_SIZE 32 OP_EQUALVERIFY OP_RIPEMD160 [hash] OP_EQUAL\n+    HASH160,   //!< OP_SIZE 32 OP_EQUALVERIFY OP_HASH160 [hash] OP_EQUAL\n+    WRAP_A,    //!< OP_TOALTSTACK [X] OP_FROMALTSTACK\n+    WRAP_S,    //!< OP_SWAP [X]\n+    WRAP_C,    //!< [X] OP_CHECKSIG\n+    WRAP_D,    //!< OP_DUP OP_IF [X] OP_ENDIF\n+    WRAP_V,    //!< [X] OP_VERIFY (or -VERIFY version of last opcode in X)\n+    WRAP_J,    //!< OP_SIZE OP_0NOTEQUAL OP_IF [X] OP_ENDIF\n+    WRAP_N,    //!< [X] OP_0NOTEQUAL\n+    AND_V,     //!< [X] [Y]\n+    AND_B,     //!< [X] [Y] OP_BOOLAND\n+    OR_B,      //!< [X] [Y] OP_BOOLOR\n+    OR_C,      //!< [X] OP_NOTIF [Y] OP_ENDIF\n+    OR_D,      //!< [X] OP_IFDUP OP_NOTIF [Y] OP_ENDIF\n+    OR_I,      //!< OP_IF [X] OP_ELSE [Y] OP_ENDIF\n+    ANDOR,     //!< [X] OP_NOTIF [Z] OP_ELSE [Y] OP_ENDIF\n+    THRESH,    //!< [X1] ([Xn] OP_ADD)* [k] OP_EQUAL\n+    MULTI,     //!< [k] [key_n]* [n] OP_CHECKMULTISIG\n+    // AND_N(X,Y) is represented as ANDOR(X,Y,0)\n+    // WRAP_T(X) is represented as AND_V(X,1)\n+    // WRAP_L(X) is represented as OR_I(0,X)\n+    // WRAP_U(X) is represented as OR_I(X,0)\n+};\n+\n+\n+namespace internal {\n+\n+//! Helper function for Node::CalcType.\n+Type ComputeType(NodeType nodetype, Type x, Type y, Type z, const std::vector<Type>& sub_types, uint32_t k, size_t data_size, size_t n_subs, size_t n_keys);\n+\n+//! Helper function for Node::CalcScriptLen.\n+size_t ComputeScriptLen(NodeType nodetype, Type sub0typ, size_t subsize, uint32_t k, size_t n_subs, size_t n_keys);\n+\n+//! A helper sanitizer/checker for the output of CalcType.\n+Type SanitizeType(Type x);\n+\n+//! Class whose objects represent the maximum of a list of integers.\n+template<typename I>\n+struct MaxInt {\n+    const bool valid;\n+    const I value;\n+\n+    MaxInt() : valid(false), value(0) {}\n+    MaxInt(I val) : valid(true), value(val) {}\n+\n+    friend MaxInt<I> operator+(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid || !b.valid) return {};\n+        return a.value + b.value;\n+    }\n+\n+    friend MaxInt<I> Choose(const MaxInt<I>& a, const MaxInt<I>& b) {\n+        if (!a.valid) return b;\n+        if (!b.valid) return a;\n+        return std::max(a.value, b.value);\n+    }\n+};\n+\n+struct Ops {\n+    //! Non-push opcodes.\n+    uint32_t stat;\n+    //! Number of keys in possibly executed OP_CHECKMULTISIG(VERIFY)s to satisfy.\n+    MaxInt<uint32_t> sat;\n+    //! Number of keys in possibly executed OP_CHECKMULTISIG(VERIFY)s to dissatisfy.\n+    MaxInt<uint32_t> dsat;\n+\n+    Ops(uint32_t in_stat, MaxInt<uint32_t> in_sat, MaxInt<uint32_t> in_dsat) : stat(in_stat), sat(in_sat), dsat(in_dsat) {};\n+};\n+\n+struct StackSize {\n+    //! Maximum stack size to satisfy;\n+    MaxInt<uint32_t> sat;\n+    //! Maximum stack size to dissatisfy;\n+    MaxInt<uint32_t> dsat;\n+\n+    StackSize(MaxInt<uint32_t> in_sat, MaxInt<uint32_t> in_dsat) : sat(in_sat), dsat(in_dsat) {};\n+};\n+\n+} // namespace internal\n+\n+//! A node in a miniscript expression.\n+template<typename Key>\n+struct Node {\n+    //! What node type this node is.\n+    const NodeType nodetype;\n+    //! The k parameter (time for OLDER/AFTER, threshold for THRESH(_M))\n+    const uint32_t k = 0;\n+    //! The keys used by this expression (only for PK_K/PK_H/MULTI)\n+    const std::vector<Key> keys;\n+    //! The data bytes in this expression (only for HASH160/HASH256/SHA256/RIPEMD10).\n+    const std::vector<unsigned char> data;\n+    //! Subexpressions (for WRAP_*/AND_*/OR_*/ANDOR/THRESH)\n+    const std::vector<NodeRef<Key>> subs;\n+\n+private:\n+    //! Cached ops counts.\n+    const internal::Ops ops;\n+    //! Cached stack size bounds.\n+    const internal::StackSize ss;\n+    //! Cached expression type (computed by CalcType and fed through SanitizeType).\n+    const Type typ;\n+    //! Cached script length (computed by CalcScriptLen).\n+    const size_t scriptlen;\n+\n+    //! Compute the length of the script for this miniscript (including children).\n+    size_t CalcScriptLen() const {\n+        size_t subsize = 0;\n+        for (const auto& sub : subs) {\n+            subsize += sub->ScriptSize();\n+        }\n+        Type sub0type = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        return internal::ComputeScriptLen(nodetype, sub0type, subsize, k, subs.size(), keys.size());\n+    }\n+\n+    /* Apply a recursive algorithm to a Miniscript tree, without actual recursive calls.\n+     *\n+     * The algorithm is defined by two functions: downfn and upfn. Conceptually, the\n+     * result can be thought of as first using downfn to compute a \"state\" for each node,\n+     * from the root down to the leaves. Then upfn is used to compute a \"result\" for each\n+     * node, from the leaves back up to the root, which is then returned. In the actual\n+     * implementation, both functions are invoked in an interleaved fashion, performing a\n+     * depth-first traversal of the tree.\n+     *\n+     * In more detail, it is invoked as node.TreeEvalMaybe<Result>(root, downfn, upfn):\n+     * - root is the state of the root node, of type State.\n+     * - downfn is a callable (State&, const Node&, size_t) -> State, which given a\n+     *   node, its state, and an index of one of its children, computes the state of that\n+     *   child. It can modify the state. Children of a given node will have downfn()\n+     *   called in order.\n+     * - upfn is a callable (State&&, const Node&, Span<Result>) -> std::optional<Result>,\n+     *   which given a node, its state, and a Span of the results of its children,\n+     *   computes the result of the node. If std::nullopt is returned by upfn,\n+     *   TreeEvalMaybe() immediately returns std::nullopt.\n+     * The return value of TreeEvalMaybe is the result of the root node.\n+     */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    std::optional<Result> TreeEvalMaybe(State root_state, DownFn downfn, UpFn upfn) const\n+    {\n+        /** Entries of the explicit stack tracked in this algorithm. */\n+        struct StackElem\n+        {\n+            const Node& node; //!< The node being evaluated.\n+            size_t expanded; //!< How many children of this node have been expanded.\n+            State state; //!< The state for that node.\n+\n+            StackElem(const Node& node_, size_t exp_, State&& state_) :\n+                node(node_), expanded(exp_), state(std::move(state_)) {}\n+        };\n+        /* Stack of tree nodes being explored. */\n+        std::vector<StackElem> stack;\n+        /* Results of subtrees so far. Their order and mapping to tree nodes\n+         * is implicitly defined by stack. */\n+        std::vector<Result> results;\n+        stack.emplace_back(*this, 0, std::move(root_state));\n+\n+        /* Here is a demonstration of the algorithm, for an example tree A(B,C(D,E),F).\n+         * State variables are omitted for simplicity.\n+         *\n+         * First: stack=[(A,0)] results=[]\n+         *        stack=[(A,1),(B,0)] results=[]\n+         *        stack=[(A,1)] results=[B]\n+         *        stack=[(A,2),(C,0)] results=[B]\n+         *        stack=[(A,2),(C,1),(D,0)] results=[B]\n+         *        stack=[(A,2),(C,1)] results=[B,D]\n+         *        stack=[(A,2),(C,2),(E,0)] results=[B,D]\n+         *        stack=[(A,2),(C,2)] results=[B,D,E]\n+         *        stack=[(A,2)] results=[B,C]\n+         *        stack=[(A,3),(F,0)] results=[B,C]\n+         *        stack=[(A,3)] results=[B,C,F]\n+         * Final: stack=[] results=[A]\n+         */\n+        while (stack.size()) {\n+            const Node& node = stack.back().node;\n+            if (stack.back().expanded < node.subs.size()) {\n+                /* We encounter a tree node with at least one unexpanded child.\n+                 * Expand it. By the time we hit this node again, the result of\n+                 * that child (and all earlier children) will be on the stack. */\n+                size_t child_index = stack.back().expanded++;\n+                State child_state = downfn(stack.back().state, node, child_index);\n+                stack.emplace_back(*node.subs[child_index], 0, std::move(child_state));\n+                continue;\n+            }\n+            // Invoke upfn with the last node.subs.size() elements of results as input.\n+            assert(results.size() >= node.subs.size());\n+            std::optional<Result> result{upfn(std::move(stack.back().state), node,\n+                Span<Result>{results}.last(node.subs.size()))};\n+            // If evaluation returns std::nullopt, abort immediately.\n+            if (!result) return {};\n+            // Replace the last node.subs.size() elements of results with the new result.\n+            results.erase(results.end() - node.subs.size(), results.end());\n+            results.push_back(std::move(*result));\n+            stack.pop_back();\n+        }\n+        // The final remaining results element is the root result, return it.\n+        assert(results.size() == 1);\n+        return std::move(results[0]);\n+    }\n+\n+    /** Like TreeEvalMaybe, but always produces a result. upfn must return Result. */\n+    template<typename Result, typename State, typename DownFn, typename UpFn>\n+    Result TreeEval(State root_state, DownFn&& downfn, UpFn upfn) const\n+    {\n+        // Invoke TreeEvalMaybe with upfn wrapped to return std::optional<Result>, and then\n+        // unconditionally dereference the result (it cannot be std::nullopt).\n+        return std::move(*TreeEvalMaybe<Result>(std::move(root_state),\n+            std::forward<DownFn>(downfn),\n+            [&upfn](State&& state, const Node& node, Span<Result> subs) {\n+                Result res{upfn(std::move(state), node, subs)};\n+                return std::optional<Result>(std::move(res));\n+            }\n+        ));\n+    }\n+\n+    //! Compute the type for this miniscript.\n+    Type CalcType() const {\n+        using namespace internal;\n+\n+        // THRESH has a variable number of subexpression\n+        std::vector<Type> sub_types;\n+        if (nodetype == NodeType::THRESH) {\n+            for (const auto& sub : subs) sub_types.push_back(sub->GetType());\n+        }\n+        // All other nodes than THRESH can be computed just from the types of the 0-3 subexpexpressions.\n+        Type x = subs.size() > 0 ? subs[0]->GetType() : \"\"_mst;\n+        Type y = subs.size() > 1 ? subs[1]->GetType() : \"\"_mst;\n+        Type z = subs.size() > 2 ? subs[2]->GetType() : \"\"_mst;\n+\n+        return SanitizeType(ComputeType(nodetype, x, y, z, sub_types, k, data.size(), subs.size(), keys.size()));\n+    }\n+\n+public:\n+    template<typename Ctx>\n+    CScript ToScript(const Ctx& ctx) const\n+    {\n+        // To construct the CScript for a Miniscript object, we use the TreeEval algorithm.\n+        // The State is a boolean: whether or not the node's script expansion is followed\n+        // by an OP_VERIFY (which may need to be combined with the last script opcode).\n+        auto downfn = [](bool verify, const Node& node, size_t index) {\n+            // For WRAP_V, the subexpression is certainly followed by OP_VERIFY.\n+            if (node.nodetype == NodeType::WRAP_V) return true;\n+            // The subexpression of WRAP_S, and the last subexpression of AND_V\n+            // inherit the followed-by-OP_VERIFY property from the parent.\n+            if (node.nodetype == NodeType::WRAP_S ||\n+                (node.nodetype == NodeType::AND_V && index == 1)) return verify;\n+            return false;\n+        };\n+        // The upward function computes for a node, given its followed-by-OP_VERIFY status\n+        // and the CScripts of its child nodes, the CScript of the node.\n+        auto upfn = [&ctx](bool verify, const Node& node, Span<CScript> subs) -> CScript {\n+            switch (node.nodetype) {\n+                case NodeType::PK_K: return CScript() << ctx.ToPKBytes(node.keys[0]);\n+                case NodeType::PK_H: return CScript() << OP_DUP << OP_HASH160 << ctx.ToPKHBytes(node.keys[0]) << OP_EQUALVERIFY;\n+                case NodeType::OLDER: return CScript() << node.k << OP_CHECKSEQUENCEVERIFY;\n+                case NodeType::AFTER: return CScript() << node.k << OP_CHECKLOCKTIMEVERIFY;\n+                case NodeType::SHA256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_SHA256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::RIPEMD160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_RIPEMD160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH256: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH256 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::HASH160: return CScript() << OP_SIZE << 32 << OP_EQUALVERIFY << OP_HASH160 << node.data << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                case NodeType::WRAP_A: return (CScript() << OP_TOALTSTACK) + std::move(subs[0]) + (CScript() << OP_FROMALTSTACK);\n+                case NodeType::WRAP_S: return (CScript() << OP_SWAP) + std::move(subs[0]);\n+                case NodeType::WRAP_C: return std::move(subs[0]) + CScript() << (verify ? OP_CHECKSIGVERIFY : OP_CHECKSIG);\n+                case NodeType::WRAP_D: return (CScript() << OP_DUP << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_V: return std::move(subs[0]) + (node.subs[0]->GetType() << \"x\"_mst ? (CScript() << OP_VERIFY) : CScript());\n+                case NodeType::WRAP_J: return (CScript() << OP_SIZE << OP_0NOTEQUAL << OP_IF) + std::move(subs[0]) + (CScript() << OP_ENDIF);\n+                case NodeType::WRAP_N: return std::move(subs[0]) + CScript() << OP_0NOTEQUAL;\n+                case NodeType::JUST_1: return CScript() << OP_1;\n+                case NodeType::JUST_0: return CScript() << OP_0;\n+                case NodeType::AND_V: return std::move(subs[0]) + std::move(subs[1]);\n+                case NodeType::AND_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLAND);\n+                case NodeType::OR_B: return std::move(subs[0]) + std::move(subs[1]) + (CScript() << OP_BOOLOR);\n+                case NodeType::OR_D: return std::move(subs[0]) + (CScript() << OP_IFDUP << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_C: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::OR_I: return (CScript() << OP_IF) + std::move(subs[0]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::ANDOR: return std::move(subs[0]) + (CScript() << OP_NOTIF) + std::move(subs[2]) + (CScript() << OP_ELSE) + std::move(subs[1]) + (CScript() << OP_ENDIF);\n+                case NodeType::MULTI: {\n+                    CScript script = CScript() << node.k;\n+                    for (const auto& key : node.keys) {\n+                        script << ctx.ToPKBytes(key);\n+                    }\n+                    return std::move(script) << node.keys.size() << (verify ? OP_CHECKMULTISIGVERIFY : OP_CHECKMULTISIG);\n+                }\n+                case NodeType::THRESH: {\n+                    CScript script = std::move(subs[0]);\n+                    for (size_t i = 1; i < subs.size(); ++i) {\n+                        script = (std::move(script) + std::move(subs[i])) << OP_ADD;\n+                    }\n+                    return std::move(script) << node.k << (verify ? OP_EQUALVERIFY : OP_EQUAL);\n+                }\n+            }\n+            assert(false);\n+            return {};\n+        };\n+        return TreeEval<CScript>(false, downfn, upfn);\n+    }\n+\n+    template<typename CTx>\n+    bool ToString(const CTx& ctx, std::string& ret) const {\n+        // To construct the std::string representation for a Miniscript object, we use\n+        // the TreeEvalMaybe algorithm. The State is a boolean: whether the parent node is a\n+        // wrapper. If so, non-wrapper expressions must be prefixed with a \":\".\n+        auto downfn = [](bool, const Node& node, size_t) {\n+            return (node.nodetype == NodeType::WRAP_A || node.nodetype == NodeType::WRAP_S ||\n+                    node.nodetype == NodeType::WRAP_D || node.nodetype == NodeType::WRAP_V ||\n+                    node.nodetype == NodeType::WRAP_J || node.nodetype == NodeType::WRAP_N ||\n+                    node.nodetype == NodeType::WRAP_C ||\n+                    (node.nodetype == NodeType::AND_V && node.subs[1]->nodetype == NodeType::JUST_1) ||\n+                    (node.nodetype == NodeType::OR_I && node.subs[0]->nodetype == NodeType::JUST_0) ||\n+                    (node.nodetype == NodeType::OR_I && node.subs[1]->nodetype == NodeType::JUST_0));\n+        };\n+        // The upward function computes for a node, given whether its parent is a wrapper,\n+        // and the string representations of its child nodes, the string representation of the node.\n+        auto upfn = [&ctx](bool wrapped, const Node& node, Span<std::string> subs) -> std::optional<std::string> {\n+            std::string ret = wrapped ? \":\" : \"\";\n+            std::stringstream k_sstr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#discussion_r791661778",
      "id" : 791661778,
      "line" : 504,
      "node_id" : "PRRC_kwDOABII584vL8zS",
      "original_commit_id" : "74d3f9b58e56c1375bfe7f4c1c1a0fda17124f1d",
      "original_line" : 504,
      "original_position" : 504,
      "original_start_line" : null,
      "path" : "src/script/miniscript.h",
      "position" : 504,
      "pull_request_review_id" : 862209933,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24147",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791661778/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-01-25T12:28:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/791661778",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Arg, the unit test (`miniscript_tests`) gets [OOM killed in the CI](https://cirrus-ci.com/task/6650942870257664) when ASAN is enabled.\r\nEDIT: reproduced locally (the RAM usage is crazy, went up to 13G before i killed it although the test without ASAN uses only a few hundreds MB).\r\nDecreasing the number of iterations for the random tests to 100 for now (caps the mem usage to 2G on my machine under ASAN). I'll look into making `GenNode` generate valid nodes more often, which i think is the main culprit here...\r\n\r\n\r\nAside: this shouldn't be labeled as \"Consensus\" (neither should #24148 be) :)",
      "created_at" : "2022-01-25T13:03:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1021161686",
      "id" : 1021161686,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII58483bDW",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1021161686/reactions"
      },
      "updated_at" : "2022-01-25T15:17:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1021161686",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK. I wonder if it makes sense to start out with a small subset of miniscript, so reviewers can focus on the implementation rather than on completeness.",
      "created_at" : "2022-01-25T15:09:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1021285627",
      "id" : 1021285627,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII584835T7",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1021285627/reactions"
      },
      "updated_at" : "2022-01-25T15:09:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1021285627",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Strong concept ACK",
      "created_at" : "2022-01-25T21:00:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1021604268",
      "id" : 1021604268,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII58485HGs",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1021604268/reactions"
      },
      "updated_at" : "2022-01-25T21:00:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1021604268",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/meshcollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/meshcollider/followers",
         "following_url" : "https://api.github.com/users/meshcollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/meshcollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/meshcollider",
         "id" : 3211283,
         "login" : "meshcollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/meshcollider/orgs",
         "received_events_url" : "https://api.github.com/users/meshcollider/received_events",
         "repos_url" : "https://api.github.com/users/meshcollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/meshcollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/meshcollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/meshcollider"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#24043](https://github.com/bitcoin/bitcoin/pull/24043) (Add (sorted)multi_a descriptor for k-of-n multisig inside tr by sipa)\n* [#13062](https://github.com/bitcoin/bitcoin/pull/13062) (Make script interpreter independent from storage type CScript by sipa)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2022-01-26T00:26:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1021735972",
      "id" : 1021735972,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII58485nQk",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1021735972/reactions"
      },
      "updated_at" : "2022-01-26T00:26:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1021735972",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "nice. Concept ACK.\n",
      "created_at" : "2022-01-27T21:03:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1023636751",
      "id" : 1023636751,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII5849A3UP",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1023636751/reactions"
      },
      "updated_at" : "2022-01-27T21:03:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1023636751",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/45598?v=4",
         "events_url" : "https://api.github.com/users/jb55/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jb55/followers",
         "following_url" : "https://api.github.com/users/jb55/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jb55/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jb55",
         "id" : 45598,
         "login" : "jb55",
         "node_id" : "MDQ6VXNlcjQ1NTk4",
         "organizations_url" : "https://api.github.com/users/jb55/orgs",
         "received_events_url" : "https://api.github.com/users/jb55/received_events",
         "repos_url" : "https://api.github.com/users/jb55/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jb55/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jb55/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jb55"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK",
      "created_at" : "2022-01-29T08:18:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1024864009",
      "id" : 1024864009,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII5849Fi8J",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024864009/reactions"
      },
      "updated_at" : "2022-01-29T08:18:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024864009",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3072149?v=4",
         "events_url" : "https://api.github.com/users/dunxen/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dunxen/followers",
         "following_url" : "https://api.github.com/users/dunxen/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dunxen/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dunxen",
         "id" : 3072149,
         "login" : "dunxen",
         "node_id" : "MDQ6VXNlcjMwNzIxNDk=",
         "organizations_url" : "https://api.github.com/users/dunxen/orgs",
         "received_events_url" : "https://api.github.com/users/dunxen/received_events",
         "repos_url" : "https://api.github.com/users/dunxen/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dunxen/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dunxen/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dunxen"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Concept ACK. I wonder if it makes sense to start out with a small subset of miniscript, so reviewers can focus on the implementation rather than on completeness.\r\n\r\nI have tried to split this work into as many PR as reasonable, to reduce the size of this first chunk as much as possible. Note that 21% (you can't make this up) of the diff here is tests, and even more so in the following PRs. I'm afraid that further splitting this doesn't make sense.\r\nFor smaller chunks to review, commits here should be focused, atomic and independently reviewable.\r\n\r\nFurther, i'm currently simplifying a few things following Pieter's comments above.\r\nI'm happy to help review as much as i can, and if not for the first reviewers, comments like \"it took time for me to grasp this was doing X, [adding a comment here / rewriting it this way] would be helpful to following reviewers\" are very welcome!",
      "created_at" : "2022-01-29T09:37:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1024876678",
      "id" : 1024876678,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII5849FmCG",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024876678/reactions"
      },
      "updated_at" : "2022-01-29T09:38:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024876678",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "It's mostly 3a2c00d9bc3c7a34fb8727d76e9c3a691395b67c that introduces a rather large body of stuff. Conceptually `c:pk_k(key)` is the easiest thing to understand, the equivalent of a `pk()` descriptor. So one commit could introduce `NodeType` with just `PK_K` and `WRAP_C`, `Type` with just B and K implemented. That should make that commit about 90% smaller, while still introducing the main moving parts of a parser, constraint checking, etc.\r\n\r\nThis doesn't necessarily require more PR's, though it might: only a limited subset of the descriptor language is necessary to get the functionality currently in descriptors. So then you could go straight to #24148 and #24149, to finish the job of blending miniscript with descriptors, while using parallel PR's to expand the miniscript language.",
      "created_at" : "2022-01-29T15:33:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24147#issuecomment-1024933026",
      "id" : 1024933026,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/24147",
      "node_id" : "IC_kwDOABII5849Fzyi",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024933026/reactions"
      },
      "updated_at" : "2022-01-29T15:37:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1024933026",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   }
]
