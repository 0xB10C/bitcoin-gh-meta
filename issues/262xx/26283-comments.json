[
   {
      "author_association" : "MEMBER",
      "body" : "Marking this draft until:\r\n1. ~~[Previous PR is merged](https://github.com/bitcoin/bitcoin/pull/23443)~~ [Follow-up is merged](https://github.com/bitcoin/bitcoin/pull/26359)\r\n2. There is one in-code TODO I have to resolve (it is minor, but it has to be improved)\r\n3. I add unit and functional tests for these features.\r\n\r\nAnother task is to sync [parent PR](https://github.com/bitcoin/bitcoin/pull/21515) with this version. I have a local branch that compiles, but tests of the full Erlay there needs a little care. If you want to see how this PR works in the broader context, the parent should be good enough to get it. Otherwise, I intend to update it soon.",
      "created_at" : "2022-10-08T07:33:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#issuecomment-1272254249",
      "id" : 1272254249,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26283",
      "node_id" : "IC_kwDOABII585L1Q8p",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1272254249/reactions"
      },
      "updated_at" : "2022-10-28T09:07:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1272254249",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#26151](https://github.com/bitcoin/bitcoin/pull/26151) (refactor: Guard TxRequestTracker by its own lock instead of cs_main by dergoegge)\n* [#26140](https://github.com/bitcoin/bitcoin/pull/26140) (refactor: Move CNodeState members guarded by g_msgproc_mutex to Peer by dergoegge)\n* [#25957](https://github.com/bitcoin/bitcoin/pull/25957) (wallet: fast rescan with BIP157 block filters for descriptor wallets by theStack)\n* [#25740](https://github.com/bitcoin/bitcoin/pull/25740) (assumeutxo: background validation completion by jamesob)\n* [#25667](https://github.com/bitcoin/bitcoin/pull/25667) (assumeutxo: snapshot initialization by jamesob)\n* [#25572](https://github.com/bitcoin/bitcoin/pull/25572) (refactor: Introduce EvictionManager and use it for the inbound eviction logic by dergoegge)\n* [#24545](https://github.com/bitcoin/bitcoin/pull/24545) (BIP324: Enable v2 P2P encrypted transport by dhruv)\n* [#24125](https://github.com/bitcoin/bitcoin/pull/24125) (p2p: Replace RecursiveMutex `cs_tx_inventory` with Mutex and rename it by w0xlt)\n* [#23549](https://github.com/bitcoin/bitcoin/pull/23549) (Add scanblocks RPC call (attempt 2) by jamesob)\n* [#23233](https://github.com/bitcoin/bitcoin/pull/23233) (BIP324: Add encrypted p2p transport {de}serializer by dhruv)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2022-10-08T16:15:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#issuecomment-1272351013",
      "id" : 1272351013,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26283",
      "node_id" : "IC_kwDOABII585L1okl",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1272351013/reactions"
      },
      "updated_at" : "2022-10-08T16:15:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1272351013",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998568613"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998568613"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/reocnciliation set/reconciliation set/g",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T18:17:12Z",
      "diff_hunk" : "@@ -5576,8 +5701,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            bool flood_target = m_txreconciliation->ShouldFloodTo(wtxid, pto->GetId());\n+\n+                            // Special treatment for unconfirmed transactions with unconfirmed\n+                            // parents.\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n+                            for (const CTxMemPoolEntry& parent : parents) {\n+                                // Two situations are possible here:\n+                                // 1. The parent was fully relayed to the peer earlier.\n+                                // 2. The parent is set for reconciliation and the child is not\n+                                //    in the mempool yet. The child arrives to the mempool and is\n+                                //    flooded. The peer receives the child earlier than the parent.\n+                                // We can differentiate between the two by looking at the recon\n+                                // set: if the set (or the snapshot) contains the parent, the parent\n+                                // is being reconciled (case 2). Then, we add the child to the\n+                                // reconciliation set, so that it doesn't arrive earlier than the\n+                                // parent.\n+                                // If it's the case 1, we proceed as usual by looking at the\n+                                // child's wtxid.\n+                                const uint256 parent_wtxid = parent.GetTx().GetWitnessHash();\n+                                if (m_txreconciliation->CurrentlyReconcilingTx(pto->GetId(), parent_wtxid) ||\n+                                    std::find(txs_to_reconcile.begin(), txs_to_reconcile.end(), parent_wtxid) != txs_to_reconcile.end()) {\n+                                    // Currently reconciling parent tx.\n+                                    // We have the following options to do:\n+                                    // 1. Flood parent+child.\n+                                    // 2. Reconcile parent+child.\n+                                    // 3. Flood parent, reconcile child.\n+                                    // We choose (2) because it has the easiest implementation.\n+                                    // The latency impact is not that bad:\n+                                    // 1. If the parent is in the reocnciliation set, the two",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998568613",
      "id" : 998568613,
      "line" : 5744,
      "node_id" : "PRRC_kwDOABII5847hPKl",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 5744,
      "original_position" : 297,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 297,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998568613/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998568613",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998588937"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998588937"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could be `<=` as `MAX_PEER_TX_ANNOUNCEMENTS` should be the maximum number of elements/transactions we announce to our peers. Note, while only strictly inferior transaction requests are considered L1409 in `net_processing.cpp`, this is different for the processing of `NOTFOUND`, L4793, still in `net_processing.cpp`.",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T18:41:23Z",
      "diff_hunk" : "@@ -5576,8 +5701,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            bool flood_target = m_txreconciliation->ShouldFloodTo(wtxid, pto->GetId());\n+\n+                            // Special treatment for unconfirmed transactions with unconfirmed\n+                            // parents.\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n+                            for (const CTxMemPoolEntry& parent : parents) {\n+                                // Two situations are possible here:\n+                                // 1. The parent was fully relayed to the peer earlier.\n+                                // 2. The parent is set for reconciliation and the child is not\n+                                //    in the mempool yet. The child arrives to the mempool and is\n+                                //    flooded. The peer receives the child earlier than the parent.\n+                                // We can differentiate between the two by looking at the recon\n+                                // set: if the set (or the snapshot) contains the parent, the parent\n+                                // is being reconciled (case 2). Then, we add the child to the\n+                                // reconciliation set, so that it doesn't arrive earlier than the\n+                                // parent.\n+                                // If it's the case 1, we proceed as usual by looking at the\n+                                // child's wtxid.\n+                                const uint256 parent_wtxid = parent.GetTx().GetWitnessHash();\n+                                if (m_txreconciliation->CurrentlyReconcilingTx(pto->GetId(), parent_wtxid) ||\n+                                    std::find(txs_to_reconcile.begin(), txs_to_reconcile.end(), parent_wtxid) != txs_to_reconcile.end()) {\n+                                    // Currently reconciling parent tx.\n+                                    // We have the following options to do:\n+                                    // 1. Flood parent+child.\n+                                    // 2. Reconcile parent+child.\n+                                    // 3. Flood parent, reconcile child.\n+                                    // We choose (2) because it has the easiest implementation.\n+                                    // The latency impact is not that bad:\n+                                    // 1. If the parent is in the reocnciliation set, the two\n+                                    // transactions will be relayed at the same time. There is\n+                                    // no point relaying the child faster anyway.\n+                                    // 2. If the parent is in the snapshot, the child will\n+                                    // be reconcilied within the next batch. This would\n+                                    // introduce extra latency (even if by wtxid the child\n+                                    // should have been flooded over this link), but this will\n+                                    // be compensated later: if the delay is non-trivial,\n+                                    // for the next nodes this condition won't be triggered (\n+                                    // parent won't be in the reconciliation set).\n+                                    //\n+                                    // In case of the multiple unconfirmed parents, we will\n+                                    // reconcile if at least one of the parents is being\n+                                    // reconciled.\n+                                    //\n+                                    // Note, the transaction still could be flooded if the\n+                                    // reconciliation set is full (see check below). This\n+                                    // is not the general case and is likely caused by the\n+                                    // issues with the peer, and then we're not responsible\n+                                    // that the package can't pass mempool limitations.\n+                                    flood_target = false;\n+                                    break;\n+                                }\n+                            }\n+\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via fan-out.\n+                            const size_t recon_set_size = m_txreconciliation->GetPeerSetSize(pto->GetId());\n+                            if (!flood_target && txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998588937",
      "id" : 998588937,
      "line" : 5781,
      "node_id" : "PRRC_kwDOABII5847hUIJ",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 5781,
      "original_position" : 334,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 334,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998588937/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998588937",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998598182"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998598182"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could be called `IsAlreadyInPeerSet` or something more speaking than transaction is already in peer local set but not announced yet. ",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T18:52:19Z",
      "diff_hunk" : "@@ -0,0 +1,128 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXRECONCILIATION_H\n+#define BITCOIN_NODE_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/** Whether transaction reconciliation protocol should be enabled by default. */\n+static constexpr bool DEFAULT_TXRECONCILIATION_ENABLE{false};\n+/** Supported transaction reconciliation protocol version */\n+static constexpr uint32_t TXRECONCILIATION_VERSION{1};\n+\n+enum ReconciliationRegisterResult {\n+    NOT_FOUND = 0,\n+    SUCCESS = 1,\n+    PROTOCOL_VIOLATION = 2,\n+};\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all txreconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0.  Txreconciliation protocol handshake.\n+ * 1.  Once we receive a new transaction, add it to the set instead of announcing immediately.\n+ * 2.  At regular intervals, a txreconciliation initiator requests a sketch from a peer, where a\n+ *     sketch is a compressed representation of short form IDs of the transactions in their set.\n+ * 3.  Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *     and combines the two sketches to attempt finding the difference in *sets*.\n+ * 4a. If the difference was not larger than estimated, see SUCCESS below.\n+ * 4b. If the difference was larger than estimated, initial txreconciliation fails. The initiator\n+ *     requests a larger sketch via an extension round (allowed only once).\n+ *     - If extension succeeds (a larger sketch is sufficient), see SUCCESS below.\n+ *     - If extension fails (a larger sketch is insufficient), see FAILURE below.\n+ *\n+ * SUCCESS. The initiator knows full symmetrical difference and can request what the initiator is\n+ *          missing and announce to the peer what the peer is missing.\n+ *\n+ * FAILURE. The initiator notifies the peer about the failure and announces all transactions from\n+ *          the corresponding set. Once the peer received the failure notification, the peer\n+ *          announces all transactions from their set.\n+\n+ * This is a modification of the Erlay protocol (https://arxiv.org/abs/1905.10518) with two\n+ * changes (sketch extensions instead of bisections, and an extra INV exchange round), both\n+ * are motivated in BIP-330.\n+ */\n+class TxReconciliationTracker\n+{\n+private:\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    explicit TxReconciliationTracker(uint32_t recon_version);\n+    ~TxReconciliationTracker();\n+\n+    /**\n+     * Step 0. Generates initial part of the state (salt) required to reconcile txs with the peer.\n+     * The salt is used for short ID computation required for txreconciliation.\n+     * The function returns the salt.\n+     * A peer can't participate in future txreconciliations without this call.\n+     * This function must be called only once per peer.\n+     */\n+    uint64_t PreRegisterPeer(NodeId peer_id);\n+\n+    /**\n+     * Step 0. Once the peer agreed to reconcile txs with us, generate the state required to track\n+     * ongoing reconciliations. Must be called only after pre-registering the peer and only once.\n+     */\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version, uint64_t remote_salt);\n+\n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     */\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     */\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove);\n+\n+    /**\n+     * Step 2. If a it's time to request a reconciliation from the peer, this function will return\n+     * the details of our local state, which should be communicated to the peer so that they better\n+     * know what we need:\n+     * - size of our reconciliation set for the peer\n+     * - our q-coefficient with the peer, formatted to be transmitted as integer value\n+     * If the peer was not previously registered for reconciliations, returns nullopt.\n+     */\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id);\n+\n+    /**\n+     * Returns the size of the reconciliation set we have locally for the given peer.\n+     * If the peer was not previously registered for reconciliations, returns nullopt.\n+     */\n+    size_t GetPeerSetSize(NodeId peer_id) const;\n+\n+    /**\n+     * Attempts to forget txreconciliation-related state of the peer (if we previously stored any).\n+     * After this, we won't be able to reconcile transactions with the peer.\n+     */\n+    void ForgetPeer(NodeId peer_id);\n+\n+    /**\n+     * Check if a peer is registered to reconcile transactions with us.\n+     */\n+    bool IsPeerRegistered(NodeId peer_id) const;\n+\n+    /**\n+     * Returns whether for the given call the peer is chosen as a low-fanout destination.\n+     */\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const;\n+\n+    /**\n+     * Check whether a particular transaction is being currently reconciled with a given peer.\n+     */\n+    bool CurrentlyReconcilingTx(NodeId peer_id, const uint256 wtxid) const;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998598182",
      "id" : 998598182,
      "line" : 125,
      "node_id" : "PRRC_kwDOABII5847hWYm",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 125,
      "original_position" : 125,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.h",
      "position" : 125,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998598182/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998598182",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998610903"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998610903"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Note, current inv-based transaction announcement (L5812) isn't gated on IBD being over though I agree it makes sense to save bandwidth as the node is unlikely to be able to validate most of the transactions received for inaccuracy of its local UTXO set. ",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T19:07:34Z",
      "diff_hunk" : "@@ -5611,11 +5822,31 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {\n+                        m_txreconciliation->AddToReconSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998610903",
      "id" : 998610903,
      "line" : 5839,
      "node_id" : "PRRC_kwDOABII5847hZfX",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 5839,
      "original_position" : 366,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 366,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998610903/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998610903",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998613472"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998613472"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/if a it's time/if it's time/g",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T19:10:45Z",
      "diff_hunk" : "@@ -0,0 +1,128 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TXRECONCILIATION_H\n+#define BITCOIN_NODE_TXRECONCILIATION_H\n+\n+#include <net.h>\n+#include <sync.h>\n+\n+#include <memory>\n+#include <tuple>\n+\n+/** Whether transaction reconciliation protocol should be enabled by default. */\n+static constexpr bool DEFAULT_TXRECONCILIATION_ENABLE{false};\n+/** Supported transaction reconciliation protocol version */\n+static constexpr uint32_t TXRECONCILIATION_VERSION{1};\n+\n+enum ReconciliationRegisterResult {\n+    NOT_FOUND = 0,\n+    SUCCESS = 1,\n+    PROTOCOL_VIOLATION = 2,\n+};\n+\n+/**\n+ * Transaction reconciliation is a way for nodes to efficiently announce transactions.\n+ * This object keeps track of all txreconciliation-related communications with the peers.\n+ * The high-level protocol is:\n+ * 0.  Txreconciliation protocol handshake.\n+ * 1.  Once we receive a new transaction, add it to the set instead of announcing immediately.\n+ * 2.  At regular intervals, a txreconciliation initiator requests a sketch from a peer, where a\n+ *     sketch is a compressed representation of short form IDs of the transactions in their set.\n+ * 3.  Once the initiator received a sketch from the peer, the initiator computes a local sketch,\n+ *     and combines the two sketches to attempt finding the difference in *sets*.\n+ * 4a. If the difference was not larger than estimated, see SUCCESS below.\n+ * 4b. If the difference was larger than estimated, initial txreconciliation fails. The initiator\n+ *     requests a larger sketch via an extension round (allowed only once).\n+ *     - If extension succeeds (a larger sketch is sufficient), see SUCCESS below.\n+ *     - If extension fails (a larger sketch is insufficient), see FAILURE below.\n+ *\n+ * SUCCESS. The initiator knows full symmetrical difference and can request what the initiator is\n+ *          missing and announce to the peer what the peer is missing.\n+ *\n+ * FAILURE. The initiator notifies the peer about the failure and announces all transactions from\n+ *          the corresponding set. Once the peer received the failure notification, the peer\n+ *          announces all transactions from their set.\n+\n+ * This is a modification of the Erlay protocol (https://arxiv.org/abs/1905.10518) with two\n+ * changes (sketch extensions instead of bisections, and an extra INV exchange round), both\n+ * are motivated in BIP-330.\n+ */\n+class TxReconciliationTracker\n+{\n+private:\n+    class Impl;\n+    const std::unique_ptr<Impl> m_impl;\n+\n+public:\n+    explicit TxReconciliationTracker(uint32_t recon_version);\n+    ~TxReconciliationTracker();\n+\n+    /**\n+     * Step 0. Generates initial part of the state (salt) required to reconcile txs with the peer.\n+     * The salt is used for short ID computation required for txreconciliation.\n+     * The function returns the salt.\n+     * A peer can't participate in future txreconciliations without this call.\n+     * This function must be called only once per peer.\n+     */\n+    uint64_t PreRegisterPeer(NodeId peer_id);\n+\n+    /**\n+     * Step 0. Once the peer agreed to reconcile txs with us, generate the state required to track\n+     * ongoing reconciliations. Must be called only after pre-registering the peer and only once.\n+     */\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version, uint64_t remote_salt);\n+\n+    /**\n+     * Step 1. Add new transactions we want to announce to the peer to the local reconciliation set\n+     * of the peer, so that those transactions will be reconciled later.\n+     */\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile);\n+\n+    /**\n+     * Before Step 2, we might want to remove a wtxid from the reconciliation set, for example if\n+     * the peer just announced the transaction to us.\n+     */\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove);\n+\n+    /**\n+     * Step 2. If a it's time to request a reconciliation from the peer, this function will return",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998613472",
      "id" : 998613472,
      "line" : 91,
      "node_id" : "PRRC_kwDOABII5847haHg",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 91,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.h",
      "position" : 91,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998613472/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998613472",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998619645"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998619645"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`reconciliation_request_data` could be called `reconciliation_request_parameters` to dissociate clearly we're sending reconciliation config info and not the set itself.",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T19:18:32Z",
      "diff_hunk" : "@@ -5611,11 +5822,31 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {\n+                        m_txreconciliation->AddToReconSet(pto->GetId(), txs_to_reconcile);\n+                    }\n                 }\n         }\n         if (!vInv.empty())\n             m_connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n \n+        //\n+        // Message: reconciliation request\n+        //\n+        {\n+            if (!m_chainman.ActiveChainstate().IsInitialBlockDownload()) {\n+                if (m_txreconciliation && m_txreconciliation->IsPeerRegistered(pto->GetId())) {\n+                    auto reconciliation_request_data = m_txreconciliation->MaybeRequestReconciliation(pto->GetId());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998619645",
      "id" : 998619645,
      "line" : 5841,
      "node_id" : "PRRC_kwDOABII5847hbn9",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 5841,
      "original_position" : 368,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 368,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998619645/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998619645",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998628718"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998628718"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not sure what you aimed to achieve here with the `std::max` between `INBOUND_INVENTORY_BROADCAST_INTERVAL` and `INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON` as the former is always superior to the latter. Maybe could be rather a `static_assert` to enforce the order at compilation time in case of future changes.  ",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T19:29:51Z",
      "diff_hunk" : "@@ -143,17 +146,22 @@ static constexpr auto AVG_ADDRESS_BROADCAST_INTERVAL{30s};\n /** Delay between rotating the peers we relay a particular address to */\n static constexpr auto ROTATE_ADDR_RELAY_DEST_INTERVAL{24h};\n /** Average delay between trickled inventory transmissions for inbound peers.\n- *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this. */\n+ *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this.\n+ *  For reconciliation peers the delay is different. */\n static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL{5s};\n+static constexpr auto INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON{2s};\n /** Average delay between trickled inventory transmissions for outbound peers.\n  *  Use a smaller delay as there is less privacy concern for them.\n- *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this. */\n+ *  Blocks and peers with NetPermissionFlags::NoBan permission bypass this.\n+ *  For reconciliation peers the delay is different. */\n static constexpr auto OUTBOUND_INVENTORY_BROADCAST_INTERVAL{2s};\n+static constexpr auto OUTBOUND_INVENTORY_BROADCAST_INTERVAL_RECON{1s};\n /** Maximum rate of inventory items to send per second.\n  *  Limits the impact of low-fee transaction floods. */\n static constexpr unsigned int INVENTORY_BROADCAST_PER_SECOND = 7;\n /** Maximum number of inventory items to send per transmission. */\n-static constexpr unsigned int INVENTORY_BROADCAST_MAX = INVENTORY_BROADCAST_PER_SECOND * count_seconds(INBOUND_INVENTORY_BROADCAST_INTERVAL);\n+static constexpr unsigned int INVENTORY_BROADCAST_MAX = INVENTORY_BROADCAST_PER_SECOND *\n+    count_seconds(std::max(INBOUND_INVENTORY_BROADCAST_INTERVAL, INBOUND_INVENTORY_BROADCAST_INTERVAL_RECON));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998628718",
      "id" : 998628718,
      "line" : 164,
      "node_id" : "PRRC_kwDOABII5847hd1u",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 164,
      "original_position" : 41,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 41,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998628718/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998628718",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998629668"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998629668"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If you can develop the comment here why \"we need to make faster\" or point towards another code comment or BIP section where it's explained.",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T19:31:04Z",
      "diff_hunk" : "@@ -5488,12 +5589,35 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                 LOCK(tx_relay->m_tx_inventory_mutex);\n                 // Check whether periodic sends should happen\n                 bool fSendTrickle = pto->HasPermission(NetPermissionFlags::NoBan);\n+                const bool supports_recon = m_txreconciliation && m_txreconciliation->IsPeerRegistered(pto->GetId());\n+\n                 if (tx_relay->m_next_inv_send_time < current_time) {\n                     fSendTrickle = true;\n                     if (pto->IsInboundConn()) {\n-                        tx_relay->m_next_inv_send_time = NextInvToInbounds(current_time, INBOUND_INVENTORY_BROADCAST_INTERVAL);\n+                        if (supports_recon) {\n+                            // Use shorter intervals for reconciliation peers because we use\n+                            // low-fanout, and 1) we need to make faster; 2) we won't get much",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998629668",
      "id" : 998629668,
      "line" : 5599,
      "node_id" : "PRRC_kwDOABII5847heEk",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 5599,
      "original_position" : 217,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 217,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998629668/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998629668",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998633914"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998633914"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could add comment if the rational behind those values selection is specified in the BIP, paper or other research.",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T19:36:25Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998633914",
      "id" : 998633914,
      "line" : 25,
      "node_id" : "PRRC_kwDOABII5847hfG6",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 25,
      "original_position" : 25,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 25,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998633914/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998633914",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998640600"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998640600"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Curious, what we care about a low transaction relay latency ? Like I would say lower latency makes it a) harder to observe original transaction broadcast by deanonymization attacker b) disincentive transaction issuers front-running the standard tx-relay rules to place their transactions first in the mempools in case of congestion and c) for instant/0confs flows improve UX, do we have more properties ?",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T19:44:50Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998640600",
      "id" : 998640600,
      "line" : 36,
      "node_id" : "PRRC_kwDOABII5847hgvY",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 36,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 36,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998640600/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998640600",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998653688"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998653688"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\"which are unlikely to game this timer in a serious way\", though is there a timeout in the rest of the patchset to evict lazy/buggy outbound peers which would stuck the reconciliation, making us stale on `Phase::INIT_REQUESTED` and which would prevent `MaybeRequestReconciliation()` to move forward due to the check L258 ?",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-18T20:00:37Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r998653688",
      "id" : 998653688,
      "line" : 136,
      "node_id" : "PRRC_kwDOABII5847hj74",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 136,
      "original_position" : 136,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 136,
      "pull_request_review_id" : 1146311466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998653688/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-18T20:01:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/998653688",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005384672"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005384672"
         }
      },
      "author_association" : "MEMBER",
      "body" : "1d9b1f7d4bbf5ca5a8f43180b994b7b2fc03447f\r\n```suggestion\r\n                    if (!txs_to_reconcile.empty()) {\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T08:36:31Z",
      "diff_hunk" : "@@ -5611,11 +5822,31 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                             tx_relay->m_tx_inventory_known_filter.insert(txid);\n                         }\n                     }\n+\n+                    // Populating local reconciliation set.\n+                    if (txs_to_reconcile.size() != 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005384672",
      "id" : 1005384672,
      "line" : 5827,
      "node_id" : "PRRC_kwDOABII58477PPg",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 5827,
      "original_position" : 354,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 354,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005384672/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005384672",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005385195"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005385195"
         }
      },
      "author_association" : "MEMBER",
      "body" : "5070c97459282346cdcff7af08914c702462fe0d\r\n```suggestion\r\nenum class Phase {\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T08:36:58Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005385195",
      "id" : 1005385195,
      "line" : 43,
      "node_id" : "PRRC_kwDOABII58477PXr",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 43,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 43,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005385195/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005385195",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005386331"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005386331"
         }
      },
      "author_association" : "MEMBER",
      "body" : "7cffb4cc0211b0494a7563d9a80a67633fa61255\r\n```suggestion\r\n                const auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T08:38:01Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005386331",
      "id" : 1005386331,
      "line" : 139,
      "node_id" : "PRRC_kwDOABII58477Ppb",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 139,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 139,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005386331/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005386331",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005387197"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005387197"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n        if (!m_queue.empty()) {\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T08:38:49Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005387197",
      "id" : 1005387197,
      "line" : 249,
      "node_id" : "PRRC_kwDOABII58477P29",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 249,
      "original_position" : 249,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 249,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005387197/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005387197",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005388347"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005388347"
         }
      },
      "author_association" : "MEMBER",
      "body" : "4cb08ebcd6190535bc2300e35557dd8b730b8951\r\n```suggestion\r\n    bool ShouldFloodTo(const uint256& wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T08:39:49Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n+    void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+            LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n+        }\n+    }\n+\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        return (recon_state != m_states.end() &&\n+                std::holds_alternative<TxReconciliationState>(recon_state->second));\n+    }\n+\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005388347",
      "id" : 1005388347,
      "line" : 305,
      "node_id" : "PRRC_kwDOABII58477QI7",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 305,
      "original_position" : 305,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 305,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005388347/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005388347",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005389029"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389029"
         }
      },
      "author_association" : "MEMBER",
      "body" : "4cb08ebcd6190535bc2300e35557dd8b730b8951\r\n```suggestion\r\n                const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T08:40:23Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n+    void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+            LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n+        }\n+    }\n+\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        return (recon_state != m_states.end() &&\n+                std::holds_alternative<TxReconciliationState>(recon_state->second));\n+    }\n+\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the similar reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+            [&eligible_peers, we_initiate](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                const auto cur_state = std::get<TxReconciliationState>(indexed_state.second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005389029",
      "id" : 1005389029,
      "line" : 320,
      "node_id" : "PRRC_kwDOABII58477QTl",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 320,
      "original_position" : 320,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 320,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389029/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389029",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005389951"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389951"
         }
      },
      "author_association" : "MEMBER",
      "body" : "4cb08ebcd6190535bc2300e35557dd8b730b8951\r\n```suggestion\r\n            [&eligible_peers, we_initiate](auto indexed_state) {\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T08:41:20Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n+    void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+            LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n+        }\n+    }\n+\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        return (recon_state != m_states.end() &&\n+                std::holds_alternative<TxReconciliationState>(recon_state->second));\n+    }\n+\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the similar reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+            [&eligible_peers, we_initiate](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005389951",
      "id" : 1005389951,
      "line" : 319,
      "node_id" : "PRRC_kwDOABII58477Qh_",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 319,
      "original_position" : 319,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 319,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389951/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005389951",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005390504"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005390504"
         }
      },
      "author_association" : "MEMBER",
      "body" : "1d9b1f7d4bbf5ca5a8f43180b994b7b2fc03447f: there are other instances where wtxid is not passed by ref\r\n```suggestion\r\n    bool CurrentlyReconcilingTx(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T08:41:50Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.\n+        size_t we_initiate_to_count = std::count_if(m_states.begin(), m_states.end(),\n+            [](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                auto* cur_state = std::get_if<TxReconciliationState>(&indexed_state.second);\n+                if (cur_state) return cur_state->m_we_initiate;\n+                return false;\n+            });\n+        m_next_recon_request = now + (RECON_REQUEST_INTERVAL / we_initiate_to_count);\n+    }\n+\n+    public:\n+    explicit Impl(uint32_t recon_version) : m_recon_version(recon_version) {}\n+\n+    uint64_t PreRegisterPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        // We do not support txreconciliation salt/version updates.\n+        assert(m_states.find(peer_id) == m_states.end());\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Pre-register peer=%d\\n\", peer_id);\n+        const uint64_t local_salt{GetRand(UINT64_MAX)};\n+\n+        // We do this exactly once per peer (which are unique by NodeId, see GetNewNodeId) so it's\n+        // safe to assume we don't have this record yet.\n+        Assert(m_states.emplace(peer_id, local_salt).second);\n+        return local_salt;\n+    }\n+\n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;\n+\n+        if (we_initiate) {\n+            m_queue.push_back(peer_id);\n+        }\n+\n+        LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Register peer=%d with the following params: \" /* Continued */\n+                                                                    \"we_initiate=%i, they_initiate=%i.\\n\",\n+                      peer_id, we_initiate, they_initiate);\n+\n+        const uint256 full_salt{ComputeSalt(*local_salt, remote_salt)};\n+        recon_state->second = TxReconciliationState(we_initiate, full_salt.GetUint64(0), full_salt.GetUint64(1));\n+        return SUCCESS;\n+    }\n+\n+    void AddToReconSet(NodeId peer_id, const std::vector<uint256>& txs_to_reconcile) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(txs_to_reconcile.size() > 0);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        size_t added = 0;\n+        for (auto& wtxid: txs_to_reconcile) {\n+            if (recon_state.m_local_set.insert(wtxid).second) {\n+                ++added;\n+            }\n+        }\n+\n+        LogPrint(BCLog::NET, \"Added %i new transactions to the reconciliation set for peer=%d. \" /* Continued */\n+            \"Now the set contains %i transactions.\\n\", added, peer_id, recon_state.m_local_set.size());\n+    }\n+\n+    void TryRemovingFromReconSet(NodeId peer_id, const uint256 wtxid_to_remove) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        recon_state.m_local_set.erase(wtxid_to_remove);\n+    }\n+\n+    std::optional<std::pair<uint16_t, uint16_t>> MaybeRequestReconciliation(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return std::nullopt;\n+        LOCK(m_txreconciliation_mutex);\n+        auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        if (m_queue.size() > 0) {\n+            // Request transaction reconciliation periodically to efficiently exchange transactions.\n+            // To make reconciliation predictable and efficient, we reconcile with peers in order\n+            // based on the queue, taking a delay between requests.\n+            auto current_time = GetTime<std::chrono::seconds>();\n+            if (m_next_recon_request <= current_time && m_queue.front() == peer_id) {\n+                m_queue.pop_front();\n+                m_queue.push_back(peer_id);\n+                UpdateNextReconRequest(current_time);\n+                if (recon_state.m_phase_init_by_us != Phase::NONE) return std::nullopt;\n+                recon_state.m_phase_init_by_us = Phase::INIT_REQUESTED;\n+\n+                size_t local_set_size = recon_state.m_local_set.size();\n+\n+                LogPrint(BCLog::NET, \"Initiate reconciliation with peer=%d with the following params: \" /* Continued */\n+                    \"local_set_size=%i\\n\", peer_id, local_set_size);\n+\n+                // In future, RECON_Q could be recomputed after every reconciliation based on the\n+                // set differences. For now, it provides good enough results without recompute\n+                // complexity, but we communicate it here to allow backward compatibility if\n+                // the value is changed or made dynamic.\n+                return std::make_pair(local_set_size, RECON_Q * Q_PRECISION);\n+            }\n+        }\n+        return std::nullopt;\n+    }\n+\n+    size_t GetPeerSetSize(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        assert(IsPeerRegistered(peer_id));\n+        LOCK(m_txreconciliation_mutex);\n+        const auto& recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        return recon_state.m_local_set.size();\n+    }\n+\n+    void ForgetPeer(NodeId peer_id) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        if (m_states.erase(peer_id)) {\n+            m_queue.erase(std::remove(m_queue.begin(), m_queue.end(), peer_id), m_queue.end());\n+            LogPrintLevel(BCLog::TXRECONCILIATION, BCLog::Level::Debug, \"Forget txreconciliation state of peer=%d\\n\", peer_id);\n+        }\n+    }\n+\n+    bool IsPeerRegistered(NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+        return (recon_state != m_states.end() &&\n+                std::holds_alternative<TxReconciliationState>(recon_state->second));\n+    }\n+\n+    bool ShouldFloodTo(uint256 wtxid, NodeId peer_id) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the similar reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+            [&eligible_peers, we_initiate](std::pair<NodeId, std::variant<uint64_t, TxReconciliationState>> indexed_state) {\n+                const auto cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+            }\n+        );\n+\n+        // TODO: there should be a cleaner way to do this.\n+        size_t flood_index_modulo;\n+        if (we_initiate) {\n+            flood_index_modulo = 1.0 / OUTBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        } else {\n+            flood_index_modulo = 1.0 / INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+        }\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        assert(it != eligible_peers.end());\n+\n+        const size_t peer_index = it - eligible_peers.begin();\n+        return txidHasher(wtxid) % flood_index_modulo == peer_index % flood_index_modulo;\n+    }\n+\n+    bool CurrentlyReconcilingTx(NodeId peer_id, const uint256 wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005390504",
      "id" : 1005390504,
      "line" : 340,
      "node_id" : "PRRC_kwDOABII58477Qqo",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 340,
      "original_position" : 340,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 340,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005390504/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005390504",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005414595"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005414595"
         }
      },
      "author_association" : "MEMBER",
      "body" : "c60235bacceecbe7f83bb70f761a0adb3e5bf65b\r\nnit but I think it's easier to read\r\n```suggestion\r\n        assert(!they_initiate || !we_initiate));\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T09:02:41Z",
      "diff_hunk" : "@@ -55,6 +93,50 @@ class TxReconciliationTracker::Impl\n         return local_salt;\n     }\n \n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005414595",
      "id" : 1005414595,
      "line" : 195,
      "node_id" : "PRRC_kwDOABII58477WjD",
      "original_commit_id" : "c60235bacceecbe7f83bb70f761a0adb3e5bf65b",
      "original_line" : 126,
      "original_position" : 100,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 100,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005414595/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005414595",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005415156"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005415156"
         }
      },
      "author_association" : "MEMBER",
      "body" : "c60235bacceecbe7f83bb70f761a0adb3e5bf65b\r\nnit but I think it's easier to read\r\n```suggestion\r\n        if (!they_initiate && !we_initiate) return PROTOCOL_VIOLATION;\r\n```",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-10-26T09:03:01Z",
      "diff_hunk" : "@@ -55,6 +93,50 @@ class TxReconciliationTracker::Impl\n         return local_salt;\n     }\n \n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));\n+\n+        // The peer set both flags to false, we treat it as a protocol violation.\n+        if (!(they_initiate || we_initiate)) return PROTOCOL_VIOLATION;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1005415156",
      "id" : 1005415156,
      "line" : 198,
      "node_id" : "PRRC_kwDOABII58477Wr0",
      "original_commit_id" : "c60235bacceecbe7f83bb70f761a0adb3e5bf65b",
      "original_line" : 129,
      "original_position" : 103,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 103,
      "pull_request_review_id" : 1156088702,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005415156/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-26T09:24:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1005415156",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013791316"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013791316"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Applied `<=`, but I don't get the second sentence :(",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-11-04T09:26:34Z",
      "diff_hunk" : "@@ -5576,8 +5701,94 @@ bool PeerManagerImpl::SendMessages(CNode* pto)\n                         }\n                         if (tx_relay->m_bloom_filter && !tx_relay->m_bloom_filter->IsRelevantAndUpdate(*txinfo.tx)) continue;\n                         // Send\n-                        State(pto->GetId())->m_recently_announced_invs.insert(hash);\n-                        vInv.push_back(inv);\n+\n+                        // Make a transaction requestable by both txid and wtxid, to avoid making\n+                        // an assumption that a child arrives after the parent.\n+                        State(pto->GetId())->m_recently_announced_invs.insert(txid);\n+                        State(pto->GetId())->m_recently_announced_invs.insert(wtxid);\n+\n+                        bool adding_to_recon_set = false;\n+                        // Check if peer supports reconciliations.\n+                        if (supports_recon) {\n+                            bool flood_target = m_txreconciliation->ShouldFloodTo(wtxid, pto->GetId());\n+\n+                            // Special treatment for unconfirmed transactions with unconfirmed\n+                            // parents.\n+                            LOCK(m_mempool.cs);\n+                            auto txiter = m_mempool.GetIter(txinfo.tx->GetHash());\n+                            assert(txiter);\n+                            const CTxMemPoolEntry::Parents& parents = (*txiter)->GetMemPoolParentsConst();\n+                            for (const CTxMemPoolEntry& parent : parents) {\n+                                // Two situations are possible here:\n+                                // 1. The parent was fully relayed to the peer earlier.\n+                                // 2. The parent is set for reconciliation and the child is not\n+                                //    in the mempool yet. The child arrives to the mempool and is\n+                                //    flooded. The peer receives the child earlier than the parent.\n+                                // We can differentiate between the two by looking at the recon\n+                                // set: if the set (or the snapshot) contains the parent, the parent\n+                                // is being reconciled (case 2). Then, we add the child to the\n+                                // reconciliation set, so that it doesn't arrive earlier than the\n+                                // parent.\n+                                // If it's the case 1, we proceed as usual by looking at the\n+                                // child's wtxid.\n+                                const uint256 parent_wtxid = parent.GetTx().GetWitnessHash();\n+                                if (m_txreconciliation->CurrentlyReconcilingTx(pto->GetId(), parent_wtxid) ||\n+                                    std::find(txs_to_reconcile.begin(), txs_to_reconcile.end(), parent_wtxid) != txs_to_reconcile.end()) {\n+                                    // Currently reconciling parent tx.\n+                                    // We have the following options to do:\n+                                    // 1. Flood parent+child.\n+                                    // 2. Reconcile parent+child.\n+                                    // 3. Flood parent, reconcile child.\n+                                    // We choose (2) because it has the easiest implementation.\n+                                    // The latency impact is not that bad:\n+                                    // 1. If the parent is in the reocnciliation set, the two\n+                                    // transactions will be relayed at the same time. There is\n+                                    // no point relaying the child faster anyway.\n+                                    // 2. If the parent is in the snapshot, the child will\n+                                    // be reconcilied within the next batch. This would\n+                                    // introduce extra latency (even if by wtxid the child\n+                                    // should have been flooded over this link), but this will\n+                                    // be compensated later: if the delay is non-trivial,\n+                                    // for the next nodes this condition won't be triggered (\n+                                    // parent won't be in the reconciliation set).\n+                                    //\n+                                    // In case of the multiple unconfirmed parents, we will\n+                                    // reconcile if at least one of the parents is being\n+                                    // reconciled.\n+                                    //\n+                                    // Note, the transaction still could be flooded if the\n+                                    // reconciliation set is full (see check below). This\n+                                    // is not the general case and is likely caused by the\n+                                    // issues with the peer, and then we're not responsible\n+                                    // that the package can't pass mempool limitations.\n+                                    flood_target = false;\n+                                    break;\n+                                }\n+                            }\n+\n+                            // Check if reconciliation set is not at capacity for two reasons:\n+                            // - limit sizes of reconciliation sets and short id mappings\n+                            // - limit CPU use for sketch computations\n+                            //\n+                            // Since we reconcile frequently, reaching capacity either means:\n+                            // (1) a peer for some reason does not request reconciliations from us for a long while, or\n+                            // (2) really a lot of valid fee-paying transactions were dumped on us at once.\n+                            // We don't care about a laggy peer (1) because we probably can't help them even if we flood transactions.\n+                            // However, exploiting (2) should not prevent us from relaying certain transactions.\n+                            //\n+                            // Transactions which don't make it to the set due to the limit are announced via fan-out.\n+                            const size_t recon_set_size = m_txreconciliation->GetPeerSetSize(pto->GetId());\n+                            if (!flood_target && txs_to_reconcile.size() + recon_set_size < MAX_PEER_TX_ANNOUNCEMENTS) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013791316",
      "id" : 1013791316,
      "in_reply_to_id" : 998588937,
      "line" : 5781,
      "node_id" : "PRRC_kwDOABII5848bTpU",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 5781,
      "original_position" : 334,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 334,
      "pull_request_review_id" : 1168195546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013791316/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-04T09:26:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013791316",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013848477"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013848477"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I thought it's kinda obvious for 0conf experience, yes. Not even accepting payment, but at least seeing it in the network... Not sure what to include in the codebase.",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-11-04T10:26:35Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013848477",
      "id" : 1013848477,
      "in_reply_to_id" : 998640600,
      "line" : 36,
      "node_id" : "PRRC_kwDOABII5848bhmd",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 36,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 36,
      "pull_request_review_id" : 1168276941,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013848477/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-04T10:26:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013848477",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013850793"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013850793"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think `Phase::INIT_REQUESTED` is somehow related to being stuck... if one peer stays in that state, it doesn't prevent us from requesting recon from other peers. Only will delay by `m_next_recon_request` once?",
      "commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "created_at" : "2022-11-04T10:29:12Z",
      "diff_hunk" : "@@ -0,0 +1,405 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <node/txreconciliation.h>\n+\n+#include <util/check.h>\n+#include <util/system.h>\n+\n+#include <unordered_map>\n+#include <util/hasher.h>\n+#include <variant>\n+\n+\n+namespace {\n+\n+/** Static salt component used to compute short txids for sketch construction, see BIP-330. */\n+const std::string RECON_STATIC_SALT = \"Tx Relay Salting\";\n+const HashWriter RECON_SALT_HASHER = TaggedHash(RECON_STATIC_SALT);\n+\n+/** Announce transactions via full wtxid to a limited number of inbound and outbound peers. */\n+constexpr double INBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+constexpr double OUTBOUND_FANOUT_DESTINATIONS_FRACTION = 0.1;\n+/** Coefficient used to estimate reconciliation set differences. */\n+constexpr double RECON_Q = 0.25;\n+/**\n+ * Used to convert a floating point reconciliation coefficient q to integer for transmission.\n+ * Specified by BIP-330.\n+ */\n+constexpr uint16_t Q_PRECISION{(2 << 14) - 1};\n+/**\n+ * Interval between initiating reconciliations with peers.\n+ * This value allows to reconcile ~(7 tx/s * 8s) transactions during normal operation.\n+ * More frequent reconciliations would cause significant constant bandwidth overhead\n+ * due to reconciliation metadata (sketch sizes etc.), which would nullify the efficiency.\n+ * Less frequent reconciliations would introduce high transaction relay latency.\n+ */\n+constexpr std::chrono::microseconds RECON_REQUEST_INTERVAL{8s};\n+\n+/**\n+ * Represents phase of the current reconciliation round with a peer.\n+ */\n+enum Phase {\n+    NONE,\n+    INIT_REQUESTED,\n+};\n+\n+/**\n+ * Salt (specified by BIP-330) constructed from contributions from both peers. It is used\n+ * to compute transaction short IDs, which are then used to construct a sketch representing a set\n+ * of transactions we want to announce to the peer.\n+ */\n+uint256 ComputeSalt(uint64_t salt1, uint64_t salt2)\n+{\n+    // According to BIP-330, salts should be combined in ascending order.\n+    return (HashWriter(RECON_SALT_HASHER) << std::min(salt1, salt2) << std::max(salt1, salt2)).GetSHA256();\n+}\n+\n+/**\n+ * Keeps track of txreconciliation-related per-peer state.\n+ */\n+class TxReconciliationState\n+{\n+public:\n+    /**\n+     * TODO: This field is public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * Reconciliation protocol assumes using one role consistently: either a reconciliation\n+     * initiator (requesting sketches), or responder (sending sketches). This defines our role.\n+     *\n+     */\n+    bool m_we_initiate;\n+\n+    /**\n+     * TODO: These fields are public to ignore -Wunused-private-field. Make private once used in\n+     * the following commits.\n+     *\n+     * These values are used to salt short IDs, which is necessary for transaction reconciliations.\n+     */\n+    uint64_t m_k0, m_k1;\n+\n+    /**\n+     * Store all wtxids which we would announce to the peer (policy checks passed, etc.)\n+     * in this set instead of announcing them right away. When reconciliation time comes, we will\n+     * compute a compressed representation of this set (\"sketch\") and use it to efficiently\n+     * reconcile this set with a set on the peer's side.\n+     */\n+    std::set<uint256> m_local_set;\n+\n+    /** Keep track of the reconciliation phase with the peer. */\n+    Phase m_phase_init_by_us{Phase::NONE};\n+\n+    TxReconciliationState(bool we_initiate, uint64_t k0, uint64_t k1) : m_we_initiate(we_initiate), m_k0(k0), m_k1(k1) {}\n+};\n+\n+} // namespace\n+\n+/** Actual implementation for TxReconciliationTracker's data structure. */\n+class TxReconciliationTracker::Impl\n+{\n+private:\n+    mutable Mutex m_txreconciliation_mutex;\n+\n+    /**\n+     * We need a ReconciliationTracker-wide randomness to decide to which peers we should flood a\n+     * given transaction based on a (w)txid.\n+     */\n+    const SaltedTxidHasher txidHasher;\n+\n+    // Local protocol version\n+    uint32_t m_recon_version;\n+\n+    /**\n+     * Keeps track of txreconciliation states of eligible peers.\n+     * For pre-registered peers, the locally generated salt is stored.\n+     * For registered peers, the locally generated salt is forgotten, and the state (including\n+     * \"full\" salt) is stored instead.\n+     */\n+    std::unordered_map<NodeId, std::variant<uint64_t, TxReconciliationState>> m_states GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Maintains a queue of reconciliations we should initiate. To achieve higher bandwidth\n+     * conservation and avoid overflows, we should reconcile in the same order, because then itâs\n+     * easier to estimate set difference size.\n+     */\n+    std::deque<NodeId> m_queue GUARDED_BY(m_txreconciliation_mutex);\n+\n+    /**\n+     * Make reconciliation requests periodically to make reconciliations efficient.\n+     */\n+    std::chrono::microseconds m_next_recon_request GUARDED_BY(m_txreconciliation_mutex){0};\n+    void UpdateNextReconRequest(std::chrono::microseconds now) EXCLUSIVE_LOCKS_REQUIRED(m_txreconciliation_mutex)\n+    {\n+        // We have one timer for the entire queue. This is safe because we initiate reconciliations\n+        // with outbound connections, which are unlikely to game this timer in a serious way.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013850793",
      "id" : 1013850793,
      "in_reply_to_id" : 998653688,
      "line" : 136,
      "node_id" : "PRRC_kwDOABII5848biKp",
      "original_commit_id" : "5070c97459282346cdcff7af08914c702462fe0d",
      "original_line" : 136,
      "original_position" : 136,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 136,
      "pull_request_review_id" : 1168280370,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013850793/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-04T10:29:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013850793",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013981776"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013981776"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not sure it's any better",
      "commit_id" : "4c3bf8f43148b46bf55a09ed53d47dc7aa69441b",
      "created_at" : "2022-11-04T12:46:02Z",
      "diff_hunk" : "@@ -55,6 +93,50 @@ class TxReconciliationTracker::Impl\n         return local_salt;\n     }\n \n+    ReconciliationRegisterResult RegisterPeer(NodeId peer_id, bool is_peer_inbound, bool is_peer_recon_initiator,\n+                                     bool is_peer_recon_responder, uint32_t peer_recon_version,\n+                                     uint64_t remote_salt) EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        LOCK(m_txreconciliation_mutex);\n+        auto recon_state = m_states.find(peer_id);\n+\n+        // A peer should be in the pre-registered state to proceed here.\n+        if (recon_state == m_states.end()) return NOT_FOUND;\n+        uint64_t* local_salt = std::get_if<uint64_t>(&recon_state->second);\n+        // A peer is already registered. This should be checked by the caller.\n+        Assume(local_salt);\n+\n+        // If the peer supports the version which is lower than ours, we downgrade to the version\n+        // it supports. For now, this only guarantees that nodes with future reconciliation\n+        // versions have the choice of reconciling with this current version. However, they also\n+        // have the choice to refuse supporting reconciliations if the common version is not\n+        // satisfactory (e.g. too low).\n+        const uint32_t recon_version{std::min(peer_recon_version, m_recon_version)};\n+        // v1 is the lowest version, so suggesting something below must be a protocol violation.\n+        if (recon_version < 1) return PROTOCOL_VIOLATION;\n+\n+        // Must match SENDTXRCNCL logic.\n+        const bool they_initiate = is_peer_recon_initiator && is_peer_inbound;\n+        const bool we_initiate = !is_peer_inbound && is_peer_recon_responder;\n+\n+        // If we ever announce support for both requesting and responding, this will need\n+        // tie-breaking. For now, this is mutually exclusive because both are based on the\n+        // inbound flag.\n+        assert(!(they_initiate && we_initiate));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1013981776",
      "id" : 1013981776,
      "in_reply_to_id" : 1005414595,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5848cCJQ",
      "original_commit_id" : "c60235bacceecbe7f83bb70f761a0adb3e5bf65b",
      "original_line" : 126,
      "original_position" : 100,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : null,
      "pull_request_review_id" : 1168466518,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013981776/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-04T12:46:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1013981776",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2022-11-04T16:29:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#issuecomment-1303841621",
      "id" : 1303841621,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/26283",
      "node_id" : "IC_kwDOABII585NtwtV",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1303841621/reactions"
      },
      "updated_at" : "2022-11-04T16:29:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1303841621",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1020190507"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020190507"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Using PRNGs is usually discouraged, is this safe here?",
      "commit_id" : "913c2cbcea58696237760c51f55acee9d91eb186",
      "created_at" : "2022-11-11T12:48:21Z",
      "diff_hunk" : "@@ -154,6 +297,77 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = floor(flood_targets);\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external\n+        // observer. This is achieved by hashing the txid.\n+        //\n+        // Say, we have 2.4 targets out of 20 inbound peers, the wtixd hash is 217, and our peer_id\n+        // holds peer_position in the list of inbound peers.\n+        // We will compute 217 % 20 = 17, as if it was a \"starting_point\", from which we see if\n+        // the target is within a range of 2.4. It's impossible for the range to exceed\n+        // the bounds because of how we computed them in the first place.\n+        // For that, we need to check the following:\n+        // 1. If 17 <= peer_position < 19, return true.\n+        // 2. If peer_position = 19, roll the dice with the remaining probability (0.4).\n+        // 3. Otherwise, return false.\n+        const size_t starting_point = txidHasher(wtxid) % eligible_peers.size();\n+        if (starting_point <= peer_position && peer_position < starting_point + round_down_flood_targets) {\n+            return true;\n+        } else if (peer_position == starting_point + round_down_flood_targets) {\n+            return rand() < (flood_targets - round_down_flood_targets) * RAND_MAX;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1020190507",
      "id" : 1020190507,
      "line" : 358,
      "node_id" : "PRRC_kwDOABII5848zt8r",
      "original_commit_id" : "913c2cbcea58696237760c51f55acee9d91eb186",
      "original_line" : 358,
      "original_position" : 341,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 341,
      "pull_request_review_id" : 1177296531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020190507/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-11T12:51:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020190507",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1020204771"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020204771"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think so âÂ since txidHasher is salted, the peer would have no control of it, and thus can't exploit this rand. But I'll keep this comment in case someone has an objection, just in case.",
      "commit_id" : "913c2cbcea58696237760c51f55acee9d91eb186",
      "created_at" : "2022-11-11T13:08:41Z",
      "diff_hunk" : "@@ -154,6 +297,77 @@ class TxReconciliationTracker::Impl\n         return (recon_state != m_states.end() &&\n                 std::holds_alternative<TxReconciliationState>(recon_state->second));\n     }\n+\n+    bool ShouldFloodTo(NodeId peer_id, const uint256& wtxid) const EXCLUSIVE_LOCKS_REQUIRED(!m_txreconciliation_mutex)\n+    {\n+        AssertLockNotHeld(m_txreconciliation_mutex);\n+        if (!IsPeerRegistered(peer_id)) return true;\n+        LOCK(m_txreconciliation_mutex);\n+        const auto recon_state = std::get<TxReconciliationState>(m_states.find(peer_id)->second);\n+\n+        // We assume that reconciliation is always initiated from inbound to outbound to avoid\n+        // code complexity.\n+        std::vector<NodeId> eligible_peers;\n+\n+        const bool we_initiate = recon_state.m_we_initiate;\n+        // Find all peers of the same reconciliation direction.\n+        std::for_each(m_states.begin(), m_states.end(),\n+                      [&eligible_peers, we_initiate](auto indexed_state) {\n+                          const auto& cur_state = std::get<TxReconciliationState>(indexed_state.second);\n+                          if (cur_state.m_we_initiate == we_initiate) eligible_peers.push_back(indexed_state.first);\n+                      });\n+\n+        // We found the peer above, so it must be in this list.\n+        assert(eligible_peers.size() >= 1);\n+\n+        // Flooding to a fraction (say, 10% of peers) is equivalent to taking the first 10% of\n+        // of the eligible peers. Sometimes it won't round to a \"full peer\", in that case we'll\n+        // roll the dice with the corresponding probability.\n+        double flood_targets;\n+        if (we_initiate) {\n+            flood_targets = OUTBOUND_FANOUT_DESTINATIONS;\n+        } else {\n+            flood_targets = eligible_peers.size() * INBOUND_FANOUT_DESTINATIONS_FRACTION;\n+            if (flood_targets == 0) return false;\n+        }\n+\n+        const size_t round_down_flood_targets = floor(flood_targets);\n+\n+        const auto it = std::find(eligible_peers.begin(), eligible_peers.end(), peer_id);\n+        Assume(it != eligible_peers.end());\n+        const size_t peer_position = it - eligible_peers.begin();\n+        // The requirements to this algorithm is the following:\n+        // 1. Every transaction should be assigned to *some* peer, at least assuming a static list\n+        // of peers. For this function that means no randomness.\n+        // 2. The choice doesn't leak the internal order of peers (m_states) to the external\n+        // observer. This is achieved by hashing the txid.\n+        //\n+        // Say, we have 2.4 targets out of 20 inbound peers, the wtixd hash is 217, and our peer_id\n+        // holds peer_position in the list of inbound peers.\n+        // We will compute 217 % 20 = 17, as if it was a \"starting_point\", from which we see if\n+        // the target is within a range of 2.4. It's impossible for the range to exceed\n+        // the bounds because of how we computed them in the first place.\n+        // For that, we need to check the following:\n+        // 1. If 17 <= peer_position < 19, return true.\n+        // 2. If peer_position = 19, roll the dice with the remaining probability (0.4).\n+        // 3. Otherwise, return false.\n+        const size_t starting_point = txidHasher(wtxid) % eligible_peers.size();\n+        if (starting_point <= peer_position && peer_position < starting_point + round_down_flood_targets) {\n+            return true;\n+        } else if (peer_position == starting_point + round_down_flood_targets) {\n+            return rand() < (flood_targets - round_down_flood_targets) * RAND_MAX;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/26283#discussion_r1020204771",
      "id" : 1020204771,
      "in_reply_to_id" : 1020190507,
      "line" : 358,
      "node_id" : "PRRC_kwDOABII5848zxbj",
      "original_commit_id" : "913c2cbcea58696237760c51f55acee9d91eb186",
      "original_line" : 358,
      "original_position" : 341,
      "original_start_line" : null,
      "path" : "src/node/txreconciliation.cpp",
      "position" : 341,
      "pull_request_review_id" : 1177318100,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/26283",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020204771/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-11T13:08:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1020204771",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   }
]
