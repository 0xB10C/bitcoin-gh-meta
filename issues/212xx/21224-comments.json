[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> This PR halts the processing of unrequested transactions in Bitcoin at TX message reception. An unrequested transaction is one defined by which a \"getdata\" message for its specific identifier (either txid or wtxid) has not been previously issued by the node.\r\n\r\nI don't see the point of this? An attacker with valid utxos can generate invalid txs that are costly to reject, and simply announce their txids and wait for a request. That's limited to 5000 txs in a batch (MAX_PEER_TX_ANNOUNCEMENTS), and I think each batch would have at least a 4s window (NONPREF_PEER_TX_DELAY + OVERLOADED_PEER_TX_DELAY). But that seems like it should be enough to keep the CPU busy? Even then, we'll make progress through every other node in between dealing with each tx from the attacker, so this shouldn't cause a denial of service as far as I can see? Presuming the tx's are consensus invalid, the attacker will get given a Misbehaving score for each invalid tx and eventually kicked.\r\n\r\n> It comes with a meaningful delay of running the framework (e.g +4min to run p2p_segwit.py)\r\n\r\nErr nack? :) Maybe better to add PF_RELAY to those tests than slow them down?",
      "created_at" : "2021-02-18T14:48:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21224#issuecomment-781395303",
      "id" : 781395303,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21224",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4MTM5NTMwMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-18T14:48:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/781395303",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #21160 (Net/Net processing: Move tx inventory into net_processing by jnewbery)\n* #21148 (Split orphan handling from net_processing into txorphanage by ajtowns)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2021-02-18T14:57:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21224#issuecomment-781401545",
      "id" : 781401545,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21224",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4MTQwMTU0NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-18T14:57:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/781401545",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@ajtowns \r\n\r\n>  I don't see the point of this? An attacker with valid utxos can generate invalid txs that are costly to reject, and simply announce their txids and wait for a request. That's limited to 5000 txs in a batc>h (    MAX_PEER_TX_ANNOUNCEMENTS), and I think each batch would have at least a 4s window (NONPREF_PEER_TX_DELAY + OVERLOADED_PEER_TX_DELAY). \r\n\r\nAre you saying this change isn't worhty because it doesn't prevent further tx-relay DoS ? As of today, an attacker doesn't have to \"wait\" for a request and can just spam us we costly-to-evaluate transactions. Rate-limiting DoSy peers beyond `MAX_TX_PEER_ANNOUNCEMENTS` is already a strict improvement, you force a time burden on them.\r\n\r\n> But that seems like it should be enough to keep the CPU busy?\r\n\r\nOnce you're dropping the unrequested transactions, you might start to squeeze a peer announcement buffer if its top-of-transaction-to-evaluate buffer is too slow/costly to evaluate. But that kind of further mitigations is useless if you can bypass it with unrequested transactions.\r\n\r\n> Even then, we'll make progress through every other node in between dealing with each tx from the attacker, so this shouldn't cause a denial of service as far as I can see?\r\n\r\nIf you have % of inbound peers being malicious and DoSing you, this starts to be a concern. What's the % is a more serious question.\r\n\r\n> Presuming the tx's are consensus invalid, the attacker will get given a Misbehaving score for each invalid tx > and eventually kicked.\r\n\r\nIf you're a motivated attacker, this is super easy to avoid the kick-out. Just craft malicious non-standard junk (e.g make the sig of the last input high-s) and you will avoid `MaybePunishNodeForTx` ban. Generally, we should assume an attacker to be always able to circumvent bans triggered from invalid transactions, just target discrepancies in tx-relay policies.\r\n\r\nNote, this mitigation proposal was a suggestion from @sdaftuar, following some CPU grinding of its own.\r\n\r\n> The last time I looked at this, it seemed like spending on the order of 1 second (on my modern workstation) to validate a transaction that would ultimately fail mempool acceptance was easily achievable; multiply that by the number of inbound connections we allow and you get a pretty bad state of affairs...\r\n\r\n(in #20277)\r\n\r\nThat said, I concede it would be better to have a common attacker model (number of malicious inbound, worst-case transactions,  CPU resources on a middle-grade host, I/O layout of UTXOs fetched, ...) before to work or propose eventual tx-relay DoS mitigations. If so, I would be happy to do such investigations.\r\n\r\n> Err nack? :) Maybe better to add PF_RELAY to those tests than slow them down?\r\n\r\nYeah I feel the same. I fixed the tests just-in-case someone was willingly to analyze tests impacted, at least I've a branch...",
      "created_at" : "2021-02-18T18:18:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21224#issuecomment-781541708",
      "id" : 781541708,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21224",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4MTU0MTcwOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-18T18:21:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/781541708",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@ajtowns I think not processing unrequested transactions is a first step towards being able to protect the node from transaction-based CPU DoS; it's of course not helpful on its own.  I think as a next step we could consider keeping some sort of score on peers based on how many slow-to-validate transactions they've relayed to us that were not accepted to the mempool, and for badly scoring peers (or new peers that have just connected to us) we could have a longer delay between inv and getdata, or tolerate fewer transactions in flight (or both).\r\n\r\nI haven't tried to figure out exactly what these measures would look like in code or exactly how much benefit we would get, so for sure this is speculative, but I also don't think any of those ideas work at all if we don't first stop processing unrequested transactions -- which seems like both a harmless and intuitive way for relay to work.\r\n",
      "created_at" : "2021-02-18T19:01:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21224#issuecomment-781567152",
      "id" : 781567152,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21224",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4MTU2NzE1Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-18T19:01:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/781567152",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "If a single tx can take 1s to validate and fail for policy reasons to avoid getting disconnected/banned, then a single peer can generate a backlog of about 1h20m (5000 seconds) of processing, beginning only 2s after getting connected using INV/GETDATA rather than just using TX, so this doesn't seem like a big help?\r\n\r\nI think an attacker could also queue ~50 slow orphan txs, have them all downloaded without revealing anything slow is happening, and then activate them by relaying a good parent for them -- without INV/GETDATA delays only able to prevent them from doing the next round of 50 slows txs. Depending on the scoring mechanism, rotating that sort of spam amongst a few peers might be enough to keep 100% load without much hassle.\r\n\r\nThe way I've been looking at this is that INV/GETDATA (and eventually erlay) is just a way to avoid wasting bandwidth, and that we should be robust to having to validate any random tx that anyone decides to send to us. Avoiding wasting bandwidth only matters for honest peers not attackers, who can presumably find plenty of ways to send us garbage data -- masses of PINGs eg. That seems easier to design for to me -- in particular, I think it might be hard to get txrequest to handle changes in the delay between INV/GETDATA efficiently, which might mean adding DoS vectors rather than removing them.\r\n\r\nAs an alternative approach, if we think a peer is wasting too much time, we could avoid calling `ProcessMessages()` for it at all until they're back at a reasonable level, relying on hitting the `fPauseRecv=true` flag as new messages get queued, and it not being cleared again until we start doing `ProcessMessages()` again. We'd need to ensure that orphan tx's get put in the from peer's workset instead of the workset of whichever peer relayed the parent that made the tx minable, but that seems fine. Something like:\r\n\r\n```c++\r\nstd::chrono::microseconds CNode::delay_processing_until{0};\r\n\r\nfor (pnode : vNodes) {\r\n    // for caling ProcessMessages\r\n    start = GetTimeMicros();\r\n    if (start > pnode->delay_processing_until) {\r\n        ProcessMessages(pnode);\r\n        fin = GetTimeMicros();\r\n        pnode->delay_processing_until = std::max(fin - 10s, pnode->delay_processing_until + 20*(fin-start));\r\n    }\r\n}\r\n```\r\n\r\n(I think the factor of 20 there would means each peer can only use up 5% of your CPU)",
      "created_at" : "2021-02-19T01:05:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21224#issuecomment-781741925",
      "id" : 781741925,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21224",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc4MTc0MTkyNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-02-19T01:05:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/781741925",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   }
]
