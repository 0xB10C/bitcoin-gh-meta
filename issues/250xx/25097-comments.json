[
   {
      "author_association" : "NONE",
      "body" : "(`Win64 native [msvc]` failed above in functional test `feature_index_prune.py` - this test has been reported recently as flaky, see #25031.)",
      "created_at" : "2022-05-10T03:52:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1121866886",
      "id" : 1121866886,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585C3lSG",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1121866886/reactions"
      },
      "updated_at" : "2022-05-10T03:52:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1121866886",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4162948?v=4",
         "events_url" : "https://api.github.com/users/david-bakin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/david-bakin/followers",
         "following_url" : "https://api.github.com/users/david-bakin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/david-bakin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/david-bakin",
         "id" : 4162948,
         "login" : "david-bakin",
         "node_id" : "MDQ6VXNlcjQxNjI5NDg=",
         "organizations_url" : "https://api.github.com/users/david-bakin/orgs",
         "received_events_url" : "https://api.github.com/users/david-bakin/received_events",
         "repos_url" : "https://api.github.com/users/david-bakin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/david-bakin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/david-bakin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/david-bakin"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Squashed and rebased this branch to master and seeing this when running the tests:\r\n```\r\n$  ./src/test/test_bitcoin -t script_tapscript_tests\r\nRunning 12 test cases...\r\ntest_bitcoin: script/interpreter.cpp:1495: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `false' failed.\r\ntest_bitcoin: script/interpreter.cpp:1497: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `in_pos < tx_to.vin.size()' failed.\r\ntest_bitcoin: script/interpreter.cpp:1528: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_annex_init' failed.\r\ntest_bitcoin: script/interpreter.cpp:1556: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_tapleaf_hash_init' failed.\r\ntest_bitcoin: script/interpreter.cpp:1559: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `execdata.m_codeseparator_pos_init' failed.\r\ntest_bitcoin: script/interpreter.cpp:1469: bool HandleMissingData(MissingDataBehavior): Assertion `!\"Missing data\"' failed.\r\ntest_bitcoin: script/interpreter.cpp:1474: bool HandleMissingData(MissingDataBehavior): Assertion `!\"Unknown MissingDataBehavior value\"' failed.\r\n```\r\n",
      "created_at" : "2022-05-18T06:47:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1129634277",
      "id" : 1129634277,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585DVNnl",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129634277/reactions"
      },
      "updated_at" : "2022-05-18T06:47:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129634277",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "> Squashed and rebased this branch to master and seeing this when running the tests:\r\n> \r\n> ```\r\n> $  ./src/test/test_bitcoin -t script_tapscript_tests\r\n> Running 12 test cases...\r\n> test_bitcoin: script/interpreter.cpp:1495: bool SignatureHashSchnorr(uint256 &, ScriptExecutionData &, const T &, uint32_t, uint8_t, SigVersion, const PrecomputedTransactionData &, MissingDataBehavior) [T = CMutableTransaction]: Assertion `false' failed.\r\n\r\n\r\nYes - that's actually expected.  Those are death tests - testing asserts.  The Boost Test framework will print that the assertion failed but then it is properly caught with an `ExecutionMonitor` so the test actually succeeds.\r\n\r\n**[Following paragraph was initially wrong but now is correct:]**\r\nThe reason for these tests is that I wanted to get 100% coverage.  This routine implements the Schnorr signature hash - which is specified in a BIP and of course is part of the consensus - and it is a very complicated routine - it takes several structs as inputs and those structs can have \"optional\" fields (but not `std::optional`) - which may or may not be initialized.  I thought it was important to make sure that the logic errors in callers actually caused the asserts to happen.  Plus, it makes it easier to look at the coverage report and say, yep, everything in here is tested.\r\n\r\nDo you have any suggestions on how I can improve the documentation or the test to avoid confusion such as this?  Perhaps I could use `BOOST_TEST_MESSAGE` to emit a message: \"These following assertions are _expected_\"??\r\n\r\n(There's a big comment explaining this in the code [@1366](https://github.com/bitcoin/bitcoin/pull/25097/files#diff-21483d0e032747850208f21325b29cde89e9c1f55f83a7a166a388cc5c27115aR1366) but of course people will just see the logs first ...)\r\n\r\nP.S. _Thank you_ for checking this PR out!  Very encouraging for me...",
      "created_at" : "2022-05-18T06:50:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1129636628",
      "id" : 1129636628,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585DVOMU",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129636628/reactions"
      },
      "updated_at" : "2022-05-18T07:02:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129636628",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4162948?v=4",
         "events_url" : "https://api.github.com/users/david-bakin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/david-bakin/followers",
         "following_url" : "https://api.github.com/users/david-bakin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/david-bakin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/david-bakin",
         "id" : 4162948,
         "login" : "david-bakin",
         "node_id" : "MDQ6VXNlcjQxNjI5NDg=",
         "organizations_url" : "https://api.github.com/users/david-bakin/orgs",
         "received_events_url" : "https://api.github.com/users/david-bakin/received_events",
         "repos_url" : "https://api.github.com/users/david-bakin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/david-bakin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/david-bakin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/david-bakin"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Oh ok, I hadn't looked at the code yet (the fixup and merge commits really need to be squashed to encourage people to look at it) but indeed there is a large comment. Agree, logging a message to explain would be helpful.",
      "created_at" : "2022-05-18T07:04:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1129647169",
      "id" : 1129647169,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585DVQxB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129647169/reactions"
      },
      "updated_at" : "2022-05-18T07:04:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129647169",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "I will squash now (actually, in the morning ...) - I was waiting until I finished the last couple of tasks but no problem doing it now.  Thanks for the tip.\r\n\r\nAlso, unfortunately, `BOOST_TEST_MESSAGE` messages aren't displayed unless you set a `log_level`, like `--log_level=message` - so most people still won't see it ...",
      "created_at" : "2022-05-18T07:05:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1129648074",
      "id" : 1129648074,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585DVQ_K",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129648074/reactions"
      },
      "updated_at" : "2022-05-18T07:19:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129648074",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4162948?v=4",
         "events_url" : "https://api.github.com/users/david-bakin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/david-bakin/followers",
         "following_url" : "https://api.github.com/users/david-bakin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/david-bakin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/david-bakin",
         "id" : 4162948,
         "login" : "david-bakin",
         "node_id" : "MDQ6VXNlcjQxNjI5NDg=",
         "organizations_url" : "https://api.github.com/users/david-bakin/orgs",
         "received_events_url" : "https://api.github.com/users/david-bakin/received_events",
         "repos_url" : "https://api.github.com/users/david-bakin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/david-bakin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/david-bakin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/david-bakin"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I tend to run individual tests with `-l test_suite` or `-l all` if anything unusual occurs when running it without a log level.\r\n\r\n In any case, the unit test runner invoked with `make check` runs it fine locally for me and it looks like you solved your CI issue.",
      "created_at" : "2022-05-18T07:45:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#issuecomment-1129682494",
      "id" : 1129682494,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25097",
      "node_id" : "IC_kwDOABII585DVZY-",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129682494/reactions"
      },
      "updated_at" : "2022-05-18T07:49:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1129682494",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r875574299"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/875574299"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Noticed this in the test output.\r\n```suggestion\r\n        BOOST_TEST_MESSAGE(\"Running \" << nAlternatives << \" scenarios\");\r\n```",
      "commit_id" : "a5808ce2f05040f740dad313e503624de2e8db93",
      "created_at" : "2022-05-18T07:46:30Z",
      "diff_hunk" : "@@ -0,0 +1,1546 @@\n+// Copyright (c) 2011-2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <hash.h>\n+#include <pubkey.h>\n+#include <script/interpreter.h>\n+#include <script/script.h>\n+#include <script/script_error.h>\n+#include <test/util/setup_common.h>\n+#include <test/util/transaction_utils.h>\n+#include <util/strencodings.h>\n+#include <univalue.h>\n+\n+#include <boost/test/execution_monitor.hpp>\n+#include <boost/test/unit_test.hpp>\n+\n+#include <algorithm>\n+#include <array>\n+#include <charconv>\n+#include <cstddef>\n+#include <stdexcept>\n+#include <iomanip>\n+#include <iterator>\n+#include <limits>\n+#include <ostream>\n+#include <set>\n+#include <string_view>\n+#include <string>\n+#include <tuple>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+using namespace std::literals::string_literals;\n+using namespace std::literals::string_view_literals;\n+\n+namespace {\n+\n+typedef std::vector<unsigned char> valtype;\n+\n+/**\n+ * Value/Name pair used in data-driven tests\n+ */\n+template <typename T>\n+struct vn_pair\n+{\n+    vn_pair(T v, std::string_view n) : value(v), name(n) {}\n+\n+    const T value;\n+    const std::string_view name;\n+};\n+\n+/**\n+ * Sequence of value/name pairs used in data-driven tests\n+ */\n+template <typename T>\n+using vn_sequence = std::vector<vn_pair<T>>;\n+\n+/**\n+ * Invokes undefined behavior.  See `std::unreachable` in C++23.\n+ */\n+[[noreturn]] inline void declare_unreachable()\n+{\n+#ifdef _MSC_VER\n+    __assume(false);\n+#else\n+    // Assume all other compilers than MSVC implement this GCC builtin.\n+    __builtin_unreachable();\n+#endif\n+}\n+\n+/**\n+ * Outputs to stream as hex\n+ */\n+template <typename US>\n+struct hex\n+{\n+    hex(US v) : value(v) {}\n+    const US value;\n+\n+    friend std::ostream& operator<<(std::ostream& os, hex hx)\n+    {\n+        auto flags = os.flags();\n+        os << std::setw(2*sizeof(US)) << std::setfill('0') << std::showbase\n+           << std::hex << +hx.value;\n+        os.flags(flags);\n+        return os;\n+    }\n+};\n+\n+/**\n+ * Representation changer to fill an integral type with a known pattern.\n+ *\n+ * Pattern is successive byte values given a starting point.  Endianness doesn't\n+ * matter.\n+ */\n+union FillWithPattern {\n+    uint256 u256{0};\n+    uint64_t u64raw[sizeof(uint256)/sizeof(uint64_t)];\n+    uint32_t u32[sizeof(uint256)/sizeof(uint32_t)];\n+    int32_t i32[sizeof(uint256)/sizeof(int32_t)];\n+    uint8_t u8[sizeof(uint256)];\n+\n+    constexpr FillWithPattern(uint8_t start)\n+    {\n+        for (auto it = std::begin(u8); it != std::end(u8); ++it) {\n+            *it = start++;\n+        }\n+    }\n+\n+    uint64_t u64() const {\n+        // It is desirable to force high bit off\n+        return u64raw[0] & static_cast<uint64_t>(std::numeric_limits<int64_t>::max());\n+    }\n+};\n+\n+} // anon namespace\n+\n+BOOST_FIXTURE_TEST_SUITE(script_tapscript_tests, BasicTestingSetup)\n+\n+/**\n+ * Testing EvalScript OP_CHECKSIGADD branch and EvalChecksigTapscript, both in\n+ * interpreter.cpp, against the BIP342 \"Rules for signature opcodes\".\n+ */\n+BOOST_AUTO_TEST_CASE(eval_checksigadd_basic_checks)\n+{\n+    const valtype SIG_64BYTES(64, 0);  // N.B.: Must be () not {}!\n+    const valtype SIG_65BYTES(65, 0);\n+    const valtype SIG_EMPTY{};\n+\n+    const valtype PUBKEY_32BYTES(32, 0);\n+    const valtype PUBKEY_15BYTES(15, 0);\n+    const valtype PUBKEY_EMPTY{};\n+\n+    constexpr int64_t TEST_NUM = 10;\n+\n+    constexpr int64_t START_VALIDATION_WEIGHT{ 90 };\n+    constexpr int64_t BIP342_SIGOPS_LIMIT{ 50 };\n+    constexpr int64_t END_VALIDATION_WEIGHT{ START_VALIDATION_WEIGHT - BIP342_SIGOPS_LIMIT };\n+\n+    /**\n+     * For these tests don't need _real_ signature/pubkey validation.  That is\n+     * tested elsewhere.  So we just _mock_ the signature checker and force it\n+     * to answer valid/invalid as we wish.\n+     */\n+\n+    struct SignatureCheckerMock : public BaseSignatureChecker\n+    {\n+        //! Whether this mock always validates, or always fails, the signature/pubkey check.\n+        enum class VALIDATION { ALWAYS_SUCCEEDS, ALWAYS_FAILS };\n+        VALIDATION m_kind = VALIDATION::ALWAYS_FAILS;\n+\n+        //! True _iff_ CheckSchnorrSignature was actually called\n+        mutable bool m_was_called = false;\n+\n+        SignatureCheckerMock() {}\n+\n+        bool CheckSchnorrSignature(Span<const unsigned char> sig,\n+                                    Span<const unsigned char> pubkey,\n+                                    SigVersion sigversion,\n+                                    ScriptExecutionData& execdata,\n+                                    ScriptError* serror = nullptr) const override\n+        {\n+            m_was_called = true;\n+            switch (m_kind) {\n+            case VALIDATION::ALWAYS_SUCCEEDS:\n+                *serror = SCRIPT_ERR_OK;\n+                return true;\n+            case VALIDATION::ALWAYS_FAILS:\n+                *serror = SCRIPT_ERR_SCHNORR_SIG;\n+                return false;\n+            }\n+            declare_unreachable();\n+        }\n+    };\n+\n+    /**\n+     * A fluent API for running these tests.\n+     *\n+     * (Easiest way to understand this class is to look at the actual tests\n+     * that follow in this function.)\n+     */\n+    struct Context\n+    {\n+        explicit Context(std::string_view descr) : testDescription(descr) {\n+            execdata.m_validation_weight_left_init = true;\n+            execdata.m_validation_weight_left = START_VALIDATION_WEIGHT;\n+        }\n+\n+        std::string testDescription;\n+        SigVersion sigVersion = SigVersion::TAPSCRIPT;\n+        uint32_t flags = 0;\n+        CScript script;\n+        ScriptError err = SCRIPT_ERR_OK;\n+        std::vector<valtype> stack;\n+        ScriptExecutionData execdata;\n+        SignatureCheckerMock sigchecker;\n+        int64_t callerLine = 0;\n+        bool result = false;\n+\n+        Context& SetVersion(SigVersion v)\n+        {\n+            sigVersion = v;\n+            return *this;\n+        }\n+\n+        Context& SetChecker(SignatureCheckerMock::VALIDATION kind)\n+        {\n+            sigchecker.m_kind = kind;\n+            return *this;\n+        }\n+\n+        Context& SetRemainingWeight(int64_t w)\n+        {\n+            execdata.m_validation_weight_left = w;\n+            return *this;\n+        }\n+\n+        Context& AddFlags(uint32_t f)\n+        {\n+            flags |= f;\n+            return *this;\n+        }\n+\n+        CScript& SetScript()\n+        {\n+            return script;\n+        }\n+\n+        Context& DoTest(int64_t line)\n+        {\n+            callerLine = line;\n+            result = EvalScript(stack, script,\n+                                SCRIPT_VERIFY_TAPROOT | flags,\n+                                sigchecker,\n+                                sigVersion,\n+                                execdata,\n+                                &err);\n+            return *this;\n+        }\n+\n+        Context& CheckCallSucceeded()\n+        {\n+            BOOST_CHECK_MESSAGE(result,\n+                               Descr()\n+                               << \": EvalScript succeeded, as expected\");\n+            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK,\n+                                Descr()\n+                                << \": Error code expected OK, actual was \"\n+                                << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckCallFailed(ScriptError expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!result,\n+                               Descr()\n+                               << \": EvalScript failed, as expected\");\n+            BOOST_CHECK_MESSAGE(err == expected,\n+                                Descr()\n+                                << \": Error code expected \" << ScriptErrorString(expected)\n+                                << \", actual was \" << ScriptErrorString(err));\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckSignatureWasNotValidated()\n+        {\n+            BOOST_CHECK_MESSAGE(!sigchecker.m_was_called,\n+                               Descr()\n+                               << \": CheckSchnorrSignature was not called, as expected\");\n+            return *this;\n+        }\n+\n+        Context& CheckRemainingValidationWeight(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(execdata.m_validation_weight_left == expected,\n+                                Descr()\n+                                << \": Remaining validation weight expected \"\n+                                << expected << \", actual was \"\n+                                << execdata.m_validation_weight_left);\n+            return *this;\n+        }\n+\n+        Context& CheckStackDepth(std::size_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(stack.size() == expected,\n+                                Descr()\n+                                << \": Stack depth expected \" << expected\n+                                << \", actual was \" << stack.size());\n+            return *this;\n+        }\n+\n+        Context& CheckTOS(int64_t expected)\n+        {\n+            BOOST_CHECK_MESSAGE(!stack.empty(),\n+                                Descr()\n+                                << \": Stack expected at least one item, actually was empty\");\n+            const int64_t actual = CScriptNum(stack.at(0), false).GetInt64();\n+            BOOST_CHECK_MESSAGE(expected == actual,\n+                                Descr()\n+                                << \": Top-of-stack expected \" << expected\n+                                << \", actual was \" << actual);\n+            return *this;\n+        }\n+\n+    private:\n+        std::string Descr() {\n+            std::array<char, 24> sline{0};\n+            std::string_view svline(\"\");\n+            // (This seems rather elaborate to avoid locale issues with `std::to_string`. One\n+            // can't help but think the C++ committee could have provided a nicer wrapper for it.)\n+            if (auto [ptr,ec] = std::to_chars(sline.data(), sline.data() + sline.size(),\n+                                            callerLine);\n+                ec == std::errc())\n+            {\n+                svline = std::string_view(sline.data(), ptr - sline.data());\n+            }\n+\n+            std::string descr;\n+            descr.reserve(testDescription.size() + 20);\n+            descr += testDescription;\n+            descr += \" (@\";\n+            descr += svline;\n+            descr += \")\";\n+            return descr;\n+        }\n+    };\n+\n+    {\n+        Context ctx(\"SigVersion must not be BASE\");\n+        ctx.SetVersion(SigVersion::BASE).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"SigVersion must not be WITNESS_V0\");\n+        ctx.SetVersion(SigVersion::WITNESS_V0).SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_BAD_OPCODE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Minimum stack height 3 for OP_CHECKSIGADD\");\n+        ctx.SetScript()\n+            << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_INVALID_STACK_OPERATION)\n+            .CheckStackDepth(2);\n+    }\n+\n+    {\n+        Context ctx(\"`n` (2nd arg) size > 4 must fail\");\n+        // This is probably meant to be a check on the _encoding_ - that it is\n+        // minimal, but it can also be a check on the _value_.  BIP342 doesn't\n+        // say which.  Could be both...\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(10000000000LL) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            // (IMO this is an _unsatisfactory_ error code to return for a required\n+            // BIP342 check, but see the `catch` clause in `EvalScript`)\n+            .CheckCallFailed(SCRIPT_ERR_UNKNOWN_ERROR)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Sig + empty pubkey\");\n+        ctx.SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_EMPTY << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_PUBKEYTYPE)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Insufficient validation weight remaining\");\n+        ctx.SetRemainingWeight(BIP342_SIGOPS_LIMIT-1)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_TAPSCRIPT_VALIDATION_WEIGHT)\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + 32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"Empty sig + non32byte pubkey skips validation\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey ('unknown pubkey type') _with_ discourage flag fails\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .AddFlags(SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_DISCOURAGE_UPGRADABLE_PUBKEYTYPE)\n+            .CheckSignatureWasNotValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation failure forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_FAILS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallFailed(SCRIPT_ERR_SCHNORR_SIG)\n+            .CheckSignatureWasValidated()\n+            .CheckStackDepth(3);\n+    }\n+\n+    {\n+        Context ctx(\"32byte pubkey + sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_64BYTES << CScriptNum(TEST_NUM) << PUBKEY_32BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasValidated()\n+            .CheckRemainingValidationWeight(END_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM+1);\n+    }\n+\n+    {\n+        Context ctx(\"non32byte pubkey + empty sig with validation success forced\");\n+        ctx.SetChecker(SignatureCheckerMock::VALIDATION::ALWAYS_SUCCEEDS)\n+            .SetScript()\n+            << SIG_EMPTY << CScriptNum(TEST_NUM) << PUBKEY_15BYTES << OP_CHECKSIGADD;\n+        ctx.DoTest(__LINE__)\n+            .CheckCallSucceeded()\n+            .CheckSignatureWasNotValidated()\n+            .CheckRemainingValidationWeight(START_VALIDATION_WEIGHT)\n+            .CheckStackDepth(1)\n+            .CheckTOS(TEST_NUM);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_failure_cases)\n+{\n+    // As defined by BIP-341 Signature Validation Rules\n+    // Here we pick an acceptable SigVersion\n+    const SigVersion sigversion = SigVersion::TAPROOT;\n+\n+    CMutableTransaction tx_to_m;\n+    tx_to_m.vin.push_back(CTxIn());\n+    const uint32_t in_pos{0};\n+\n+    PrecomputedTransactionData cache;\n+    cache.m_bip341_taproot_ready = true;\n+    cache.m_spent_outputs_ready = true;\n+\n+    ScriptExecutionData execdata;\n+    execdata.m_annex_init = true;\n+    execdata.m_annex_present = false;\n+    execdata.m_annex_hash = uint256::ZERO;\n+    execdata.m_tapleaf_hash_init = false;\n+    execdata.m_codeseparator_pos_init = true;\n+\n+    uint256 hash_out{0};\n+\n+    {\n+        // Check all invalid hash_type codes rejected\n+        const std::set<uint8_t> allowable_hash_types{ 0x00, 0x01, 0x02, 0x03, 0x81, 0x82, 0x83 };\n+        for (unsigned ht = 0; ht <= 255; ht++) {\n+            const uint8_t hash_type = static_cast<uint8_t>(ht);\n+            if (allowable_hash_types.find(hash_type) != allowable_hash_types.end()) continue;\n+\n+            BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m, in_pos,\n+                                                      hash_type, sigversion, cache,\n+                                                      MissingDataBehavior::FAIL),\n+                                \"hash_type = \" << hex(hash_type) << \" expected to fail\");\n+        }\n+    }\n+\n+    {\n+        // Check that if hash_type == SIGHASH_SINGLE then missing a \"corresponding\n+        // output\" fails.\n+        CMutableTransaction tx_to_m;\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+        tx_to_m.vin.push_back(CTxIn());\n+\n+        uint8_t in_pos = 1;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(1) > #tx_to==0 is expected to fail\");\n+\n+        tx_to_m.vout.push_back(CTxOut());\n+        in_pos = 2;\n+        BOOST_CHECK_MESSAGE(!SignatureHashSchnorr(hash_out, execdata, tx_to_m,\n+                                                  in_pos, SIGHASH_SINGLE, sigversion, cache,\n+                                                  MissingDataBehavior::FAIL),\n+                            \"SIGHASH_SINGLE with in_pos(2) > #tx_to==1 is expected to fail\");\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(signature_hash_schnorr_all_success_paths)\n+{\n+    // Our approach here will be to follow BIP-341's signature algorithm (with\n+    // the BIP-342 extension) doing two things at once:\n+    //   1) We'll set up the input arguments to `SignatureHashSchnorr` function\n+    //      being tested, _and_\n+    //   2) we'll _compute the hash of those fields ourselves_ exaxctly as\n+    //      it is described in BIP-341 and BIP-342.\n+    // Then we can compare the two.  We'll do this in a data-driven way for each\n+    // of the different scenarios that the algorithm supports.\n+    //\n+    // In this way this test achieves 100% _path_ coverage of `SignatureHashSchnorr`\n+    // (not just 100% _branch_ coverage).\n+    // - Sadly, this isn't shown in the `lcov` reports.  There are still a few\n+    //   red `-` marks left.  This is because:\n+    //   1. `lcov` wasn't designed to handle death tests.\n+    //   2. ??? Some other unknown reasons, possibly due to the instrumentation,\n+    //      possibly due to `lcov` limitations.  You can see by the test output\n+    //      (`-log_level=all`) or within a debugger that in fact _all_ branches\n+    //      are taken when executing all the tests in this file.\n+\n+    // Here we define, and then generate, all combinations of the alternatives\n+    // for the parameters that vary the signature combination algorithm\n+\n+    const vn_sequence<SigVersion> SigVersion_alternatives{\n+        {SigVersion::TAPROOT, \"TAPROOT\"sv},\n+        {SigVersion::TAPSCRIPT, \"TAPSCRIPT\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_output_alternatives{\n+        {SIGHASH_DEFAULT, \"SIGHASH_DEFAULT\"sv},\n+        {SIGHASH_ALL, \"SIGHASH_ALL\"sv},\n+        {SIGHASH_NONE, \"SIGHASH_NONE\"sv},\n+        {SIGHASH_SINGLE, \"SIGHASH_SINGLE\"sv}\n+    };\n+\n+    const vn_sequence<uint32_t> hash_type_input_alternatives{\n+        {0, \"N/A\"sv},\n+        {SIGHASH_ANYONECANPAY, \"SIGHASH_ANYONECANPAY\"sv}\n+    };\n+\n+    const vn_sequence<uint8_t> annex_alternatives{\n+        {0, \"no annex\"sv},\n+        {1, \"annex present\"sv}\n+    };\n+\n+    const vn_sequence<bool> output_hash_alternatives{\n+        {false, \"output hash missing\"sv},\n+        {true, \"output hash provided\"sv}\n+    };\n+\n+    {\n+        const int nAlternatives = SigVersion_alternatives.size()\n+                                  * hash_type_output_alternatives.size()\n+                                  * hash_type_input_alternatives.size()\n+                                  * annex_alternatives.size()\n+                                  * output_hash_alternatives.size()\n+                                  - 8 /* exclude SIGHASH_DEFAULT w/ SISHASH_ANYONECANPAY */;\n+\n+        BOOST_TEST_MESSAGE(\"Running \" << nAlternatives << \"scenarios\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25097#discussion_r875574299",
      "id" : 875574299,
      "line" : 602,
      "node_id" : "PRRC_kwDOABII5840MDQb",
      "original_commit_id" : "a5808ce2f05040f740dad313e503624de2e8db93",
      "original_line" : 602,
      "original_position" : 602,
      "original_start_line" : null,
      "path" : "src/test/script_tapscript_tests.cpp",
      "position" : 602,
      "pull_request_review_id" : 976500374,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25097",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/875574299/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-05-18T07:46:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/875574299",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   }
]
