[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #17812 (config, net, test: asmap functional tests and feature refinements by jonatack)\n* #17428 (p2p: Try to preserve outbound block-relay-only connections during restart by hebasto)\n* #16883 (WIP: Qt: add QML based mobile GUI by icota)\n* #16549 ([WIP] UI external signer support (e.g. hardware wallet) by Sjors)\n* #16546 ([WIP] External signer support - Wallet Box edition by Sjors)\n* #15112 (build: Optionally enable -Wzero-as-null-pointer-constant by Empact)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2020-02-05T23:18:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-582659603",
      "id" : 582659603,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4MjY1OTYwMw==",
      "updated_at" : "2020-02-21T23:21:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/582659603",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Thanks for picking this up again. I hope we manage to do this this time.",
      "created_at" : "2020-02-06T11:22:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-582859339",
      "id" : 582859339,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4Mjg1OTMzOQ==",
      "updated_at" : "2020-02-06T11:22:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/582859339",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r375996088"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/375996088"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This will break building with both NAT-PMP and UPnP support...",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-06T18:06:53Z",
      "diff_hunk" : "@@ -0,0 +1,221 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <arpa/inet.h>\n+#include <netinet/in.h>\n+#endif\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#endif\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_upnp_interrupt;\n+static std::thread g_upnp_thread;\n+\n+#ifdef USE_NATPMP\n+static void ThreadMapPort()\n+{\n+    int r;\n+    natpmp_t natpmp;\n+    natpmpresp_t response;\n+\n+    r = initnatpmp(&natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r);\n+        closenatpmp(&natpmp);\n+        return;\n+    }\n+\n+    if (fDiscover) {\n+        r = sendpublicaddressrequest(&natpmp);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r);\n+        } else {\n+            do {\n+                r = readnatpmpresponseorretry(&natpmp, &response);\n+            } while (r == NATPMP_TRYAGAIN);\n+            if (r < 0 || response.type != NATPMP_RESPTYPE_PUBLICADDRESS) {\n+                LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r);\n+            } else {\n+                const char* public_address = inet_ntoa(response.pnu.publicaddress.addr);\n+                if (public_address[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(public_address, resolved, false)) {\n+                        LogPrintf(\"NAT-PMP: public address = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_UPNP);\n+                    }\n+                } else {\n+                    LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed.\\n\");\n+                }\n+            }\n+        }\n+    }\n+\n+    const uint16_t port = GetListenPort();\n+    do {\n+        r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, 3600 /*seconds*/);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r);\n+            break;\n+        }\n+\n+        do {\n+            r = readnatpmpresponseorretry(&natpmp, &response);\n+        } while (r == NATPMP_TRYAGAIN);\n+        if (r < 0 || response.type != NATPMP_RESPTYPE_TCPPORTMAPPING) {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r);\n+        } else {\n+            auto pm = response.pnu.newportmapping;\n+            if (port == pm.privateport && port == pm.mappedpublicport && pm.lifetime > 0) {\n+                LogPrintf(\"NAT-PMP: port mapping successful.\\n\");\n+            } else {\n+                LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed.\\n\");\n+            }\n+        }\n+\n+    } while (g_upnp_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+    r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, /* remove a port mapping */ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r);\n+    }\n+\n+    closenatpmp(&natpmp);\n+}\n+\n+#else // USE_UPNP",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r375996088",
      "id" : 375996088,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk5NjA4OA==",
      "original_commit_id" : "60e2524c8aa0edf5ce09d842cec09065cb854bcd",
      "original_position" : 119,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 354660903,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/375996088",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r375999662"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/375999662"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> This will break building with both NAT-PMP and UPnP support...\r\n\r\nYes, I'm aware of that. This PR in its current state is intended for NAT-PMP functionality tests and concept (N)ACKs.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-06T18:14:29Z",
      "diff_hunk" : "@@ -0,0 +1,221 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <arpa/inet.h>\n+#include <netinet/in.h>\n+#endif\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#endif\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_upnp_interrupt;\n+static std::thread g_upnp_thread;\n+\n+#ifdef USE_NATPMP\n+static void ThreadMapPort()\n+{\n+    int r;\n+    natpmp_t natpmp;\n+    natpmpresp_t response;\n+\n+    r = initnatpmp(&natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r);\n+        closenatpmp(&natpmp);\n+        return;\n+    }\n+\n+    if (fDiscover) {\n+        r = sendpublicaddressrequest(&natpmp);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r);\n+        } else {\n+            do {\n+                r = readnatpmpresponseorretry(&natpmp, &response);\n+            } while (r == NATPMP_TRYAGAIN);\n+            if (r < 0 || response.type != NATPMP_RESPTYPE_PUBLICADDRESS) {\n+                LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r);\n+            } else {\n+                const char* public_address = inet_ntoa(response.pnu.publicaddress.addr);\n+                if (public_address[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(public_address, resolved, false)) {\n+                        LogPrintf(\"NAT-PMP: public address = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_UPNP);\n+                    }\n+                } else {\n+                    LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed.\\n\");\n+                }\n+            }\n+        }\n+    }\n+\n+    const uint16_t port = GetListenPort();\n+    do {\n+        r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, 3600 /*seconds*/);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r);\n+            break;\n+        }\n+\n+        do {\n+            r = readnatpmpresponseorretry(&natpmp, &response);\n+        } while (r == NATPMP_TRYAGAIN);\n+        if (r < 0 || response.type != NATPMP_RESPTYPE_TCPPORTMAPPING) {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r);\n+        } else {\n+            auto pm = response.pnu.newportmapping;\n+            if (port == pm.privateport && port == pm.mappedpublicport && pm.lifetime > 0) {\n+                LogPrintf(\"NAT-PMP: port mapping successful.\\n\");\n+            } else {\n+                LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed.\\n\");\n+            }\n+        }\n+\n+    } while (g_upnp_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+    r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, /* remove a port mapping */ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r);\n+    }\n+\n+    closenatpmp(&natpmp);\n+}\n+\n+#else // USE_UPNP",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r375999662",
      "id" : 375999662,
      "in_reply_to_id" : 375996088,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk5OTY2Mg==",
      "original_commit_id" : "60e2524c8aa0edf5ce09d842cec09065cb854bcd",
      "original_position" : 119,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 354665487,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/375999662",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK",
      "created_at" : "2020-02-06T18:16:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-583039181",
      "id" : 583039181,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4MzAzOTE4MQ==",
      "updated_at" : "2020-02-06T18:16:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/583039181",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "It is ready for reviewing now.",
      "created_at" : "2020-02-07T20:53:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-583606396",
      "id" : 583606396,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4MzYwNjM5Ng==",
      "updated_at" : "2020-02-07T20:53:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/583606396",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Updated 4ff5349a3172d02fceb976bf4989996c88f86680 -> cf94431e8f4bfd6636998a17e2355feb2c5c3d58 ([pr18077.03](https://github.com/hebasto/bitcoin/commits/pr18077.03) -> [pr18077.04](https://github.com/hebasto/bitcoin/commits/pr18077.04), [compare](https://github.com/hebasto/bitcoin/compare/pr18077.03..pr18077.04)):\r\n\r\nadded `libnatpmp` package to macOS 10.14 native Travis build.",
      "created_at" : "2020-02-07T21:49:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-583630233",
      "id" : 583630233,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4MzYzMDIzMw==",
      "updated_at" : "2020-02-07T21:49:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/583630233",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Updated cf94431e8f4bfd6636998a17e2355feb2c5c3d58 -> 88248a44241c8e3922a80729ce4a9a178ef2dbea ([pr18077.04](https://github.com/hebasto/bitcoin/commits/pr18077.04) -> [pr18077.05](https://github.com/hebasto/bitcoin/commits/pr18077.05), [compare](https://github.com/hebasto/bitcoin/compare/pr18077.04..pr18077.05)):\r\n\r\nadded:\r\n- changes to docs\r\n- release notes",
      "created_at" : "2020-02-08T08:17:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-583715048",
      "id" : 583715048,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4MzcxNTA0OA==",
      "updated_at" : "2020-02-08T08:17:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/583715048",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2020-02-10T12:03:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-584090512",
      "id" : 584090512,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NDA5MDUxMg==",
      "updated_at" : "2020-02-10T12:03:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/584090512",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased after #17398 and #18081 have been merged.",
      "created_at" : "2020-02-10T17:20:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-584234105",
      "id" : 584234105,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NDIzNDEwNQ==",
      "updated_at" : "2020-02-10T17:20:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/584234105",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK, will test on my home router.",
      "created_at" : "2020-02-10T19:26:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-584307307",
      "id" : 584307307,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NDMwNzMwNw==",
      "updated_at" : "2020-02-10T19:26:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/584307307",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3445290?v=4",
         "events_url" : "https://api.github.com/users/dongcarl/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dongcarl/followers",
         "following_url" : "https://api.github.com/users/dongcarl/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dongcarl/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dongcarl",
         "id" : 3445290,
         "login" : "dongcarl",
         "node_id" : "MDQ6VXNlcjM0NDUyOTA=",
         "organizations_url" : "https://api.github.com/users/dongcarl/orgs",
         "received_events_url" : "https://api.github.com/users/dongcarl/received_events",
         "repos_url" : "https://api.github.com/users/dongcarl/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dongcarl/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dongcarl"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK. Lightly tested configure / build on macOS.\r\n\r\nUnfortunately I'm behind a IPv6 DS-Lite router, I can't test the IPv4 port forward. Perhaps `-7` could be replaced by something more readable.\r\n\r\n```\r\n2020-02-11T17:48:27Z natpmp thread start\r\n2020-02-11T17:48:27Z Bound to [::]:8333\r\n2020-02-11T17:48:27Z Bound to 0.0.0.0:8333\r\n2020-02-11T17:48:27Z init message: Loading P2P addresses...\r\n2020-02-11T17:48:27Z NAT-PMP: readnatpmpresponseorretry() for public address failed with -7 error.\r\n2020-02-11T17:48:27Z NAT-PMP: readnatpmpresponseorretry() for port mapping failed with -7 error. \r\n```\r\n\r\nI looked up the error code, and it's what I would expect given my setup:\r\n```\r\n/* NATPMP_ERR_NOGATEWAYSUPPORT : the gateway does not support NAT-PMP */\r\n#define NATPMP_ERR_NOGATEWAYSUPPORT (-7)\r\n```\r\n\r\nTwo suggesitons for followups, or this PR:\r\n* add checkbox in QT Settings (above UPNP)\r\n* add support for IPv6 pinhole if the library supports it, see #17012 (looks like it doesn't)",
      "created_at" : "2020-02-11T17:57:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-584768149",
      "id" : 584768149,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NDc2ODE0OQ==",
      "updated_at" : "2020-02-11T18:03:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/584768149",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@Sjors \r\n\r\nThank you for your review and testing.\r\n\r\n> I looked up the error code, and it's what I would expect given my setup:\r\n> \r\n> ```\r\n> /* NATPMP_ERR_NOGATEWAYSUPPORT : the gateway does not support NAT-PMP */\r\n> #define NATPMP_ERR_NOGATEWAYSUPPORT (-7)\r\n> ```\r\n\r\nAgree.\r\nBut in this initial PR I intentionally do not provide user-friendly error messages in order to keep `ThreadNatpmp()` dense and tight for easier reviewing ;)\r\n\r\nIn followups every library call (`initnatpmp()`, `sendpublicaddressrequest()` and `sendnewportmappingrequest()`) with the following `readnatpmpresponseorretry()` loops could be refactored out to separate functions with user-friendly error messages.\r\n\r\n> Two suggesitons for followups, or this PR:\r\n> \r\n>     * add checkbox in QT Settings (above UPNP)\r\n\r\nAgree. From the OP:\r\n> Some follow-ups are out of this PR's scope:\r\n> \r\n>     * mention NAT-PMP library in the version message\r\n> \r\n>     * integrate NAT-PMP into the GUI\r\n\r\n",
      "created_at" : "2020-02-11T19:11:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-584801614",
      "id" : 584801614,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NDgwMTYxNA==",
      "updated_at" : "2020-02-11T19:13:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/584801614",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r378006285"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/378006285"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Won't this overwrite the `g_mapport_thread` set above if both are enabled?",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-12T02:12:13Z",
      "diff_hunk" : "@@ -0,0 +1,236 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <arpa/inet.h>\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+\n+#ifdef USE_NATPMP\n+static void ThreadNatpmp()\n+{\n+    int r;\n+    natpmp_t natpmp;\n+    natpmpresp_t response;\n+\n+    r = initnatpmp(&natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r);\n+        closenatpmp(&natpmp);\n+        return;\n+    }\n+\n+    if (fDiscover) {\n+        r = sendpublicaddressrequest(&natpmp);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r);\n+        } else {\n+            do {\n+                r = readnatpmpresponseorretry(&natpmp, &response);\n+            } while (r == NATPMP_TRYAGAIN);\n+            if (r < 0 || response.type != NATPMP_RESPTYPE_PUBLICADDRESS) {\n+                LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r);\n+            } else {\n+                const char* public_address = inet_ntoa(response.pnu.publicaddress.addr);\n+                if (public_address[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(public_address, resolved, false)) {\n+                        LogPrintf(\"NAT-PMP: public address = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed.\\n\");\n+                }\n+            }\n+        }\n+    }\n+\n+    const uint16_t port = GetListenPort();\n+    do {\n+        r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, 3600 /*seconds*/);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r);\n+            break;\n+        }\n+\n+        do {\n+            r = readnatpmpresponseorretry(&natpmp, &response);\n+        } while (r == NATPMP_TRYAGAIN);\n+        if (r < 0 || response.type != NATPMP_RESPTYPE_TCPPORTMAPPING) {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r);\n+        } else {\n+            auto pm = response.pnu.newportmapping;\n+            if (port == pm.privateport && port == pm.mappedpublicport && pm.lifetime > 0) {\n+                LogPrintf(\"NAT-PMP: port mapping successful.\\n\");\n+            } else {\n+                LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed.\\n\");\n+            }\n+        }\n+\n+    } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+    r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, /* remove a port mapping */ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r);\n+    }\n+\n+    closenatpmp(&natpmp);\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static void ThreadUpnp()\n+{\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+            } else {\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+}\n+#endif // #ifdef USE_UPNP\n+\n+void StartMapPort(MapPort proto)\n+{\n+    if (!g_mapport_thread.joinable()) {\n+        assert(!g_mapport_interrupt);\n+        switch (proto) {\n+        case MapPort::NAT_PMP: {\n+#ifdef USE_NATPMP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"natpmp\", &ThreadNatpmp)));\n+#endif // #ifdef USE_NATPMP\n+            return;\n+        }\n+        case MapPort::UPNP: {\n+#ifdef USE_UPNP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"upnp\", &ThreadUpnp)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r378006285",
      "id" : 378006285,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODAwNjI4NQ==",
      "original_commit_id" : "c7e90ca40ad9b7c66f3429b792435e9279ceca6b",
      "original_position" : 199,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 357148016,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/378006285",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r378072197"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/378072197"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I believe that the both port mapping protocols shouldn't be enabled simultaneously:\r\nhttps://github.com/bitcoin/bitcoin/blob/c7e90ca40ad9b7c66f3429b792435e9279ceca6b/src/init.cpp#L1781-L1786",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-12T07:10:35Z",
      "diff_hunk" : "@@ -0,0 +1,236 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <arpa/inet.h>\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+\n+#ifdef USE_NATPMP\n+static void ThreadNatpmp()\n+{\n+    int r;\n+    natpmp_t natpmp;\n+    natpmpresp_t response;\n+\n+    r = initnatpmp(&natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r);\n+        closenatpmp(&natpmp);\n+        return;\n+    }\n+\n+    if (fDiscover) {\n+        r = sendpublicaddressrequest(&natpmp);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r);\n+        } else {\n+            do {\n+                r = readnatpmpresponseorretry(&natpmp, &response);\n+            } while (r == NATPMP_TRYAGAIN);\n+            if (r < 0 || response.type != NATPMP_RESPTYPE_PUBLICADDRESS) {\n+                LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r);\n+            } else {\n+                const char* public_address = inet_ntoa(response.pnu.publicaddress.addr);\n+                if (public_address[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(public_address, resolved, false)) {\n+                        LogPrintf(\"NAT-PMP: public address = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed.\\n\");\n+                }\n+            }\n+        }\n+    }\n+\n+    const uint16_t port = GetListenPort();\n+    do {\n+        r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, 3600 /*seconds*/);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r);\n+            break;\n+        }\n+\n+        do {\n+            r = readnatpmpresponseorretry(&natpmp, &response);\n+        } while (r == NATPMP_TRYAGAIN);\n+        if (r < 0 || response.type != NATPMP_RESPTYPE_TCPPORTMAPPING) {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r);\n+        } else {\n+            auto pm = response.pnu.newportmapping;\n+            if (port == pm.privateport && port == pm.mappedpublicport && pm.lifetime > 0) {\n+                LogPrintf(\"NAT-PMP: port mapping successful.\\n\");\n+            } else {\n+                LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed.\\n\");\n+            }\n+        }\n+\n+    } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+    r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, /* remove a port mapping */ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r);\n+    }\n+\n+    closenatpmp(&natpmp);\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static void ThreadUpnp()\n+{\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+            } else {\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+}\n+#endif // #ifdef USE_UPNP\n+\n+void StartMapPort(MapPort proto)\n+{\n+    if (!g_mapport_thread.joinable()) {\n+        assert(!g_mapport_interrupt);\n+        switch (proto) {\n+        case MapPort::NAT_PMP: {\n+#ifdef USE_NATPMP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"natpmp\", &ThreadNatpmp)));\n+#endif // #ifdef USE_NATPMP\n+            return;\n+        }\n+        case MapPort::UPNP: {\n+#ifdef USE_UPNP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"upnp\", &ThreadUpnp)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r378072197",
      "id" : 378072197,
      "in_reply_to_id" : 378006285,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODA3MjE5Nw==",
      "original_commit_id" : "c7e90ca40ad9b7c66f3429b792435e9279ceca6b",
      "original_position" : 199,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 357227561,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/378072197",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r378210260"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/378210260"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It should be possible to enable both.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-12T12:05:22Z",
      "diff_hunk" : "@@ -0,0 +1,236 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <arpa/inet.h>\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+\n+#ifdef USE_NATPMP\n+static void ThreadNatpmp()\n+{\n+    int r;\n+    natpmp_t natpmp;\n+    natpmpresp_t response;\n+\n+    r = initnatpmp(&natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r);\n+        closenatpmp(&natpmp);\n+        return;\n+    }\n+\n+    if (fDiscover) {\n+        r = sendpublicaddressrequest(&natpmp);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r);\n+        } else {\n+            do {\n+                r = readnatpmpresponseorretry(&natpmp, &response);\n+            } while (r == NATPMP_TRYAGAIN);\n+            if (r < 0 || response.type != NATPMP_RESPTYPE_PUBLICADDRESS) {\n+                LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r);\n+            } else {\n+                const char* public_address = inet_ntoa(response.pnu.publicaddress.addr);\n+                if (public_address[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(public_address, resolved, false)) {\n+                        LogPrintf(\"NAT-PMP: public address = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed.\\n\");\n+                }\n+            }\n+        }\n+    }\n+\n+    const uint16_t port = GetListenPort();\n+    do {\n+        r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, 3600 /*seconds*/);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r);\n+            break;\n+        }\n+\n+        do {\n+            r = readnatpmpresponseorretry(&natpmp, &response);\n+        } while (r == NATPMP_TRYAGAIN);\n+        if (r < 0 || response.type != NATPMP_RESPTYPE_TCPPORTMAPPING) {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r);\n+        } else {\n+            auto pm = response.pnu.newportmapping;\n+            if (port == pm.privateport && port == pm.mappedpublicport && pm.lifetime > 0) {\n+                LogPrintf(\"NAT-PMP: port mapping successful.\\n\");\n+            } else {\n+                LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed.\\n\");\n+            }\n+        }\n+\n+    } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+    r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, /* remove a port mapping */ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r);\n+    }\n+\n+    closenatpmp(&natpmp);\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static void ThreadUpnp()\n+{\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+            } else {\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+}\n+#endif // #ifdef USE_UPNP\n+\n+void StartMapPort(MapPort proto)\n+{\n+    if (!g_mapport_thread.joinable()) {\n+        assert(!g_mapport_interrupt);\n+        switch (proto) {\n+        case MapPort::NAT_PMP: {\n+#ifdef USE_NATPMP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"natpmp\", &ThreadNatpmp)));\n+#endif // #ifdef USE_NATPMP\n+            return;\n+        }\n+        case MapPort::UPNP: {\n+#ifdef USE_UPNP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"upnp\", &ThreadUpnp)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r378210260",
      "id" : 378210260,
      "in_reply_to_id" : 378006285,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIxMDI2MA==",
      "original_commit_id" : "c7e90ca40ad9b7c66f3429b792435e9279ceca6b",
      "original_position" : 199,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 357399634,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/378210260",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r378219481"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/378219481"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If both are enabled, would you try to open de port with NAT_PMP first and if that fails UPNP?",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-12T12:26:31Z",
      "diff_hunk" : "@@ -0,0 +1,236 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <arpa/inet.h>\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+\n+#ifdef USE_NATPMP\n+static void ThreadNatpmp()\n+{\n+    int r;\n+    natpmp_t natpmp;\n+    natpmpresp_t response;\n+\n+    r = initnatpmp(&natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r);\n+        closenatpmp(&natpmp);\n+        return;\n+    }\n+\n+    if (fDiscover) {\n+        r = sendpublicaddressrequest(&natpmp);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r);\n+        } else {\n+            do {\n+                r = readnatpmpresponseorretry(&natpmp, &response);\n+            } while (r == NATPMP_TRYAGAIN);\n+            if (r < 0 || response.type != NATPMP_RESPTYPE_PUBLICADDRESS) {\n+                LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r);\n+            } else {\n+                const char* public_address = inet_ntoa(response.pnu.publicaddress.addr);\n+                if (public_address[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(public_address, resolved, false)) {\n+                        LogPrintf(\"NAT-PMP: public address = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed.\\n\");\n+                }\n+            }\n+        }\n+    }\n+\n+    const uint16_t port = GetListenPort();\n+    do {\n+        r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, 3600 /*seconds*/);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r);\n+            break;\n+        }\n+\n+        do {\n+            r = readnatpmpresponseorretry(&natpmp, &response);\n+        } while (r == NATPMP_TRYAGAIN);\n+        if (r < 0 || response.type != NATPMP_RESPTYPE_TCPPORTMAPPING) {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r);\n+        } else {\n+            auto pm = response.pnu.newportmapping;\n+            if (port == pm.privateport && port == pm.mappedpublicport && pm.lifetime > 0) {\n+                LogPrintf(\"NAT-PMP: port mapping successful.\\n\");\n+            } else {\n+                LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed.\\n\");\n+            }\n+        }\n+\n+    } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+    r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, /* remove a port mapping */ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r);\n+    }\n+\n+    closenatpmp(&natpmp);\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static void ThreadUpnp()\n+{\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+            } else {\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+}\n+#endif // #ifdef USE_UPNP\n+\n+void StartMapPort(MapPort proto)\n+{\n+    if (!g_mapport_thread.joinable()) {\n+        assert(!g_mapport_interrupt);\n+        switch (proto) {\n+        case MapPort::NAT_PMP: {\n+#ifdef USE_NATPMP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"natpmp\", &ThreadNatpmp)));\n+#endif // #ifdef USE_NATPMP\n+            return;\n+        }\n+        case MapPort::UPNP: {\n+#ifdef USE_UPNP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"upnp\", &ThreadUpnp)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r378219481",
      "id" : 378219481,
      "in_reply_to_id" : 378006285,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIxOTQ4MQ==",
      "original_commit_id" : "c7e90ca40ad9b7c66f3429b792435e9279ceca6b",
      "original_position" : 199,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 357411424,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/378219481",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r378221757"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/378221757"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> It should be possible to enable both.\r\n\r\nDo you mean that a router could do port mapping using both NAT-PMP and UPnP simultaneously? What is the reason for that?",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-12T12:31:52Z",
      "diff_hunk" : "@@ -0,0 +1,236 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <arpa/inet.h>\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+\n+#ifdef USE_NATPMP\n+static void ThreadNatpmp()\n+{\n+    int r;\n+    natpmp_t natpmp;\n+    natpmpresp_t response;\n+\n+    r = initnatpmp(&natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r);\n+        closenatpmp(&natpmp);\n+        return;\n+    }\n+\n+    if (fDiscover) {\n+        r = sendpublicaddressrequest(&natpmp);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r);\n+        } else {\n+            do {\n+                r = readnatpmpresponseorretry(&natpmp, &response);\n+            } while (r == NATPMP_TRYAGAIN);\n+            if (r < 0 || response.type != NATPMP_RESPTYPE_PUBLICADDRESS) {\n+                LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r);\n+            } else {\n+                const char* public_address = inet_ntoa(response.pnu.publicaddress.addr);\n+                if (public_address[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(public_address, resolved, false)) {\n+                        LogPrintf(\"NAT-PMP: public address = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed.\\n\");\n+                }\n+            }\n+        }\n+    }\n+\n+    const uint16_t port = GetListenPort();\n+    do {\n+        r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, 3600 /*seconds*/);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r);\n+            break;\n+        }\n+\n+        do {\n+            r = readnatpmpresponseorretry(&natpmp, &response);\n+        } while (r == NATPMP_TRYAGAIN);\n+        if (r < 0 || response.type != NATPMP_RESPTYPE_TCPPORTMAPPING) {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r);\n+        } else {\n+            auto pm = response.pnu.newportmapping;\n+            if (port == pm.privateport && port == pm.mappedpublicport && pm.lifetime > 0) {\n+                LogPrintf(\"NAT-PMP: port mapping successful.\\n\");\n+            } else {\n+                LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed.\\n\");\n+            }\n+        }\n+\n+    } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+    r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, /* remove a port mapping */ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r);\n+    }\n+\n+    closenatpmp(&natpmp);\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static void ThreadUpnp()\n+{\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+            } else {\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+}\n+#endif // #ifdef USE_UPNP\n+\n+void StartMapPort(MapPort proto)\n+{\n+    if (!g_mapport_thread.joinable()) {\n+        assert(!g_mapport_interrupt);\n+        switch (proto) {\n+        case MapPort::NAT_PMP: {\n+#ifdef USE_NATPMP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"natpmp\", &ThreadNatpmp)));\n+#endif // #ifdef USE_NATPMP\n+            return;\n+        }\n+        case MapPort::UPNP: {\n+#ifdef USE_UPNP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"upnp\", &ThreadUpnp)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r378221757",
      "id" : 378221757,
      "in_reply_to_id" : 378006285,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIyMTc1Nw==",
      "original_commit_id" : "c7e90ca40ad9b7c66f3429b792435e9279ceca6b",
      "original_position" : 199,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 357414425,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/378221757",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r378227115"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/378227115"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I wouldn't use them simultaneously, but one fails it makes sense to try the other. Though I believe our long plan is to remove UPnP, if NAT-PMP does the job.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-12T12:43:39Z",
      "diff_hunk" : "@@ -0,0 +1,236 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <arpa/inet.h>\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+\n+#ifdef USE_NATPMP\n+static void ThreadNatpmp()\n+{\n+    int r;\n+    natpmp_t natpmp;\n+    natpmpresp_t response;\n+\n+    r = initnatpmp(&natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r);\n+        closenatpmp(&natpmp);\n+        return;\n+    }\n+\n+    if (fDiscover) {\n+        r = sendpublicaddressrequest(&natpmp);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r);\n+        } else {\n+            do {\n+                r = readnatpmpresponseorretry(&natpmp, &response);\n+            } while (r == NATPMP_TRYAGAIN);\n+            if (r < 0 || response.type != NATPMP_RESPTYPE_PUBLICADDRESS) {\n+                LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r);\n+            } else {\n+                const char* public_address = inet_ntoa(response.pnu.publicaddress.addr);\n+                if (public_address[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(public_address, resolved, false)) {\n+                        LogPrintf(\"NAT-PMP: public address = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed.\\n\");\n+                }\n+            }\n+        }\n+    }\n+\n+    const uint16_t port = GetListenPort();\n+    do {\n+        r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, 3600 /*seconds*/);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r);\n+            break;\n+        }\n+\n+        do {\n+            r = readnatpmpresponseorretry(&natpmp, &response);\n+        } while (r == NATPMP_TRYAGAIN);\n+        if (r < 0 || response.type != NATPMP_RESPTYPE_TCPPORTMAPPING) {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r);\n+        } else {\n+            auto pm = response.pnu.newportmapping;\n+            if (port == pm.privateport && port == pm.mappedpublicport && pm.lifetime > 0) {\n+                LogPrintf(\"NAT-PMP: port mapping successful.\\n\");\n+            } else {\n+                LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed.\\n\");\n+            }\n+        }\n+\n+    } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+    r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, /* remove a port mapping */ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r);\n+    }\n+\n+    closenatpmp(&natpmp);\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static void ThreadUpnp()\n+{\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+            } else {\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+}\n+#endif // #ifdef USE_UPNP\n+\n+void StartMapPort(MapPort proto)\n+{\n+    if (!g_mapport_thread.joinable()) {\n+        assert(!g_mapport_interrupt);\n+        switch (proto) {\n+        case MapPort::NAT_PMP: {\n+#ifdef USE_NATPMP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"natpmp\", &ThreadNatpmp)));\n+#endif // #ifdef USE_NATPMP\n+            return;\n+        }\n+        case MapPort::UPNP: {\n+#ifdef USE_UPNP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"upnp\", &ThreadUpnp)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r378227115",
      "id" : 378227115,
      "in_reply_to_id" : 378006285,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIyNzExNQ==",
      "original_commit_id" : "c7e90ca40ad9b7c66f3429b792435e9279ceca6b",
      "original_position" : 199,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 357421173,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/378227115",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r378235158"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/378235158"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> I wouldn't use them simultaneously, but one fails it makes sense to try the other.\r\n\r\nGood suggestion for a followup.\r\n\r\n> Though I believe our long plan is to remove UPnP, if NAT-PMP does the job.\r\n\r\nNot all routers with stock software have NAT-PMP port mapping feature.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-12T13:01:00Z",
      "diff_hunk" : "@@ -0,0 +1,236 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <arpa/inet.h>\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+\n+#ifdef USE_NATPMP\n+static void ThreadNatpmp()\n+{\n+    int r;\n+    natpmp_t natpmp;\n+    natpmpresp_t response;\n+\n+    r = initnatpmp(&natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r);\n+        closenatpmp(&natpmp);\n+        return;\n+    }\n+\n+    if (fDiscover) {\n+        r = sendpublicaddressrequest(&natpmp);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r);\n+        } else {\n+            do {\n+                r = readnatpmpresponseorretry(&natpmp, &response);\n+            } while (r == NATPMP_TRYAGAIN);\n+            if (r < 0 || response.type != NATPMP_RESPTYPE_PUBLICADDRESS) {\n+                LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r);\n+            } else {\n+                const char* public_address = inet_ntoa(response.pnu.publicaddress.addr);\n+                if (public_address[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(public_address, resolved, false)) {\n+                        LogPrintf(\"NAT-PMP: public address = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed.\\n\");\n+                }\n+            }\n+        }\n+    }\n+\n+    const uint16_t port = GetListenPort();\n+    do {\n+        r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, 3600 /*seconds*/);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r);\n+            break;\n+        }\n+\n+        do {\n+            r = readnatpmpresponseorretry(&natpmp, &response);\n+        } while (r == NATPMP_TRYAGAIN);\n+        if (r < 0 || response.type != NATPMP_RESPTYPE_TCPPORTMAPPING) {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r);\n+        } else {\n+            auto pm = response.pnu.newportmapping;\n+            if (port == pm.privateport && port == pm.mappedpublicport && pm.lifetime > 0) {\n+                LogPrintf(\"NAT-PMP: port mapping successful.\\n\");\n+            } else {\n+                LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed.\\n\");\n+            }\n+        }\n+\n+    } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+    r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, /* remove a port mapping */ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r);\n+    }\n+\n+    closenatpmp(&natpmp);\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static void ThreadUpnp()\n+{\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+            } else {\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+}\n+#endif // #ifdef USE_UPNP\n+\n+void StartMapPort(MapPort proto)\n+{\n+    if (!g_mapport_thread.joinable()) {\n+        assert(!g_mapport_interrupt);\n+        switch (proto) {\n+        case MapPort::NAT_PMP: {\n+#ifdef USE_NATPMP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"natpmp\", &ThreadNatpmp)));\n+#endif // #ifdef USE_NATPMP\n+            return;\n+        }\n+        case MapPort::UPNP: {\n+#ifdef USE_UPNP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"upnp\", &ThreadUpnp)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r378235158",
      "id" : 378235158,
      "in_reply_to_id" : 378006285,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzNTE1OA==",
      "original_commit_id" : "c7e90ca40ad9b7c66f3429b792435e9279ceca6b",
      "original_position" : 199,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 357431400,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/378235158",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r378236713"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/378236713"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Users who don't know what their router supports should be able to just flip both on. And laptops might very well migrate between different routers using each protocol.\r\n\r\nAgree with @hebasto that NAT-PMP can't be a complete substitute for UPnP since routers might not support both.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-12T13:04:21Z",
      "diff_hunk" : "@@ -0,0 +1,236 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <arpa/inet.h>\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+\n+#ifdef USE_NATPMP\n+static void ThreadNatpmp()\n+{\n+    int r;\n+    natpmp_t natpmp;\n+    natpmpresp_t response;\n+\n+    r = initnatpmp(&natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r);\n+        closenatpmp(&natpmp);\n+        return;\n+    }\n+\n+    if (fDiscover) {\n+        r = sendpublicaddressrequest(&natpmp);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r);\n+        } else {\n+            do {\n+                r = readnatpmpresponseorretry(&natpmp, &response);\n+            } while (r == NATPMP_TRYAGAIN);\n+            if (r < 0 || response.type != NATPMP_RESPTYPE_PUBLICADDRESS) {\n+                LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r);\n+            } else {\n+                const char* public_address = inet_ntoa(response.pnu.publicaddress.addr);\n+                if (public_address[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(public_address, resolved, false)) {\n+                        LogPrintf(\"NAT-PMP: public address = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed.\\n\");\n+                }\n+            }\n+        }\n+    }\n+\n+    const uint16_t port = GetListenPort();\n+    do {\n+        r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, 3600 /*seconds*/);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r);\n+            break;\n+        }\n+\n+        do {\n+            r = readnatpmpresponseorretry(&natpmp, &response);\n+        } while (r == NATPMP_TRYAGAIN);\n+        if (r < 0 || response.type != NATPMP_RESPTYPE_TCPPORTMAPPING) {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r);\n+        } else {\n+            auto pm = response.pnu.newportmapping;\n+            if (port == pm.privateport && port == pm.mappedpublicport && pm.lifetime > 0) {\n+                LogPrintf(\"NAT-PMP: port mapping successful.\\n\");\n+            } else {\n+                LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed.\\n\");\n+            }\n+        }\n+\n+    } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+    r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, /* remove a port mapping */ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r);\n+    }\n+\n+    closenatpmp(&natpmp);\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static void ThreadUpnp()\n+{\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+            } else {\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+}\n+#endif // #ifdef USE_UPNP\n+\n+void StartMapPort(MapPort proto)\n+{\n+    if (!g_mapport_thread.joinable()) {\n+        assert(!g_mapport_interrupt);\n+        switch (proto) {\n+        case MapPort::NAT_PMP: {\n+#ifdef USE_NATPMP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"natpmp\", &ThreadNatpmp)));\n+#endif // #ifdef USE_NATPMP\n+            return;\n+        }\n+        case MapPort::UPNP: {\n+#ifdef USE_UPNP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"upnp\", &ThreadUpnp)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r378236713",
      "id" : 378236713,
      "in_reply_to_id" : 378006285,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODIzNjcxMw==",
      "original_commit_id" : "c7e90ca40ad9b7c66f3429b792435e9279ceca6b",
      "original_position" : 199,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 357433454,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/378236713",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Updated c7e90ca40ad9b7c66f3429b792435e9279ceca6b -> dc228d6db8d2e9406d6d6e0eb04e37940b1ffb82 ([pr18077.06](https://github.com/hebasto/bitcoin/commits/pr18077.06) -> [pr18077.07](https://github.com/hebasto/bitcoin/commits/pr18077.07), [compare](https://github.com/hebasto/bitcoin/compare/pr18077.06..pr18077.07)):\r\n\r\nChanges:\r\n- added a user-friendly error message for the `NATPMP_ERR_NOGATEWAYSUPPORT` error\r\n- enable both NAT-PMP and UPnP if `-natpmp` and `-upnp` options are supplied\r\n\r\n---\r\n\r\n@Sjors \r\n> Perhaps `-7` could be replaced by something more readable.\r\n\r\nDone.\r\n\r\n> If both are enabled, would you try to open de port with NAT_PMP first and if that fails UPNP?\r\n> I wouldn't use them simultaneously, but one fails it makes sense to try the other.\r\n\r\nDone.",
      "created_at" : "2020-02-16T15:59:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-586722575",
      "id" : 586722575,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NjcyMjU3NQ==",
      "updated_at" : "2020-02-16T16:09:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/586722575",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r379913637"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/379913637"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Addressed in the latest push.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-16T16:00:20Z",
      "diff_hunk" : "@@ -0,0 +1,236 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <arpa/inet.h>\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+\n+#ifdef USE_NATPMP\n+static void ThreadNatpmp()\n+{\n+    int r;\n+    natpmp_t natpmp;\n+    natpmpresp_t response;\n+\n+    r = initnatpmp(&natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r);\n+        closenatpmp(&natpmp);\n+        return;\n+    }\n+\n+    if (fDiscover) {\n+        r = sendpublicaddressrequest(&natpmp);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r);\n+        } else {\n+            do {\n+                r = readnatpmpresponseorretry(&natpmp, &response);\n+            } while (r == NATPMP_TRYAGAIN);\n+            if (r < 0 || response.type != NATPMP_RESPTYPE_PUBLICADDRESS) {\n+                LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r);\n+            } else {\n+                const char* public_address = inet_ntoa(response.pnu.publicaddress.addr);\n+                if (public_address[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(public_address, resolved, false)) {\n+                        LogPrintf(\"NAT-PMP: public address = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed.\\n\");\n+                }\n+            }\n+        }\n+    }\n+\n+    const uint16_t port = GetListenPort();\n+    do {\n+        r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, 3600 /*seconds*/);\n+        if (r < 0) {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r);\n+            break;\n+        }\n+\n+        do {\n+            r = readnatpmpresponseorretry(&natpmp, &response);\n+        } while (r == NATPMP_TRYAGAIN);\n+        if (r < 0 || response.type != NATPMP_RESPTYPE_TCPPORTMAPPING) {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r);\n+        } else {\n+            auto pm = response.pnu.newportmapping;\n+            if (port == pm.privateport && port == pm.mappedpublicport && pm.lifetime > 0) {\n+                LogPrintf(\"NAT-PMP: port mapping successful.\\n\");\n+            } else {\n+                LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed.\\n\");\n+            }\n+        }\n+\n+    } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+    r = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, port, port, /* remove a port mapping */ 0);\n+    if (r < 0) {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r);\n+    }\n+\n+    closenatpmp(&natpmp);\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static void ThreadUpnp()\n+{\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+            } else {\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(std::chrono::minutes(20)));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+}\n+#endif // #ifdef USE_UPNP\n+\n+void StartMapPort(MapPort proto)\n+{\n+    if (!g_mapport_thread.joinable()) {\n+        assert(!g_mapport_interrupt);\n+        switch (proto) {\n+        case MapPort::NAT_PMP: {\n+#ifdef USE_NATPMP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"natpmp\", &ThreadNatpmp)));\n+#endif // #ifdef USE_NATPMP\n+            return;\n+        }\n+        case MapPort::UPNP: {\n+#ifdef USE_UPNP\n+            g_mapport_thread = std::thread((std::bind(&TraceThread<void (*)()>, \"upnp\", &ThreadUpnp)));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r379913637",
      "id" : 379913637,
      "in_reply_to_id" : 378006285,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkxMzYzNw==",
      "original_commit_id" : "c7e90ca40ad9b7c66f3429b792435e9279ceca6b",
      "original_position" : 199,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 359412797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/379913637",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r379960033"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/379960033"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Prefer to leave this alone (and use `%s` in the new options)",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-17T02:09:25Z",
      "diff_hunk" : "@@ -438,15 +439,24 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-torcontrol=<ip>:<port>\", strprintf(\"Tor control port to use if onion listening enabled (default: %s)\", DEFAULT_TOR_CONTROL), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-torpassword=<pass>\", \"Tor control port password (default: empty)\", ArgsManager::ALLOW_ANY | ArgsManager::SENSITIVE, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-asmap=<file>\", \"Specify asn mapping used for bucketing of the peers. Path should be relative to the -datadir path.\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#ifdef USE_NATPMP\n+#if USE_NATPMP\n+    gArgs.AddArg(\"-natpmp\", \"Use NAT-PMP to map the listening port (default: 1 when listening and no -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#else\n+    gArgs.AddArg(\"-natpmp\", \"Use NAT-PMP to map the listening port (default: 0)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#endif\n+#else\n+    hidden_args.emplace_back(\"-natpmp\");\n+#endif // #ifdef USE_NATPMP\n #ifdef USE_UPNP\n #if USE_UPNP\n     gArgs.AddArg(\"-upnp\", \"Use UPnP to map the listening port (default: 1 when listening and no -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n #else\n-    gArgs.AddArg(\"-upnp\", strprintf(\"Use UPnP to map the listening port (default: %u)\", 0), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-upnp\", \"Use UPnP to map the listening port (default: 0)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r379960033",
      "id" : 379960033,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2MDAzMw==",
      "original_commit_id" : "dc228d6db8d2e9406d6d6e0eb04e37940b1ffb82",
      "original_position" : 49,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 359457316,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/379960033",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "The logic here still seems broken. Again, consider that users may migrate between different routers each with NAT-PMP or UPnP support. So there should be a common thread main that *at each refresh* (which ideally should trigger when network availability changes, but that can be another PR) checks for which protocol to use and does the right thing.",
      "created_at" : "2020-02-17T02:13:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-586789305",
      "id" : 586789305,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4Njc4OTMwNQ==",
      "updated_at" : "2020-02-17T02:13:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/586789305",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380002423"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380002423"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree. It will be fixed.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-17T06:25:09Z",
      "diff_hunk" : "@@ -438,15 +439,24 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-torcontrol=<ip>:<port>\", strprintf(\"Tor control port to use if onion listening enabled (default: %s)\", DEFAULT_TOR_CONTROL), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-torpassword=<pass>\", \"Tor control port password (default: empty)\", ArgsManager::ALLOW_ANY | ArgsManager::SENSITIVE, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-asmap=<file>\", \"Specify asn mapping used for bucketing of the peers. Path should be relative to the -datadir path.\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#ifdef USE_NATPMP\n+#if USE_NATPMP\n+    gArgs.AddArg(\"-natpmp\", \"Use NAT-PMP to map the listening port (default: 1 when listening and no -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#else\n+    gArgs.AddArg(\"-natpmp\", \"Use NAT-PMP to map the listening port (default: 0)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#endif\n+#else\n+    hidden_args.emplace_back(\"-natpmp\");\n+#endif // #ifdef USE_NATPMP\n #ifdef USE_UPNP\n #if USE_UPNP\n     gArgs.AddArg(\"-upnp\", \"Use UPnP to map the listening port (default: 1 when listening and no -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n #else\n-    gArgs.AddArg(\"-upnp\", strprintf(\"Use UPnP to map the listening port (default: %u)\", 0), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-upnp\", \"Use UPnP to map the listening port (default: 0)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380002423",
      "id" : 380002423,
      "in_reply_to_id" : 379960033,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDAwMjQyMw==",
      "original_commit_id" : "dc228d6db8d2e9406d6d6e0eb04e37940b1ffb82",
      "original_position" : 49,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 359509336,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380002423",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@luke-jr \r\n> The logic here still seems broken. Again, consider that users may migrate between different routers each with NAT-PMP or UPnP support. So there should be a common thread main that _at each refresh_ (which ideally should trigger when network availability changes, but that can be another PR) checks for which protocol to use and does the right thing.\r\n\r\n`ThreadAnyAvailable()` does almost the same:\r\nif a used protocol becomes unavailable, `ThreadAnyAvailable()` switches to another one, no?",
      "created_at" : "2020-02-17T06:28:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-586837309",
      "id" : 586837309,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NjgzNzMwOQ==",
      "updated_at" : "2020-02-17T06:28:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/586837309",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Yes, re-reading it, you're right, it does. I saw the loops in the per-protocol functions and missed the outer one.",
      "created_at" : "2020-02-17T14:23:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-587017420",
      "id" : 587017420,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NzAxNzQyMA==",
      "updated_at" : "2020-02-17T14:23:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/587017420",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Updated dc228d6db8d2e9406d6d6e0eb04e37940b1ffb82 -> 2d5d98ce0aa07401c6771731f4e27634629f197c ([pr18077.07](https://github.com/hebasto/bitcoin/commits/pr18077.07) -> [pr18077.08](https://github.com/hebasto/bitcoin/commits/pr18077.08), [compare](https://github.com/hebasto/bitcoin/compare/pr18077.07..pr18077.08)):\r\n\r\nChanges:\r\n- addressed @luke-jr's [comment](https://github.com/bitcoin/bitcoin/pull/18077#discussion_r379960033)",
      "created_at" : "2020-02-17T16:55:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-587082936",
      "id" : 587082936,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NzA4MjkzNg==",
      "updated_at" : "2020-02-17T16:55:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/587082936",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380289414"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380289414"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-17T16:56:03Z",
      "diff_hunk" : "@@ -438,15 +439,24 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-torcontrol=<ip>:<port>\", strprintf(\"Tor control port to use if onion listening enabled (default: %s)\", DEFAULT_TOR_CONTROL), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-torpassword=<pass>\", \"Tor control port password (default: empty)\", ArgsManager::ALLOW_ANY | ArgsManager::SENSITIVE, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-asmap=<file>\", \"Specify asn mapping used for bucketing of the peers. Path should be relative to the -datadir path.\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#ifdef USE_NATPMP\n+#if USE_NATPMP\n+    gArgs.AddArg(\"-natpmp\", \"Use NAT-PMP to map the listening port (default: 1 when listening and no -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#else\n+    gArgs.AddArg(\"-natpmp\", \"Use NAT-PMP to map the listening port (default: 0)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#endif\n+#else\n+    hidden_args.emplace_back(\"-natpmp\");\n+#endif // #ifdef USE_NATPMP\n #ifdef USE_UPNP\n #if USE_UPNP\n     gArgs.AddArg(\"-upnp\", \"Use UPnP to map the listening port (default: 1 when listening and no -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n #else\n-    gArgs.AddArg(\"-upnp\", strprintf(\"Use UPnP to map the listening port (default: %u)\", 0), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-upnp\", \"Use UPnP to map the listening port (default: 0)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380289414",
      "id" : 380289414,
      "in_reply_to_id" : 379960033,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI4OTQxNA==",
      "original_commit_id" : "dc228d6db8d2e9406d6d6e0eb04e37940b1ffb82",
      "original_position" : 49,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 359871878,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380289414",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380352723"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380352723"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Suggest just making this `StartMapPort(bool use_upnp, bool use_natpmp)`",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-17T20:16:34Z",
      "diff_hunk" : "@@ -1764,9 +1778,17 @@ bool AppInitMain(NodeContext& node)\n \n     Discover();\n \n-    // Map ports with UPnP\n-    if (gArgs.GetBoolArg(\"-upnp\", DEFAULT_UPNP)) {\n-        StartMapPort();\n+    // Map ports with NAT-PMP (preferable) or UPnP.\n+    {\n+        const bool natpmp = gArgs.GetBoolArg(\"-natpmp\", DEFAULT_NATPMP);\n+        const bool upnp = gArgs.GetBoolArg(\"-upnp\", DEFAULT_UPNP);\n+        if (natpmp && upnp) {\n+            StartMapPort(MapPort::ANY_AVAILABLE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380352723",
      "id" : 380352723,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1MjcyMw==",
      "original_commit_id" : "2d5d98ce0aa07401c6771731f4e27634629f197c",
      "original_position" : 89,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 359949105,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380352723",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380352965"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380352965"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This logic won't work if the thread is already running...",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-17T20:17:38Z",
      "diff_hunk" : "@@ -350,9 +362,13 @@ bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in\n             fMinimizeToTray = value.toBool();\n             settings.setValue(\"fMinimizeToTray\", fMinimizeToTray);\n             break;\n+        case MapPortNatpmp: // core option - can be changed on-the-fly\n+            settings.setValue(\"fUseNatpmp\", value.toBool());\n+            m_node.mapPort(value.toBool(), MapPort::NAT_PMP);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380352965",
      "id" : 380352965,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1Mjk2NQ==",
      "original_commit_id" : "2d5d98ce0aa07401c6771731f4e27634629f197c",
      "original_position" : 45,
      "path" : "src/qt/optionsmodel.cpp",
      "position" : null,
      "pull_request_review_id" : 359949105,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380352965",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380362646"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380362646"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`%s` > `%u`",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-17T20:54:31Z",
      "diff_hunk" : "@@ -438,6 +439,15 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-torcontrol=<ip>:<port>\", strprintf(\"Tor control port to use if onion listening enabled (default: %s)\", DEFAULT_TOR_CONTROL), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-torpassword=<pass>\", \"Tor control port password (default: empty)\", ArgsManager::ALLOW_ANY | ArgsManager::SENSITIVE, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-asmap=<file>\", \"Specify asn mapping used for bucketing of the peers. Path should be relative to the -datadir path.\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#ifdef USE_NATPMP\n+#if USE_NATPMP\n+    gArgs.AddArg(\"-natpmp\", \"Use NAT-PMP to map the listening port (default: 1 when listening and no -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#else\n+    gArgs.AddArg(\"-natpmp\", strprintf(\"Use NAT-PMP to map the listening port (default: %u)\", 0), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380362646",
      "id" : 380362646,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM2MjY0Ng==",
      "original_commit_id" : "2d5d98ce0aa07401c6771731f4e27634629f197c",
      "original_position" : 39,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 359961465,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380362646",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380371070"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380371070"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Or better yet: Just check gArgs inside StartMapPort...",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-17T21:26:59Z",
      "diff_hunk" : "@@ -1764,9 +1778,17 @@ bool AppInitMain(NodeContext& node)\n \n     Discover();\n \n-    // Map ports with UPnP\n-    if (gArgs.GetBoolArg(\"-upnp\", DEFAULT_UPNP)) {\n-        StartMapPort();\n+    // Map ports with NAT-PMP (preferable) or UPnP.\n+    {\n+        const bool natpmp = gArgs.GetBoolArg(\"-natpmp\", DEFAULT_NATPMP);\n+        const bool upnp = gArgs.GetBoolArg(\"-upnp\", DEFAULT_UPNP);\n+        if (natpmp && upnp) {\n+            StartMapPort(MapPort::ANY_AVAILABLE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380371070",
      "id" : 380371070,
      "in_reply_to_id" : 380352723,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM3MTA3MA==",
      "original_commit_id" : "2d5d98ce0aa07401c6771731f4e27634629f197c",
      "original_position" : 89,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 359971764,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380371070",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380525759"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380525759"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Going to fix it.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-18T08:42:29Z",
      "diff_hunk" : "@@ -350,9 +362,13 @@ bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in\n             fMinimizeToTray = value.toBool();\n             settings.setValue(\"fMinimizeToTray\", fMinimizeToTray);\n             break;\n+        case MapPortNatpmp: // core option - can be changed on-the-fly\n+            settings.setValue(\"fUseNatpmp\", value.toBool());\n+            m_node.mapPort(value.toBool(), MapPort::NAT_PMP);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380525759",
      "id" : 380525759,
      "in_reply_to_id" : 380352965,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUyNTc1OQ==",
      "original_commit_id" : "2d5d98ce0aa07401c6771731f4e27634629f197c",
      "original_position" : 45,
      "path" : "src/qt/optionsmodel.cpp",
      "position" : null,
      "pull_request_review_id" : 360151983,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380525759",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380527819"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380527819"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> `%s` > `%u`\r\n\r\nWhat is the rationale? We already use the `%u` specifier for unsigned integers in `tfm::format()`.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-18T08:46:44Z",
      "diff_hunk" : "@@ -438,6 +439,15 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-torcontrol=<ip>:<port>\", strprintf(\"Tor control port to use if onion listening enabled (default: %s)\", DEFAULT_TOR_CONTROL), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-torpassword=<pass>\", \"Tor control port password (default: empty)\", ArgsManager::ALLOW_ANY | ArgsManager::SENSITIVE, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-asmap=<file>\", \"Specify asn mapping used for bucketing of the peers. Path should be relative to the -datadir path.\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#ifdef USE_NATPMP\n+#if USE_NATPMP\n+    gArgs.AddArg(\"-natpmp\", \"Use NAT-PMP to map the listening port (default: 1 when listening and no -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#else\n+    gArgs.AddArg(\"-natpmp\", strprintf(\"Use NAT-PMP to map the listening port (default: %u)\", 0), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380527819",
      "id" : 380527819,
      "in_reply_to_id" : 380362646,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUyNzgxOQ==",
      "original_commit_id" : "2d5d98ce0aa07401c6771731f4e27634629f197c",
      "original_position" : 39,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 360154539,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380527819",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Updated 2d5d98ce0aa07401c6771731f4e27634629f197c -> ccb4a7ea18c38914f084b7c070303d020adad326 ([pr18077.08](https://github.com/hebasto/bitcoin/commits/pr18077.08) -> [pr18077.09](https://github.com/hebasto/bitcoin/commits/pr18077.09), [compare](https://github.com/hebasto/bitcoin/compare/pr18077.08..pr18077.09)):\r\n\r\n- fixed a [bug](https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380352965) pointed by @luke-jr ",
      "created_at" : "2020-02-18T22:01:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-587924741",
      "id" : 587924741,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NzkyNDc0MQ==",
      "updated_at" : "2020-02-18T22:01:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/587924741",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380961736"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380961736"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed in the latest push.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-18T22:01:34Z",
      "diff_hunk" : "@@ -350,9 +362,13 @@ bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in\n             fMinimizeToTray = value.toBool();\n             settings.setValue(\"fMinimizeToTray\", fMinimizeToTray);\n             break;\n+        case MapPortNatpmp: // core option - can be changed on-the-fly\n+            settings.setValue(\"fUseNatpmp\", value.toBool());\n+            m_node.mapPort(value.toBool(), MapPort::NAT_PMP);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380961736",
      "id" : 380961736,
      "in_reply_to_id" : 380352965,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MTczNg==",
      "original_commit_id" : "2d5d98ce0aa07401c6771731f4e27634629f197c",
      "original_position" : 45,
      "path" : "src/qt/optionsmodel.cpp",
      "position" : null,
      "pull_request_review_id" : 360705700,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380961736",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380961933"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380961933"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Reworked in the latest push.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-18T22:01:57Z",
      "diff_hunk" : "@@ -1764,9 +1778,17 @@ bool AppInitMain(NodeContext& node)\n \n     Discover();\n \n-    // Map ports with UPnP\n-    if (gArgs.GetBoolArg(\"-upnp\", DEFAULT_UPNP)) {\n-        StartMapPort();\n+    // Map ports with NAT-PMP (preferable) or UPnP.\n+    {\n+        const bool natpmp = gArgs.GetBoolArg(\"-natpmp\", DEFAULT_NATPMP);\n+        const bool upnp = gArgs.GetBoolArg(\"-upnp\", DEFAULT_UPNP);\n+        if (natpmp && upnp) {\n+            StartMapPort(MapPort::ANY_AVAILABLE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r380961933",
      "id" : 380961933,
      "in_reply_to_id" : 380352723,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDk2MTkzMw==",
      "original_commit_id" : "2d5d98ce0aa07401c6771731f4e27634629f197c",
      "original_position" : 89,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 360705933,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/380961933",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Hi all, did some testing on ccb4a7ea18c38914f084b7c070303d020adad326. What I did:\r\n\r\n1. Installed natpmpd on my OpenBSD gateway router\r\n2. Started `natpmpd`, added relevant `pf.conf` line, reloaded `pf`\r\n3. Configure and compile `bitcoind` with `--without-miniupnpc --disable-bench --disable-wallet --without-gui --with-natpmp`\r\n4. Start `bitcoind` with `-natpmp`\r\n5. Saw the following lines:\r\n```\r\n2020-02-18T22:26:26Z NAT-PMP: Public address = 108.21.84.253\r\n2020-02-18T22:26:26Z AddLocal(108.21.84.253:8333,3)\r\n2020-02-18T22:26:26Z NAT-PMP: Port mapping failed.\r\n2020-02-18T22:26:26Z NAT-PMP: Port mapping removed successfully.\r\n```\r\n6. Checked my `natpmpd` anchored `pfctl` rules:\r\n```\r\n$ doas pfctl -a natpmpd -s rules\r\npass in quick on rdomain 0 inet proto tcp from any to <my-egress-ip> port = 62774 flags any rdr-to 192.168.0.5 port 8333\r\n```\r\n\r\nI believe this means that natpmpd successfully allocated a port 62774 to `bitcoind`, but since that port does not equal our private port, this check failed: https://github.com/bitcoin/bitcoin/pull/18077/files#diff-161ad6a962291e0bbafeb83ddc8a977cR109. I believe this is because `natpmpd` ignores our \"Suggested External Port\", which is perfectly valid, and we should probably account for that possibility. ",
      "created_at" : "2020-02-18T23:11:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-587950934",
      "id" : 587950934,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4Nzk1MDkzNA==",
      "updated_at" : "2020-02-19T01:55:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/587950934",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3445290?v=4",
         "events_url" : "https://api.github.com/users/dongcarl/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dongcarl/followers",
         "following_url" : "https://api.github.com/users/dongcarl/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dongcarl/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dongcarl",
         "id" : 3445290,
         "login" : "dongcarl",
         "node_id" : "MDQ6VXNlcjM0NDUyOTA=",
         "organizations_url" : "https://api.github.com/users/dongcarl/orgs",
         "received_events_url" : "https://api.github.com/users/dongcarl/received_events",
         "repos_url" : "https://api.github.com/users/dongcarl/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dongcarl/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dongcarl/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dongcarl"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381008856"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/381008856"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`%s` doesn't care what type the value is.\r\n\r\nYou can use the same format string above, with a value of `\"1 when listening and no -proxy\"`",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-19T00:08:21Z",
      "diff_hunk" : "@@ -438,6 +439,15 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-torcontrol=<ip>:<port>\", strprintf(\"Tor control port to use if onion listening enabled (default: %s)\", DEFAULT_TOR_CONTROL), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-torpassword=<pass>\", \"Tor control port password (default: empty)\", ArgsManager::ALLOW_ANY | ArgsManager::SENSITIVE, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-asmap=<file>\", \"Specify asn mapping used for bucketing of the peers. Path should be relative to the -datadir path.\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#ifdef USE_NATPMP\n+#if USE_NATPMP\n+    gArgs.AddArg(\"-natpmp\", \"Use NAT-PMP to map the listening port (default: 1 when listening and no -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#else\n+    gArgs.AddArg(\"-natpmp\", strprintf(\"Use NAT-PMP to map the listening port (default: %u)\", 0), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381008856",
      "id" : 381008856,
      "in_reply_to_id" : 380362646,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAwODg1Ng==",
      "original_commit_id" : "2d5d98ce0aa07401c6771731f4e27634629f197c",
      "original_position" : 39,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 360762594,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/381008856",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "If NAT-PMP allows ignoring the suggested port, then we probably should handle that by advertising the correct port for the external IP in addrman.",
      "created_at" : "2020-02-19T00:19:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-587970728",
      "id" : 587970728,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4Nzk3MDcyOA==",
      "updated_at" : "2020-02-19T00:19:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/587970728",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@dongcarl \r\nThank you for testing this PR with [`natpmpd`](https://github.com/bodgit/natpmpd) on OpenBSD (I've tested with [`miniupnpd`](https://github.com/miniupnp/miniupnp/tree/master/miniupnpd) on OpenWrt).\r\n\r\n> I believe this is because `natpmpd` ignores our \"Suggested External Port\", which is perfectly valid, and we should probably account for that possibility.\r\n\r\nCorrect. From `natpmpd` [docs](http://bodgitandscarper.co.uk/natpmpd/):\r\n> The external TCP or UDP port assigned to the client is _always_ randomised rather than giving the first client the port it actually requested and then trying to work out what to do for additional clients that want the same external port.\r\n\r\n(highlighted in italics by me).\r\n\r\nOTOH, [RFC 6886](https://tools.ietf.org/html/rfc6886) states:\r\n> If the client would prefer to have a high-numbered \"anonymous\" external port assigned, then it should set the Suggested External Port to zero, which indicates to the gateway that it should allocate a high-numbered port of its choosing.  If the client would prefer instead to have the mapped external port be the same as its local internal port if possible (e.g., a web server listening on port 80 that would ideally like to have external port 80), then it should set the Suggested External Port to the desired value.  However, the gateway is _not_ obliged to assign the port suggested, and may choose not to, either for policy reasons (e.g., port 80 is reserved and clients may not request it) or because that port has already been assigned to some other client.\r\n\r\n(highlighted in italics by me).\r\n\r\n@luke-jr \r\n> If NAT-PMP allows ignoring the suggested port, then we probably should handle that by advertising the correct port for the external IP in addrman.\r\n\r\nSure, we should.",
      "created_at" : "2020-02-19T09:29:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-588121365",
      "id" : 588121365,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4ODEyMTM2NQ==",
      "updated_at" : "2020-02-19T09:29:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/588121365",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Updated ccb4a7ea18c38914f084b7c070303d020adad326 -> 03e2733be1772ef69caf34e84c7b400f64a8ea9f ([pr18077.09](https://github.com/hebasto/bitcoin/commits/pr18077.09) -> [pr18077.10](https://github.com/hebasto/bitcoin/commits/pr18077.10), [compare](https://github.com/hebasto/bitcoin/compare/pr18077.09..pr18077.10)):\r\n\r\n- aligned with RFC 6886\r\n\r\n@dongcarl @luke-jr \r\nThank you for your reviews. All your comments have been addressed.",
      "created_at" : "2020-02-19T20:05:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-588422681",
      "id" : 588422681,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4ODQyMjY4MQ==",
      "updated_at" : "2020-02-19T20:05:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/588422681",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381514731"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/381514731"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done in the latest push.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-19T20:05:53Z",
      "diff_hunk" : "@@ -438,6 +439,15 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-torcontrol=<ip>:<port>\", strprintf(\"Tor control port to use if onion listening enabled (default: %s)\", DEFAULT_TOR_CONTROL), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-torpassword=<pass>\", \"Tor control port password (default: empty)\", ArgsManager::ALLOW_ANY | ArgsManager::SENSITIVE, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-asmap=<file>\", \"Specify asn mapping used for bucketing of the peers. Path should be relative to the -datadir path.\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#ifdef USE_NATPMP\n+#if USE_NATPMP\n+    gArgs.AddArg(\"-natpmp\", \"Use NAT-PMP to map the listening port (default: 1 when listening and no -proxy)\", ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n+#else\n+    gArgs.AddArg(\"-natpmp\", strprintf(\"Use NAT-PMP to map the listening port (default: %u)\", 0), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381514731",
      "id" : 381514731,
      "in_reply_to_id" : 380362646,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTUxNDczMQ==",
      "original_commit_id" : "2d5d98ce0aa07401c6771731f4e27634629f197c",
      "original_position" : 39,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 361399235,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/381514731",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381553831"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/381553831"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This logic breaks the \"command line overrides GUI options\" stuff above (see `addOverriddenOption`)...\r\n\r\nNot really sure what the best solution here is.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-19T21:26:25Z",
      "diff_hunk" : "@@ -344,15 +356,19 @@ bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in\n         case HideTrayIcon:\n             fHideTrayIcon = value.toBool();\n             settings.setValue(\"fHideTrayIcon\", fHideTrayIcon);\n-    \t\tQ_EMIT hideTrayIconChanged(fHideTrayIcon);\n+            Q_EMIT hideTrayIconChanged(fHideTrayIcon);\n             break;\n         case MinimizeToTray:\n             fMinimizeToTray = value.toBool();\n             settings.setValue(\"fMinimizeToTray\", fMinimizeToTray);\n             break;\n+        case MapPortNatpmp: // core option - can be changed on-the-fly\n+            settings.setValue(\"fUseNatpmp\", value.toBool());\n+            m_node.mapPort(value.toBool(), settings.value(\"fUseUPnP\").toBool());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381553831",
      "id" : 381553831,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MzgzMQ==",
      "original_commit_id" : "03e2733be1772ef69caf34e84c7b400f64a8ea9f",
      "original_position" : 52,
      "path" : "src/qt/optionsmodel.cpp",
      "position" : null,
      "pull_request_review_id" : 361448941,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/381553831",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381557545"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/381557545"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This won't work if we used to have both protocols enabled, are currently using UPnP, but want to disable UPnP.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-19T21:33:54Z",
      "diff_hunk" : "@@ -0,0 +1,320 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+static MapPortProto g_mapport_current_proto = MapPortProto::NONE;\n+static unsigned int g_mapport_target_proto = g_mapport_current_proto;\n+static uint16_t g_mapport_external_port = 0;\n+static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD = std::chrono::minutes(20);\n+static constexpr auto PORT_MAPPING_RETRY_PERIOD = std::chrono::minutes(5);\n+\n+#ifdef USE_NATPMP\n+static bool NatpmpInit(natpmp_t* natpmp)\n+{\n+    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r_init == 0) return true;\n+    LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r_init);\n+    return false;\n+}\n+\n+static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n+{\n+    const int r_send = sendpublicaddressrequest(natpmp);\n+    if (r_send == 2 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            external_ipv4_addr = response.pnu.publicaddress.addr;\n+            return true;\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n+{\n+    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n+    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n+    if (r_send == 12 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            auto pm = response.pnu.newportmapping;\n+            if (private_port == pm.privateport && pm.lifetime > 0) {\n+                g_mapport_current_proto = MapPortProto::NAT_PMP;\n+                g_mapport_external_port = pm.mappedpublicport;\n+                const CService external{external_ipv4_addr, pm.mappedpublicport};\n+                if (!external_ip_discovered && fDiscover) {\n+                    AddLocal(external, LOCAL_MAPPED);\n+                    external_ip_discovered = true;\n+                }\n+\n+                LogPrintf(\"NAT-PMP: Port mapping successful. External address = %s\\n\", external.ToString());\n+                return true;\n+            } else {\n+                LogPrintf(\"NAT-PMP: Port mapping failed.\\n\");\n+            }\n+\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool ThreadNatpmp()\n+{\n+    bool ret = false;\n+    natpmp_t natpmp;\n+    struct in_addr external_ipv4_addr;\n+    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n+        bool external_ip_discovered = false;\n+        const uint16_t private_port = GetListenPort();\n+        do {\n+            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n+        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n+        g_mapport_external_port = 0;\n+        if (r_send == 12 /* OK */) {\n+            LogPrintf(\"NAT-PMP: Port mapping removed successfully.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        }\n+    }\n+\n+    closenatpmp(&natpmp);\n+    return ret;\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static bool ThreadUpnp()\n+{\n+    bool ret = false;\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                ret = false;\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+                break;\n+            } else {\n+                ret = true;\n+                g_mapport_current_proto = MapPortProto::UPNP;\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+\n+    return ret;\n+}\n+#endif // #ifdef USE_UPNP\n+\n+static void ThreadMapPort()\n+{\n+    bool ok;\n+    do {\n+        ok = false;\n+\n+#ifdef USE_NATPMP\n+        if (g_mapport_target_proto & MapPortProto::NAT_PMP) {\n+            ok = ThreadNatpmp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+        if (g_mapport_target_proto & MapPortProto::UPNP) {\n+            ok = ThreadUpnp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_UPNP\n+\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            g_mapport_current_proto = MapPortProto::NONE;\n+            return;\n+        }\n+\n+    } while (ok || g_mapport_interrupt.sleep_for(PORT_MAPPING_RETRY_PERIOD));\n+}\n+\n+void StartMapPort(bool use_natpmp, bool use_upnp)\n+{\n+    if (use_natpmp) {\n+        g_mapport_target_proto |= MapPortProto::NAT_PMP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::NAT_PMP;\n+    }\n+\n+    if (use_upnp) {\n+        g_mapport_target_proto |= MapPortProto::UPNP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::UPNP;\n+    }\n+\n+    if (g_mapport_current_proto == MapPortProto::NONE) {\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            return;\n+        }\n+    } else if (g_mapport_target_proto & g_mapport_current_proto) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381557545",
      "id" : 381557545,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1NzU0NQ==",
      "original_commit_id" : "03e2733be1772ef69caf34e84c7b400f64a8ea9f",
      "original_position" : 273,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 361453595,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/381557545",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381558152"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/381558152"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Won't this cause the thread to shut down?",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-19T21:35:05Z",
      "diff_hunk" : "@@ -0,0 +1,320 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+static MapPortProto g_mapport_current_proto = MapPortProto::NONE;\n+static unsigned int g_mapport_target_proto = g_mapport_current_proto;\n+static uint16_t g_mapport_external_port = 0;\n+static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD = std::chrono::minutes(20);\n+static constexpr auto PORT_MAPPING_RETRY_PERIOD = std::chrono::minutes(5);\n+\n+#ifdef USE_NATPMP\n+static bool NatpmpInit(natpmp_t* natpmp)\n+{\n+    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r_init == 0) return true;\n+    LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r_init);\n+    return false;\n+}\n+\n+static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n+{\n+    const int r_send = sendpublicaddressrequest(natpmp);\n+    if (r_send == 2 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            external_ipv4_addr = response.pnu.publicaddress.addr;\n+            return true;\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n+{\n+    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n+    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n+    if (r_send == 12 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            auto pm = response.pnu.newportmapping;\n+            if (private_port == pm.privateport && pm.lifetime > 0) {\n+                g_mapport_current_proto = MapPortProto::NAT_PMP;\n+                g_mapport_external_port = pm.mappedpublicport;\n+                const CService external{external_ipv4_addr, pm.mappedpublicport};\n+                if (!external_ip_discovered && fDiscover) {\n+                    AddLocal(external, LOCAL_MAPPED);\n+                    external_ip_discovered = true;\n+                }\n+\n+                LogPrintf(\"NAT-PMP: Port mapping successful. External address = %s\\n\", external.ToString());\n+                return true;\n+            } else {\n+                LogPrintf(\"NAT-PMP: Port mapping failed.\\n\");\n+            }\n+\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool ThreadNatpmp()\n+{\n+    bool ret = false;\n+    natpmp_t natpmp;\n+    struct in_addr external_ipv4_addr;\n+    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n+        bool external_ip_discovered = false;\n+        const uint16_t private_port = GetListenPort();\n+        do {\n+            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n+        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n+        g_mapport_external_port = 0;\n+        if (r_send == 12 /* OK */) {\n+            LogPrintf(\"NAT-PMP: Port mapping removed successfully.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        }\n+    }\n+\n+    closenatpmp(&natpmp);\n+    return ret;\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static bool ThreadUpnp()\n+{\n+    bool ret = false;\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                ret = false;\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+                break;\n+            } else {\n+                ret = true;\n+                g_mapport_current_proto = MapPortProto::UPNP;\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+\n+    return ret;\n+}\n+#endif // #ifdef USE_UPNP\n+\n+static void ThreadMapPort()\n+{\n+    bool ok;\n+    do {\n+        ok = false;\n+\n+#ifdef USE_NATPMP\n+        if (g_mapport_target_proto & MapPortProto::NAT_PMP) {\n+            ok = ThreadNatpmp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+        if (g_mapport_target_proto & MapPortProto::UPNP) {\n+            ok = ThreadUpnp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_UPNP\n+\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            g_mapport_current_proto = MapPortProto::NONE;\n+            return;\n+        }\n+\n+    } while (ok || g_mapport_interrupt.sleep_for(PORT_MAPPING_RETRY_PERIOD));\n+}\n+\n+void StartMapPort(bool use_natpmp, bool use_upnp)\n+{\n+    if (use_natpmp) {\n+        g_mapport_target_proto |= MapPortProto::NAT_PMP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::NAT_PMP;\n+    }\n+\n+    if (use_upnp) {\n+        g_mapport_target_proto |= MapPortProto::UPNP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::UPNP;\n+    }\n+\n+    if (g_mapport_current_proto == MapPortProto::NONE) {\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            return;\n+        }\n+    } else if (g_mapport_target_proto & g_mapport_current_proto) {\n+        return;\n+    }\n+\n+    if (g_mapport_target_proto == MapPortProto::NONE) {\n+        InterruptMapPort();\n+        StopMapPort();\n+        return;\n+    }\n+\n+    if (g_mapport_thread.joinable()) {\n+        g_mapport_interrupt();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381558152",
      "id" : 381558152,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1ODE1Mg==",
      "original_commit_id" : "03e2733be1772ef69caf34e84c7b400f64a8ea9f",
      "original_position" : 284,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 361454311,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/381558152",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381558659"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/381558659"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't see the logic here to handle being assigned a different port number.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-19T21:36:08Z",
      "diff_hunk" : "@@ -0,0 +1,320 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+static MapPortProto g_mapport_current_proto = MapPortProto::NONE;\n+static unsigned int g_mapport_target_proto = g_mapport_current_proto;\n+static uint16_t g_mapport_external_port = 0;\n+static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD = std::chrono::minutes(20);\n+static constexpr auto PORT_MAPPING_RETRY_PERIOD = std::chrono::minutes(5);\n+\n+#ifdef USE_NATPMP\n+static bool NatpmpInit(natpmp_t* natpmp)\n+{\n+    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r_init == 0) return true;\n+    LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r_init);\n+    return false;\n+}\n+\n+static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n+{\n+    const int r_send = sendpublicaddressrequest(natpmp);\n+    if (r_send == 2 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            external_ipv4_addr = response.pnu.publicaddress.addr;\n+            return true;\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n+{\n+    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n+    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n+    if (r_send == 12 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            auto pm = response.pnu.newportmapping;\n+            if (private_port == pm.privateport && pm.lifetime > 0) {\n+                g_mapport_current_proto = MapPortProto::NAT_PMP;\n+                g_mapport_external_port = pm.mappedpublicport;\n+                const CService external{external_ipv4_addr, pm.mappedpublicport};\n+                if (!external_ip_discovered && fDiscover) {\n+                    AddLocal(external, LOCAL_MAPPED);\n+                    external_ip_discovered = true;\n+                }\n+\n+                LogPrintf(\"NAT-PMP: Port mapping successful. External address = %s\\n\", external.ToString());\n+                return true;\n+            } else {\n+                LogPrintf(\"NAT-PMP: Port mapping failed.\\n\");\n+            }\n+\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool ThreadNatpmp()\n+{\n+    bool ret = false;\n+    natpmp_t natpmp;\n+    struct in_addr external_ipv4_addr;\n+    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n+        bool external_ip_discovered = false;\n+        const uint16_t private_port = GetListenPort();\n+        do {\n+            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381558659",
      "id" : 381558659,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1ODY1OQ==",
      "original_commit_id" : "03e2733be1772ef69caf34e84c7b400f64a8ea9f",
      "original_position" : 137,
      "path" : "src/mapport.cpp",
      "position" : 137,
      "pull_request_review_id" : 361454958,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/381558659",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I suggest putting the variable renames in a separate commit for easier review.\r\n\r\nAlso, since NAT-PMP apparently maps random ports often, I think we should prefer UPnP...",
      "created_at" : "2020-02-19T21:37:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-588484002",
      "id" : 588484002,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4ODQ4NDAwMg==",
      "updated_at" : "2020-02-19T21:37:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/588484002",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381830792"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/381830792"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The logic to handle being assigned a different external port number by the gateway uses the `g_mapport_external_port` variable.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-20T07:49:34Z",
      "diff_hunk" : "@@ -0,0 +1,320 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+static MapPortProto g_mapport_current_proto = MapPortProto::NONE;\n+static unsigned int g_mapport_target_proto = g_mapport_current_proto;\n+static uint16_t g_mapport_external_port = 0;\n+static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD = std::chrono::minutes(20);\n+static constexpr auto PORT_MAPPING_RETRY_PERIOD = std::chrono::minutes(5);\n+\n+#ifdef USE_NATPMP\n+static bool NatpmpInit(natpmp_t* natpmp)\n+{\n+    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r_init == 0) return true;\n+    LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r_init);\n+    return false;\n+}\n+\n+static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n+{\n+    const int r_send = sendpublicaddressrequest(natpmp);\n+    if (r_send == 2 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            external_ipv4_addr = response.pnu.publicaddress.addr;\n+            return true;\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n+{\n+    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n+    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n+    if (r_send == 12 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            auto pm = response.pnu.newportmapping;\n+            if (private_port == pm.privateport && pm.lifetime > 0) {\n+                g_mapport_current_proto = MapPortProto::NAT_PMP;\n+                g_mapport_external_port = pm.mappedpublicport;\n+                const CService external{external_ipv4_addr, pm.mappedpublicport};\n+                if (!external_ip_discovered && fDiscover) {\n+                    AddLocal(external, LOCAL_MAPPED);\n+                    external_ip_discovered = true;\n+                }\n+\n+                LogPrintf(\"NAT-PMP: Port mapping successful. External address = %s\\n\", external.ToString());\n+                return true;\n+            } else {\n+                LogPrintf(\"NAT-PMP: Port mapping failed.\\n\");\n+            }\n+\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool ThreadNatpmp()\n+{\n+    bool ret = false;\n+    natpmp_t natpmp;\n+    struct in_addr external_ipv4_addr;\n+    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n+        bool external_ip_discovered = false;\n+        const uint16_t private_port = GetListenPort();\n+        do {\n+            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381830792",
      "id" : 381830792,
      "in_reply_to_id" : 381558659,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTgzMDc5Mg==",
      "original_commit_id" : "03e2733be1772ef69caf34e84c7b400f64a8ea9f",
      "original_position" : 137,
      "path" : "src/mapport.cpp",
      "position" : 137,
      "pull_request_review_id" : 361688719,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/381830792",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@luke-jr \r\n> I suggest putting the variable renames in a separate commit for easier review.\r\n\r\nThere is a dedicated commit \"refactor: Rename UPnP stuff\" (a2de373a96dc1b9f5374eb70d605dcaf49f9b244).\r\nWhat variable rename did I miss to put it to?",
      "created_at" : "2020-02-20T07:56:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-588713300",
      "id" : 588713300,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4ODcxMzMwMA==",
      "updated_at" : "2020-02-20T07:56:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/588713300",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381908006"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/381908006"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The separate issue #18184 has been submitted.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-20T10:21:34Z",
      "diff_hunk" : "@@ -344,15 +356,19 @@ bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in\n         case HideTrayIcon:\n             fHideTrayIcon = value.toBool();\n             settings.setValue(\"fHideTrayIcon\", fHideTrayIcon);\n-    \t\tQ_EMIT hideTrayIconChanged(fHideTrayIcon);\n+            Q_EMIT hideTrayIconChanged(fHideTrayIcon);\n             break;\n         case MinimizeToTray:\n             fMinimizeToTray = value.toBool();\n             settings.setValue(\"fMinimizeToTray\", fMinimizeToTray);\n             break;\n+        case MapPortNatpmp: // core option - can be changed on-the-fly\n+            settings.setValue(\"fUseNatpmp\", value.toBool());\n+            m_node.mapPort(value.toBool(), settings.value(\"fUseUPnP\").toBool());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381908006",
      "id" : 381908006,
      "in_reply_to_id" : 381553831,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTkwODAwNg==",
      "original_commit_id" : "03e2733be1772ef69caf34e84c7b400f64a8ea9f",
      "original_position" : 52,
      "path" : "src/qt/optionsmodel.cpp",
      "position" : null,
      "pull_request_review_id" : 361785165,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/381908006",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Updated 03e2733be1772ef69caf34e84c7b400f64a8ea9f -> dd3229e7af8563c69d26955c4207f73ae1d3bc94 ([pr18077.10](https://github.com/hebasto/bitcoin/commits/pr18077.10) -> [pr18077.11](https://github.com/hebasto/bitcoin/commits/pr18077.11), [compare](https://github.com/hebasto/bitcoin/compare/pr18077.10..pr18077.11)):\r\n\r\n- fixed CI issues\r\n- the NAT-PMP checkbox added to the GUI (this simplifies testing a lot)\r\n- fixed a [bug](https://github.com/bitcoin/bitcoin/pull/18077#discussion_r381558152) pointed by @luke-jr",
      "created_at" : "2020-02-20T23:21:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-589405068",
      "id" : 589405068,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTQwNTA2OA==",
      "updated_at" : "2020-02-20T23:21:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589405068",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382315043"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382315043"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed in the latest [push](https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-589405068).",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-20T23:24:10Z",
      "diff_hunk" : "@@ -0,0 +1,320 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+static MapPortProto g_mapport_current_proto = MapPortProto::NONE;\n+static unsigned int g_mapport_target_proto = g_mapport_current_proto;\n+static uint16_t g_mapport_external_port = 0;\n+static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD = std::chrono::minutes(20);\n+static constexpr auto PORT_MAPPING_RETRY_PERIOD = std::chrono::minutes(5);\n+\n+#ifdef USE_NATPMP\n+static bool NatpmpInit(natpmp_t* natpmp)\n+{\n+    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r_init == 0) return true;\n+    LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r_init);\n+    return false;\n+}\n+\n+static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n+{\n+    const int r_send = sendpublicaddressrequest(natpmp);\n+    if (r_send == 2 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            external_ipv4_addr = response.pnu.publicaddress.addr;\n+            return true;\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n+{\n+    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n+    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n+    if (r_send == 12 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            auto pm = response.pnu.newportmapping;\n+            if (private_port == pm.privateport && pm.lifetime > 0) {\n+                g_mapport_current_proto = MapPortProto::NAT_PMP;\n+                g_mapport_external_port = pm.mappedpublicport;\n+                const CService external{external_ipv4_addr, pm.mappedpublicport};\n+                if (!external_ip_discovered && fDiscover) {\n+                    AddLocal(external, LOCAL_MAPPED);\n+                    external_ip_discovered = true;\n+                }\n+\n+                LogPrintf(\"NAT-PMP: Port mapping successful. External address = %s\\n\", external.ToString());\n+                return true;\n+            } else {\n+                LogPrintf(\"NAT-PMP: Port mapping failed.\\n\");\n+            }\n+\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool ThreadNatpmp()\n+{\n+    bool ret = false;\n+    natpmp_t natpmp;\n+    struct in_addr external_ipv4_addr;\n+    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n+        bool external_ip_discovered = false;\n+        const uint16_t private_port = GetListenPort();\n+        do {\n+            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n+        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n+        g_mapport_external_port = 0;\n+        if (r_send == 12 /* OK */) {\n+            LogPrintf(\"NAT-PMP: Port mapping removed successfully.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        }\n+    }\n+\n+    closenatpmp(&natpmp);\n+    return ret;\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static bool ThreadUpnp()\n+{\n+    bool ret = false;\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                ret = false;\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+                break;\n+            } else {\n+                ret = true;\n+                g_mapport_current_proto = MapPortProto::UPNP;\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+\n+    return ret;\n+}\n+#endif // #ifdef USE_UPNP\n+\n+static void ThreadMapPort()\n+{\n+    bool ok;\n+    do {\n+        ok = false;\n+\n+#ifdef USE_NATPMP\n+        if (g_mapport_target_proto & MapPortProto::NAT_PMP) {\n+            ok = ThreadNatpmp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+        if (g_mapport_target_proto & MapPortProto::UPNP) {\n+            ok = ThreadUpnp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_UPNP\n+\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            g_mapport_current_proto = MapPortProto::NONE;\n+            return;\n+        }\n+\n+    } while (ok || g_mapport_interrupt.sleep_for(PORT_MAPPING_RETRY_PERIOD));\n+}\n+\n+void StartMapPort(bool use_natpmp, bool use_upnp)\n+{\n+    if (use_natpmp) {\n+        g_mapport_target_proto |= MapPortProto::NAT_PMP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::NAT_PMP;\n+    }\n+\n+    if (use_upnp) {\n+        g_mapport_target_proto |= MapPortProto::UPNP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::UPNP;\n+    }\n+\n+    if (g_mapport_current_proto == MapPortProto::NONE) {\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            return;\n+        }\n+    } else if (g_mapport_target_proto & g_mapport_current_proto) {\n+        return;\n+    }\n+\n+    if (g_mapport_target_proto == MapPortProto::NONE) {\n+        InterruptMapPort();\n+        StopMapPort();\n+        return;\n+    }\n+\n+    if (g_mapport_thread.joinable()) {\n+        g_mapport_interrupt();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382315043",
      "id" : 382315043,
      "in_reply_to_id" : 381558152,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNTA0Mw==",
      "original_commit_id" : "03e2733be1772ef69caf34e84c7b400f64a8ea9f",
      "original_position" : 284,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 362306083,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382315043",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382316994"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382316994"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Sure it works.\r\nThe log excerpt for the mentioned case:\r\n```\r\n2020-02-20T23:26:30Z [mapport] UPNP_DeletePortMapping() returned: 0\r\n2020-02-20T23:26:30Z [mapport] AddLocal(95.164.65.194:18333,3)\r\n2020-02-20T23:26:30Z [mapport] NAT-PMP: Port mapping successful. External address = 95.164.65.194:18333\r\n\r\n```",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-20T23:29:52Z",
      "diff_hunk" : "@@ -0,0 +1,320 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+static MapPortProto g_mapport_current_proto = MapPortProto::NONE;\n+static unsigned int g_mapport_target_proto = g_mapport_current_proto;\n+static uint16_t g_mapport_external_port = 0;\n+static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD = std::chrono::minutes(20);\n+static constexpr auto PORT_MAPPING_RETRY_PERIOD = std::chrono::minutes(5);\n+\n+#ifdef USE_NATPMP\n+static bool NatpmpInit(natpmp_t* natpmp)\n+{\n+    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r_init == 0) return true;\n+    LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r_init);\n+    return false;\n+}\n+\n+static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n+{\n+    const int r_send = sendpublicaddressrequest(natpmp);\n+    if (r_send == 2 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            external_ipv4_addr = response.pnu.publicaddress.addr;\n+            return true;\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n+{\n+    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n+    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n+    if (r_send == 12 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            auto pm = response.pnu.newportmapping;\n+            if (private_port == pm.privateport && pm.lifetime > 0) {\n+                g_mapport_current_proto = MapPortProto::NAT_PMP;\n+                g_mapport_external_port = pm.mappedpublicport;\n+                const CService external{external_ipv4_addr, pm.mappedpublicport};\n+                if (!external_ip_discovered && fDiscover) {\n+                    AddLocal(external, LOCAL_MAPPED);\n+                    external_ip_discovered = true;\n+                }\n+\n+                LogPrintf(\"NAT-PMP: Port mapping successful. External address = %s\\n\", external.ToString());\n+                return true;\n+            } else {\n+                LogPrintf(\"NAT-PMP: Port mapping failed.\\n\");\n+            }\n+\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool ThreadNatpmp()\n+{\n+    bool ret = false;\n+    natpmp_t natpmp;\n+    struct in_addr external_ipv4_addr;\n+    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n+        bool external_ip_discovered = false;\n+        const uint16_t private_port = GetListenPort();\n+        do {\n+            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n+        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n+        g_mapport_external_port = 0;\n+        if (r_send == 12 /* OK */) {\n+            LogPrintf(\"NAT-PMP: Port mapping removed successfully.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        }\n+    }\n+\n+    closenatpmp(&natpmp);\n+    return ret;\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static bool ThreadUpnp()\n+{\n+    bool ret = false;\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                ret = false;\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+                break;\n+            } else {\n+                ret = true;\n+                g_mapport_current_proto = MapPortProto::UPNP;\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+\n+    return ret;\n+}\n+#endif // #ifdef USE_UPNP\n+\n+static void ThreadMapPort()\n+{\n+    bool ok;\n+    do {\n+        ok = false;\n+\n+#ifdef USE_NATPMP\n+        if (g_mapport_target_proto & MapPortProto::NAT_PMP) {\n+            ok = ThreadNatpmp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+        if (g_mapport_target_proto & MapPortProto::UPNP) {\n+            ok = ThreadUpnp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_UPNP\n+\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            g_mapport_current_proto = MapPortProto::NONE;\n+            return;\n+        }\n+\n+    } while (ok || g_mapport_interrupt.sleep_for(PORT_MAPPING_RETRY_PERIOD));\n+}\n+\n+void StartMapPort(bool use_natpmp, bool use_upnp)\n+{\n+    if (use_natpmp) {\n+        g_mapport_target_proto |= MapPortProto::NAT_PMP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::NAT_PMP;\n+    }\n+\n+    if (use_upnp) {\n+        g_mapport_target_proto |= MapPortProto::UPNP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::UPNP;\n+    }\n+\n+    if (g_mapport_current_proto == MapPortProto::NONE) {\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            return;\n+        }\n+    } else if (g_mapport_target_proto & g_mapport_current_proto) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382316994",
      "id" : 382316994,
      "in_reply_to_id" : 381557545,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMxNjk5NA==",
      "original_commit_id" : "03e2733be1772ef69caf34e84c7b400f64a8ea9f",
      "original_position" : 273,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 362308336,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382316994",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@luke-jr \r\n> Also, since NAT-PMP apparently maps random ports often, I think we should prefer UPnP...\r\n\r\nDoes this behavior of NAT-PMP gateways hurt the entire p2p network?\r\n\r\nOTOH, NAT-PMP seems more secure than UPnP (for example, one could compare numbers of CVEs for each protocol).",
      "created_at" : "2020-02-20T23:42:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-589416424",
      "id" : 589416424,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTQxNjQyNA==",
      "updated_at" : "2020-02-20T23:42:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589416424",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : ">Does this behavior of NAT-PMP gateways hurt the entire p2p network?\r\n\r\nDNS seeds can't provide port numbers, so using anything other than 8333 reduces the list of nodes we can advertise. Currently, mine (which is IIRC more restrictive than others) has 3090 eligible nodes, so it's not a big deal, but it'd be nicer to have a wider selection available than a narrower selection.\r\n\r\n> OTOH, NAT-PMP seems more secure than UPnP (for example, one could compare numbers of CVEs for each protocol).\r\n\r\nThe CVEs AFAIK are for the implementations, not the protocol.\r\n\r\nIn any case, when we are using either, I think we're reduced to the weakest no matter which we prefer (a hostile router could block NAT-PMP to force fallback to UPnP).",
      "created_at" : "2020-02-20T23:52:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-589428754",
      "id" : 589428754,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTQyODc1NA==",
      "updated_at" : "2020-02-20T23:52:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589428754",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382325993"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382325993"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why would it? You'd return early here without making the change...",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-20T23:55:02Z",
      "diff_hunk" : "@@ -0,0 +1,320 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+static MapPortProto g_mapport_current_proto = MapPortProto::NONE;\n+static unsigned int g_mapport_target_proto = g_mapport_current_proto;\n+static uint16_t g_mapport_external_port = 0;\n+static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD = std::chrono::minutes(20);\n+static constexpr auto PORT_MAPPING_RETRY_PERIOD = std::chrono::minutes(5);\n+\n+#ifdef USE_NATPMP\n+static bool NatpmpInit(natpmp_t* natpmp)\n+{\n+    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r_init == 0) return true;\n+    LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r_init);\n+    return false;\n+}\n+\n+static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n+{\n+    const int r_send = sendpublicaddressrequest(natpmp);\n+    if (r_send == 2 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            external_ipv4_addr = response.pnu.publicaddress.addr;\n+            return true;\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n+{\n+    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n+    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n+    if (r_send == 12 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            auto pm = response.pnu.newportmapping;\n+            if (private_port == pm.privateport && pm.lifetime > 0) {\n+                g_mapport_current_proto = MapPortProto::NAT_PMP;\n+                g_mapport_external_port = pm.mappedpublicport;\n+                const CService external{external_ipv4_addr, pm.mappedpublicport};\n+                if (!external_ip_discovered && fDiscover) {\n+                    AddLocal(external, LOCAL_MAPPED);\n+                    external_ip_discovered = true;\n+                }\n+\n+                LogPrintf(\"NAT-PMP: Port mapping successful. External address = %s\\n\", external.ToString());\n+                return true;\n+            } else {\n+                LogPrintf(\"NAT-PMP: Port mapping failed.\\n\");\n+            }\n+\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool ThreadNatpmp()\n+{\n+    bool ret = false;\n+    natpmp_t natpmp;\n+    struct in_addr external_ipv4_addr;\n+    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n+        bool external_ip_discovered = false;\n+        const uint16_t private_port = GetListenPort();\n+        do {\n+            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n+        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n+        g_mapport_external_port = 0;\n+        if (r_send == 12 /* OK */) {\n+            LogPrintf(\"NAT-PMP: Port mapping removed successfully.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        }\n+    }\n+\n+    closenatpmp(&natpmp);\n+    return ret;\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static bool ThreadUpnp()\n+{\n+    bool ret = false;\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                ret = false;\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+                break;\n+            } else {\n+                ret = true;\n+                g_mapport_current_proto = MapPortProto::UPNP;\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+\n+    return ret;\n+}\n+#endif // #ifdef USE_UPNP\n+\n+static void ThreadMapPort()\n+{\n+    bool ok;\n+    do {\n+        ok = false;\n+\n+#ifdef USE_NATPMP\n+        if (g_mapport_target_proto & MapPortProto::NAT_PMP) {\n+            ok = ThreadNatpmp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+        if (g_mapport_target_proto & MapPortProto::UPNP) {\n+            ok = ThreadUpnp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_UPNP\n+\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            g_mapport_current_proto = MapPortProto::NONE;\n+            return;\n+        }\n+\n+    } while (ok || g_mapport_interrupt.sleep_for(PORT_MAPPING_RETRY_PERIOD));\n+}\n+\n+void StartMapPort(bool use_natpmp, bool use_upnp)\n+{\n+    if (use_natpmp) {\n+        g_mapport_target_proto |= MapPortProto::NAT_PMP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::NAT_PMP;\n+    }\n+\n+    if (use_upnp) {\n+        g_mapport_target_proto |= MapPortProto::UPNP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::UPNP;\n+    }\n+\n+    if (g_mapport_current_proto == MapPortProto::NONE) {\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            return;\n+        }\n+    } else if (g_mapport_target_proto & g_mapport_current_proto) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382325993",
      "id" : 382325993,
      "in_reply_to_id" : 381557545,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNTk5Mw==",
      "original_commit_id" : "03e2733be1772ef69caf34e84c7b400f64a8ea9f",
      "original_position" : 273,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 362319026,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382325993",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382327259"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382327259"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If both protocols were enabled, `g_mapport_target_proto != MapPortProto::NONE`",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-20T23:59:05Z",
      "diff_hunk" : "@@ -0,0 +1,320 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+static MapPortProto g_mapport_current_proto = MapPortProto::NONE;\n+static unsigned int g_mapport_target_proto = g_mapport_current_proto;\n+static uint16_t g_mapport_external_port = 0;\n+static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD = std::chrono::minutes(20);\n+static constexpr auto PORT_MAPPING_RETRY_PERIOD = std::chrono::minutes(5);\n+\n+#ifdef USE_NATPMP\n+static bool NatpmpInit(natpmp_t* natpmp)\n+{\n+    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r_init == 0) return true;\n+    LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r_init);\n+    return false;\n+}\n+\n+static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n+{\n+    const int r_send = sendpublicaddressrequest(natpmp);\n+    if (r_send == 2 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            external_ipv4_addr = response.pnu.publicaddress.addr;\n+            return true;\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n+{\n+    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n+    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n+    if (r_send == 12 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            auto pm = response.pnu.newportmapping;\n+            if (private_port == pm.privateport && pm.lifetime > 0) {\n+                g_mapport_current_proto = MapPortProto::NAT_PMP;\n+                g_mapport_external_port = pm.mappedpublicport;\n+                const CService external{external_ipv4_addr, pm.mappedpublicport};\n+                if (!external_ip_discovered && fDiscover) {\n+                    AddLocal(external, LOCAL_MAPPED);\n+                    external_ip_discovered = true;\n+                }\n+\n+                LogPrintf(\"NAT-PMP: Port mapping successful. External address = %s\\n\", external.ToString());\n+                return true;\n+            } else {\n+                LogPrintf(\"NAT-PMP: Port mapping failed.\\n\");\n+            }\n+\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool ThreadNatpmp()\n+{\n+    bool ret = false;\n+    natpmp_t natpmp;\n+    struct in_addr external_ipv4_addr;\n+    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n+        bool external_ip_discovered = false;\n+        const uint16_t private_port = GetListenPort();\n+        do {\n+            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n+        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n+        g_mapport_external_port = 0;\n+        if (r_send == 12 /* OK */) {\n+            LogPrintf(\"NAT-PMP: Port mapping removed successfully.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        }\n+    }\n+\n+    closenatpmp(&natpmp);\n+    return ret;\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static bool ThreadUpnp()\n+{\n+    bool ret = false;\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                ret = false;\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+                break;\n+            } else {\n+                ret = true;\n+                g_mapport_current_proto = MapPortProto::UPNP;\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+\n+    return ret;\n+}\n+#endif // #ifdef USE_UPNP\n+\n+static void ThreadMapPort()\n+{\n+    bool ok;\n+    do {\n+        ok = false;\n+\n+#ifdef USE_NATPMP\n+        if (g_mapport_target_proto & MapPortProto::NAT_PMP) {\n+            ok = ThreadNatpmp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+        if (g_mapport_target_proto & MapPortProto::UPNP) {\n+            ok = ThreadUpnp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_UPNP\n+\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            g_mapport_current_proto = MapPortProto::NONE;\n+            return;\n+        }\n+\n+    } while (ok || g_mapport_interrupt.sleep_for(PORT_MAPPING_RETRY_PERIOD));\n+}\n+\n+void StartMapPort(bool use_natpmp, bool use_upnp)\n+{\n+    if (use_natpmp) {\n+        g_mapport_target_proto |= MapPortProto::NAT_PMP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::NAT_PMP;\n+    }\n+\n+    if (use_upnp) {\n+        g_mapport_target_proto |= MapPortProto::UPNP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::UPNP;\n+    }\n+\n+    if (g_mapport_current_proto == MapPortProto::NONE) {\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            return;\n+        }\n+    } else if (g_mapport_target_proto & g_mapport_current_proto) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382327259",
      "id" : 382327259,
      "in_reply_to_id" : 381557545,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjMyNzI1OQ==",
      "original_commit_id" : "03e2733be1772ef69caf34e84c7b400f64a8ea9f",
      "original_position" : 273,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 362320522,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382327259",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382377105"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382377105"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The conditional here is `(g_mapport_target_proto & g_mapport_current_proto)`",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-21T03:13:33Z",
      "diff_hunk" : "@@ -0,0 +1,320 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+static MapPortProto g_mapport_current_proto = MapPortProto::NONE;\n+static unsigned int g_mapport_target_proto = g_mapport_current_proto;\n+static uint16_t g_mapport_external_port = 0;\n+static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD = std::chrono::minutes(20);\n+static constexpr auto PORT_MAPPING_RETRY_PERIOD = std::chrono::minutes(5);\n+\n+#ifdef USE_NATPMP\n+static bool NatpmpInit(natpmp_t* natpmp)\n+{\n+    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r_init == 0) return true;\n+    LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r_init);\n+    return false;\n+}\n+\n+static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n+{\n+    const int r_send = sendpublicaddressrequest(natpmp);\n+    if (r_send == 2 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            external_ipv4_addr = response.pnu.publicaddress.addr;\n+            return true;\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n+{\n+    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n+    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n+    if (r_send == 12 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            auto pm = response.pnu.newportmapping;\n+            if (private_port == pm.privateport && pm.lifetime > 0) {\n+                g_mapport_current_proto = MapPortProto::NAT_PMP;\n+                g_mapport_external_port = pm.mappedpublicport;\n+                const CService external{external_ipv4_addr, pm.mappedpublicport};\n+                if (!external_ip_discovered && fDiscover) {\n+                    AddLocal(external, LOCAL_MAPPED);\n+                    external_ip_discovered = true;\n+                }\n+\n+                LogPrintf(\"NAT-PMP: Port mapping successful. External address = %s\\n\", external.ToString());\n+                return true;\n+            } else {\n+                LogPrintf(\"NAT-PMP: Port mapping failed.\\n\");\n+            }\n+\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool ThreadNatpmp()\n+{\n+    bool ret = false;\n+    natpmp_t natpmp;\n+    struct in_addr external_ipv4_addr;\n+    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n+        bool external_ip_discovered = false;\n+        const uint16_t private_port = GetListenPort();\n+        do {\n+            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n+        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n+        g_mapport_external_port = 0;\n+        if (r_send == 12 /* OK */) {\n+            LogPrintf(\"NAT-PMP: Port mapping removed successfully.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        }\n+    }\n+\n+    closenatpmp(&natpmp);\n+    return ret;\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static bool ThreadUpnp()\n+{\n+    bool ret = false;\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                ret = false;\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+                break;\n+            } else {\n+                ret = true;\n+                g_mapport_current_proto = MapPortProto::UPNP;\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+\n+    return ret;\n+}\n+#endif // #ifdef USE_UPNP\n+\n+static void ThreadMapPort()\n+{\n+    bool ok;\n+    do {\n+        ok = false;\n+\n+#ifdef USE_NATPMP\n+        if (g_mapport_target_proto & MapPortProto::NAT_PMP) {\n+            ok = ThreadNatpmp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+        if (g_mapport_target_proto & MapPortProto::UPNP) {\n+            ok = ThreadUpnp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_UPNP\n+\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            g_mapport_current_proto = MapPortProto::NONE;\n+            return;\n+        }\n+\n+    } while (ok || g_mapport_interrupt.sleep_for(PORT_MAPPING_RETRY_PERIOD));\n+}\n+\n+void StartMapPort(bool use_natpmp, bool use_upnp)\n+{\n+    if (use_natpmp) {\n+        g_mapport_target_proto |= MapPortProto::NAT_PMP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::NAT_PMP;\n+    }\n+\n+    if (use_upnp) {\n+        g_mapport_target_proto |= MapPortProto::UPNP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::UPNP;\n+    }\n+\n+    if (g_mapport_current_proto == MapPortProto::NONE) {\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            return;\n+        }\n+    } else if (g_mapport_target_proto & g_mapport_current_proto) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382377105",
      "id" : 382377105,
      "in_reply_to_id" : 381557545,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjM3NzEwNQ==",
      "original_commit_id" : "03e2733be1772ef69caf34e84c7b400f64a8ea9f",
      "original_position" : 273,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 362376836,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382377105",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382547566"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382547566"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```C++\r\nvoid StartMapPort(bool use_natpmp, bool use_upnp)\r\n{\r\n    // Both protocols are enabled, so\r\n    // g_mapport_target_proto == MapPortProto::NAT_PMP | MapPortProto::UPNP\r\n    //\r\n    // UPnP is currently using, so\r\n    // g_mapport_current_proto == MapPortProto::UPNP\r\n    //\r\n    // A user disables UPnP then passed arguments are:\r\n    // use_natpmp == true, use_upnp = false\r\n\r\n    if (use_natpmp) {\r\n        // Effectively noop here as MapPortProto::NAT_PMP is set already.\r\n        g_mapport_target_proto |= MapPortProto::NAT_PMP;\r\n    } else {\r\n        g_mapport_target_proto &= ~MapPortProto::NAT_PMP;\r\n    }\r\n\r\n    if (use_upnp) {\r\n        g_mapport_target_proto |= MapPortProto::UPNP;\r\n    } else {\r\n        // Unset MapPortProto::UPNP bit.\r\n        g_mapport_target_proto &= ~MapPortProto::UPNP;\r\n    }\r\n\r\n    // At this point variables are set to the following values:\r\n    // g_mapport_target_proto == MapPortProto::NAT_PMP\r\n    // g_mapport_current_proto == MapPortProto::UPNP\r\n    // ...\r\n    if (g_mapport_current_proto == MapPortProto::NONE) {\r\n        if (g_mapport_target_proto == MapPortProto::NONE) {\r\n            return;\r\n        }\r\n    // ... and the next condition evaluates to false.\r\n    } else if (g_mapport_target_proto & g_mapport_current_proto) {\r\n        return;\r\n    }\r\n\r\n    // Making the changes...\r\n    ...\r\n}\r\n```\r\n\r\nAnd logs confirm this logic.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-21T12:06:51Z",
      "diff_hunk" : "@@ -0,0 +1,320 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+static MapPortProto g_mapport_current_proto = MapPortProto::NONE;\n+static unsigned int g_mapport_target_proto = g_mapport_current_proto;\n+static uint16_t g_mapport_external_port = 0;\n+static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD = std::chrono::minutes(20);\n+static constexpr auto PORT_MAPPING_RETRY_PERIOD = std::chrono::minutes(5);\n+\n+#ifdef USE_NATPMP\n+static bool NatpmpInit(natpmp_t* natpmp)\n+{\n+    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r_init == 0) return true;\n+    LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r_init);\n+    return false;\n+}\n+\n+static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n+{\n+    const int r_send = sendpublicaddressrequest(natpmp);\n+    if (r_send == 2 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            external_ipv4_addr = response.pnu.publicaddress.addr;\n+            return true;\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n+{\n+    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n+    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n+    if (r_send == 12 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            auto pm = response.pnu.newportmapping;\n+            if (private_port == pm.privateport && pm.lifetime > 0) {\n+                g_mapport_current_proto = MapPortProto::NAT_PMP;\n+                g_mapport_external_port = pm.mappedpublicport;\n+                const CService external{external_ipv4_addr, pm.mappedpublicport};\n+                if (!external_ip_discovered && fDiscover) {\n+                    AddLocal(external, LOCAL_MAPPED);\n+                    external_ip_discovered = true;\n+                }\n+\n+                LogPrintf(\"NAT-PMP: Port mapping successful. External address = %s\\n\", external.ToString());\n+                return true;\n+            } else {\n+                LogPrintf(\"NAT-PMP: Port mapping failed.\\n\");\n+            }\n+\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool ThreadNatpmp()\n+{\n+    bool ret = false;\n+    natpmp_t natpmp;\n+    struct in_addr external_ipv4_addr;\n+    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n+        bool external_ip_discovered = false;\n+        const uint16_t private_port = GetListenPort();\n+        do {\n+            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n+        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n+        g_mapport_external_port = 0;\n+        if (r_send == 12 /* OK */) {\n+            LogPrintf(\"NAT-PMP: Port mapping removed successfully.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        }\n+    }\n+\n+    closenatpmp(&natpmp);\n+    return ret;\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static bool ThreadUpnp()\n+{\n+    bool ret = false;\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                ret = false;\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+                break;\n+            } else {\n+                ret = true;\n+                g_mapport_current_proto = MapPortProto::UPNP;\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+\n+    return ret;\n+}\n+#endif // #ifdef USE_UPNP\n+\n+static void ThreadMapPort()\n+{\n+    bool ok;\n+    do {\n+        ok = false;\n+\n+#ifdef USE_NATPMP\n+        if (g_mapport_target_proto & MapPortProto::NAT_PMP) {\n+            ok = ThreadNatpmp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+        if (g_mapport_target_proto & MapPortProto::UPNP) {\n+            ok = ThreadUpnp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_UPNP\n+\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            g_mapport_current_proto = MapPortProto::NONE;\n+            return;\n+        }\n+\n+    } while (ok || g_mapport_interrupt.sleep_for(PORT_MAPPING_RETRY_PERIOD));\n+}\n+\n+void StartMapPort(bool use_natpmp, bool use_upnp)\n+{\n+    if (use_natpmp) {\n+        g_mapport_target_proto |= MapPortProto::NAT_PMP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::NAT_PMP;\n+    }\n+\n+    if (use_upnp) {\n+        g_mapport_target_proto |= MapPortProto::UPNP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::UPNP;\n+    }\n+\n+    if (g_mapport_current_proto == MapPortProto::NONE) {\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            return;\n+        }\n+    } else if (g_mapport_target_proto & g_mapport_current_proto) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382547566",
      "id" : 382547566,
      "in_reply_to_id" : 381557545,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjU0NzU2Ng==",
      "original_commit_id" : "03e2733be1772ef69caf34e84c7b400f64a8ea9f",
      "original_position" : 273,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 362585478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382547566",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382571364"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382571364"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Got it. I was confusing it with (target & new_target)",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-21T13:07:25Z",
      "diff_hunk" : "@@ -0,0 +1,320 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+static MapPortProto g_mapport_current_proto = MapPortProto::NONE;\n+static unsigned int g_mapport_target_proto = g_mapport_current_proto;\n+static uint16_t g_mapport_external_port = 0;\n+static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD = std::chrono::minutes(20);\n+static constexpr auto PORT_MAPPING_RETRY_PERIOD = std::chrono::minutes(5);\n+\n+#ifdef USE_NATPMP\n+static bool NatpmpInit(natpmp_t* natpmp)\n+{\n+    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r_init == 0) return true;\n+    LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r_init);\n+    return false;\n+}\n+\n+static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n+{\n+    const int r_send = sendpublicaddressrequest(natpmp);\n+    if (r_send == 2 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            external_ipv4_addr = response.pnu.publicaddress.addr;\n+            return true;\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n+{\n+    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n+    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n+    if (r_send == 12 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            auto pm = response.pnu.newportmapping;\n+            if (private_port == pm.privateport && pm.lifetime > 0) {\n+                g_mapport_current_proto = MapPortProto::NAT_PMP;\n+                g_mapport_external_port = pm.mappedpublicport;\n+                const CService external{external_ipv4_addr, pm.mappedpublicport};\n+                if (!external_ip_discovered && fDiscover) {\n+                    AddLocal(external, LOCAL_MAPPED);\n+                    external_ip_discovered = true;\n+                }\n+\n+                LogPrintf(\"NAT-PMP: Port mapping successful. External address = %s\\n\", external.ToString());\n+                return true;\n+            } else {\n+                LogPrintf(\"NAT-PMP: Port mapping failed.\\n\");\n+            }\n+\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool ThreadNatpmp()\n+{\n+    bool ret = false;\n+    natpmp_t natpmp;\n+    struct in_addr external_ipv4_addr;\n+    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n+        bool external_ip_discovered = false;\n+        const uint16_t private_port = GetListenPort();\n+        do {\n+            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n+        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n+        g_mapport_external_port = 0;\n+        if (r_send == 12 /* OK */) {\n+            LogPrintf(\"NAT-PMP: Port mapping removed successfully.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        }\n+    }\n+\n+    closenatpmp(&natpmp);\n+    return ret;\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static bool ThreadUpnp()\n+{\n+    bool ret = false;\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                ret = false;\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+                break;\n+            } else {\n+                ret = true;\n+                g_mapport_current_proto = MapPortProto::UPNP;\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+\n+    return ret;\n+}\n+#endif // #ifdef USE_UPNP\n+\n+static void ThreadMapPort()\n+{\n+    bool ok;\n+    do {\n+        ok = false;\n+\n+#ifdef USE_NATPMP\n+        if (g_mapport_target_proto & MapPortProto::NAT_PMP) {\n+            ok = ThreadNatpmp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+        if (g_mapport_target_proto & MapPortProto::UPNP) {\n+            ok = ThreadUpnp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_UPNP\n+\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            g_mapport_current_proto = MapPortProto::NONE;\n+            return;\n+        }\n+\n+    } while (ok || g_mapport_interrupt.sleep_for(PORT_MAPPING_RETRY_PERIOD));\n+}\n+\n+void StartMapPort(bool use_natpmp, bool use_upnp)\n+{\n+    if (use_natpmp) {\n+        g_mapport_target_proto |= MapPortProto::NAT_PMP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::NAT_PMP;\n+    }\n+\n+    if (use_upnp) {\n+        g_mapport_target_proto |= MapPortProto::UPNP;\n+    } else {\n+        g_mapport_target_proto &= ~MapPortProto::UPNP;\n+    }\n+\n+    if (g_mapport_current_proto == MapPortProto::NONE) {\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            return;\n+        }\n+    } else if (g_mapport_target_proto & g_mapport_current_proto) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382571364",
      "id" : 382571364,
      "in_reply_to_id" : 381557545,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjU3MTM2NA==",
      "original_commit_id" : "03e2733be1772ef69caf34e84c7b400f64a8ea9f",
      "original_position" : 273,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 362615449,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382571364",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382750749"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382750749"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This should be reset outside of the protocol-specific functions, or else we could end up with a race.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-21T18:58:20Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+static MapPortProto g_mapport_current_proto = MapPortProto::NONE;\n+static unsigned int g_mapport_target_proto = g_mapport_current_proto;\n+static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD = std::chrono::minutes(20);\n+static constexpr auto PORT_MAPPING_RETRY_PERIOD = std::chrono::minutes(5);\n+\n+#ifdef USE_NATPMP\n+static uint16_t g_mapport_external_port = 0;\n+static bool NatpmpInit(natpmp_t* natpmp)\n+{\n+    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r_init == 0) return true;\n+    LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r_init);\n+    return false;\n+}\n+\n+static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n+{\n+    const int r_send = sendpublicaddressrequest(natpmp);\n+    if (r_send == 2 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            external_ipv4_addr = response.pnu.publicaddress.addr;\n+            return true;\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n+{\n+    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n+    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n+    if (r_send == 12 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            auto pm = response.pnu.newportmapping;\n+            if (private_port == pm.privateport && pm.lifetime > 0) {\n+                g_mapport_current_proto = MapPortProto::NAT_PMP;\n+                g_mapport_external_port = pm.mappedpublicport;\n+                const CService external{external_ipv4_addr, pm.mappedpublicport};\n+                if (!external_ip_discovered && fDiscover) {\n+                    AddLocal(external, LOCAL_MAPPED);\n+                    external_ip_discovered = true;\n+                }\n+\n+                LogPrintf(\"NAT-PMP: Port mapping successful. External address = %s\\n\", external.ToString());\n+                return true;\n+            } else {\n+                LogPrintf(\"NAT-PMP: Port mapping failed.\\n\");\n+            }\n+\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool ThreadNatpmp()\n+{\n+    bool ret = false;\n+    natpmp_t natpmp;\n+    struct in_addr external_ipv4_addr;\n+    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n+        bool external_ip_discovered = false;\n+        const uint16_t private_port = GetListenPort();\n+        g_mapport_interrupt.reset();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382750749",
      "id" : 382750749,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1MDc0OQ==",
      "original_commit_id" : "dd3229e7af8563c69d26955c4207f73ae1d3bc94",
      "original_position" : 136,
      "path" : "src/mapport.cpp",
      "position" : null,
      "pull_request_review_id" : 362846053,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382750749",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382751074"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382751074"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This will exit if it get the interrupt, causing target changes to shut off port mapping entirely.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-21T18:59:02Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+static MapPortProto g_mapport_current_proto = MapPortProto::NONE;\n+static unsigned int g_mapport_target_proto = g_mapport_current_proto;\n+static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD = std::chrono::minutes(20);\n+static constexpr auto PORT_MAPPING_RETRY_PERIOD = std::chrono::minutes(5);\n+\n+#ifdef USE_NATPMP\n+static uint16_t g_mapport_external_port = 0;\n+static bool NatpmpInit(natpmp_t* natpmp)\n+{\n+    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r_init == 0) return true;\n+    LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r_init);\n+    return false;\n+}\n+\n+static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n+{\n+    const int r_send = sendpublicaddressrequest(natpmp);\n+    if (r_send == 2 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            external_ipv4_addr = response.pnu.publicaddress.addr;\n+            return true;\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n+{\n+    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n+    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n+    if (r_send == 12 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            auto pm = response.pnu.newportmapping;\n+            if (private_port == pm.privateport && pm.lifetime > 0) {\n+                g_mapport_current_proto = MapPortProto::NAT_PMP;\n+                g_mapport_external_port = pm.mappedpublicport;\n+                const CService external{external_ipv4_addr, pm.mappedpublicport};\n+                if (!external_ip_discovered && fDiscover) {\n+                    AddLocal(external, LOCAL_MAPPED);\n+                    external_ip_discovered = true;\n+                }\n+\n+                LogPrintf(\"NAT-PMP: Port mapping successful. External address = %s\\n\", external.ToString());\n+                return true;\n+            } else {\n+                LogPrintf(\"NAT-PMP: Port mapping failed.\\n\");\n+            }\n+\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool ThreadNatpmp()\n+{\n+    bool ret = false;\n+    natpmp_t natpmp;\n+    struct in_addr external_ipv4_addr;\n+    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n+        bool external_ip_discovered = false;\n+        const uint16_t private_port = GetListenPort();\n+        g_mapport_interrupt.reset();\n+        do {\n+            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n+        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n+        g_mapport_external_port = 0;\n+        if (r_send == 12 /* OK */) {\n+            LogPrintf(\"NAT-PMP: Port mapping removed successfully.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        }\n+    }\n+\n+    closenatpmp(&natpmp);\n+    return ret;\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static bool ThreadUpnp()\n+{\n+    bool ret = false;\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        g_mapport_interrupt.reset();\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                ret = false;\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+                break;\n+            } else {\n+                ret = true;\n+                g_mapport_current_proto = MapPortProto::UPNP;\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+\n+    return ret;\n+}\n+#endif // #ifdef USE_UPNP\n+\n+static void ThreadMapPort()\n+{\n+    bool ok;\n+    do {\n+        ok = false;\n+\n+#ifdef USE_NATPMP\n+        if (g_mapport_target_proto & MapPortProto::NAT_PMP) {\n+            ok = ThreadNatpmp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+        if (g_mapport_target_proto & MapPortProto::UPNP) {\n+            ok = ThreadUpnp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_UPNP\n+\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            g_mapport_current_proto = MapPortProto::NONE;\n+            return;\n+        }\n+\n+    } while (ok || g_mapport_interrupt.sleep_for(PORT_MAPPING_RETRY_PERIOD));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382751074",
      "id" : 382751074,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjc1MTA3NA==",
      "original_commit_id" : "dd3229e7af8563c69d26955c4207f73ae1d3bc94",
      "original_position" : 254,
      "path" : "src/mapport.cpp",
      "position" : 257,
      "pull_request_review_id" : 362846053,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382751074",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Re NAT-PMP preference: Also, with the port number changing every startup, it will be hard for peers to reconnect or meaningfully pass on addr messages for you...\r\n\r\nI think cd7a0f689c5 should get split up. It's too hard to follow what it's doing.",
      "created_at" : "2020-02-21T19:01:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-589789757",
      "id" : 589789757,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTc4OTc1Nw==",
      "updated_at" : "2020-02-21T19:01:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589789757",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Re NAT-PMP preference: Also, with the port number changing every startup, it will be hard for peers to reconnect or meaningfully pass on addr messages for you...\r\n\r\nOnly [`natpmpd`](https://github.com/bodgit/natpmpd) on OpenBSD will change external port number on every startup.\r\n[`miniupnpd`](https://github.com/miniupnp/miniupnp/tree/master/miniupnpd) assigns suggested one, i.e. 8333.",
      "created_at" : "2020-02-22T08:43:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-589933497",
      "id" : 589933497,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTkzMzQ5Nw==",
      "updated_at" : "2020-02-22T08:43:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589933497",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382904239"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382904239"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If the protocol switch is initiated by a user, the `g_mapport_interrupt()` call will end the internal protocol-specific loop in the `ThreadNatpmp()` or in the `ThreadUpnp()`, `ok == true` and `g_mapport_interrupt.sleep_for(PORT_MAPPING_RETRY_PERIOD)` will not call at all.\r\n\r\nIf the protocol switch is initiated by a protocol failure, `ok == false` and `g_mapport_interrupt.sleep_for(PORT_MAPPING_RETRY_PERIOD)` will behave as intended.\r\n\r\nSetting `g_mapport_target_proto` variable to `MapPortProto::NONE` also causes shutting off port mapping entirely.\r\n\r\n",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-22T10:51:02Z",
      "diff_hunk" : "@@ -0,0 +1,322 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+static MapPortProto g_mapport_current_proto = MapPortProto::NONE;\n+static unsigned int g_mapport_target_proto = g_mapport_current_proto;\n+static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD = std::chrono::minutes(20);\n+static constexpr auto PORT_MAPPING_RETRY_PERIOD = std::chrono::minutes(5);\n+\n+#ifdef USE_NATPMP\n+static uint16_t g_mapport_external_port = 0;\n+static bool NatpmpInit(natpmp_t* natpmp)\n+{\n+    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r_init == 0) return true;\n+    LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r_init);\n+    return false;\n+}\n+\n+static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n+{\n+    const int r_send = sendpublicaddressrequest(natpmp);\n+    if (r_send == 2 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            external_ipv4_addr = response.pnu.publicaddress.addr;\n+            return true;\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n+{\n+    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n+    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n+    if (r_send == 12 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            auto pm = response.pnu.newportmapping;\n+            if (private_port == pm.privateport && pm.lifetime > 0) {\n+                g_mapport_current_proto = MapPortProto::NAT_PMP;\n+                g_mapport_external_port = pm.mappedpublicport;\n+                const CService external{external_ipv4_addr, pm.mappedpublicport};\n+                if (!external_ip_discovered && fDiscover) {\n+                    AddLocal(external, LOCAL_MAPPED);\n+                    external_ip_discovered = true;\n+                }\n+\n+                LogPrintf(\"NAT-PMP: Port mapping successful. External address = %s\\n\", external.ToString());\n+                return true;\n+            } else {\n+                LogPrintf(\"NAT-PMP: Port mapping failed.\\n\");\n+            }\n+\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool ThreadNatpmp()\n+{\n+    bool ret = false;\n+    natpmp_t natpmp;\n+    struct in_addr external_ipv4_addr;\n+    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n+        bool external_ip_discovered = false;\n+        const uint16_t private_port = GetListenPort();\n+        g_mapport_interrupt.reset();\n+        do {\n+            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n+        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        const int r_send = sendnewportmappingrequest(&natpmp, NATPMP_PROTOCOL_TCP, private_port, g_mapport_external_port, /* remove a port mapping */ 0);\n+        g_mapport_external_port = 0;\n+        if (r_send == 12 /* OK */) {\n+            LogPrintf(\"NAT-PMP: Port mapping removed successfully.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: sendnewportmappingrequest(0) failed with %d error.\\n\", r_send);\n+        }\n+    }\n+\n+    closenatpmp(&natpmp);\n+    return ret;\n+}\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+static bool ThreadUpnp()\n+{\n+    bool ret = false;\n+    std::string port = strprintf(\"%u\", GetListenPort());\n+    const char * multicastif = nullptr;\n+    const char * minissdpdpath = nullptr;\n+    struct UPNPDev * devlist = nullptr;\n+    char lanaddr[64];\n+\n+    int error = 0;\n+#if MINIUPNPC_API_VERSION < 14\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, &error);\n+#else\n+    devlist = upnpDiscover(2000, multicastif, minissdpdpath, 0, 0, 2, &error);\n+#endif\n+\n+    struct UPNPUrls urls;\n+    struct IGDdatas data;\n+    int r;\n+\n+    r = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr));\n+    if (r == 1)\n+    {\n+        if (fDiscover) {\n+            char externalIPAddress[40];\n+            r = UPNP_GetExternalIPAddress(urls.controlURL, data.first.servicetype, externalIPAddress);\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                LogPrintf(\"UPnP: GetExternalIPAddress() returned %d\\n\", r);\n+            } else {\n+                if (externalIPAddress[0]) {\n+                    CNetAddr resolved;\n+                    if (LookupHost(externalIPAddress, resolved, false)) {\n+                        LogPrintf(\"UPnP: ExternalIPAddress = %s\\n\", resolved.ToString());\n+                        AddLocal(resolved, LOCAL_MAPPED);\n+                    }\n+                } else {\n+                    LogPrintf(\"UPnP: GetExternalIPAddress failed.\\n\");\n+                }\n+            }\n+        }\n+\n+        std::string strDesc = PACKAGE_NAME \" \" + FormatFullVersion();\n+\n+        g_mapport_interrupt.reset();\n+        do {\n+            r = UPNP_AddPortMapping(urls.controlURL, data.first.servicetype, port.c_str(), port.c_str(), lanaddr, strDesc.c_str(), \"TCP\", 0, \"0\");\n+\n+            if (r != UPNPCOMMAND_SUCCESS) {\n+                ret = false;\n+                LogPrintf(\"AddPortMapping(%s, %s, %s) failed with code %d (%s)\\n\", port, port, lanaddr, r, strupnperror(r));\n+                break;\n+            } else {\n+                ret = true;\n+                g_mapport_current_proto = MapPortProto::UPNP;\n+                LogPrintf(\"UPnP Port Mapping successful.\\n\");\n+            }\n+        } while (g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+\n+        r = UPNP_DeletePortMapping(urls.controlURL, data.first.servicetype, port.c_str(), \"TCP\", 0);\n+        LogPrintf(\"UPNP_DeletePortMapping() returned: %d\\n\", r);\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        FreeUPNPUrls(&urls);\n+    } else {\n+        LogPrintf(\"No valid UPnP IGDs found\\n\");\n+        freeUPNPDevlist(devlist); devlist = nullptr;\n+        if (r != 0)\n+            FreeUPNPUrls(&urls);\n+    }\n+\n+    return ret;\n+}\n+#endif // #ifdef USE_UPNP\n+\n+static void ThreadMapPort()\n+{\n+    bool ok;\n+    do {\n+        ok = false;\n+\n+#ifdef USE_NATPMP\n+        if (g_mapport_target_proto & MapPortProto::NAT_PMP) {\n+            ok = ThreadNatpmp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+        if (g_mapport_target_proto & MapPortProto::UPNP) {\n+            ok = ThreadUpnp();\n+            if (ok) continue;\n+        }\n+#endif // #ifdef USE_UPNP\n+\n+        if (g_mapport_target_proto == MapPortProto::NONE) {\n+            g_mapport_current_proto = MapPortProto::NONE;\n+            return;\n+        }\n+\n+    } while (ok || g_mapport_interrupt.sleep_for(PORT_MAPPING_RETRY_PERIOD));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382904239",
      "id" : 382904239,
      "in_reply_to_id" : 382751074,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjkwNDIzOQ==",
      "original_commit_id" : "dd3229e7af8563c69d26955c4207f73ae1d3bc94",
      "original_position" : 254,
      "path" : "src/mapport.cpp",
      "position" : 257,
      "pull_request_review_id" : 363022932,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T00:48:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382904239",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Yes, but UPnP is reliably using the same/requested port if it works.",
      "created_at" : "2020-02-22T16:00:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-589969568",
      "id" : 589969568,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTk2OTU2OA==",
      "updated_at" : "2020-02-22T16:00:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589969568",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Updated dd3229e7af8563c69d26955c4207f73ae1d3bc94 -> d9ecda8fa0ebce5b6da972691b19f4425164ae43 ([pr18077.11](https://github.com/hebasto/bitcoin/commits/pr18077.11) -> [pr18077.12](https://github.com/hebasto/bitcoin/commits/pr18077.12), [compare](https://github.com/hebasto/bitcoin/compare/pr18077.11..pr18077.12)):\r\n\r\n- UPnP is prioritized (as @luke-jr suggested)\r\n- a note about possible random external port number is added to the NAT-PMP tooltip\r\n- commits are split and reordered to make review easier, I hope",
      "created_at" : "2020-02-23T01:00:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#issuecomment-590014625",
      "id" : 590014625,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18077",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5MDAxNDYyNQ==",
      "updated_at" : "2020-02-23T01:00:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/590014625",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382954341"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382954341"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@luke-jr \r\n> This should be reset outside of the protocol-specific functions, or else we could end up with a race.\r\n\r\nLooking into the `CThreadInterrupt` class implementation I couldn't see possibilities for a race.\r\n\r\nWhat did I miss?",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-23T01:08:27Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <mapport.h>\n+\n+#include <clientversion.h>\n+#include <logging.h>\n+#include <net.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <threadinterrupt.h>\n+#include <util/system.h>\n+\n+#ifdef USE_NATPMP\n+#include <natpmp.h>\n+#ifdef WIN32\n+#include <winsock2.h>\n+#else\n+#include <netinet/in.h>\n+#endif // #ifdef WIN32\n+#endif // #ifdef USE_NATPMP\n+\n+#ifdef USE_UPNP\n+#include <miniupnpc/miniupnpc.h>\n+#include <miniupnpc/upnpcommands.h>\n+#include <miniupnpc/upnperrors.h>\n+// The minimum supported miniUPnPc API version is set to 10. This keeps compatibility\n+// with Ubuntu 16.04 LTS and Debian 8 libminiupnpc-dev packages.\n+static_assert(MINIUPNPC_API_VERSION >= 10, \"miniUPnPc API version >= 10 assumed\");\n+#endif // #ifdef USE_UPNP\n+\n+#include <atomic>\n+#include <cassert>\n+#include <chrono>\n+#include <functional>\n+#include <string>\n+#include <thread>\n+\n+#if defined(USE_NATPMP) || defined(USE_UPNP)\n+static CThreadInterrupt g_mapport_interrupt;\n+static std::thread g_mapport_thread;\n+static std::atomic_uint g_mapport_target_proto{MapPortProto::NONE};\n+static std::atomic<MapPortProto> g_mapport_current_proto{MapPortProto::NONE};\n+static constexpr auto PORT_MAPPING_REANNOUNCE_PERIOD = std::chrono::minutes(20);\n+static constexpr auto PORT_MAPPING_RETRY_PERIOD = std::chrono::minutes(5);\n+\n+#ifdef USE_NATPMP\n+static uint16_t g_mapport_external_port = 0;\n+static bool NatpmpInit(natpmp_t* natpmp)\n+{\n+    const int r_init = initnatpmp(natpmp, /* detect gateway automatically */ 0, /* forced gateway - NOT APPLIED*/ 0);\n+    if (r_init == 0) return true;\n+    LogPrintf(\"NAT-PMP: initnatpmp() failed with %d error.\\n\", r_init);\n+    return false;\n+}\n+\n+static bool NatpmpDiscover(natpmp_t* natpmp, struct in_addr& external_ipv4_addr)\n+{\n+    const int r_send = sendpublicaddressrequest(natpmp);\n+    if (r_send == 2 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            external_ipv4_addr = response.pnu.publicaddress.addr;\n+            return true;\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for public address failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendpublicaddressrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool NatpmpMapping(natpmp_t* natpmp, const struct in_addr& external_ipv4_addr, uint16_t private_port, bool& external_ip_discovered)\n+{\n+    const uint16_t suggested_external_port = g_mapport_external_port ? g_mapport_external_port : private_port;\n+    const int r_send = sendnewportmappingrequest(natpmp, NATPMP_PROTOCOL_TCP, private_port, suggested_external_port, 3600 /*seconds*/);\n+    if (r_send == 12 /* OK */) {\n+        int r_read;\n+        natpmpresp_t response;\n+        do {\n+            r_read = readnatpmpresponseorretry(natpmp, &response);\n+        } while (r_read == NATPMP_TRYAGAIN);\n+\n+        if (r_read == 0) {\n+            auto pm = response.pnu.newportmapping;\n+            if (private_port == pm.privateport && pm.lifetime > 0) {\n+                g_mapport_external_port = pm.mappedpublicport;\n+                const CService external{external_ipv4_addr, pm.mappedpublicport};\n+                if (!external_ip_discovered && fDiscover) {\n+                    AddLocal(external, LOCAL_MAPPED);\n+                    external_ip_discovered = true;\n+                }\n+\n+                LogPrintf(\"NAT-PMP: Port mapping successful. External address = %s\\n\", external.ToString());\n+                return true;\n+            } else {\n+                LogPrintf(\"NAT-PMP: Port mapping failed.\\n\");\n+            }\n+\n+        } else if (r_read == NATPMP_ERR_NOGATEWAYSUPPORT) {\n+            LogPrintf(\"NAT-PMP: The gateway does not support NAT-PMP.\\n\");\n+        } else {\n+            LogPrintf(\"NAT-PMP: readnatpmpresponseorretry() for port mapping failed with %d error.\\n\", r_read);\n+        }\n+\n+    } else {\n+        LogPrintf(\"NAT-PMP: sendnewportmappingrequest() failed with %d error.\\n\", r_send);\n+    }\n+\n+    return false;\n+}\n+\n+static bool ThreadNatpmp()\n+{\n+    bool ret = false;\n+    natpmp_t natpmp;\n+    struct in_addr external_ipv4_addr;\n+    if (NatpmpInit(&natpmp) && NatpmpDiscover(&natpmp, external_ipv4_addr)) {\n+        bool external_ip_discovered = false;\n+        const uint16_t private_port = GetListenPort();\n+        do {\n+            ret = NatpmpMapping(&natpmp, external_ipv4_addr, private_port, external_ip_discovered);\n+        } while (ret && g_mapport_interrupt.sleep_for(PORT_MAPPING_REANNOUNCE_PERIOD));\n+        g_mapport_interrupt.reset();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382954341",
      "id" : 382954341,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NDM0MQ==",
      "original_commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "original_position" : 139,
      "path" : "src/mapport.cpp",
      "position" : 139,
      "pull_request_review_id" : 363059461,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-23T01:08:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382954341",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382957249"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382957249"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This name is way too vague...",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-23T02:11:59Z",
      "diff_hunk" : "@@ -115,14 +117,39 @@ static void ThreadMapPort()\n     } while (g_upnp_interrupt.sleep_for(PORT_MAPPING_RETRY_PERIOD));\n }\n \n-void StartMapPort()\n+void StartThread()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382957249",
      "id" : 382957249,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NzI0OQ==",
      "original_commit_id" : "acb567e3eecf3e63e629c4bffca2124462142352",
      "original_position" : 21,
      "path" : "src/mapport.cpp",
      "position" : 260,
      "pull_request_review_id" : 363061187,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-24T17:22:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382957249",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382957368"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382957368"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`enum class`",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-23T02:14:54Z",
      "diff_hunk" : "@@ -12,7 +12,12 @@ static const bool DEFAULT_UPNP = USE_UPNP;\n static const bool DEFAULT_UPNP = false;\n #endif\n \n-void StartMapPort();\n+enum MapPortProto : unsigned int {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382957368",
      "id" : 382957368,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1NzM2OA==",
      "original_commit_id" : "acb567e3eecf3e63e629c4bffca2124462142352",
      "original_position" : 5,
      "path" : "src/mapport.h",
      "position" : 22,
      "pull_request_review_id" : 363061187,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-24T17:22:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382957368",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382959771"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382959771"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Are we sure the settings are changed *before* the signal? Or could it be in parallel and therefore a race?",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-23T03:09:27Z",
      "diff_hunk" : "@@ -50,6 +51,10 @@ OptionsDialog::OptionsDialog(QWidget *parent, bool enableWallet) :\n #ifndef USE_UPNP\n     ui->mapPortUpnp->setEnabled(false);\n #endif\n+    connect(this, &QDialog::accepted, [this](){\n+        QSettings settings;\n+        model->node().mapPort(settings.value(\"fUseUPnP\").toBool());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r382959771",
      "id" : 382959771,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1OTc3MQ==",
      "original_commit_id" : "2b0ba0cfe41a1260c75497114e5932d2b9da0d1c",
      "original_position" : 14,
      "path" : "src/qt/optionsdialog.cpp",
      "position" : null,
      "pull_request_review_id" : 363061187,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-24T17:22:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/382959771",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r383034794"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/383034794"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Pretty sure `a?b:c` requires `b` and `c` to have the same type.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-23T20:14:40Z",
      "diff_hunk" : "@@ -447,7 +447,12 @@ void SetupServerArgs()\n #endif\n #else\n     hidden_args.emplace_back(\"-upnp\");\n-#endif\n+#endif // #ifdef USE_UPNP\n+#ifdef USE_NATPMP\n+    gArgs.AddArg(\"-natpmp\", strprintf(\"Use NAT-PMP to map the listening port (default: %s)\", DEFAULT_NATPMP ? \"1 when listening and no -proxy\" : 0), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r383034794",
      "id" : 383034794,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNDc5NA==",
      "original_commit_id" : "de19f109c77790c06a3b92527a4780aa5d11b532",
      "original_position" : 7,
      "path" : "src/init.cpp",
      "position" : 38,
      "pull_request_review_id" : 363061187,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-24T17:22:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/383034794",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r383035036"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/383035036"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Pretty sure `a?b:c` requires `b` and `c` to have the same type.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-23T20:18:07Z",
      "diff_hunk" : "@@ -447,7 +447,12 @@ void SetupServerArgs()\n #endif\n #else\n     hidden_args.emplace_back(\"-upnp\");\n-#endif\n+#endif // #ifdef USE_UPNP\n+#ifdef USE_NATPMP\n+    gArgs.AddArg(\"-natpmp\", strprintf(\"Use NAT-PMP to map the listening port (default: %s)\", DEFAULT_NATPMP ? \"1 when listening and no -proxy\" : 0), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r383035036",
      "id" : 383035036,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzAzNTAzNg==",
      "original_commit_id" : "de19f109c77790c06a3b92527a4780aa5d11b532",
      "original_position" : 7,
      "path" : "src/init.cpp",
      "position" : 38,
      "pull_request_review_id" : 363061187,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-24T17:22:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/383035036",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r383494027"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/383494027"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> This name is way too vague...\r\n\r\nYeah... I'm not good at choosing English names, and will appreciate your suggestion.",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-24T20:23:07Z",
      "diff_hunk" : "@@ -115,14 +117,39 @@ static void ThreadMapPort()\n     } while (g_upnp_interrupt.sleep_for(PORT_MAPPING_RETRY_PERIOD));\n }\n \n-void StartMapPort()\n+void StartThread()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r383494027",
      "id" : 383494027,
      "in_reply_to_id" : 382957249,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5NDAyNw==",
      "original_commit_id" : "acb567e3eecf3e63e629c4bffca2124462142352",
      "original_position" : 21,
      "path" : "src/mapport.cpp",
      "position" : 260,
      "pull_request_review_id" : 363675606,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-24T20:23:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/383494027",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r383496750"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/383496750"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It will require to define bitwise operators which are used here:\r\nhttps://github.com/bitcoin/bitcoin/blob/d9ecda8fa0ebce5b6da972691b19f4425164ae43/src/mapport.cpp#L297-L304\r\n\r\nMaybe in follow-up?",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-24T20:29:09Z",
      "diff_hunk" : "@@ -12,7 +12,12 @@ static const bool DEFAULT_UPNP = USE_UPNP;\n static const bool DEFAULT_UPNP = false;\n #endif\n \n-void StartMapPort();\n+enum MapPortProto : unsigned int {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r383496750",
      "id" : 383496750,
      "in_reply_to_id" : 382957368,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5Njc1MA==",
      "original_commit_id" : "acb567e3eecf3e63e629c4bffca2124462142352",
      "original_position" : 5,
      "path" : "src/mapport.h",
      "position" : 22,
      "pull_request_review_id" : 363678930,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-24T20:29:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/383496750",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r383498346"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/383498346"
         }
      },
      "author_association" : "MEMBER",
      "body" : "StartThreadMapPort maybe",
      "commit_id" : "d9ecda8fa0ebce5b6da972691b19f4425164ae43",
      "created_at" : "2020-02-24T20:32:51Z",
      "diff_hunk" : "@@ -115,14 +117,39 @@ static void ThreadMapPort()\n     } while (g_upnp_interrupt.sleep_for(PORT_MAPPING_RETRY_PERIOD));\n }\n \n-void StartMapPort()\n+void StartThread()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18077#discussion_r383498346",
      "id" : 383498346,
      "in_reply_to_id" : 382957249,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5ODM0Ng==",
      "original_commit_id" : "acb567e3eecf3e63e629c4bffca2124462142352",
      "original_position" : 21,
      "path" : "src/mapport.cpp",
      "position" : 260,
      "pull_request_review_id" : 363680997,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18077",
      "updated_at" : "2020-02-24T20:32:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/383498346",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   }
]
