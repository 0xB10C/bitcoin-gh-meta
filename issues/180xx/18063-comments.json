[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#17566](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17566.html) (Switch to weight units for all feerates computation by darosior)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2020-02-03T23:41:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18063#issuecomment-581672987",
      "id" : 581672987,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18063",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4MTY3Mjk4Nw==",
      "updated_at" : "2020-02-03T23:41:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/581672987",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18063#discussion_r377263645"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18063"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/377263645"
         }
      },
      "author_association" : "MEMBER",
      "body" : "From reading this code, it looks like if you have a hit in the cache, then you wouldn't end up adding `grand_child_it` to `update_cache`; you'd just add `grand_child_it`'s descendants?   That looks like a bug, though I haven't written a test to try to demonstrate it.\r\n\r\nI know the cache goes away in the next commit, so assuming that makes sense then this may not be worth fixing (versus just squashing the two commits together), but I think it'd just be a two-line fix, if my understanding is correct?",
      "commit_id" : "ad29e7719f364fa520602272f8c23abded7ae301",
      "created_at" : "2020-02-10T19:17:36Z",
      "diff_hunk" : "@@ -57,48 +57,69 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const std::set<uint256>& exclude)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    const CTxMemPool::setEntries& direct_children = GetMemPoolChildren(update_it);\n+    // set up the update_cache to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction)\n+    vecEntries update_cache;\n+    update_cache.reserve(direct_children.size());\n+    // mark every direct_child as visited so that we don't accidentally re-add them\n+    // to the cache in the grandchild is child case\n+    for (const txiter direct_child : direct_children) {\n+        update_cache.emplace_back(direct_child);\n+        visited(direct_child);\n+    }\n+    // already_traversed index keeps track of the elements that we've\n+    // already expanded. If index is < already_traversed, we've walked it.\n+    // If index is >= already_traversed, we need to walk it.\n+    // If already_traversed >= update_cache.size(), we're finished.\n+    for (size_t already_traversed = 0; already_traversed < update_cache.size(); /* modified in loop body */) {\n+        // rotate the back() to behind already_traversed\n+        const txiter child_it = update_cache.back();\n+        std::swap(update_cache[already_traversed++], update_cache.back());\n+\n+        // N.B. grand_children may also be children\n+        const CTxMemPool::setEntries& grand_children = GetMemPoolChildren(child_it);\n+        for (const txiter grand_child_it : grand_children) {\n+            if (visited(grand_child_it)) continue;\n+            cacheMap::iterator cached_great_grand_children = cache.find(grand_child_it);\n+            if (cached_great_grand_children != cache.end()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18063#discussion_r377263645",
      "id" : 377263645,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI2MzY0NQ==",
      "original_commit_id" : "89a50ce5cb022332d3381c9b5588e1c2f0f473c6",
      "original_position" : 49,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 356194912,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18063",
      "updated_at" : "2020-02-10T19:45:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/377263645",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> The cache was an optimization to limit re-traversal in UpdateForDescendants. But because we know that descendants limit limits the total number of descendants, this actually doesn't help that much. There are some common cases where having a CacheMap might be faster, but an adversary can trivially construct a worst-case example that causes equal behavior with or without a cachemap. For example, a transaction with N/2 children which each have N/2 outputs that get spent by N/2 grandchildren will cause the parent to iterate over N^2 entries with or without CacheMap. Post Epochs, UpdateForDescendants is sufficiently cheap such that the cachemap is just extra memory overhead.\r\n\r\nI've been thinking about this again, trying to remember the motivation here.  I think the concern is that when you're adding back transactions from a block, you have no guarantees for what kinds of chains could exist in that block.  For instance, maybe you have a block with 4000 transactions that consist of each transaction being a child of the one preceding it?  In that situation, it seems like caching the results as you go could be faster than rewalking each time.\r\n\r\nI can try to come up with some adversarial examples and benchmark them.  It's not totally obvious what to be optimizing for; I imagine that in the common case having no cache is best, but limiting worst-case behavior might be the better metric here (so that a reorg-capable-attacker isn't sidelining honest hashpower through tricks like this).",
      "created_at" : "2020-02-10T20:12:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18063#issuecomment-584330983",
      "id" : 584330983,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18063",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4NDMzMDk4Mw==",
      "updated_at" : "2020-02-10T20:12:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/584330983",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18063#discussion_r377305680"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18063"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/377305680"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think you're correct about that. The fix is to include grand_child_it and then swap it into the already_traversed index if there is a hit.",
      "commit_id" : "ad29e7719f364fa520602272f8c23abded7ae301",
      "created_at" : "2020-02-10T20:44:31Z",
      "diff_hunk" : "@@ -57,48 +57,69 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const std::set<uint256>& exclude)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    const CTxMemPool::setEntries& direct_children = GetMemPoolChildren(update_it);\n+    // set up the update_cache to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction)\n+    vecEntries update_cache;\n+    update_cache.reserve(direct_children.size());\n+    // mark every direct_child as visited so that we don't accidentally re-add them\n+    // to the cache in the grandchild is child case\n+    for (const txiter direct_child : direct_children) {\n+        update_cache.emplace_back(direct_child);\n+        visited(direct_child);\n+    }\n+    // already_traversed index keeps track of the elements that we've\n+    // already expanded. If index is < already_traversed, we've walked it.\n+    // If index is >= already_traversed, we need to walk it.\n+    // If already_traversed >= update_cache.size(), we're finished.\n+    for (size_t already_traversed = 0; already_traversed < update_cache.size(); /* modified in loop body */) {\n+        // rotate the back() to behind already_traversed\n+        const txiter child_it = update_cache.back();\n+        std::swap(update_cache[already_traversed++], update_cache.back());\n+\n+        // N.B. grand_children may also be children\n+        const CTxMemPool::setEntries& grand_children = GetMemPoolChildren(child_it);\n+        for (const txiter grand_child_it : grand_children) {\n+            if (visited(grand_child_it)) continue;\n+            cacheMap::iterator cached_great_grand_children = cache.find(grand_child_it);\n+            if (cached_great_grand_children != cache.end()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18063#discussion_r377305680",
      "id" : 377305680,
      "in_reply_to_id" : 377263645,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzMwNTY4MA==",
      "original_commit_id" : "89a50ce5cb022332d3381c9b5588e1c2f0f473c6",
      "original_position" : 49,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 356249080,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18063",
      "updated_at" : "2020-02-10T20:44:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/377305680",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   }
]
