[
   {
      "body" : "Some ideas for additions:\r\n- Non-fee total output amount\r\n- Coinbase reward\r\n- Money supply including this block\r\n- Transaction weight `txweight` (it can be derived from existing fields, however)\r\n\r\nI would prefer to see both `time` and `mediantime` returned, since they are available.\r\n\r\nShould we return non-independent fields, such as `avgfee` when also including `totalfee` and `txs`?\r\n\r\nI find that for bitcoin-related data, the median is often more useful than the average of a distribution. Including `medianweight`, `medianfee`, `medianfeerate`, `medianoutput` etc would expose these useful quantities to the user.",
      "created_at" : "2017-07-07T15:03:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313707397",
      "id" : 313707397,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T15:03:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313707397",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1562417?v=3",
         "events_url" : "https://api.github.com/users/clarkmoody/events{/privacy}",
         "followers_url" : "https://api.github.com/users/clarkmoody/followers",
         "following_url" : "https://api.github.com/users/clarkmoody/following{/other_user}",
         "gists_url" : "https://api.github.com/users/clarkmoody/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/clarkmoody",
         "id" : 1562417,
         "login" : "clarkmoody",
         "organizations_url" : "https://api.github.com/users/clarkmoody/orgs",
         "received_events_url" : "https://api.github.com/users/clarkmoody/received_events",
         "repos_url" : "https://api.github.com/users/clarkmoody/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/clarkmoody/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/clarkmoody/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/clarkmoody"
      }
   },
   {
      "body" : "> but once written, why not keep it?\r\n\r\nBecause more code => more bugs and more maintenance effort. I prefer:\r\n\r\nIf it's not really needed, why add it?\r\n\r\nThis is perhaps a nice-to-have, but since #8704, `getblock` can return all transactions in a block (without requiring `txindex`). Those can then be parsed and analysed offline.\r\n\r\nIs there a compelling use-case I'm missing here? This seems like a feature only a small subset of users would be interested in, in which case an offline tools seems more appropriate.\r\n\r\nSorry - not meaning to be negative, but my default reaction to new RPCs/arguments tends towards NACK unless I can see a compelling and widespread use-case.",
      "created_at" : "2017-07-07T15:28:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313714215",
      "id" : 313714215,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T15:28:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313714215",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1063656?v=3",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "body" : "> This is perhaps a nice-to-have, but since #8704, getblock can return all transactions in a block (without requiring txindex). Those can then be parsed and analysed offline.\r\n\r\nThis code pulls each transaction input's previous outpoint in order to compute transaction fees. Replicating that in RPC would require thousands of calls for most blocks.",
      "created_at" : "2017-07-07T15:50:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313720092",
      "id" : 313720092,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T15:50:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313720092",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1562417?v=3",
         "events_url" : "https://api.github.com/users/clarkmoody/events{/privacy}",
         "followers_url" : "https://api.github.com/users/clarkmoody/followers",
         "following_url" : "https://api.github.com/users/clarkmoody/following{/other_user}",
         "gists_url" : "https://api.github.com/users/clarkmoody/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/clarkmoody",
         "id" : 1562417,
         "login" : "clarkmoody",
         "organizations_url" : "https://api.github.com/users/clarkmoody/orgs",
         "received_events_url" : "https://api.github.com/users/clarkmoody/received_events",
         "repos_url" : "https://api.github.com/users/clarkmoody/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/clarkmoody/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/clarkmoody/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/clarkmoody"
      }
   },
   {
      "body" : "> This code pulls each transaction input's previous outpoint\r\n\r\nAh yes, of course. Concept ACK in that case. Doing this with `getblock` / `getrawtransaction` is infeasible.",
      "created_at" : "2017-07-07T15:53:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313720976",
      "id" : 313720976,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T15:53:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313720976",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1063656?v=3",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "body" : "> Because more code => more bugs and more maintenance effort. I prefer:\r\n\r\nSure, but I mean, removing for example the avgfee or avgfeerate won't  safe much code or testing code, just a few lines. Forget I said this, if there's specific functions to remove because nobody will want them, let's remove those and focus on the ones people want. Adding specific things only a few people want can also happen in their own branches, so it's no big deal.\r\n\r\nThe only use case is gather statistics, presumably to plot things, create charts. That is, at least, compelling to me, but I don't think that will have widespread usage. I also don't think all rpc calls have it. Is getchaintxstats, for example, a widespread use case?\r\n\r\nIf that's enough reason not to merge this, it's fine, I can maintain it as a separate branch that I periodically rebase, it is simple enough, so that won't be a big deal. On the other hand, if I can get it reviewed and merged it'll be less work for me in the long run and I also get the review.\r\n\r\n> Non-fee total output amount\r\n> Coinbase reward\r\n\r\nSounds good.\r\n\r\n> Money supply including this block\r\n\r\nMhmm, it would be simpler to calculate here from start to end here than from genesis. But it's pretty trivial to write a function in any language that returns the total supply for a given height without access to any historic data. Unless you are talking about discounting op_return outputs or something like that. I don't think this is very interesting here. Perhaps that can be done in getchaintxstats ?\r\n\r\n> Transaction weight txweight (it can be derived from existing fields, however)\r\n\r\nIn fact I'm using weight for everything. I should s/size/weight/ and probably also show size separately. \r\nMaybe separate feerates in by weight and serialize size? I don't know...\r\n\r\n> I would prefer to see both time and mediantime returned, since they are available.\r\n\r\nYeah, the mediantime takes a little bit longer to be calculated but not much and one can always disable anything. In fact, the height and time shouldn't be treated in any special way for being \"the x axis\" and should be allowed to be disabled like the rest.\r\n\r\n> Should we return non-independent fields, such as avgfee when also including totalfee and txs?\r\n\r\nThis is a good question. This is mostly what I meant by \"why not if it's this easy?\".\r\nBut yeah, I guess non-independent are good candidates to be removed.\r\n\r\nre median: yeah, that sounds interesting too, good idea!\r\n",
      "created_at" : "2017-07-07T16:29:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313729916",
      "id" : 313729916,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T16:30:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313729916",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "> Mhmm, it would be simpler to calculate here from start to end here than from genesis. But it's pretty trivial to write a function in any language that returns the total supply for a given height without access to any historic data. Unless you are talking about discounting op_return outputs or something like that. I don't think this is very interesting here. Perhaps that can be done in getchaintxstats ?\r\n\r\nI was thinking of the more trivial version, rather than the `supply - provably_unspendable` version, so keeping that as external code makes more sense. Maintaining the sum of spendable outputs against block height is a much more ambitious idea, and it may make sense in the future. However, it is probably out of scope of this PR.",
      "created_at" : "2017-07-07T16:37:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313731922",
      "id" : 313731922,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-07T16:37:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313731922",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1562417?v=3",
         "events_url" : "https://api.github.com/users/clarkmoody/events{/privacy}",
         "followers_url" : "https://api.github.com/users/clarkmoody/followers",
         "following_url" : "https://api.github.com/users/clarkmoody/following{/other_user}",
         "gists_url" : "https://api.github.com/users/clarkmoody/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/clarkmoody",
         "id" : 1562417,
         "login" : "clarkmoody",
         "organizations_url" : "https://api.github.com/users/clarkmoody/orgs",
         "received_events_url" : "https://api.github.com/users/clarkmoody/received_events",
         "repos_url" : "https://api.github.com/users/clarkmoody/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/clarkmoody/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/clarkmoody/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/clarkmoody"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126259127"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126259127"
         }
      },
      "body" : "Remove.",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-07T22:37:58Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126259127",
      "id" : 126259127,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 149,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126259127",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126260721"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126260721"
         }
      },
      "body" : "```cpp\r\nstd::set<std::string> allowed_plot_values = {\"minfee\", \"maxfee\", \"...\"};\r\n```",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-07T22:52:25Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126260721",
      "id" : 126260721,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 150,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126260721",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126260851"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126260851"
         }
      },
      "body" : "Remove.",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-07T22:53:29Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126260851",
      "id" : 126260851,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 151,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126260851",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261000"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261000"
         }
      },
      "body" : "```cpp\r\n\"...\" + boost::join(allowed_plot_values, \",\")\r\n```",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-07T22:54:32Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261000",
      "id" : 126261000,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 160,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261000",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261085"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261085"
         }
      },
      "body" : "Missing result example.",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-07T22:55:17Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261085",
      "id" : 126261085,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 163,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261085",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261101"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261101"
         }
      },
      "body" : "Duplicate.",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-07T22:55:25Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261101",
      "id" : 126261101,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 166,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261101",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261710"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261710"
         }
      },
      "body" : "```cpp\r\nstd::set<std::string> plot_values;\r\nif (request.params.size() > 2) {\r\n  boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\r\n\r\n  // only validate in this case\r\n  // ... \r\n} else {\r\n  plot_values = allowed_plot_values;\r\n}\r\n```",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-07T23:00:26Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+    } else {\n+        end = chainActive.Height();\n+    }\n+    if (end < 0 || end > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+    }\n+\n+    std::string str_plot_values = str_allowed_plot_values;\n+    if (request.params.size() > 2) {\n+        str_plot_values = request.params[2].get_str();\n+    }\n+    std::vector<std::string> plot_values;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261710",
      "id" : 126261710,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 190,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126261710",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126262049"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126262049"
         }
      },
      "body" : "Remove.",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-07T23:03:29Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126262049",
      "id" : 126262049,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 137,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126262049",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126262450"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126262450"
         }
      },
      "body" : "```cpp\r\nif (allowed_plot_values.count(plot_value) == 0) {\r\n```",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-07T23:07:37Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+    } else {\n+        end = chainActive.Height();\n+    }\n+    if (end < 0 || end > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+    }\n+\n+    std::string str_plot_values = str_allowed_plot_values;\n+    if (request.params.size() > 2) {\n+        str_plot_values = request.params[2].get_str();\n+    }\n+    std::vector<std::string> plot_values;\n+    boost::split(plot_values, str_plot_values, boost::is_any_of(\",\"));\n+    for (const std::string plot_value : plot_values) {\n+        if (!IsAllowedPlotValue(plot_value, allowed_plot_values)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126262450",
      "id" : 126262450,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 193,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48733116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126262450",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126267402"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126267402"
         }
      },
      "body" : "One is HelpExampleCli and the other is HelpExampleRpc",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-08T00:08:10Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126267402",
      "id" : 126267402,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 166,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48741927,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126267402",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126267869"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126267869"
         }
      },
      "body" : "Ops sorry, overlooked it.",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-08T00:16:40Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126267869",
      "id" : 126267869,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 166,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48742472,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126267869",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126269648"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126269648"
         }
      },
      "body" : "duh, I was so much over-complicating things so much for no good reason...thank you!",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-08T00:57:06Z",
      "diff_hunk" : "@@ -1532,6 +1539,178 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static CAmount RpcGetTxFee(const CTransaction& tx)\n+{\n+    CAmount in_amount_total = 0;\n+\n+    for (const CTxIn& in : tx.vin) {\n+        CTransactionRef tx_in;\n+        uint256 hashBlock;\n+        if (!GetTransaction(in.prevout.hash, tx_in, Params().GetConsensus(), hashBlock, true)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+                : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+        }\n+        in_amount_total += tx_in->vout[in.prevout.n].nValue;\n+    }\n+\n+    return in_amount_total - tx.GetValueOut();\n+}\n+\n+static void UpdateBlockStats(const CBlock& block, std::vector<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    CAmount min = MAX_MONEY;\n+    CAmount max = 0;\n+    CAmount total = 0;\n+    CFeeRate minfeerate = CFeeRate(MAX_MONEY, 1);\n+    CFeeRate maxfeerate = CFeeRate(0);\n+    int64_t total_weight = 0;\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        inputs += tx->vin.size();\n+        outputs += tx->vout.size();\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+\n+        CAmount txfee = RpcGetTxFee(*tx);\n+        assert(MoneyRange(txfee));\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+        CFeeRate feerate = CFeeRate(txfee, weight);\n+        for (const std::string& plot_value : plot_values) {\n+            if (plot_value == \"minfee\") {\n+                min = std::min(min, txfee);\n+            } else if (plot_value == \"maxfee\") {\n+                max = std::max(max, txfee);\n+            } else if (plot_value == \"totalfee\") {\n+                total += txfee;\n+            } else if (plot_value == \"minfeerate\") {\n+                minfeerate = std::min(minfeerate, feerate);\n+            } else if (plot_value == \"maxfeerate\") {\n+                maxfeerate = std::max(maxfeerate, feerate);\n+            }\n+        }\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((min == MAX_MONEY) ? 0 : min);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(max);\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(total);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == CFeeRate(MAX_MONEY, 1)) ? CFeeRate(0).GetFee(1) : minfeerate.GetFee(1));\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate.GetFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? total / (block.vtx.size() - 1) : 0);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(total, total_weight).GetFee(1));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        }\n+    }\n+}\n+\n+static bool IsAllowedPlotValue(const std::string& plot_value, std::vector<std::string>& allowed_plot_values)\n+{\n+    for (const std::string& allowed_plot_value : allowed_plot_values) {\n+        if (allowed_plot_value == plot_value) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+UniValue getperblockstats(const JSONRPCRequest& request)\n+{\n+    std::string str_allowed_plot_values = \"minfee,maxfee,totalfee,minfeerate,maxfeerate,avgfee,avgfeerate,txs,ins,outs\";\n+    std::vector<std::string> allowed_plot_values;\n+    boost::split(allowed_plot_values, str_allowed_plot_values, boost::is_any_of(\",\"));\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getperblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + str_allowed_plot_values +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getperblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getperblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+    } else {\n+        end = chainActive.Height();\n+    }\n+    if (end < 0 || end > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+    }\n+\n+    std::string str_plot_values = str_allowed_plot_values;\n+    if (request.params.size() > 2) {\n+        str_plot_values = request.params[2].get_str();\n+    }\n+    std::vector<std::string> plot_values;\n+    boost::split(plot_values, str_plot_values, boost::is_any_of(\",\"));\n+    for (const std::string plot_value : plot_values) {\n+        if (!IsAllowedPlotValue(plot_value, allowed_plot_values)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126269648",
      "id" : 126269648,
      "original_commit_id" : "53ea4dea6f4532f19cd61ca93d1f17be22ed4828",
      "original_position" : 193,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48744410,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126269648",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "Thanks again for the great feedback!\r\n\r\n@promag I think I solved all your nits except for https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126261101\r\n\r\n@clarkmoody I think I added most of your suggestions, explicitly excluding anything that involved accumulations neither from height=1 nor from height=start.\r\nThe former potentially implies a world of complexity and the latter can be trivially calculated on the visual side: I would completely discard any accumulator redundancy in this rpc beforehand.\r\n\r\nAnd for the rest of the redundancies, @jnewbery and @clarkmoody - thanks again for pointing it out -, it's never too late to remove them before merging like a trivial squash and it's never too soon to start saying which ones you would bikesay* out first. Also bikesay the names for the curves and even the order in the list (duplicated for c++ and python).\r\n\r\nIn the meantime, I embraced redundancy since, as said, it will be trivial for me to remove later. And also the pertinent optimizations to skip calculations when plot_values.count(\"minfee\") == 0 or actually only when the extra calculation is more expensive than the searching in plot_values which is a set of strings.\r\n\r\nFor example, we have blockfees, reward, subsidy, complying with consensus rule ```reward == blockfees + subsidy```. Only 2 of the 3 are necessary, at least one is redundant. My personal preference is removing either subsidy or reward or subsidy, but not blockfees. But at said once written there's no problem with me in just making sure their tests don't surprise me until we decide which ones didn't deserve it. \r\n\r\nWhich one seems bikesaying in principle. But not in this case. \r\nblockfees/total_fees serves for other calculations like avgfeerate. Let's not remove that one, just rename it.\r\n\r\nBut it is more interesting to propose new ones than to rename or vote for removal IMO. I believe the most interesting addition to this point was utxo_size_inc, which would welcomed some review from people who measures sizes more carefully like @sipa , since this doesn't use GetSerializeSize for Coin intentionally, independently of the optimization to read Coin if available in the utxo before calling RpcGetTx. I'm still not sure what to do with pre/post segwit feerates, does anybody care about the pre ones? which one needs the scale factor? none?\r\n\r\nREM CalculateTruncatedMedian doesn't need to be a template at this point, but there's no harm being static IMO\r\n\r\nEDIT: still some TODOs, mostly documentation and pending decisions\r\n",
      "created_at" : "2017-07-08T07:27:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313840344",
      "id" : 313840344,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-08T07:32:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313840344",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "@jtimon no problem. There are some nits to fix but I'll review more in depth later.",
      "created_at" : "2017-07-08T07:36:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-313840707",
      "id" : 313840707,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-08T07:36:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/313840707",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292902"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292902"
         }
      },
      "body" : "Drop `_`? Same below.",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-09T00:11:49Z",
      "diff_hunk" : "@@ -20,20 +20,22 @@ CFeeRate::CFeeRate(const CAmount& nFeePaid, size_t nBytes_)\n         nSatoshisPerK = 0;\n }\n \n-CAmount CFeeRate::GetFee(size_t nBytes_) const\n+CAmount CFeeRate::GetTruncatedFee(size_t nBytes_) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292902",
      "id" : 126292902,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 5,
      "path" : "src/policy/feerate.cpp",
      "position" : 5,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292902",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292910"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292910"
         }
      },
      "body" : "Keep argument order as `ReadBlockFromDisk`? Is there a convention for where the *output arguments* should be?",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-09T00:13:04Z",
      "diff_hunk" : "@@ -685,6 +686,22 @@ UniValue getblockheader(const JSONRPCRequest& request)\n     return blockheaderToJSON(pblockindex);\n }\n \n+static void ReadBlockCheckPruned(const CBlockIndex* pblockindex, CBlock& block)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292910",
      "id" : 126292910,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 12,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 12,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292910",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292958"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292958"
         }
      },
      "body" : "Nit, could sort only after `size == 1` case.",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-09T00:19:36Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126292958",
      "id" : 126292958,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 68,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126292958",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126457455"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126457455"
         }
      },
      "body" : "`static constexpr ...`",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-10T15:34:29Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126457455",
      "id" : 126457455,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 82,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126457455",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126457503"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126457503"
         }
      },
      "body" : "Remove empty line.",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-10T15:34:43Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126457503",
      "id" : 126457503,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 107,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126457503",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126462550"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126462550"
         }
      },
      "body" : "Remove.",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-10T15:51:49Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+        }\n+    } else {\n+        end = chainActive.Height();\n+    }\n+\n+    std::set<std::string> plot_values;\n+    if (request.params.size() > 2) {\n+        boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\n+\n+        for (const std::string& plot_value : plot_values) {\n+            if (valid_plot_values.count(plot_value) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid plot value %s\", plot_value));\n+            }\n+        }\n+    } else {\n+        plot_values = valid_plot_values;\n+    }\n+\n+    std::map<std::string, UniValue> map_stats;\n+    for (const std::string& plot_value : plot_values) {\n+        map_stats[plot_value] = UniValue(UniValue::VARR);\n+    }\n+\n+    CBlockIndex* pindex = chainActive[end];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126462550",
      "id" : 126462550,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 296,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 295,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126462550",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126462704"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126462704"
         }
      },
      "body" : "```cpp\r\nUpdateBlockStats(chainActive[i], ...);\r\n```",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-10T15:52:22Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+        }\n+    } else {\n+        end = chainActive.Height();\n+    }\n+\n+    std::set<std::string> plot_values;\n+    if (request.params.size() > 2) {\n+        boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\n+\n+        for (const std::string& plot_value : plot_values) {\n+            if (valid_plot_values.count(plot_value) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid plot value %s\", plot_value));\n+            }\n+        }\n+    } else {\n+        plot_values = valid_plot_values;\n+    }\n+\n+    std::map<std::string, UniValue> map_stats;\n+    for (const std::string& plot_value : plot_values) {\n+        map_stats[plot_value] = UniValue(UniValue::VARR);\n+    }\n+\n+    CBlockIndex* pindex = chainActive[end];\n+    for (int i = end; i >= start; i--) {\n+        UpdateBlockStats(pindex, plot_values, map_stats);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126462704",
      "id" : 126462704,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 298,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 297,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126462704",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126463400"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126463400"
         }
      },
      "body" : "Replace `plotvalues` with `stats`? Also, 3rd argument could be object `options`?",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-10T15:54:58Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126463400",
      "id" : 126463400,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 251,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 250,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126463400",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126463865"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126463865"
         }
      },
      "body" : "Nit, negative block could mean `end = height - end` to avoid early blocks (not new concept here I believe)?",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-10T15:56:31Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126463865",
      "id" : 126463865,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 271,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 270,
      "pull_request_review_id" : 48766531,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126463865",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126492736"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126492736"
         }
      },
      "body" : "Not that I know of, but your proposed change sounds good to me.",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-10T17:56:12Z",
      "diff_hunk" : "@@ -685,6 +686,22 @@ UniValue getblockheader(const JSONRPCRequest& request)\n     return blockheaderToJSON(pblockindex);\n }\n \n+static void ReadBlockCheckPruned(const CBlockIndex* pblockindex, CBlock& block)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126492736",
      "id" : 126492736,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 12,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 12,
      "pull_request_review_id" : 48982074,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126492736",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126493273"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126493273"
         }
      },
      "body" : "what's the gain? https://stackoverflow.com/a/41132221/935325 says it's the same...",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-10T17:58:25Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126493273",
      "id" : 126493273,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 82,
      "path" : "src/rpc/blockchain.cpp",
      "position" : null,
      "pull_request_review_id" : 48982680,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126493273",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126493852"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126493852"
         }
      },
      "body" : "This will be slightly less efficient, no?",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-10T18:00:48Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+        }\n+    } else {\n+        end = chainActive.Height();\n+    }\n+\n+    std::set<std::string> plot_values;\n+    if (request.params.size() > 2) {\n+        boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\n+\n+        for (const std::string& plot_value : plot_values) {\n+            if (valid_plot_values.count(plot_value) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid plot value %s\", plot_value));\n+            }\n+        }\n+    } else {\n+        plot_values = valid_plot_values;\n+    }\n+\n+    std::map<std::string, UniValue> map_stats;\n+    for (const std::string& plot_value : plot_values) {\n+        map_stats[plot_value] = UniValue(UniValue::VARR);\n+    }\n+\n+    CBlockIndex* pindex = chainActive[end];\n+    for (int i = end; i >= start; i--) {\n+        UpdateBlockStats(pindex, plot_values, map_stats);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126493852",
      "id" : 126493852,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 298,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 297,
      "pull_request_review_id" : 48983341,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126493852",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126494452"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126494452"
         }
      },
      "body" : "Mhmm, interesting. To be clear you mean start=-10 end=200 would be equivalent to start=190 end=200, right?\r\n",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-10T18:03:16Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126494452",
      "id" : 126494452,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 271,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 270,
      "pull_request_review_id" : 48984019,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126494452",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126494613"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126494613"
         }
      },
      "body" : "Isn't the string simpler?",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-10T18:03:56Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126494613",
      "id" : 126494613,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 251,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 250,
      "pull_request_review_id" : 48984210,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126494613",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126569538"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126569538"
         }
      },
      "body" : "Well, yes, conserving the old name only saves 1 line of extra disruption. But I guess if we're touching the variable name we should use the new style. just bytes?",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-11T00:28:26Z",
      "diff_hunk" : "@@ -20,20 +20,22 @@ CFeeRate::CFeeRate(const CAmount& nFeePaid, size_t nBytes_)\n         nSatoshisPerK = 0;\n }\n \n-CAmount CFeeRate::GetFee(size_t nBytes_) const\n+CAmount CFeeRate::GetTruncatedFee(size_t nBytes_) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126569538",
      "id" : 126569538,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 5,
      "path" : "src/policy/feerate.cpp",
      "position" : 5,
      "pull_request_review_id" : 49066057,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T08:16:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126569538",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126654629"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126654629"
         }
      },
      "body" : "No, I meant negative values are relative to the tip. To get the stats for the last 10 blocks you would pass start = -10 without querying the current block height.",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-11T10:45:53Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126654629",
      "id" : 126654629,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 271,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 270,
      "pull_request_review_id" : 49157689,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T10:45:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126654629",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126654771"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126654771"
         }
      },
      "body" : "Ignore `options` suggestion.",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-11T10:46:43Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126654771",
      "id" : 126654771,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 251,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 250,
      "pull_request_review_id" : 49157867,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T10:46:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126654771",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126655004"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126655004"
         }
      },
      "body" : "I guess it takes few more cycles but non critical code should be cleaner?",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-11T10:48:01Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+        }\n+    } else {\n+        end = chainActive.Height();\n+    }\n+\n+    std::set<std::string> plot_values;\n+    if (request.params.size() > 2) {\n+        boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\n+\n+        for (const std::string& plot_value : plot_values) {\n+            if (valid_plot_values.count(plot_value) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid plot value %s\", plot_value));\n+            }\n+        }\n+    } else {\n+        plot_values = valid_plot_values;\n+    }\n+\n+    std::map<std::string, UniValue> map_stats;\n+    for (const std::string& plot_value : plot_values) {\n+        map_stats[plot_value] = UniValue(UniValue::VARR);\n+    }\n+\n+    CBlockIndex* pindex = chainActive[end];\n+    for (int i = end; i >= start; i--) {\n+        UpdateBlockStats(pindex, plot_values, map_stats);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126655004",
      "id" : 126655004,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 298,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 297,
      "pull_request_review_id" : 49158135,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T10:48:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126655004",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3534524?v=3",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "body" : "Here are some images generated using this branch in combination with (WIP): https://github.com/jtimon/rpc-explorer\r\n\r\nGUI detail:\r\n\r\n![screenshot_plotter](https://user-images.githubusercontent.com/1008458/28092233-ed1cb2ca-6692-11e7-9374-38a98cd6c258.png)\r\n\r\nGUI detail zoom:\r\n\r\n![screenshot_plotter_zoom](https://user-images.githubusercontent.com/1008458/28092271-048e594a-6693-11e7-9572-81f80980a087.png)\r\n\r\nHide some:\r\n\r\n![plotter1](https://user-images.githubusercontent.com/1008458/28092276-083a4518-6693-11e7-815d-c45d0acbfc4d.png)\r\n\r\nHide more:\r\n\r\n![plotter2](https://user-images.githubusercontent.com/1008458/28092279-0ac02fd2-6693-11e7-87c5-84d230985d6c.png)\r\n\r\nFees:\r\n\r\n![plotterfees](https://user-images.githubusercontent.com/1008458/28092284-0d22c2a8-6693-11e7-937d-451bfe0c5da5.png)\r\n\r\nUtxo size increase:\r\n\r\n![plotter_utxo](https://user-images.githubusercontent.com/1008458/28092288-0f6bc3d4-6693-11e7-910e-b18e3bfa44a2.png)\r\n",
      "created_at" : "2017-07-11T21:47:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-314581913",
      "id" : 314581913,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-11T21:49:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/314581913",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126826779"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126826779"
         }
      },
      "body" : "Maybe. I'll wait for someone else to weight in since it doesn't seem a big deal either way. ",
      "commit_id" : "6b2b951862cd7bf06f58f04d92e2469199cd51f0",
      "created_at" : "2017-07-11T22:42:03Z",
      "diff_hunk" : "@@ -1532,6 +1539,262 @@ UniValue getchaintxstats(const JSONRPCRequest& request)\n     return ret;\n }\n \n+static void RpcGetTx(const uint256& hash, CTransactionRef& tx_out)\n+{\n+    uint256 hashBlock;\n+    if (!GetTransaction(hash, tx_out, Params().GetConsensus(), hashBlock, true)) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(fTxIndex ? \"No such mempool or blockchain transaction\"\n+          : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\"));\n+    }\n+}\n+\n+template<typename T>\n+static T CalculateTruncatedMedian(std::vector<T>& scores)\n+{\n+    T median;\n+    size_t size = scores.size();\n+    std::sort(scores.begin(), scores.end());\n+    if (size == 0) {\n+        median = 0;\n+    } else if (size == 1) {\n+        median = scores[0];\n+    } else if (size % 2 == 0) {\n+        median = (scores[size / 2 - 1] + scores[size / 2]) / 2;\n+    } else {\n+        median = scores[size / 2];\n+    }\n+    return median;\n+}\n+\n+// outpoint (needed for the utxo index) + nHeight + fCoinBase\n+static const size_t PER_UTXO_OVERHEAD = sizeof(COutPoint) + sizeof(uint32_t) + sizeof(bool);\n+\n+static void UpdateBlockStats(const CBlockIndex* pindex, std::set<std::string>& plot_values, std::map<std::string, UniValue>& map_stats)\n+{\n+    int64_t inputs = 0;\n+    int64_t outputs = 0;\n+    int64_t total_size = 0;\n+    int64_t total_weight = 0;\n+    int64_t utxo_size_inc = 0;\n+    CAmount total_out = 0;\n+    CAmount totalfee = 0;\n+    CAmount minfee = MAX_MONEY;\n+    CAmount maxfee = 0;\n+    CAmount minfeerate = MAX_MONEY;\n+    CAmount maxfeerate = 0;\n+    CAmount minfeerate_old = MAX_MONEY;\n+    CAmount maxfeerate_old = 0;\n+    std::vector<CAmount> fee_array;\n+    std::vector<CAmount> feerate_old_array;\n+    std::vector<CAmount> feerate_array;\n+\n+    CBlock block;\n+    ReadBlockCheckPruned(pindex, block);\n+\n+    for (const auto& tx : block.vtx) {\n+\n+        outputs += tx->vout.size();\n+        CAmount tx_total_out = 0;\n+        for (const CTxOut& out : tx->vout) {\n+            utxo_size_inc += GetSerializeSize(out, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+            tx_total_out += out.nValue;\n+        }\n+\n+        if (tx->IsCoinBase()) {\n+            continue;\n+        }\n+        // TODO decide with or without subsidy and/or block fees\n+        total_out += tx_total_out;\n+\n+        inputs += tx->vin.size(); // Don't count coinbase's fake input\n+        int64_t tx_size = tx->GetTotalSize();\n+        total_size += tx_size;\n+        int64_t weight = GetTransactionWeight(*tx);\n+        total_weight += weight;\n+\n+        CAmount tx_total_in = 0;\n+        for (const CTxIn& in : tx->vin) {\n+            CTransactionRef tx_in;\n+            RpcGetTx(in.prevout.hash, tx_in);\n+            CTxOut prevoutput = tx_in->vout[in.prevout.n];\n+\n+            tx_total_in += prevoutput.nValue;\n+            // TODO don't count provable spendable (OP_RETURN) as it doesn't belong in the utxo index\n+            utxo_size_inc -= GetSerializeSize(prevoutput, SER_NETWORK, PROTOCOL_VERSION) + PER_UTXO_OVERHEAD;\n+        }\n+        CAmount txfee = tx_total_in - tx_total_out;\n+        assert(MoneyRange(txfee));\n+        fee_array.push_back(txfee);\n+        totalfee += txfee;\n+        minfee = std::min(minfee, txfee);\n+        maxfee = std::max(maxfee, txfee);\n+\n+        CAmount feerate_old = CFeeRate(txfee, tx_size).GetTruncatedFee(1);\n+        feerate_old_array.push_back(feerate_old);\n+        // New feerate uses satoshis per weighted byte instead of per byte\n+        CAmount feerate = CFeeRate(txfee, weight).GetTruncatedFee(WITNESS_SCALE_FACTOR);\n+        feerate_array.push_back(feerate);\n+\n+        minfeerate = std::min(minfeerate, feerate);\n+        maxfeerate = std::max(maxfeerate, feerate);\n+        minfeerate_old = std::min(minfeerate_old, feerate_old);\n+        maxfeerate_old = std::max(maxfeerate_old, feerate_old);\n+    }\n+\n+    for (const std::string& plot_value : plot_values) {\n+        // Update map_stats\n+        if (plot_value == \"height\") {\n+            map_stats[plot_value].push_back((int64_t)pindex->nHeight);\n+        } else if (plot_value == \"time\") {\n+            map_stats[plot_value].push_back(pindex->GetBlockTime());\n+        } else if (plot_value == \"mediantime\") {\n+            map_stats[plot_value].push_back(pindex->GetMedianTimePast());\n+        } else if (plot_value == \"subsidy\") {\n+            map_stats[plot_value].push_back(GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"totalfee\") {\n+            map_stats[plot_value].push_back(totalfee);\n+        } else if (plot_value == \"reward\") {\n+            map_stats[plot_value].push_back(totalfee + GetBlockSubsidy(pindex->nHeight, Params().GetConsensus()));\n+        } else if (plot_value == \"txs\") {\n+            map_stats[plot_value].push_back((int64_t)block.vtx.size());\n+        } else if (plot_value == \"ins\") {\n+            map_stats[plot_value].push_back(inputs);\n+        } else if (plot_value == \"outs\") {\n+            map_stats[plot_value].push_back(outputs);\n+        } else if (plot_value == \"utxo_increase\") {\n+            map_stats[plot_value].push_back(outputs - inputs);\n+        } else if (plot_value == \"utxo_size_inc\") {\n+            map_stats[plot_value].push_back(utxo_size_inc);\n+        } else if (plot_value == \"total_size\") {\n+            map_stats[plot_value].push_back(total_size);\n+        } else if (plot_value == \"total_weight\") {\n+            map_stats[plot_value].push_back(total_weight);\n+        } else if (plot_value == \"total_out\") {\n+            map_stats[plot_value].push_back(total_out);\n+        } else if (plot_value == \"medianfee\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(fee_array));\n+        } else if (plot_value == \"medianfeerate\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_array));\n+        } else if (plot_value == \"medianfeerate_old\") {\n+            map_stats[plot_value].push_back(CalculateTruncatedMedian(feerate_old_array));\n+        } else if (plot_value == \"minfee\") {\n+            map_stats[plot_value].push_back((minfee == MAX_MONEY) ? 0 : minfee);\n+        } else if (plot_value == \"maxfee\") {\n+            map_stats[plot_value].push_back(maxfee);\n+        } else if (plot_value == \"minfeerate\") {\n+            map_stats[plot_value].push_back((minfeerate == MAX_MONEY) ? 0 : minfeerate);\n+        } else if (plot_value == \"minfeerate_old\") {\n+            map_stats[plot_value].push_back((minfeerate_old == MAX_MONEY) ? 0 : minfeerate_old);\n+        } else if (plot_value == \"maxfeerate\") {\n+            map_stats[plot_value].push_back(maxfeerate);\n+        } else if (plot_value == \"maxfeerate_old\") {\n+            map_stats[plot_value].push_back(maxfeerate_old);\n+        } else if (plot_value == \"avgfeerate\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_weight).GetTruncatedFee(WITNESS_SCALE_FACTOR));\n+        } else if (plot_value == \"avgfeerate_old\") {\n+            map_stats[plot_value].push_back(CFeeRate(totalfee, total_size).GetTruncatedFee(1));\n+        } else if (plot_value == \"avgfee\") {\n+            map_stats[plot_value].push_back((block.vtx.size() > 1) ? totalfee / (block.vtx.size() - 1) : 0);\n+        }\n+    }\n+}\n+\n+UniValue getblockstats(const JSONRPCRequest& request)\n+{\n+    std::set<std::string> valid_plot_values = {\n+        \"height\",\n+        \"time\",\n+        \"mediantime\",\n+        \"txs\",\n+        \"ins\",\n+        \"outs\",\n+        \"subsidy\",\n+        \"totalfee\",\n+        \"reward\",\n+        \"utxo_increase\",\n+        \"utxo_size_inc\",\n+        \"total_size\",\n+        \"total_weight\",\n+        \"total_out\",\n+        \"minfee\",\n+        \"maxfee\",\n+        \"medianfee\",\n+        \"medianfeerate\",\n+        \"medianfeerate_old\",\n+        \"minfeerate\",\n+        \"minfeerate_old\",\n+        \"maxfeerate\",\n+        \"maxfeerate_old\",\n+        \"avgfeerate\",\n+        \"avgfeerate_old\",\n+        \"avgfee\",\n+    };\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n+        throw std::runtime_error(\n+            \"getblockstats ( nStart nEnd plotValues )\\n\"\n+            \"\\nCompute per block statistics for a given window.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"start\\\"      (numeric, required) The height of the block that starts the window.\\n\"\n+            \"2. \\\"end\\\"        (numeric, optional) The height of the block that ends the window (default: current tip).\\n\"\n+            \"3. \\\"plotvalues\\\"  (string,  optional) Values to plot (comma separated), default(all): \" + boost::join(valid_plot_values, \",\") +\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"TODO\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getblockstats\", \"1000 1000 \\\"minfeerate,avgfeerate\\\"\")\n+            + HelpExampleRpc(\"getblockstats\", \"1000 1000 \\\"maxfeerate,avgfeerate\\\"\")\n+        );\n+\n+    LOCK(cs_main);\n+\n+    int start = request.params[0].get_int();\n+    if (start < 1 || start > chainActive.Height()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Start block height out of range\");\n+    }\n+\n+    int end;\n+    if (request.params.size() > 1) {\n+        end = request.params[1].get_int();\n+        if (end < 0 || end > chainActive.Height()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End block height out of range\");\n+        }\n+    } else {\n+        end = chainActive.Height();\n+    }\n+\n+    std::set<std::string> plot_values;\n+    if (request.params.size() > 2) {\n+        boost::split(plot_values, request.params[2].get_str(), boost::is_any_of(\",\"));\n+\n+        for (const std::string& plot_value : plot_values) {\n+            if (valid_plot_values.count(plot_value) == 0) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid plot value %s\", plot_value));\n+            }\n+        }\n+    } else {\n+        plot_values = valid_plot_values;\n+    }\n+\n+    std::map<std::string, UniValue> map_stats;\n+    for (const std::string& plot_value : plot_values) {\n+        map_stats[plot_value] = UniValue(UniValue::VARR);\n+    }\n+\n+    CBlockIndex* pindex = chainActive[end];\n+    for (int i = end; i >= start; i--) {\n+        UpdateBlockStats(pindex, plot_values, map_stats);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126826779",
      "id" : 126826779,
      "original_commit_id" : "c316a9f0691ee6cd096d3821ada6a50c8109bff5",
      "original_position" : 298,
      "path" : "src/rpc/blockchain.cpp",
      "position" : 297,
      "pull_request_review_id" : 49349707,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10757",
      "updated_at" : "2017-07-11T22:42:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/126826779",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "Without the documentation for the result it was impossible to distinguish a weird choice to spring discussion from an implementation mistake. Removed the other TODO comments.\r\nCoded more pending suggestions by @promag (hopefully all pending ones? if not, please insist) with some extra bikeshedding derived from s/plotvalues/stats/ and adapt tests to start and end being allowed to be negative.\r\n\r\nMore cleanups can be done, specially in the tests if we go further with https://github.com/bitcoin/bitcoin/pull/10757#discussion_r126462704 and not calculate in inverse order (there's no point if we don't get the slight optimization).\r\n\r\n",
      "created_at" : "2017-07-12T05:54:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10757#issuecomment-314659201",
      "id" : 314659201,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10757",
      "updated_at" : "2017-07-12T05:54:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/314659201",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   }
]
