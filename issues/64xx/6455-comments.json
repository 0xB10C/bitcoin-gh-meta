[
   {
      "body" : "Kinda inclined to NACK the floating relay fee idea here. (though everything else looks fine)\r\n\r\nWith the mempool limited in size, the minimum relay fee loses the purpose of protecting nodes from running out of RAM - that I'm sure we can agree on!\r\n\r\nFor miners, it still has the (sort of accidental) purpose of ensuring they don't fill up their blocks with useless txs that cost them more to mine in orphan risk than fee revenue. (although it's probably something like 10x or more too low for that)\r\n\r\nFor relay nodes, first let's consider transactions with a high probability of getting mined eventually. By that I mean if not for high demand the tx will eventually get mined and the sender isn't intending to double-spend it anytime soon. Here we're converging towards a more and more valuable mempool, so regardless what the minimum is bandwidth usage will diminish as the mempool value increases, eventually reaching a steady state. If I understand the floating relay fee idea, this is the same outcome, basically.\r\n\r\nWhat an attacker can game is the case where your node is accepting transactions that have a low probability of getting mined. For instance, at the extreme if we have another sigop-like bug, the attacker can fill the mempool by broadcasting high fee txs, using up bandwidth, double-spending them, and repeating. Without a floating relay fee, after each one of those cycles your relay node is immediately back to normal, helping move txs. With a floating relay fee the attacker could succeed in increasing the minimum to the point where other txs aren't getting propagated - bad!\r\n\r\nI've got some more ideas on this, but I'll save them for the list...",
      "created_at" : "2015-07-18T18:04:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122572058",
      "id" : 122572058,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-18T18:04:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122572058",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7042?v=3",
         "events_url" : "https://api.github.com/users/petertodd/events{/privacy}",
         "followers_url" : "https://api.github.com/users/petertodd/followers",
         "following_url" : "https://api.github.com/users/petertodd/following{/other_user}",
         "gists_url" : "https://api.github.com/users/petertodd/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/petertodd",
         "id" : 7042,
         "login" : "petertodd",
         "organizations_url" : "https://api.github.com/users/petertodd/orgs",
         "received_events_url" : "https://api.github.com/users/petertodd/received_events",
         "repos_url" : "https://api.github.com/users/petertodd/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/petertodd/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/petertodd"
      }
   },
   {
      "body" : "I'll try to explain the reasoning behind it.\r\n\r\n1) The mempool limitation uses a rule that the new, replacing transaction should pay for the relay of both the replaced transaction and the new transaction. That means that if we previously accepted low-fee transactions into the mempool (perhaps because a block was just mined, and there is now space), we've now made it unnecessarily expensive for new transactions to get in.\r\n\r\n2) The mempool limitation code uses heuristics to avoid bad performance, but this means it also makes suboptimal decisions. After many replacements, with the bottom filled with big \"packages\", it may become impossible for a significant portion of the transactions to get in, and thus, to get relayed.\r\n\r\n3) The above would even happen if the mempool code did an exhaustive search for the best possible replacement, as it is still only a per-incoming-transaction decision, and single transactions will rarely beat the fee requirements to replace a set of dependent transactions.\r\n\r\n4) The effective feerate to get relaying on the network is a sawtooth function when purely the limitation code is being used, more or less synchronized across the network. I believe it's not good for predictability to have such sharp changes - e.g., people may aim to suddenly broadcast right after a block to increase inclusion chances.\r\n\r\n5) The DoS protection with mempool limitation is still based on having a marginal price per byte on the network, and if that value drifts to much, it becomes ineffective. This also includes dust protection, which IMHO needs feedback from the network to avoid having a fixed configured value.",
      "created_at" : "2015-07-18T18:34:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122576820",
      "id" : 122576820,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-18T18:34:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122576820",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "I do understand the worry about mempools becoming filled with high-fee but unconfirming transactions, leading to (ever) increasing fees until the mempool clears. I've thought about using fees actually in the mempool, or time-based experation. Perhaps a rule that the relay fee in case of \"high water\" mempool (above the aimed size) cannot go above the lowest feerate actually in the mempool.\r\n\r\nIn practice, what I'm seeing so far with this code in the current network conditions is that the relay fee actually goes back to the default often, and only rises a bit for a few hours at a time.",
      "created_at" : "2015-07-18T18:48:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122580009",
      "id" : 122580009,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-18T18:48:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122580009",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "mempools are guaranteed not to fill with unconfirming transactions if you use an accurate sampling method: time-based expiration + blocks naturally confirming and clearing out transactions.\r\n\r\nAll other methods - this PR, abs size limit, floating relay fee - must be treated as inaccurate fallbacks for situations such as transaction bursts when time-based expiration fails to cap the mempool at an absolute size - because transaction replacement is fundamentally an inaccurate guess at what is best to be removed.\r\n\r\nThe solution needs to be considered holistically (and this PR is a good attempt at that):\r\n- time based expiration + natural block confs, the best way to sample what miners are actually confirming\r\n- an absolute cap, to deal with short term traffic bursts.  good local node defense.\r\n- a floating relay fee, to deal with floods and filter out will-not-confirm traffic\r\n\r\n",
      "created_at" : "2015-07-18T21:41:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122598669",
      "id" : 122598669,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-18T21:41:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122598669",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/494411?v=3",
         "events_url" : "https://api.github.com/users/jgarzik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jgarzik/followers",
         "following_url" : "https://api.github.com/users/jgarzik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jgarzik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jgarzik",
         "id" : 494411,
         "login" : "jgarzik",
         "organizations_url" : "https://api.github.com/users/jgarzik/orgs",
         "received_events_url" : "https://api.github.com/users/jgarzik/received_events",
         "repos_url" : "https://api.github.com/users/jgarzik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jgarzik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jgarzik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jgarzik"
      }
   },
   {
      "body" : "Added default-48h expiry to the mempool; thanks to @ashleyholman's indexed mempool this is trivial.\r\n\r\nI was previously of the opinion that expiration doesn't really help as rebroadcast (by anyone can always override it), but in combination with floating relay fee I think it makes sense as extra protection against divergent behaviour.",
      "created_at" : "2015-07-19T00:03:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122607639",
      "id" : 122607639,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-19T00:03:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122607639",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "The floating fee is node-specific, which could lead to lumpy minimum fees across the network.  When some nodes raise their minimum, other nodes will see reduced traffic without having had to raise theirs.\r\n\r\nRather than just integrating with fee estimation, I wonder if fee estimation could be improved to where it serves as the dynamic fee rate mechanism.  The advantage is that it's based on the global blockchain data set.",
      "created_at" : "2015-07-19T21:06:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122707156",
      "id" : 122707156,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-19T21:06:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122707156",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4284124?v=3",
         "events_url" : "https://api.github.com/users/dgenr8/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgenr8/followers",
         "following_url" : "https://api.github.com/users/dgenr8/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgenr8/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgenr8",
         "id" : 4284124,
         "login" : "dgenr8",
         "organizations_url" : "https://api.github.com/users/dgenr8/orgs",
         "received_events_url" : "https://api.github.com/users/dgenr8/received_events",
         "repos_url" : "https://api.github.com/users/dgenr8/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgenr8/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgenr8/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgenr8"
      }
   },
   {
      "body" : "It is true that this results in dynamic effectice relay fees across the\nnetwork, however that is inevitable with a limited memory pool linked to\nrelay.\n\nThe purpose of the floating relay is to dampen the effect of that limit,\nand make it more constant over time.\n",
      "created_at" : "2015-07-19T22:08:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122710335",
      "id" : 122710335,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-19T22:08:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122710335",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "For the goal of maximizing fees, filling the mempool by **fee rate** is a heuristic.  Truly maximizing fees would require filling by absolute fee, subject to the size constraint, continually re-solving a **knapsack problem**.\r\n\r\nIn particular, the feerate heuristic is unkind to an efficient large-size transaction if its feerate is slightly lower than another smaller-sized transaction, and there is not enough room for both.\r\n\r\nBut for a relay node, the **goal** itself of maximizing fees does not seem right.  It allows a transaction that pays greater fees than necessary for 1-conf to push earlier transactions out, and cause fee estimates to increase.  That's good for miners, but not good for users.  A relay node should be agnostic between miners and users.\r\n\r\nThe dependent handling logic is complex.  It would be simpler if **dependents** were made **less attractive** directly because they are dependent, and to make them even less attractive for being multiple levels deep.  A nice property of this is that they automatically get more attractive later, once their parents are confirmed.\r\n\r\nAll of these reasons suggest relay nodes use a **different metric** for filling their mempool than miners use for filling blocks.  A relay node has no revenue, so profit maximization is equivalent to cost minimization.  A relay node's cost of carrying a transaction in the mempool is proportional to two main factors: the size of the transaction and the amount of time it spends in the mempool.  Therefore a possible metric for relay nodes is ``sizeBytes * expectedBlocksToConfirm(feeRate)``.  The values stored for this on mempool entries could be updated as the fee rate structure changes.",
      "created_at" : "2015-07-19T23:08:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122716041",
      "id" : 122716041,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-19T23:08:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122716041",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4284124?v=3",
         "events_url" : "https://api.github.com/users/dgenr8/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgenr8/followers",
         "following_url" : "https://api.github.com/users/dgenr8/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgenr8/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgenr8",
         "id" : 4284124,
         "login" : "dgenr8",
         "organizations_url" : "https://api.github.com/users/dgenr8/orgs",
         "received_events_url" : "https://api.github.com/users/dgenr8/received_events",
         "repos_url" : "https://api.github.com/users/dgenr8/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgenr8/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgenr8/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgenr8"
      }
   },
   {
      "body" : "@sipa \r\n\r\n> 1) The mempool limitation uses a rule that the new, replacing transaction should pay for the relay of both the replaced transaction and the new transaction. That means that if we previously accepted low-fee transactions into the mempool (perhaps because a block was just mined, and there is now space), we've now made it unnecessarily expensive for new transactions to get in.\r\n>\r\n> 2) The mempool limitation code uses heuristics to avoid bad performance, but this means it also makes suboptimal decisions. After many replacements, with the bottom filled with big \"packages\", it may become impossible for a significant portion of the transactions to get in, and thus, to get relayed.\r\n>\r\n> 3) The above would even happen if the mempool code did an exhaustive search for the best possible replacement, as it is still only a per-incoming-transaction decision, and single transactions will rarely beat the fee requirements to replace a set of dependent transactions.\r\n\r\nAll these issues with large chains of unconfirmed transactions make me think it makes sense to just put a size limit on them, e.g. no single set of unconfirmed txs should be more than 125KB in size, and contain more than 100 txs. When you think about it, large unconfirmed sets are inherently problematic to mine, because it's hard to \"fit\" them in with other transactions in optimal ways. So why not just stop relaying them? The use-case is both rare, and often associated with abusive behaviors.\r\n\r\nWith that limit in place, the size difference between the largest possible package to replace, and a single transaction, would be about 625:1 (125KB to 0.2KB) If we replaced txs purely on a fee/KB basis, that'd mean the trick of replacing large transactions with small ones could get you 625x cheaper bandwidth DoS attacks - not great. However from a miner's profitability point of view, given that the mempool is much larger than a single block, it's probably still a economically rational decision. (for replace-by-fee this logic probably should be modified, but that's my problem, not yours!)\r\n\r\nNow suppose instead that we set the minimum relay fee based purely on bandwidth used. E.g. grow min relay fee during times of high bandwidth and let it decay back to the absolute minimum during lulls. In that case the attempting to do a bandwidth DoS with repeated replacements would just drive up the relay fee, quickly limiting the effectiveness of the attack to the pre-defined bandwidth limit. Having such a mechanism would also be useful for RBF. \r\n\r\n> 4) The effective feerate to get relaying on the network is a sawtooth function when purely the limitation code is being used, more or less synchronized across the network. I believe it's not good for predictability to have such sharp changes - e.g., people may aim to suddenly broadcast right after a block to increase inclusion chances.\r\n\r\nIs that actually such a bad thing? Basically what such a change would say is \"previously there was no chance that your tx would get mined, but that suddenly changed, so rebroadcast it now\" I think that's a better outcome than unnecessarily preventing perfectly valid and profitable-to-mine transactions  from getting to miners.\r\n\r\n> I do understand the worry about mempools becoming filled with high-fee but unconfirming transactions, leading to (ever) increasing fees until the mempool clears. I've thought about using fees actually in the mempool, or time-based experation. Perhaps a rule that the relay fee in case of \"high water\" mempool (above the aimed size) cannot go above the lowest feerate actually in the mempool.\r\n\r\nSo, really you have two conflicting problems with the unminable transaction issue:\r\n\r\n1) Bandwidth usage\r\n\r\n2) Unnecessarily high fees\r\n\r\nExpiration improves the situation for #2, but makes #1 worse as it lets the attacker re-use the txouts faster. OTOH, they're probably doing that anyway, because they can double-spend the outputs. Limiting total unconfirmed tx chain depth also helps here in a few ways, such as forcing the attacker to tie up more txouts in the attack. The attacker is limited by how much BTC they have access to; the larger the mempool the more BTC they need to pull off the attack.\r\n\r\nEach time a block is found and a tx is not included in that block, it's essentially a sign that the economic feerate of the tx may be lower than the apparent feerate we calculated. So quickly reducing the apparent feerate on every block for the top 1MB * x transactions found probably makes sense for the mempool. (though the mining code should use the actual feerates!) For instance, halving the feerate each time a block is found for those txs probably makes sense; the remaining part of the mempool would then act to make the bandwidth attack expensive to pull off. \r\n\r\nFinally for worst-case recovery, I agree that a 48-hour expiration can't hurt.",
      "created_at" : "2015-07-19T23:19:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122716680",
      "id" : 122716680,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-19T23:19:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122716680",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7042?v=3",
         "events_url" : "https://api.github.com/users/petertodd/events{/privacy}",
         "followers_url" : "https://api.github.com/users/petertodd/followers",
         "following_url" : "https://api.github.com/users/petertodd/following{/other_user}",
         "gists_url" : "https://api.github.com/users/petertodd/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/petertodd",
         "id" : 7042,
         "login" : "petertodd",
         "organizations_url" : "https://api.github.com/users/petertodd/orgs",
         "received_events_url" : "https://api.github.com/users/petertodd/received_events",
         "repos_url" : "https://api.github.com/users/petertodd/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/petertodd/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/petertodd"
      }
   },
   {
      "body" : "As Peter Todd noted, if relay behaviour and miner behaviour are allowed to\ndiverge, there is no real need anymore to keep a mempool at all, if a\nsolution is found to deal with dependent transactions (for example,\nrelaying by package of dependent transactions).\n\nThe strategy here is trying to maintain a solution that applies to both\nrelaying and mining, trying to optimize for what is most economic to be\nmined.\n",
      "created_at" : "2015-07-19T23:22:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122716820",
      "id" : 122716820,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-19T23:22:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122716820",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "@dgenr8 Relaying transactions that miners aren't interested in mining is pointless and just wastes bandwidth; go too far with that philosophy and large miners will start creating alternate tx submission mechanisms, which is harmful to decentralization.\r\n\r\nRe: the knapsack problem, so long as the mempool is much larger than the blocksize limit and we have a maximum transaction size well under the blocksize limit - and better yet maximum unconfirmed tx package size - ignoring the knapsack stuff is a reasonable approximation of ideal behavior anyway. There's very little legit use-cases for creating extremely large transactions, especially not extremely large chains of them. In particular, note how the efficiency gain of large transactions quickly goes down as the number of outputs goes up, while very long chains of txs are much more efficiently done with a few large single transactions.",
      "created_at" : "2015-07-19T23:30:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122717577",
      "id" : 122717577,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-19T23:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122717577",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7042?v=3",
         "events_url" : "https://api.github.com/users/petertodd/events{/privacy}",
         "followers_url" : "https://api.github.com/users/petertodd/followers",
         "following_url" : "https://api.github.com/users/petertodd/following{/other_user}",
         "gists_url" : "https://api.github.com/users/petertodd/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/petertodd",
         "id" : 7042,
         "login" : "petertodd",
         "organizations_url" : "https://api.github.com/users/petertodd/orgs",
         "received_events_url" : "https://api.github.com/users/petertodd/received_events",
         "repos_url" : "https://api.github.com/users/petertodd/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/petertodd/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/petertodd"
      }
   },
   {
      "body" : "@sipa @petertodd It sounds like you don't think fee estimation works?\r\n\r\nExperience with min relay fee, non-validating mining, blacklists, RBF, and other examples show that miners will always want to diverge from relay policy.\r\n\r\nThere's no point in worrying about miners creating submission mechanisms.  If it's a major worry though, creating a private miner relay network was an odd thing to do (but consistent with having the p2p relay network act in miners' interest).",
      "created_at" : "2015-07-20T00:46:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6455#issuecomment-122723010",
      "id" : 122723010,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6455",
      "updated_at" : "2015-07-20T00:46:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/122723010",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4284124?v=3",
         "events_url" : "https://api.github.com/users/dgenr8/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgenr8/followers",
         "following_url" : "https://api.github.com/users/dgenr8/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgenr8/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgenr8",
         "id" : 4284124,
         "login" : "dgenr8",
         "organizations_url" : "https://api.github.com/users/dgenr8/orgs",
         "received_events_url" : "https://api.github.com/users/dgenr8/received_events",
         "repos_url" : "https://api.github.com/users/dgenr8/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgenr8/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgenr8/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgenr8"
      }
   }
]
