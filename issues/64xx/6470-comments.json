[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35382668"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35382668"
         }
      },
      "body" : "Can't ```- GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60``` be inside pool.Expire?, it may become an attribute of the txmempool in the future or something.",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-23T23:16:33Z",
      "diff_hunk" : "@@ -852,6 +877,12 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                                    hash.ToString(), nSigOps, MAX_STANDARD_TX_SIGOPS),\n                              REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\");\n \n+        // Expire old transactions before trying to replace low-priority ones.\n+        int expired = pool.Expire(GetTime() - GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35382668",
      "id" : 35382668,
      "original_commit_id" : "6b4af964ff15ffec0bc6dccef90f854fd28efddc",
      "original_position" : 71,
      "path" : "src/main.cpp",
      "position" : 71,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-24T02:05:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35382668",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35382823"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35382823"
         }
      },
      "body" : "s/mempool/pool don't use the global when you have the parameter",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-23T23:18:33Z",
      "diff_hunk" : "@@ -859,22 +890,51 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), mempool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n-        // Don't accept it if it can't get into a block\n-        CAmount txMinFee = GetMinRelayFee(tx, nSize, true);\n-        if (fLimitFree && nFees < txMinFee)\n-            return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\",\n-                                      hash.ToString(), nFees, txMinFee),\n-                             REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n-\n-        // Require that free transactions have sufficient priority to be mined in the next block.\n-        if (GetBoolArg(\"-relaypriority\", true) && nFees < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        // The fees required to accept this transaction start with the fees required to accept it on its own\n+        CAmount nFeesRequired = 0;\n+        if (fLimitFree) {\n+            nFeesRequired = GetMinRelayFee(tx, nSize, true);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\", hash.ToString(), nFees, nFeesRequired),\n+                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+        }\n+        // If we are not relaying low priority free transactions, then if this tx doesn't have sufficient priority\n+        // it must have minRelayTxFee\n+        if (GetBoolArg(\"-relaypriority\", true) && nFeesRequired < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n+            nFeesRequired =  ::minRelayTxFee.GetFee(nSize);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        }\n+\n+        // Try to make space in mempool\n+        size_t softcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 700000;\n+        size_t hardcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n+        size_t capstep = (hardcap - softcap) / 10;\n+        std::set<uint256> stagedelete;\n+        CAmount nFeesDeleted = 0;\n+\n+        if (!mempool.StageTrimToSize(softcap, entry, stagedelete, nFeesRequired, nFeesDeleted)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35382823",
      "id" : 35382823,
      "original_commit_id" : "6b4af964ff15ffec0bc6dccef90f854fd28efddc",
      "original_position" : 116,
      "path" : "src/main.cpp",
      "position" : 116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-24T02:05:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35382823",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35383584"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35383584"
         }
      },
      "body" : "Can't all this code around pool.addUnchecked be moved to a new mempool method that internally calls pool.addUnchecked ?\r\nYou could go further. stagedelete and nFeesDeleted could just be ctxmempool attributes so that you don't need to pass it to pool.RemoveStagedAndAddUnchecked (or whatever you want to call the method) and pool.StageTrimToSize (or whatever you want to call the method)",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-23T23:29:37Z",
      "diff_hunk" : "@@ -921,8 +981,38 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             return error(\"AcceptToMemoryPool: BUG! PLEASE REPORT THIS! ConnectInputs failed against MANDATORY but not STANDARD flags %s\", hash.ToString());\n         }\n \n+        // Make actually space",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35383584",
      "id" : 35383584,
      "original_commit_id" : "6b4af964ff15ffec0bc6dccef90f854fd28efddc",
      "original_position" : 146,
      "path" : "src/main.cpp",
      "position" : 146,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-24T02:05:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35383584",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35384695"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35384695"
         }
      },
      "body" : "Can't all this new code be part of  mempool.StageTrimToSize ?\r\nIn fact, I would go further and take anything that depends on nFeesDeleted to txmempool as well (including ```csFreeLimiter``` ```GetBoolArg(\"-relaypriority\", true)``` and ```GetMinRelayFee```).\r\nI would also move https://github.com/bitcoin/bitcoin/blob/master/src/main.cpp#L785 there and have all mempool-replacement-related things in one place: txmempool. We could also move some things directly to policy/fees but I'm not going to ask for that much.\r\n\r\nI'm sorry but I won't push my nits as branches with fixup! commits anymore on this subject.\r\nI guess I'll have to wait the ages that will take to move the code later and accept that nobody else but me cares about  the movement being better-than-free right now. I won't miss the chance to beg you though.\r\nPlease, try some of my movement suggestions and if takes you too long to adapt the parameter too recompile or you don't like what my suggestions are doing to the number of parameters in pool.StageTrimToSize just stop it. And I guess I can just add/maintain all those things in my tomove list. It seems I'm the only one that doesn't love the fact that most of our changes conflict with each other in main.cpp. But I understand, moving things out of main so that things don't need to conflict and don't need to be prioritized is not a priority.\r\n@sipa I must be getting something wrong or I've been communicating poorly around this. Maybe code doesn't talk as much as I thought after all.",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-23T23:51:10Z",
      "diff_hunk" : "@@ -859,22 +890,51 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), mempool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n-        // Don't accept it if it can't get into a block\n-        CAmount txMinFee = GetMinRelayFee(tx, nSize, true);\n-        if (fLimitFree && nFees < txMinFee)\n-            return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\",\n-                                      hash.ToString(), nFees, txMinFee),\n-                             REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n-\n-        // Require that free transactions have sufficient priority to be mined in the next block.\n-        if (GetBoolArg(\"-relaypriority\", true) && nFees < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        // The fees required to accept this transaction start with the fees required to accept it on its own",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35384695",
      "id" : 35384695,
      "original_commit_id" : "6b4af964ff15ffec0bc6dccef90f854fd28efddc",
      "original_position" : 93,
      "path" : "src/main.cpp",
      "position" : 93,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-24T02:05:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35384695",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1008458?v=3",
         "events_url" : "https://api.github.com/users/jtimon/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jtimon/followers",
         "following_url" : "https://api.github.com/users/jtimon/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jtimon/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jtimon",
         "id" : 1008458,
         "login" : "jtimon",
         "organizations_url" : "https://api.github.com/users/jtimon/orgs",
         "received_events_url" : "https://api.github.com/users/jtimon/received_events",
         "repos_url" : "https://api.github.com/users/jtimon/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jtimon/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jtimon/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jtimon"
      }
   },
   {
      "body" : "re: GetRand slowness, wouldn't insecure_rand() be good enough here?\r\nIf you need both fast and cryptographic randomness you'd have to wait for #5885",
      "created_at" : "2015-07-24T07:56:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#issuecomment-124409428",
      "id" : 124409428,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6470",
      "updated_at" : "2015-07-24T07:56:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/124409428",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "I like the approach; I'll review the code in detail soon.",
      "created_at" : "2015-07-24T17:53:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#issuecomment-124598997",
      "id" : 124598997,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6470",
      "updated_at" : "2015-07-24T17:53:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/124598997",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "The idea that a transaction must be \"paid for\" when evicted by an unrelated transaction is mistaken.  It creates zero incentive for the evicted author to pay more fees in the future.  He got what he wanted -- his tx was relayed.\r\n\r\nIf the decision does not affect the cost, the cost should not affect the decision.",
      "created_at" : "2015-07-25T16:26:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#issuecomment-124859207",
      "id" : 124859207,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6470",
      "updated_at" : "2015-07-25T16:26:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/124859207",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4284124?v=3",
         "events_url" : "https://api.github.com/users/dgenr8/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgenr8/followers",
         "following_url" : "https://api.github.com/users/dgenr8/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgenr8/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgenr8",
         "id" : 4284124,
         "login" : "dgenr8",
         "organizations_url" : "https://api.github.com/users/dgenr8/orgs",
         "received_events_url" : "https://api.github.com/users/dgenr8/received_events",
         "repos_url" : "https://api.github.com/users/dgenr8/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgenr8/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgenr8/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgenr8"
      }
   },
   {
      "body" : "The assumption is that when a transaction is evicted, it won't be mined, thus it won't have paid anything at all.\r\n",
      "created_at" : "2015-07-25T16:35:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#issuecomment-124859721",
      "id" : 124859721,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6470",
      "updated_at" : "2015-07-25T17:13:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/124859721",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "@sipa In that case, it also received no benefit.",
      "created_at" : "2015-07-25T16:55:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#issuecomment-124861731",
      "id" : 124861731,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6470",
      "updated_at" : "2015-07-25T16:55:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/124861731",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4284124?v=3",
         "events_url" : "https://api.github.com/users/dgenr8/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgenr8/followers",
         "following_url" : "https://api.github.com/users/dgenr8/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgenr8/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgenr8",
         "id" : 4284124,
         "login" : "dgenr8",
         "organizations_url" : "https://api.github.com/users/dgenr8/orgs",
         "received_events_url" : "https://api.github.com/users/dgenr8/received_events",
         "repos_url" : "https://api.github.com/users/dgenr8/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgenr8/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgenr8/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgenr8"
      }
   },
   {
      "body" : "It got relayed, which has network costs.\r\n\r\nThe purpose of this payment requirement is to prevent someone from spamming the network by constantly replacing the lowest priority one, and only paying once.",
      "created_at" : "2015-07-25T17:09:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#issuecomment-124862722",
      "id" : 124862722,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6470",
      "updated_at" : "2015-07-25T17:09:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/124862722",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "For DoS protection, all that's needed is (new fee/kb) - (old fee/kb) >= (minimum fee/kb).",
      "created_at" : "2015-07-25T17:24:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#issuecomment-124863335",
      "id" : 124863335,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6470",
      "updated_at" : "2015-07-25T17:24:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/124863335",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4284124?v=3",
         "events_url" : "https://api.github.com/users/dgenr8/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgenr8/followers",
         "following_url" : "https://api.github.com/users/dgenr8/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgenr8/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgenr8",
         "id" : 4284124,
         "login" : "dgenr8",
         "organizations_url" : "https://api.github.com/users/dgenr8/orgs",
         "received_events_url" : "https://api.github.com/users/dgenr8/received_events",
         "repos_url" : "https://api.github.com/users/dgenr8/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgenr8/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgenr8/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgenr8"
      }
   },
   {
      "body" : "@dgenr8 No, that would let a small transaction erase a large transaction, making space for several new transactions to be cheaply relayed.",
      "created_at" : "2015-07-27T14:36:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#issuecomment-125227514",
      "id" : 125227514,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6470",
      "updated_at" : "2015-07-27T14:36:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/125227514",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35542402"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35542402"
         }
      },
      "body" : "I would prefer not doing that, and keeping CTxMempool as much as possible a dumb data structure - the decisions about what happens to it (policy?) should stay out of it, IMHO.\r\n\r\nEDIT: We're already failing at that pretty badly anyway, it seems, with the feerate index and the trim code inside CTxMempool. Too bad, but disregard this comment.",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-27T14:39:06Z",
      "diff_hunk" : "@@ -852,6 +877,12 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n                                    hash.ToString(), nSigOps, MAX_STANDARD_TX_SIGOPS),\n                              REJECT_NONSTANDARD, \"bad-txns-too-many-sigops\");\n \n+        // Expire old transactions before trying to replace low-priority ones.\n+        int expired = pool.Expire(GetTime() - GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35542402",
      "id" : 35542402,
      "original_commit_id" : "6b4af964ff15ffec0bc6dccef90f854fd28efddc",
      "original_position" : 71,
      "path" : "src/main.cpp",
      "position" : 71,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-27T14:41:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35542402",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35542959"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35542959"
         }
      },
      "body" : "@jtimon Let's first find a solution to the problem at hand.\r\n\r\nCode movement that goes into the master branch conflicts with everything, so complicates changes that we want in backports too.",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-27T14:43:31Z",
      "diff_hunk" : "@@ -859,22 +890,51 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), mempool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n-        // Don't accept it if it can't get into a block\n-        CAmount txMinFee = GetMinRelayFee(tx, nSize, true);\n-        if (fLimitFree && nFees < txMinFee)\n-            return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\",\n-                                      hash.ToString(), nFees, txMinFee),\n-                             REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n-\n-        // Require that free transactions have sufficient priority to be mined in the next block.\n-        if (GetBoolArg(\"-relaypriority\", true) && nFees < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        // The fees required to accept this transaction start with the fees required to accept it on its own",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35542959",
      "id" : 35542959,
      "original_commit_id" : "6b4af964ff15ffec0bc6dccef90f854fd28efddc",
      "original_position" : 93,
      "path" : "src/main.cpp",
      "position" : 93,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-27T14:43:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35542959",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35543788"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35543788"
         }
      },
      "body" : "Agree.",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-27T14:50:16Z",
      "diff_hunk" : "@@ -859,22 +890,51 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), mempool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n-        // Don't accept it if it can't get into a block\n-        CAmount txMinFee = GetMinRelayFee(tx, nSize, true);\n-        if (fLimitFree && nFees < txMinFee)\n-            return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\",\n-                                      hash.ToString(), nFees, txMinFee),\n-                             REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n-\n-        // Require that free transactions have sufficient priority to be mined in the next block.\n-        if (GetBoolArg(\"-relaypriority\", true) && nFees < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        // The fees required to accept this transaction start with the fees required to accept it on its own\n+        CAmount nFeesRequired = 0;\n+        if (fLimitFree) {\n+            nFeesRequired = GetMinRelayFee(tx, nSize, true);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\", hash.ToString(), nFees, nFeesRequired),\n+                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+        }\n+        // If we are not relaying low priority free transactions, then if this tx doesn't have sufficient priority\n+        // it must have minRelayTxFee\n+        if (GetBoolArg(\"-relaypriority\", true) && nFeesRequired < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n+            nFeesRequired =  ::minRelayTxFee.GetFee(nSize);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        }\n+\n+        // Try to make space in mempool\n+        size_t softcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 700000;\n+        size_t hardcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n+        size_t capstep = (hardcap - softcap) / 10;\n+        std::set<uint256> stagedelete;\n+        CAmount nFeesDeleted = 0;\n+\n+        if (!mempool.StageTrimToSize(softcap, entry, stagedelete, nFeesRequired, nFeesDeleted)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35543788",
      "id" : 35543788,
      "original_commit_id" : "6b4af964ff15ffec0bc6dccef90f854fd28efddc",
      "original_position" : 116,
      "path" : "src/main.cpp",
      "position" : 116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-27T14:50:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35543788",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35544286"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35544286"
         }
      },
      "body" : "Storing attributes inside CTxMempool just to avoid passing them around seems ugly. It would be incompatible with some multithreaded modifications, for example.\r\n\r\nA cleaner way to do this is having a separate TxMempoolStagedChange class for example that is calculated from an add/delete, kept by AcceptToMemoryPool during validation, and finally applied to the mempool or thrown away.",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-27T14:53:56Z",
      "diff_hunk" : "@@ -921,8 +981,38 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             return error(\"AcceptToMemoryPool: BUG! PLEASE REPORT THIS! ConnectInputs failed against MANDATORY but not STANDARD flags %s\", hash.ToString());\n         }\n \n+        // Make actually space",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35544286",
      "id" : 35544286,
      "original_commit_id" : "6b4af964ff15ffec0bc6dccef90f854fd28efddc",
      "original_position" : 146,
      "path" : "src/main.cpp",
      "position" : 146,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-27T14:53:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35544286",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35544529"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35544529"
         }
      },
      "body" : "Please use { } around the then block.",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-27T14:55:36Z",
      "diff_hunk" : "@@ -859,22 +890,51 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), mempool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n-        // Don't accept it if it can't get into a block\n-        CAmount txMinFee = GetMinRelayFee(tx, nSize, true);\n-        if (fLimitFree && nFees < txMinFee)\n-            return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\",\n-                                      hash.ToString(), nFees, txMinFee),\n-                             REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n-\n-        // Require that free transactions have sufficient priority to be mined in the next block.\n-        if (GetBoolArg(\"-relaypriority\", true) && nFees < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        // The fees required to accept this transaction start with the fees required to accept it on its own\n+        CAmount nFeesRequired = 0;\n+        if (fLimitFree) {\n+            nFeesRequired = GetMinRelayFee(tx, nSize, true);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\", hash.ToString(), nFees, nFeesRequired),\n+                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+        }\n+        // If we are not relaying low priority free transactions, then if this tx doesn't have sufficient priority\n+        // it must have minRelayTxFee\n+        if (GetBoolArg(\"-relaypriority\", true) && nFeesRequired < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n+            nFeesRequired =  ::minRelayTxFee.GetFee(nSize);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        }\n+\n+        // Try to make space in mempool\n+        size_t softcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 700000;\n+        size_t hardcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n+        size_t capstep = (hardcap - softcap) / 10;\n+        std::set<uint256> stagedelete;\n+        CAmount nFeesDeleted = 0;\n+\n+        if (!mempool.StageTrimToSize(softcap, entry, stagedelete, nFeesRequired, nFeesDeleted)) {\n+            size_t expsize = mempool.DynamicMemoryUsage() + mempool.GuessDynamicMemoryUsage(entry);\n+            if (expsize > hardcap)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35544529",
      "id" : 35544529,
      "original_commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "original_position" : 118,
      "path" : "src/main.cpp",
      "position" : 118,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-27T14:55:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35544529",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35546403"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35546403"
         }
      },
      "body" : "This comment is technically no longer true since the majority of transactions are being skipped. Maybe the code should be removed altogether now, or does it still offer a benefit? In any case, the comment needs addressing.",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-27T15:08:58Z",
      "diff_hunk" : "@@ -429,5 +438,159 @@ bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n-    return memusage::DynamicUsage(mapTx) + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+    // Estimate the overhead of mapTx to be 9 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+}\n+\n+size_t CTxMemPool::GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const {\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) + entry.DynamicMemoryUsage() + memusage::IncrementalDynamicUsage(mapNextTx) * entry.GetTx().vin.size();\n+}\n+\n+bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, std::set<uint256>& stage,\n+                                 CAmount& nFeesReserved, CAmount& nFeesRemoved) {\n+    std::set<uint256> protect;\n+    BOOST_FOREACH(const CTxIn& in, toadd.GetTx().vin) {\n+        protect.insert(in.prevout.hash);\n+    }\n+\n+    size_t incUsage = GuessDynamicMemoryUsage(toadd);\n+    size_t expsize = DynamicMemoryUsage() + incUsage; // Track the expected resulting memory usage of the mempool.\n+    if (expsize > sizelimit) {\n+        size_t sizeToTrim = std::min(expsize - sizelimit, incUsage);\n+        return TrimMempool(sizeToTrim, protect, nFeesReserved, toadd.GetTxSize(), toadd.GetFee(), stage, nFeesRemoved, true);\n+    }\n+    else\n+        return true;\n+}\n+\n+bool CTxMemPool::SurplusTrim(int multiplier, CFeeRate minRelayRate, std::set<uint256>& stage, size_t usageToTrim) {\n+    CFeeRate excessRate(multiplier * minRelayRate.GetFeePerK());\n+    std::set<uint256> noprotect;\n+    CAmount nFeesRemoved = 0;\n+    size_t sizeToTrim = usageToTrim / 4;  //Conservatively assume we have transactions at least 1/4 the size of the mempool space they've taken\n+    return TrimMempool(usageToTrim, noprotect, 0, sizeToTrim, excessRate.GetFee(sizeToTrim), stage, nFeesRemoved, false);\n+}\n+\n+bool CTxMemPool::TrimMempool(size_t sizeToTrim, std::set<uint256> &protect, CAmount nFeesReserved, size_t sizeToUse, CAmount feeToUse,\n+                             std::set<uint256>& stage, CAmount &nFeesRemoved, bool mustTrimAllSize) {\n+    size_t usageRemoved = 0;\n+    indexed_transaction_set::nth_index<1>::type::reverse_iterator it = mapTx.get<1>().rbegin();\n+    int fails = 0; // Number of mempool transactions iterated over that were not included in the stage.\n+    int itertotal = 0;\n+    int iterextra = mustTrimAllSize ? 10 : 100; //Allow many more iterations to find large size during SurplusTrim\n+    int iterperfail = mustTrimAllSize ? 5 : 10; //Try to follow more links during SurplusTrim\n+    int failmax = 10; //Try no more than 10 starting transactions\n+    uint64_t skipPattern = GetRand((uint64_t)1<<61);\n+    // Iterate from lowest feerate to highest feerate in the mempool:\n+    while (usageRemoved < sizeToTrim && it != mapTx.get<1>().rend()) {\n+        //Randomly skip between 0 and 7 entries\n+        unsigned int skipNum = std::min(fails,19);\n+        for (unsigned int i = 0; i < ((uint64_t)7 & (skipPattern >> (3*skipNum))) && it != mapTx.get<1>().rend();i++,it++);\n+        if (it == mapTx.get<1>().rend())\n+            break;\n+\n+        const uint256& hash = it->GetTx().GetHash();\n+        if (stage.count(hash)) {\n+            // If the transaction is already staged for deletion, we know its descendants are already processed, so skip it.\n+            it++;\n+            continue;\n+        }\n+        if ((double)it->GetFee() * sizeToUse > (double)feeToUse * it->GetTxSize()) {\n+            // If the transaction's feerate is worse than what we're looking for, we have processed everything in the mempool",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35546403",
      "id" : 35546403,
      "original_commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "original_position" : 234,
      "path" : "src/txmempool.cpp",
      "position" : 234,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-27T15:08:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35546403",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35546588"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35546588"
         }
      },
      "body" : "Comment should say 10, not 32 - or just refer to the failmax variable.",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-27T15:10:35Z",
      "diff_hunk" : "@@ -429,5 +438,159 @@ bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n-    return memusage::DynamicUsage(mapTx) + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+    // Estimate the overhead of mapTx to be 9 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+}\n+\n+size_t CTxMemPool::GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const {\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) + entry.DynamicMemoryUsage() + memusage::IncrementalDynamicUsage(mapNextTx) * entry.GetTx().vin.size();\n+}\n+\n+bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, std::set<uint256>& stage,\n+                                 CAmount& nFeesReserved, CAmount& nFeesRemoved) {\n+    std::set<uint256> protect;\n+    BOOST_FOREACH(const CTxIn& in, toadd.GetTx().vin) {\n+        protect.insert(in.prevout.hash);\n+    }\n+\n+    size_t incUsage = GuessDynamicMemoryUsage(toadd);\n+    size_t expsize = DynamicMemoryUsage() + incUsage; // Track the expected resulting memory usage of the mempool.\n+    if (expsize > sizelimit) {\n+        size_t sizeToTrim = std::min(expsize - sizelimit, incUsage);\n+        return TrimMempool(sizeToTrim, protect, nFeesReserved, toadd.GetTxSize(), toadd.GetFee(), stage, nFeesRemoved, true);\n+    }\n+    else\n+        return true;\n+}\n+\n+bool CTxMemPool::SurplusTrim(int multiplier, CFeeRate minRelayRate, std::set<uint256>& stage, size_t usageToTrim) {\n+    CFeeRate excessRate(multiplier * minRelayRate.GetFeePerK());\n+    std::set<uint256> noprotect;\n+    CAmount nFeesRemoved = 0;\n+    size_t sizeToTrim = usageToTrim / 4;  //Conservatively assume we have transactions at least 1/4 the size of the mempool space they've taken\n+    return TrimMempool(usageToTrim, noprotect, 0, sizeToTrim, excessRate.GetFee(sizeToTrim), stage, nFeesRemoved, false);\n+}\n+\n+bool CTxMemPool::TrimMempool(size_t sizeToTrim, std::set<uint256> &protect, CAmount nFeesReserved, size_t sizeToUse, CAmount feeToUse,\n+                             std::set<uint256>& stage, CAmount &nFeesRemoved, bool mustTrimAllSize) {\n+    size_t usageRemoved = 0;\n+    indexed_transaction_set::nth_index<1>::type::reverse_iterator it = mapTx.get<1>().rbegin();\n+    int fails = 0; // Number of mempool transactions iterated over that were not included in the stage.\n+    int itertotal = 0;\n+    int iterextra = mustTrimAllSize ? 10 : 100; //Allow many more iterations to find large size during SurplusTrim\n+    int iterperfail = mustTrimAllSize ? 5 : 10; //Try to follow more links during SurplusTrim\n+    int failmax = 10; //Try no more than 10 starting transactions\n+    uint64_t skipPattern = GetRand((uint64_t)1<<61);\n+    // Iterate from lowest feerate to highest feerate in the mempool:\n+    while (usageRemoved < sizeToTrim && it != mapTx.get<1>().rend()) {\n+        //Randomly skip between 0 and 7 entries\n+        unsigned int skipNum = std::min(fails,19);\n+        for (unsigned int i = 0; i < ((uint64_t)7 & (skipPattern >> (3*skipNum))) && it != mapTx.get<1>().rend();i++,it++);\n+        if (it == mapTx.get<1>().rend())\n+            break;\n+\n+        const uint256& hash = it->GetTx().GetHash();\n+        if (stage.count(hash)) {\n+            // If the transaction is already staged for deletion, we know its descendants are already processed, so skip it.\n+            it++;\n+            continue;\n+        }\n+        if ((double)it->GetFee() * sizeToUse > (double)feeToUse * it->GetTxSize()) {\n+            // If the transaction's feerate is worse than what we're looking for, we have processed everything in the mempool\n+            // that could improve the staged set. If we don't have an acceptable solution by now, bail out.\n+            break;\n+        }\n+        std::deque<uint256> todo; // List of hashes that we still need to process (descendants of 'hash').\n+        std::set<uint256> now; // Set of hashes that will need to be added to stage if 'hash' is included.\n+        CAmount nowfee = 0; // Sum of the fees in 'now'.\n+        size_t nowsize = 0; // Sum of the tx sizes in 'now'.\n+        size_t nowusage = 0; // Sum of the memory usages of transactions in 'now'.\n+        todo.push_back(it->GetTx().GetHash()); // Add 'hash' to the todo list, to initiate processing its children.\n+        bool good = true; // Whether including 'hash' (and all its descendants) is a good idea.\n+        // Iterate breadth-first over all descendants of transaction with hash 'hash'.\n+        while (!todo.empty()) {\n+            uint256 hashnow = todo.front();\n+            if (protect.count(hashnow)) {\n+                // If this transaction is in the protected set, we're done with 'hash'.\n+                good = false;\n+                break;\n+            }\n+            itertotal++; // We only count transactions we actually had to go find in the mempool.\n+            if (itertotal > iterextra + iterperfail*(fails+1)) {\n+                good = false;\n+                break;\n+            }\n+            const CTxMemPoolEntry* origTx = &*mapTx.find(hashnow);\n+            nowfee += origTx->GetFee();\n+            if (nFeesReserved + nFeesRemoved + nowfee > feeToUse) {\n+                // If this pushes up to the total fees deleted too high, we're done with 'hash'.\n+                good = false;\n+                break;\n+            }\n+            todo.pop_front();\n+            // Add 'hashnow' to the 'now' set, and update its statistics.\n+            now.insert(hashnow);\n+            nowusage += GuessDynamicMemoryUsage(*origTx);\n+            nowsize += origTx->GetTxSize();\n+            // Find dependencies of 'hashnow' and them to todo.\n+            std::map<COutPoint, CInPoint>::iterator iter = mapNextTx.lower_bound(COutPoint(hashnow, 0));\n+            while (iter != mapNextTx.end() && iter->first.hash == hashnow) {\n+                const uint256& nexthash = iter->second.ptx->GetHash();\n+                if (!(stage.count(nexthash) || now.count(nexthash))) {\n+                    todo.push_back(nexthash);\n+                }\n+                iter++;\n+            }\n+        }\n+        if (good && (double)nowfee * sizeToUse > (double)feeToUse * nowsize) {\n+            // The new transaction's feerate is below that of the set we're removing.\n+            good = false;\n+        }\n+        if (good) {\n+            stage.insert(now.begin(), now.end());\n+            nFeesRemoved += nowfee;\n+            usageRemoved += nowusage;\n+        } else {\n+            fails++;\n+            if (fails > failmax) {\n+                // Bail out after traversing 32 transactions that are not acceptable.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35546588",
      "id" : 35546588,
      "original_commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "original_position" : 291,
      "path" : "src/txmempool.cpp",
      "position" : 291,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-27T15:10:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35546588",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35547904"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35547904"
         }
      },
      "body" : "Agree the comment needs changing, but the check is still valuable.  No reason to continue checking further transactions at this point, even if we haven't used up all of our fails.",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-27T15:20:36Z",
      "diff_hunk" : "@@ -429,5 +438,159 @@ bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n-    return memusage::DynamicUsage(mapTx) + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+    // Estimate the overhead of mapTx to be 9 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+}\n+\n+size_t CTxMemPool::GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const {\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) + entry.DynamicMemoryUsage() + memusage::IncrementalDynamicUsage(mapNextTx) * entry.GetTx().vin.size();\n+}\n+\n+bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, std::set<uint256>& stage,\n+                                 CAmount& nFeesReserved, CAmount& nFeesRemoved) {\n+    std::set<uint256> protect;\n+    BOOST_FOREACH(const CTxIn& in, toadd.GetTx().vin) {\n+        protect.insert(in.prevout.hash);\n+    }\n+\n+    size_t incUsage = GuessDynamicMemoryUsage(toadd);\n+    size_t expsize = DynamicMemoryUsage() + incUsage; // Track the expected resulting memory usage of the mempool.\n+    if (expsize > sizelimit) {\n+        size_t sizeToTrim = std::min(expsize - sizelimit, incUsage);\n+        return TrimMempool(sizeToTrim, protect, nFeesReserved, toadd.GetTxSize(), toadd.GetFee(), stage, nFeesRemoved, true);\n+    }\n+    else\n+        return true;\n+}\n+\n+bool CTxMemPool::SurplusTrim(int multiplier, CFeeRate minRelayRate, std::set<uint256>& stage, size_t usageToTrim) {\n+    CFeeRate excessRate(multiplier * minRelayRate.GetFeePerK());\n+    std::set<uint256> noprotect;\n+    CAmount nFeesRemoved = 0;\n+    size_t sizeToTrim = usageToTrim / 4;  //Conservatively assume we have transactions at least 1/4 the size of the mempool space they've taken\n+    return TrimMempool(usageToTrim, noprotect, 0, sizeToTrim, excessRate.GetFee(sizeToTrim), stage, nFeesRemoved, false);\n+}\n+\n+bool CTxMemPool::TrimMempool(size_t sizeToTrim, std::set<uint256> &protect, CAmount nFeesReserved, size_t sizeToUse, CAmount feeToUse,\n+                             std::set<uint256>& stage, CAmount &nFeesRemoved, bool mustTrimAllSize) {\n+    size_t usageRemoved = 0;\n+    indexed_transaction_set::nth_index<1>::type::reverse_iterator it = mapTx.get<1>().rbegin();\n+    int fails = 0; // Number of mempool transactions iterated over that were not included in the stage.\n+    int itertotal = 0;\n+    int iterextra = mustTrimAllSize ? 10 : 100; //Allow many more iterations to find large size during SurplusTrim\n+    int iterperfail = mustTrimAllSize ? 5 : 10; //Try to follow more links during SurplusTrim\n+    int failmax = 10; //Try no more than 10 starting transactions\n+    uint64_t skipPattern = GetRand((uint64_t)1<<61);\n+    // Iterate from lowest feerate to highest feerate in the mempool:\n+    while (usageRemoved < sizeToTrim && it != mapTx.get<1>().rend()) {\n+        //Randomly skip between 0 and 7 entries\n+        unsigned int skipNum = std::min(fails,19);\n+        for (unsigned int i = 0; i < ((uint64_t)7 & (skipPattern >> (3*skipNum))) && it != mapTx.get<1>().rend();i++,it++);\n+        if (it == mapTx.get<1>().rend())\n+            break;\n+\n+        const uint256& hash = it->GetTx().GetHash();\n+        if (stage.count(hash)) {\n+            // If the transaction is already staged for deletion, we know its descendants are already processed, so skip it.\n+            it++;\n+            continue;\n+        }\n+        if ((double)it->GetFee() * sizeToUse > (double)feeToUse * it->GetTxSize()) {\n+            // If the transaction's feerate is worse than what we're looking for, we have processed everything in the mempool",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35547904",
      "id" : 35547904,
      "original_commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "original_position" : 234,
      "path" : "src/txmempool.cpp",
      "position" : 234,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-27T15:20:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35547904",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "body" : "@jtimon I'd like to add some sanity checking for the command line arguments that are passed in.  I assume that should go in init.cpp?  Where is the appropriate place for me to store variables such as hard cap, mempool expiry time, etc..  so they aren't recalculated every time.   ",
      "created_at" : "2015-07-27T15:40:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#issuecomment-125249073",
      "id" : 125249073,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6470",
      "updated_at" : "2015-07-27T15:40:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/125249073",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35551967"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35551967"
         }
      },
      "body" : "@morcos If this method call returns false, do we need to wipe stagedelete/nFeesDeleted, or are they guaranteed to be empty/zero?",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-27T15:53:11Z",
      "diff_hunk" : "@@ -859,22 +890,51 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), mempool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n-        // Don't accept it if it can't get into a block\n-        CAmount txMinFee = GetMinRelayFee(tx, nSize, true);\n-        if (fLimitFree && nFees < txMinFee)\n-            return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\",\n-                                      hash.ToString(), nFees, txMinFee),\n-                             REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n-\n-        // Require that free transactions have sufficient priority to be mined in the next block.\n-        if (GetBoolArg(\"-relaypriority\", true) && nFees < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        // The fees required to accept this transaction start with the fees required to accept it on its own\n+        CAmount nFeesRequired = 0;\n+        if (fLimitFree) {\n+            nFeesRequired = GetMinRelayFee(tx, nSize, true);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\", hash.ToString(), nFees, nFeesRequired),\n+                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+        }\n+        // If we are not relaying low priority free transactions, then if this tx doesn't have sufficient priority\n+        // it must have minRelayTxFee\n+        if (GetBoolArg(\"-relaypriority\", true) && nFeesRequired < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n+            nFeesRequired =  ::minRelayTxFee.GetFee(nSize);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        }\n+\n+        // Try to make space in mempool\n+        size_t softcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 700000;\n+        size_t hardcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n+        size_t capstep = (hardcap - softcap) / 10;\n+        std::set<uint256> stagedelete;\n+        CAmount nFeesDeleted = 0;\n+\n+        if (!mempool.StageTrimToSize(softcap, entry, stagedelete, nFeesRequired, nFeesDeleted)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35551967",
      "id" : 35551967,
      "original_commit_id" : "6b4af964ff15ffec0bc6dccef90f854fd28efddc",
      "original_position" : 116,
      "path" : "src/main.cpp",
      "position" : 116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-27T15:53:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35551967",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35554882"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35554882"
         }
      },
      "body" : "@sipa   Neither is the answer.  Perhaps it needs commenting though.  If the transaction is accepted into the reserve space and stagedelete is non-empty then it is both safe and desirable to evict any transactions that were staged.   If the transaction is not accepted into the reserve space, then as before we return failure from ATMP before we have a chance to evict anything.\r\n\r\nThe one slight caveat is in the case where you pass entry into the reserve space, but then you fail the rate limiter code directly below it.  In that case, it probably wasn't very fair that your feesDeleted were causing you to be counted as a free transaction.  It's overly conservative and rare behavior though.  I was planning on suggesting a fix but I wanted to see if there were any thoughts on the free relay code remaining in place here before I complicated it.  The suggested fix is that if the transaction is entering the mempool via the reserve space, and then it fails the rate limiter code, you let it in anyway but just wipe stagedelete.  Note that if stagedelete were empty then the tx by definition wouldn't have been subject to the rate limit test because it has a multiple of the minRelayFee.",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-27T16:18:19Z",
      "diff_hunk" : "@@ -859,22 +890,51 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), mempool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n-        // Don't accept it if it can't get into a block\n-        CAmount txMinFee = GetMinRelayFee(tx, nSize, true);\n-        if (fLimitFree && nFees < txMinFee)\n-            return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\",\n-                                      hash.ToString(), nFees, txMinFee),\n-                             REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n-\n-        // Require that free transactions have sufficient priority to be mined in the next block.\n-        if (GetBoolArg(\"-relaypriority\", true) && nFees < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        // The fees required to accept this transaction start with the fees required to accept it on its own\n+        CAmount nFeesRequired = 0;\n+        if (fLimitFree) {\n+            nFeesRequired = GetMinRelayFee(tx, nSize, true);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\", hash.ToString(), nFees, nFeesRequired),\n+                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+        }\n+        // If we are not relaying low priority free transactions, then if this tx doesn't have sufficient priority\n+        // it must have minRelayTxFee\n+        if (GetBoolArg(\"-relaypriority\", true) && nFeesRequired < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n+            nFeesRequired =  ::minRelayTxFee.GetFee(nSize);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        }\n+\n+        // Try to make space in mempool\n+        size_t softcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 700000;\n+        size_t hardcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n+        size_t capstep = (hardcap - softcap) / 10;\n+        std::set<uint256> stagedelete;\n+        CAmount nFeesDeleted = 0;\n+\n+        if (!mempool.StageTrimToSize(softcap, entry, stagedelete, nFeesRequired, nFeesDeleted)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35554882",
      "id" : 35554882,
      "original_commit_id" : "6b4af964ff15ffec0bc6dccef90f854fd28efddc",
      "original_position" : 116,
      "path" : "src/main.cpp",
      "position" : 116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-27T16:18:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35554882",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35555411"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35555411"
         }
      },
      "body" : "ACK, understood. That seems fine, but could probably use a comment.",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-27T16:22:57Z",
      "diff_hunk" : "@@ -859,22 +890,51 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), mempool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n-        // Don't accept it if it can't get into a block\n-        CAmount txMinFee = GetMinRelayFee(tx, nSize, true);\n-        if (fLimitFree && nFees < txMinFee)\n-            return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\",\n-                                      hash.ToString(), nFees, txMinFee),\n-                             REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n-\n-        // Require that free transactions have sufficient priority to be mined in the next block.\n-        if (GetBoolArg(\"-relaypriority\", true) && nFees < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        // The fees required to accept this transaction start with the fees required to accept it on its own\n+        CAmount nFeesRequired = 0;\n+        if (fLimitFree) {\n+            nFeesRequired = GetMinRelayFee(tx, nSize, true);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\", hash.ToString(), nFees, nFeesRequired),\n+                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+        }\n+        // If we are not relaying low priority free transactions, then if this tx doesn't have sufficient priority\n+        // it must have minRelayTxFee\n+        if (GetBoolArg(\"-relaypriority\", true) && nFeesRequired < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n+            nFeesRequired =  ::minRelayTxFee.GetFee(nSize);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        }\n+\n+        // Try to make space in mempool\n+        size_t softcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 700000;\n+        size_t hardcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n+        size_t capstep = (hardcap - softcap) / 10;\n+        std::set<uint256> stagedelete;\n+        CAmount nFeesDeleted = 0;\n+\n+        if (!mempool.StageTrimToSize(softcap, entry, stagedelete, nFeesRequired, nFeesDeleted)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35555411",
      "id" : 35555411,
      "original_commit_id" : "6b4af964ff15ffec0bc6dccef90f854fd28efddc",
      "original_position" : 116,
      "path" : "src/main.cpp",
      "position" : 116,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-27T16:22:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35555411",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35555690"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35555690"
         }
      },
      "body" : "Do you mind turning these into arguments, that get passed from the 2 callsites instead?",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-27T16:25:43Z",
      "diff_hunk" : "@@ -429,5 +438,159 @@ bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n     LOCK(cs);\n-    return memusage::DynamicUsage(mapTx) + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+    // Estimate the overhead of mapTx to be 9 pointers + an allocation, as no exact formula for boost::multi_index_contained is implemented.\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) * mapTx.size() + memusage::DynamicUsage(mapNextTx) + memusage::DynamicUsage(mapDeltas) + cachedInnerUsage;\n+}\n+\n+size_t CTxMemPool::GuessDynamicMemoryUsage(const CTxMemPoolEntry& entry) const {\n+    return memusage::MallocUsage(sizeof(CTxMemPoolEntry) + 9 * sizeof(void*)) + entry.DynamicMemoryUsage() + memusage::IncrementalDynamicUsage(mapNextTx) * entry.GetTx().vin.size();\n+}\n+\n+bool CTxMemPool::StageTrimToSize(size_t sizelimit, const CTxMemPoolEntry& toadd, std::set<uint256>& stage,\n+                                 CAmount& nFeesReserved, CAmount& nFeesRemoved) {\n+    std::set<uint256> protect;\n+    BOOST_FOREACH(const CTxIn& in, toadd.GetTx().vin) {\n+        protect.insert(in.prevout.hash);\n+    }\n+\n+    size_t incUsage = GuessDynamicMemoryUsage(toadd);\n+    size_t expsize = DynamicMemoryUsage() + incUsage; // Track the expected resulting memory usage of the mempool.\n+    if (expsize > sizelimit) {\n+        size_t sizeToTrim = std::min(expsize - sizelimit, incUsage);\n+        return TrimMempool(sizeToTrim, protect, nFeesReserved, toadd.GetTxSize(), toadd.GetFee(), stage, nFeesRemoved, true);\n+    }\n+    else\n+        return true;\n+}\n+\n+bool CTxMemPool::SurplusTrim(int multiplier, CFeeRate minRelayRate, std::set<uint256>& stage, size_t usageToTrim) {\n+    CFeeRate excessRate(multiplier * minRelayRate.GetFeePerK());\n+    std::set<uint256> noprotect;\n+    CAmount nFeesRemoved = 0;\n+    size_t sizeToTrim = usageToTrim / 4;  //Conservatively assume we have transactions at least 1/4 the size of the mempool space they've taken\n+    return TrimMempool(usageToTrim, noprotect, 0, sizeToTrim, excessRate.GetFee(sizeToTrim), stage, nFeesRemoved, false);\n+}\n+\n+bool CTxMemPool::TrimMempool(size_t sizeToTrim, std::set<uint256> &protect, CAmount nFeesReserved, size_t sizeToUse, CAmount feeToUse,\n+                             std::set<uint256>& stage, CAmount &nFeesRemoved, bool mustTrimAllSize) {\n+    size_t usageRemoved = 0;\n+    indexed_transaction_set::nth_index<1>::type::reverse_iterator it = mapTx.get<1>().rbegin();\n+    int fails = 0; // Number of mempool transactions iterated over that were not included in the stage.\n+    int itertotal = 0;\n+    int iterextra = mustTrimAllSize ? 10 : 100; //Allow many more iterations to find large size during SurplusTrim",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35555690",
      "id" : 35555690,
      "original_commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "original_position" : 215,
      "path" : "src/txmempool.cpp",
      "position" : 215,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-27T16:25:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35555690",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Needs rebase.",
      "created_at" : "2015-07-27T16:28:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#issuecomment-125264497",
      "id" : 125264497,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6470",
      "updated_at" : "2015-07-27T16:28:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/125264497",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "> that would let a small transaction erase a large transaction, making space for several new transactions to be cheaply relayed\r\n\r\n@sipa That is good.  You don't want a 500KB spam-monster tx paying (minimum fee/kb) to require a regular-sized tx to pay 1001 * (minimum fee/kb) to dislodge it.  Bad guy could get 1000 little txes relayed anyway by sending them first -- the pay-for-evicted rule creates a race to be first or pay double.",
      "created_at" : "2015-07-27T18:31:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#issuecomment-125298357",
      "id" : 125298357,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6470",
      "updated_at" : "2015-07-27T18:31:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/125298357",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4284124?v=3",
         "events_url" : "https://api.github.com/users/dgenr8/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgenr8/followers",
         "following_url" : "https://api.github.com/users/dgenr8/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgenr8/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgenr8",
         "id" : 4284124,
         "login" : "dgenr8",
         "organizations_url" : "https://api.github.com/users/dgenr8/orgs",
         "received_events_url" : "https://api.github.com/users/dgenr8/received_events",
         "repos_url" : "https://api.github.com/users/dgenr8/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgenr8/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgenr8/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgenr8"
      }
   },
   {
      "body" : "@dgenr8 While that is a potential problem for optimizing what gets into the mempool, note that this PR is attempting to provide a solution so that many small transactions can be used to evict large transaction packages.",
      "created_at" : "2015-07-27T18:37:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#issuecomment-125300493",
      "id" : 125300493,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6470",
      "updated_at" : "2015-07-27T18:37:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/125300493",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "body" : "@dgenr8 This conversation has been spread over a couple of PR's and IRC, so I apologize if I'm repeating a prior argument, but I think it would be good to explain the reasoning behind the logic in this pull.\r\n\r\nPrior to limiting the mempool (or having RBF implemented), we had protection against bandwidth spamming attacks by requiring all transactions that were relayed to be accepted into the mempool and have either fee or priority.  Since those transactions are now in the mempool and can't be recalled, those fees are now at risk for being consumed by being included in a block.  This pull isn't meant to provide some new protection against that attack, but is only meant to protect against OOM attacks by ever expanding mempools.   However, it must be sure not to break that pre-existing protection.\r\n\r\nOnce we create a way for transactions to be removed from the mempool, we have to realize that the fees placed on those transactions are no longer at risk.   The approach we've been using is to say that (modulo transactions that have already been mined) the mempool must contain enough fees to pay for the relay cost of all transactions that have been historically broadcast whether they are still in the mempool or not.  What this prevents is someone replacing or evicting their own transactions \"cheaply\" and thereby achieving free relay of their original transactions.   The fact that there might be a race to get into the mempool before it fills up is a slight aberration that occurs as a one off.  We still need a mechanism by which to adjust the minimum relay fee over time in the event that it is too small to dissuade spam. \r\n\r\nYour concern about a monster transaction of low fees preventing a small transaction from getting in the mempool is addressed in 4 separate ways in this pull.  \r\n1) Multiple attempts are made to evict transactions, so being unlucky and trying against one large transaction is insufficient to block  you.\r\n2) Some portion of the mempool space is reserved for higher and higher fee transactions.  That space is not cheaply fillable with spam and should serve to act as a temporarily higher min relay rate which will keep the relay path open for high fee paying tx's (large or small).\r\n3) Any tx's occupying the reserve space are periodically looked at in aggregate and used to remove large tx's or chains of tx's from the bottom of the mempool that would otherwise be unevictable.\r\n4) There is a time based eviction mechanism as a last fall back.\r\n\r\nNo doubt further improvements are possible, but I think this is a good step in the right direction.",
      "created_at" : "2015-07-27T19:51:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#issuecomment-125324736",
      "id" : 125324736,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6470",
      "updated_at" : "2015-07-27T19:51:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/125324736",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35581287"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35581287"
         }
      },
      "body" : "No objection to changing, but just want to understand what the style request is related to this.   All then blocks should have braces or only because the else block is multi-line?  A single-line then block without braces appears as example code in developer-notes.md.",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-27T20:18:29Z",
      "diff_hunk" : "@@ -859,22 +890,51 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), mempool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n-        // Don't accept it if it can't get into a block\n-        CAmount txMinFee = GetMinRelayFee(tx, nSize, true);\n-        if (fLimitFree && nFees < txMinFee)\n-            return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\",\n-                                      hash.ToString(), nFees, txMinFee),\n-                             REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n-\n-        // Require that free transactions have sufficient priority to be mined in the next block.\n-        if (GetBoolArg(\"-relaypriority\", true) && nFees < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        // The fees required to accept this transaction start with the fees required to accept it on its own\n+        CAmount nFeesRequired = 0;\n+        if (fLimitFree) {\n+            nFeesRequired = GetMinRelayFee(tx, nSize, true);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\", hash.ToString(), nFees, nFeesRequired),\n+                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+        }\n+        // If we are not relaying low priority free transactions, then if this tx doesn't have sufficient priority\n+        // it must have minRelayTxFee\n+        if (GetBoolArg(\"-relaypriority\", true) && nFeesRequired < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n+            nFeesRequired =  ::minRelayTxFee.GetFee(nSize);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        }\n+\n+        // Try to make space in mempool\n+        size_t softcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 700000;\n+        size_t hardcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n+        size_t capstep = (hardcap - softcap) / 10;\n+        std::set<uint256> stagedelete;\n+        CAmount nFeesDeleted = 0;\n+\n+        if (!mempool.StageTrimToSize(softcap, entry, stagedelete, nFeesRequired, nFeesDeleted)) {\n+            size_t expsize = mempool.DynamicMemoryUsage() + mempool.GuessDynamicMemoryUsage(entry);\n+            if (expsize > hardcap)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35581287",
      "id" : 35581287,
      "original_commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "original_position" : 118,
      "path" : "src/main.cpp",
      "position" : 118,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-27T20:18:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35581287",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35582107"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35582107"
         }
      },
      "body" : "Oh, I thought we changed that. Never mind then.\n\nI personally dislike those, as they easily lead to mistakes when merging\ndifferent patches (see the OSX SSL bug that was likely the result of it),\nbut I shouldn't ask that as long as our notes use it.\n",
      "commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "created_at" : "2015-07-27T20:25:03Z",
      "diff_hunk" : "@@ -859,22 +890,51 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), mempool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n-        // Don't accept it if it can't get into a block\n-        CAmount txMinFee = GetMinRelayFee(tx, nSize, true);\n-        if (fLimitFree && nFees < txMinFee)\n-            return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\",\n-                                      hash.ToString(), nFees, txMinFee),\n-                             REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n-\n-        // Require that free transactions have sufficient priority to be mined in the next block.\n-        if (GetBoolArg(\"-relaypriority\", true) && nFees < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n-            return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        // The fees required to accept this transaction start with the fees required to accept it on its own\n+        CAmount nFeesRequired = 0;\n+        if (fLimitFree) {\n+            nFeesRequired = GetMinRelayFee(tx, nSize, true);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, error(\"AcceptToMemoryPool: not enough fees %s, %d < %d\", hash.ToString(), nFees, nFeesRequired),\n+                                 REJECT_INSUFFICIENTFEE, \"insufficient fee\");\n+        }\n+        // If we are not relaying low priority free transactions, then if this tx doesn't have sufficient priority\n+        // it must have minRelayTxFee\n+        if (GetBoolArg(\"-relaypriority\", true) && nFeesRequired < ::minRelayTxFee.GetFee(nSize) && !AllowFree(view.GetPriority(tx, chainActive.Height() + 1))) {\n+            nFeesRequired =  ::minRelayTxFee.GetFee(nSize);\n+            if (nFees < nFeesRequired)\n+                return state.DoS(0, false, REJECT_INSUFFICIENTFEE, \"insufficient priority\");\n+        }\n+\n+        // Try to make space in mempool\n+        size_t softcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 700000;\n+        size_t hardcap = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n+        size_t capstep = (hardcap - softcap) / 10;\n+        std::set<uint256> stagedelete;\n+        CAmount nFeesDeleted = 0;\n+\n+        if (!mempool.StageTrimToSize(softcap, entry, stagedelete, nFeesRequired, nFeesDeleted)) {\n+            size_t expsize = mempool.DynamicMemoryUsage() + mempool.GuessDynamicMemoryUsage(entry);\n+            if (expsize > hardcap)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#discussion_r35582107",
      "id" : 35582107,
      "original_commit_id" : "c4d87ae1157c4a854329693a40b23e8996c604e0",
      "original_position" : 118,
      "path" : "src/main.cpp",
      "position" : 118,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/6470",
      "updated_at" : "2015-07-27T20:25:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/35582107",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "@morcos Thanks.  I feel the capping part of this pull is too complex, and could be simplifed (a little) by removing the \"pay for eviction\" idea, which has no good incentive effect.\r\n\r\nThe person paid is the miner, who doesn't need to be paid ~double to mine the evictor tx.  The person who pays is the unlucky evictor.  Evictee gets a chance at cheap fees, and others who come after eviction could pay even less, since there might then be extra space for them.\r\n\r\nThe case where evictor == evictee could be handled explicitly, if it were actually possible to target this kind of replacement with all the factors that affect the selection of the evictees, such as propagation variation, node start time variation, mining, and nodes having different mempool size limits.\r\n\r\n\r\n",
      "created_at" : "2015-07-28T00:43:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/6470#issuecomment-125392790",
      "id" : 125392790,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/6470",
      "updated_at" : "2015-07-28T00:43:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/125392790",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4284124?v=3",
         "events_url" : "https://api.github.com/users/dgenr8/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dgenr8/followers",
         "following_url" : "https://api.github.com/users/dgenr8/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dgenr8/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dgenr8",
         "id" : 4284124,
         "login" : "dgenr8",
         "organizations_url" : "https://api.github.com/users/dgenr8/orgs",
         "received_events_url" : "https://api.github.com/users/dgenr8/received_events",
         "repos_url" : "https://api.github.com/users/dgenr8/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dgenr8/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dgenr8/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dgenr8"
      }
   }
]
