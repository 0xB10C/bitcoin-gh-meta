[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r63647803"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/63647803"
         }
      },
      "body" : "clang warns about `lsb` and `msb` used uninitialized.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-05-18T05:41:59Z",
      "diff_hunk" : "@@ -0,0 +1,202 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+class CTxMemPool;\n+\n+class TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding\n+    }\n+};\n+\n+struct BlockTransactionsRequest {\n+    uint256 blockhash;\n+    std::vector<uint32_t> indexes;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(blockhash);\n+        size_t indexes_size = indexes.size();\n+        READWRITE(VARINT(indexes_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (indexes.size() < indexes_size) {\n+                indexes.resize(std::min(1000 + indexes.size(), indexes_size));\n+                for (; i < indexes.size(); i++)\n+                    READWRITE(VARINT(indexes[i]));\n+            }\n+\n+            uint32_t offset = 0;\n+            for (size_t i = 0; i < indexes.size(); i++) {\n+                if (uint64_t(indexes[i]) + uint64_t(offset) > std::numeric_limits<uint32_t>::max())\n+                    throw std::ios_base::failure(\"indexes overflowed 32-bits\");\n+                indexes[i] = indexes[i] + offset;\n+                offset = indexes[i] + 1;\n+            }\n+        } else {\n+            for (size_t i = 0; i < indexes.size(); i++) {\n+                uint32_t index = indexes[i] - (i == 0 ? 0 : (indexes[i - 1] + 1));\n+                READWRITE(VARINT(index));\n+            }\n+        }\n+    }\n+};\n+\n+struct BlockTransactions {\n+    uint256 blockhash;\n+    std::vector<CTransaction> txn;\n+\n+    BlockTransactions() {}\n+    BlockTransactions(const BlockTransactionsRequest& req) :\n+        blockhash(req.blockhash), txn(req.indexes.size()) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(blockhash);\n+        size_t txn_size = txn.size();\n+        READWRITE(VARINT(txn_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (txn.size() < txn_size) {\n+                txn.resize(std::min(1000 + txn.size(), txn_size));\n+                for (; i < txn.size(); i++)\n+                    READWRITE(REF(TransactionCompressor(txn[i])));\n+            }\n+        } else {\n+            for (size_t i = 0; i < txn.size(); i++)\n+                READWRITE(REF(TransactionCompressor(txn[i])));\n+        }\n+    }\n+};\n+\n+struct PrefilledTransaction {\n+    // Used as an offset since last prefilled tx in CBlockHeaderAndShortTxIDs,\n+    // as a proper transaction-in-block-index in PartiallyDownloadedBlock\n+    uint16_t index;\n+    CTransaction tx;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(VARINT(index));\n+        READWRITE(REF(TransactionCompressor(tx)));\n+    }\n+};\n+\n+typedef enum ReadStatus_t\n+{\n+    READ_STATUS_OK,\n+    READ_STATUS_INVALID, // Invalid object, peer is sending bogus crap\n+    READ_STATUS_FAILED, // Failed to process object\n+} ReadStatus;\n+\n+class CBlockHeaderAndShortTxIDs {\n+private:\n+    mutable uint64_t shorttxidk0, shorttxidk1;\n+    uint64_t nonce;\n+\n+    void FillShortTxIDSelector() const;\n+\n+    friend class PartiallyDownloadedBlock;\n+\n+    static const int SHORTTXIDS_LENGTH = 6;\n+protected:\n+    std::vector<uint64_t> shorttxids;\n+    std::vector<PrefilledTransaction> prefilledtxn;\n+\n+public:\n+    CBlockHeader header;\n+\n+    // Dummy for deserialization\n+    CBlockHeaderAndShortTxIDs() {}\n+\n+    CBlockHeaderAndShortTxIDs(const CBlock& block);\n+\n+    uint64_t GetShortID(const uint256& txhash) const;\n+\n+    size_t BlockTxCount() const { return shorttxids.size() + prefilledtxn.size(); }\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(header);\n+        READWRITE(nonce);\n+\n+        size_t shorttxids_size = shorttxids.size();\n+        READWRITE(VARINT(shorttxids_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (shorttxids.size() < shorttxids_size) {\n+                shorttxids.resize(std::min(1000 + shorttxids.size(), shorttxids_size));\n+                for (; i < shorttxids.size(); i++) {\n+                    uint32_t lsb; uint16_t msb;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r63647803",
      "id" : 63647803,
      "original_commit_id" : "816956e8dae6c122dfde63a46ea110cca187b836",
      "original_position" : 152,
      "path" : "src/blockencodings.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/63647803",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "`test/test_bitcoin` failures in travis are strange. Can't reproduce locally. Hmm, we should probably include `src/test-suite.log` in the travis output in such cases.\r\n\r\n... just a second after I wrote this, I see this failure in my logs:\r\n\r\n```\r\nRunning 200 test cases...\r\ntest/net_tests.cpp:92: error in \"caddrdb_read\": check addrman1.size() == 3 failed\r\ntest/net_tests.cpp:102: error in \"caddrdb_read\": check addrman2.size() == 3 failed\r\n\r\n*** 2 failures detected in test suite \"Bitcoin Test Suite\"\r\n```\r\n\r\nI will compare many runs in master and this PR:\r\n\r\n```\r\nmaster: 8 failures\r\n8068: 6 failures\r\n```\r\n\r\nAs this is present in master already, it is not caused by this PR. I'll investigate...\r\n\r\nThe question is, if the travis failure in `test_bitcoin` is the same I see here...\r\n\r\nLooks like the same problem was already reported by me: https://github.com/bitcoin/bitcoin/pull/7696#issuecomment-197200010\r\n\r\nSeparate issue now: #8069\r\n",
      "created_at" : "2016-05-18T05:52:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-219931715",
      "id" : 219931715,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-05-18T07:36:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/219931715",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "Needs rebase to remove the siphash commits from the top. :)",
      "created_at" : "2016-05-18T09:47:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-219977952",
      "id" : 219977952,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-05-18T09:47:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/219977952",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "Rebased and fixed @paveljanik's clang compile-warning.",
      "created_at" : "2016-05-18T20:23:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-220146640",
      "id" : 220146640,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-05-18T20:23:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/220146640",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "Also removed the varint stuff...turns out it wasnt as big a gain as I thought.",
      "created_at" : "2016-05-18T20:23:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-220146749",
      "id" : 220146749,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-05-18T20:23:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/220146749",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "concept ACK",
      "created_at" : "2016-05-19T01:43:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-220206517",
      "id" : 220206517,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-05-19T01:43:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/220206517",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "body" : "Thinking more about this (and seeing more pull requests touching the mempool), I think having the mempool store its CTransaction objects using shared_ptr's would make sense.\r\n\r\n* During erasing from the mempool, we return the deleted entries upwards (for signalling to wallets etc). This requires expensive copying that could be avoided with shared_ptr (alternatively, see #8099)\r\n* During transaction relay, BIP35 processing, and tx getdata, we fetch mempool transactions (copying them!) before determining whether they can be relayed. Especially with filters active, this is a pretty expensive operation for omitted cases. As none of the things done with the result (filtering, inving, serializing) require a full copy, shared_ptr would be far more efficient.\n* mapRelay often contains transactions that are also stored in the mempool. Shared_ptr's would alleviate duplicate storage space.\r\n* In this PR, it would avoid the need for manual reference counting and for giving the CTxMempool the weird responsibility for owning transactions that aren't even in the mempool anymore.\r\n",
      "created_at" : "2016-05-26T13:00:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-221863723",
      "id" : 221863723,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-05-28T17:22:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/221863723",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Will test that during next week, I need to use it for one of my project",
      "created_at" : "2016-05-29T00:59:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-222336764",
      "id" : 222336764,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-05-29T00:59:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/222336764",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "body" : "This should update the implemented BIPs list.",
      "created_at" : "2016-05-30T16:06:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-222521282",
      "id" : 222521282,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-05-30T16:06:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/222521282",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "Here is a rebase on top of #8126, using shared_ptr's for partial block transactions: https://github.com/sipa/bitcoin/commits/compactblocks",
      "created_at" : "2016-06-01T01:35:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-222869545",
      "id" : 222869545,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-01T13:10:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/222869545",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Ok, some comments after looking through the code and working to rebase:\r\n* `CBlockHeaderAndShortTxIDs::FillShortTxIDSelector` should use `htole64` before serializing the nonce (endianness correctness)\r\n* `PartiallyDownloadedBlock::InitData`'s `have_txn` can use a `vector<bool>` (which is bitpacked internally) instead of manual bit logic (nit)\r\n* The code in `ProcessMessage` to add a peer as a direct compact block request peer is duplicated.\r\n* A lot of calls to `error()` that should be LogPrintf's or nothing at all.",
      "created_at" : "2016-06-01T13:27:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-222991558",
      "id" : 222991558,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-01T13:27:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/222991558",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "It would be nice if the getpeerinfo showed the sendcmpct status (maybe hex for the version?).",
      "created_at" : "2016-06-01T17:16:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223062347",
      "id" : 223062347,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-01T17:16:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223062347",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "> (maybe hex for the version?)\r\n\r\nHow to display numbers is a client-side thing, and I'm not sure it makes sense to bloat up bitcoin-cli with this kind of logic?",
      "created_at" : "2016-06-01T17:39:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223068790",
      "id" : 223068790,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-01T17:39:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223068790",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "body" : "> (maybe hex for the version?)\r\n\r\nWorth nothing this issue has [come up before](https://github.com/bitcoin/bitcoin/pull/7774) and was added as `versionHex`.",
      "created_at" : "2016-06-02T02:58:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223183123",
      "id" : 223183123,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-02T02:59:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223183123",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/413395?v=3",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65798257"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65798257"
         }
      },
      "body" : "No need for taking lock on pool->cs ?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-04T06:19:04Z",
      "diff_hunk" : "@@ -0,0 +1,170 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"util.h\"\n+\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    hasher.Write((unsigned char*)&nonce, sizeof(nonce));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txhashes.empty());\n+    header = cmpctblock.header;\n+    txhashes.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    prefilledtxn.reserve(cmpctblock.prefilledtxn.size());\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txhashes[lastprefilledindex] = cmpctblock.prefilledtxn[i].tx.GetHash();\n+        prefilledtxn.push_back({(uint16_t)lastprefilledindex, cmpctblock.prefilledtxn[i].tx});\n+    }\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    std::map<uint64_t, uint16_t> shorttxids;\n+    uint16_t index_offset = 0;\n+    std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (prefilledit != prefilledtxn.end() && i + index_offset == prefilledit->index) {\n+            index_offset++;\n+            prefilledit++;\n+        }\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+    }\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())\n+        return READ_STATUS_FAILED; // Short ID collision\n+\n+    char have_txn[txhashes.size() / 8 + 1];\n+    memset(have_txn, 0, txhashes.size() / 8 + 1);\n+\n+    LOCK(pool->cs);\n+    for (CTxMemPool::txiter it = pool->mapTx.begin(); it != pool->mapTx.end(); it++) {\n+        std::map<uint64_t, uint16_t>::iterator idit = shorttxids.find(cmpctblock.GetShortID(it->GetTx().GetHash()));\n+        if (idit != shorttxids.end()) {\n+            if (!(have_txn[idit->second / 8] & (1 << (idit->second & 0x7)))) {\n+                it->AddRef();\n+                txhashes[idit->second] = it->GetTx().GetHash();\n+                have_txn[idit->second / 8] |= 1 << (idit->second & 0x7);\n+            } else {\n+                // If we find two mempool txn that match the short id, just request it.\n+                // This should be rare enough that the extra bandwidth doesn't matter,\n+                // but eating a round-trip due to FillBlock failure would be annoying\n+                pool->ReleaseTxLock(txhashes[idit->second]);\n+                txhashes[idit->second].SetNull();\n+            }\n+        }\n+    }\n+\n+    LogPrint(\"cmpctblock\", \"Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\\n\", cmpctblock.header.GetHash().ToString(), cmpctblock.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION));\n+\n+    return READ_STATUS_OK;\n+}\n+\n+bool PartiallyDownloadedBlock::IsTxAvailable(size_t index) const {\n+    assert(!header.IsNull());\n+    assert(index < txhashes.size());\n+    return !txhashes[index].IsNull();\n+}\n+\n+ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<CTransaction>& vtx_missing) const {\n+    assert(!header.IsNull());\n+    block = header;\n+    block.vtx.resize(txhashes.size());\n+\n+    size_t tx_missing_offset = 0;\n+    std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+    size_t prefilled_count = 0, missing_count = 0, mempool_count = 0;\n+    for (size_t i = 0; i < txhashes.size(); i++) {\n+        if (txhashes[i].IsNull()) {\n+            if (vtx_missing.size() <= tx_missing_offset)\n+                return READ_STATUS_INVALID;\n+            block.vtx[i] = vtx_missing[tx_missing_offset++];\n+            missing_count++;\n+        } else {\n+            if (prefilledit != prefilledtxn.end() && prefilledit->index == i) {\n+                block.vtx[i] = prefilledit->tx;\n+                prefilledit++;\n+                prefilled_count++;\n+            } else {\n+                assert(pool->lookup(txhashes[i], block.vtx[i], true));\n+                mempool_count++;\n+            }\n+        }\n+    }\n+    assert(prefilledit == prefilledtxn.end());\n+    if (vtx_missing.size() == tx_missing_offset) {\n+        LogPrint(\"cmpctblock\", \"Successfully reconstructed block %s with %lu txn prefilled, %lu txn from mempool and %lu txn requested\\n\", header.GetHash().ToString(), prefilled_count, mempool_count, missing_count);\n+        if (vtx_missing.size() < 5) {\n+            BOOST_FOREACH(const CTransaction& tx, vtx_missing)\n+                LogPrint(\"cmpctblock\", \"Reconstructed block %s required tx %s\\n\", header.GetHash().ToString(), tx.GetHash().ToString());\n+        }\n+    }\n+    return vtx_missing.size() == tx_missing_offset ? READ_STATUS_OK : READ_STATUS_INVALID;\n+}\n+\n+PartiallyDownloadedBlock::~PartiallyDownloadedBlock() {\n+    if (!header.IsNull()) {\n+        std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+        for (size_t i = 0; i < txhashes.size(); i++) {\n+            if (!txhashes[i].IsNull()) {\n+                if (prefilledit != prefilledtxn.end() && prefilledit->index == i)\n+                    prefilledit++;\n+                else\n+                    pool->ReleaseTxLock(txhashes[i]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65798257",
      "id" : 65798257,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 166,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65798257",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65799356"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65799356"
         }
      },
      "body" : "If you intend to do it later, it's better removing it from the PR. Just for curiosity, if it is later included, the goal will be to use sendcmpct's version to decide the type of serialization of the transactions ?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-04T08:08:15Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+class CTxMemPool;\n+\n+class TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65799356",
      "id" : 65799356,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 22,
      "path" : "src/blockencodings.h",
      "position" : 25,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65799356",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65799753"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65799753"
         }
      },
      "body" : "`fAnnounceUsingCMPCTBLOCK` is the way with which the remote node prefer to receive block notifications.\r\n\r\nIt gives no information about whether the remote node itself provide or not header and IDs.\r\nImho it should be fixed to:\r\n\r\n`State(pfrom->GetId())->fProvidesHeaderAndIDs = pfrom->nVersion >= SHORT_IDS_BLOCKS_VERSION && pfrom->nServices & NODE_NETWORK;`\r\n\r\nMoved when we the node receive the VERSION message.\r\n\r\nBecause even if fAnnounceUsingCMPCTBLOCK is `false` (low bandwidth relaying case), the node still provide header and ids.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-04T08:47:46Z",
      "diff_hunk" : "@@ -4789,6 +4836,18 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         State(pfrom->GetId())->fPreferHeaders = true;\n     }\n \n+    else if (strCommand == NetMsgType::SENDCMPCT)\n+    {\n+        bool fAnnounceUsingCMPCTBLOCK = false;\n+        uint64_t nCMPCTBLOCKVersion = 1;\n+        vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;\n+        if (nCMPCTBLOCKVersion == 1) {\n+            LOCK(cs_main);\n+            State(pfrom->GetId())->fProvidesHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65799753",
      "id" : 65799753,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 156,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65799753",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65802242"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65802242"
         }
      },
      "body" : "nit: constant would be nice, 3 is reused on https://github.com/bitcoin/bitcoin/pull/8068/files#diff-7ec3c68a81efff79b6ca22ac1f1eabbaR5499\r\n\r\nActually I think that this whole code about unsubscribing from CMPCTBLOCK of other node and registering to this node is duplicated below.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-04T12:56:50Z",
      "diff_hunk" : "@@ -4835,10 +4894,39 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n                     CNodeState *nodestate = State(pfrom->GetId());\n                     if (CanDirectFetch(chainparams.GetConsensus()) &&\n                         nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n-                        vToFetch.push_back(inv);\n+                        if (nodestate->fProvidesHeaderAndIDs)\n+                            vToFetch.push_back(CInv(MSG_CMPCT_BLOCK, inv.hash));\n+                        else\n+                            vToFetch.push_back(inv);\n                         // Mark block as in flight already, even though the actual \"getdata\" message only goes out\n                         // later (within the same cs_main lock, though).\n                         MarkBlockAsInFlight(pfrom->GetId(), inv.hash, chainparams.GetConsensus());\n+                        if (mapBlocksInFlight.size() <= 2) {\n+                            // We seem to be rather well-synced, so it appears pfrom was the first to provide us\n+                            // with this block! Let's get them to announce using compact blocks in the future.\n+                            if (nodestate->fProvidesHeaderAndIDs) {\n+                                bool fAlreadyAnnouncing = false;\n+                                BOOST_FOREACH(const NodeId nodeid, lNodesAnnouncingHeaderAndIDs)\n+                                    if (nodeid == pfrom->GetId())\n+                                        fAlreadyAnnouncing = true;\n+                                if (!fAlreadyAnnouncing) {\n+                                    bool fAnnounceUsingCMPCTBLOCK = false;\n+                                    uint64_t nCMPCTBLOCKVersion = 1;\n+                                    if (lNodesAnnouncingHeaderAndIDs.size() >= 3) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65802242",
      "id" : 65802242,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 187,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65802242",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65803246"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65803246"
         }
      },
      "body" : "typo: indicies",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-04T14:32:29Z",
      "diff_hunk" : "@@ -4930,6 +5018,35 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::GETBLOCKTXN)\n+    {\n+        BlockTransactionsRequest req;\n+        vRecv >> req;\n+\n+        BlockMap::iterator it = mapBlockIndex.find(req.blockhash);\n+        if (it == mapBlockIndex.end() || !(it->second->nStatus & BLOCK_HAVE_DATA)) {\n+            Misbehaving(pfrom->GetId(), 100);\n+            return error(\"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->id);\n+        }\n+\n+        if (it->second->nHeight < chainActive.Height() - 10)\n+            return error(\"Peer %d sent us a getblocktxn for a block > 10 deep\", pfrom->id);\n+\n+        CBlock block;\n+        assert(ReadBlockFromDisk(block, it->second, chainparams.GetConsensus()));\n+\n+        BlockTransactions resp(req);\n+        for (size_t i = 0; i < req.indexes.size(); i++) {\n+            if (req.indexes[i] >= block.vtx.size()) {\n+                Misbehaving(pfrom->GetId(), 100);\n+                return error(\"Peer %d sent us a getblocktxn with out-of-bounds tx indicies\", pfrom->id);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65803246",
      "id" : 65803246,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 230,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65803246",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "body" : "@TheBlueMatt when you continue this you should probably continue from Pieter's rebase.",
      "created_at" : "2016-06-04T17:48:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223768784",
      "id" : 223768784,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-04T17:48:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223768784",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65848221"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65848221"
         }
      },
      "body" : "Not sure what you're asking? There is no explicit lock on cs here, but ReleaseTxLock does LOCK(cs) itself.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-06T07:45:33Z",
      "diff_hunk" : "@@ -0,0 +1,170 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"util.h\"\n+\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    hasher.Write((unsigned char*)&nonce, sizeof(nonce));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txhashes.empty());\n+    header = cmpctblock.header;\n+    txhashes.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    prefilledtxn.reserve(cmpctblock.prefilledtxn.size());\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txhashes[lastprefilledindex] = cmpctblock.prefilledtxn[i].tx.GetHash();\n+        prefilledtxn.push_back({(uint16_t)lastprefilledindex, cmpctblock.prefilledtxn[i].tx});\n+    }\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    std::map<uint64_t, uint16_t> shorttxids;\n+    uint16_t index_offset = 0;\n+    std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (prefilledit != prefilledtxn.end() && i + index_offset == prefilledit->index) {\n+            index_offset++;\n+            prefilledit++;\n+        }\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+    }\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())\n+        return READ_STATUS_FAILED; // Short ID collision\n+\n+    char have_txn[txhashes.size() / 8 + 1];\n+    memset(have_txn, 0, txhashes.size() / 8 + 1);\n+\n+    LOCK(pool->cs);\n+    for (CTxMemPool::txiter it = pool->mapTx.begin(); it != pool->mapTx.end(); it++) {\n+        std::map<uint64_t, uint16_t>::iterator idit = shorttxids.find(cmpctblock.GetShortID(it->GetTx().GetHash()));\n+        if (idit != shorttxids.end()) {\n+            if (!(have_txn[idit->second / 8] & (1 << (idit->second & 0x7)))) {\n+                it->AddRef();\n+                txhashes[idit->second] = it->GetTx().GetHash();\n+                have_txn[idit->second / 8] |= 1 << (idit->second & 0x7);\n+            } else {\n+                // If we find two mempool txn that match the short id, just request it.\n+                // This should be rare enough that the extra bandwidth doesn't matter,\n+                // but eating a round-trip due to FillBlock failure would be annoying\n+                pool->ReleaseTxLock(txhashes[idit->second]);\n+                txhashes[idit->second].SetNull();\n+            }\n+        }\n+    }\n+\n+    LogPrint(\"cmpctblock\", \"Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\\n\", cmpctblock.header.GetHash().ToString(), cmpctblock.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION));\n+\n+    return READ_STATUS_OK;\n+}\n+\n+bool PartiallyDownloadedBlock::IsTxAvailable(size_t index) const {\n+    assert(!header.IsNull());\n+    assert(index < txhashes.size());\n+    return !txhashes[index].IsNull();\n+}\n+\n+ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<CTransaction>& vtx_missing) const {\n+    assert(!header.IsNull());\n+    block = header;\n+    block.vtx.resize(txhashes.size());\n+\n+    size_t tx_missing_offset = 0;\n+    std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+    size_t prefilled_count = 0, missing_count = 0, mempool_count = 0;\n+    for (size_t i = 0; i < txhashes.size(); i++) {\n+        if (txhashes[i].IsNull()) {\n+            if (vtx_missing.size() <= tx_missing_offset)\n+                return READ_STATUS_INVALID;\n+            block.vtx[i] = vtx_missing[tx_missing_offset++];\n+            missing_count++;\n+        } else {\n+            if (prefilledit != prefilledtxn.end() && prefilledit->index == i) {\n+                block.vtx[i] = prefilledit->tx;\n+                prefilledit++;\n+                prefilled_count++;\n+            } else {\n+                assert(pool->lookup(txhashes[i], block.vtx[i], true));\n+                mempool_count++;\n+            }\n+        }\n+    }\n+    assert(prefilledit == prefilledtxn.end());\n+    if (vtx_missing.size() == tx_missing_offset) {\n+        LogPrint(\"cmpctblock\", \"Successfully reconstructed block %s with %lu txn prefilled, %lu txn from mempool and %lu txn requested\\n\", header.GetHash().ToString(), prefilled_count, mempool_count, missing_count);\n+        if (vtx_missing.size() < 5) {\n+            BOOST_FOREACH(const CTransaction& tx, vtx_missing)\n+                LogPrint(\"cmpctblock\", \"Reconstructed block %s required tx %s\\n\", header.GetHash().ToString(), tx.GetHash().ToString());\n+        }\n+    }\n+    return vtx_missing.size() == tx_missing_offset ? READ_STATUS_OK : READ_STATUS_INVALID;\n+}\n+\n+PartiallyDownloadedBlock::~PartiallyDownloadedBlock() {\n+    if (!header.IsNull()) {\n+        std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+        for (size_t i = 0; i < txhashes.size(); i++) {\n+            if (!txhashes[i].IsNull()) {\n+                if (prefilledit != prefilledtxn.end() && prefilledit->index == i)\n+                    prefilledit++;\n+                else\n+                    pool->ReleaseTxLock(txhashes[i]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65848221",
      "id" : 65848221,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 166,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65848221",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65848308"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65848308"
         }
      },
      "body" : "Yes, use the version field in cmpctblock is the upgrade mechanism here.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-06T07:46:09Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+class CTxMemPool;\n+\n+class TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65848308",
      "id" : 65848308,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 22,
      "path" : "src/blockencodings.h",
      "position" : 25,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65848308",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65850726"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65850726"
         }
      },
      "body" : "Yup, they were just inverted, fixed.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-06T08:07:05Z",
      "diff_hunk" : "@@ -4789,6 +4836,18 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n         State(pfrom->GetId())->fPreferHeaders = true;\n     }\n \n+    else if (strCommand == NetMsgType::SENDCMPCT)\n+    {\n+        bool fAnnounceUsingCMPCTBLOCK = false;\n+        uint64_t nCMPCTBLOCKVersion = 1;\n+        vRecv >> fAnnounceUsingCMPCTBLOCK >> nCMPCTBLOCKVersion;\n+        if (nCMPCTBLOCKVersion == 1) {\n+            LOCK(cs_main);\n+            State(pfrom->GetId())->fProvidesHeaderAndIDs = fAnnounceUsingCMPCTBLOCK;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65850726",
      "id" : 65850726,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 156,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65850726",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "Rebased on latest master (Pieter's is an insignificant change here, I'll just rebase when it gets merged), and addressed all the comments I saw above, though I didnt add cmpctblock status to getpeerinfo since its already there (in the form of message size info) and I dont want to be bikeshedded for getpeerinfo api....\r\n\r\nNote for LogPrints in network processing, I tried to use the rule \"LogPrint(\"net\" in general, but LogPrintf( if you're gonna set a DoS score, since it always irritates me when I see nodes getting DoS scores and nothing to tell me why in debug.log.",
      "created_at" : "2016-06-06T08:18:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223895608",
      "id" : 223895608,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-06T08:18:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223895608",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "From Travis:\r\n\r\n```\r\nEXCEPTION: St12out_of_range       \r\nCInv::GetCommand(): type=4 unknown type       \r\nbitcoin in ProcessMessages()\r\n```",
      "created_at" : "2016-06-06T12:00:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-223939085",
      "id" : 223939085,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-06T12:00:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/223939085",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65925840"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65925840"
         }
      },
      "body" : "ok, it responds to my question thanks.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-06T16:50:42Z",
      "diff_hunk" : "@@ -0,0 +1,170 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"util.h\"\n+\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    hasher.Write((unsigned char*)&nonce, sizeof(nonce));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txhashes.empty());\n+    header = cmpctblock.header;\n+    txhashes.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    prefilledtxn.reserve(cmpctblock.prefilledtxn.size());\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txhashes[lastprefilledindex] = cmpctblock.prefilledtxn[i].tx.GetHash();\n+        prefilledtxn.push_back({(uint16_t)lastprefilledindex, cmpctblock.prefilledtxn[i].tx});\n+    }\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    std::map<uint64_t, uint16_t> shorttxids;\n+    uint16_t index_offset = 0;\n+    std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (prefilledit != prefilledtxn.end() && i + index_offset == prefilledit->index) {\n+            index_offset++;\n+            prefilledit++;\n+        }\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+    }\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())\n+        return READ_STATUS_FAILED; // Short ID collision\n+\n+    char have_txn[txhashes.size() / 8 + 1];\n+    memset(have_txn, 0, txhashes.size() / 8 + 1);\n+\n+    LOCK(pool->cs);\n+    for (CTxMemPool::txiter it = pool->mapTx.begin(); it != pool->mapTx.end(); it++) {\n+        std::map<uint64_t, uint16_t>::iterator idit = shorttxids.find(cmpctblock.GetShortID(it->GetTx().GetHash()));\n+        if (idit != shorttxids.end()) {\n+            if (!(have_txn[idit->second / 8] & (1 << (idit->second & 0x7)))) {\n+                it->AddRef();\n+                txhashes[idit->second] = it->GetTx().GetHash();\n+                have_txn[idit->second / 8] |= 1 << (idit->second & 0x7);\n+            } else {\n+                // If we find two mempool txn that match the short id, just request it.\n+                // This should be rare enough that the extra bandwidth doesn't matter,\n+                // but eating a round-trip due to FillBlock failure would be annoying\n+                pool->ReleaseTxLock(txhashes[idit->second]);\n+                txhashes[idit->second].SetNull();\n+            }\n+        }\n+    }\n+\n+    LogPrint(\"cmpctblock\", \"Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\\n\", cmpctblock.header.GetHash().ToString(), cmpctblock.GetSerializeSize(SER_NETWORK, PROTOCOL_VERSION));\n+\n+    return READ_STATUS_OK;\n+}\n+\n+bool PartiallyDownloadedBlock::IsTxAvailable(size_t index) const {\n+    assert(!header.IsNull());\n+    assert(index < txhashes.size());\n+    return !txhashes[index].IsNull();\n+}\n+\n+ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<CTransaction>& vtx_missing) const {\n+    assert(!header.IsNull());\n+    block = header;\n+    block.vtx.resize(txhashes.size());\n+\n+    size_t tx_missing_offset = 0;\n+    std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+    size_t prefilled_count = 0, missing_count = 0, mempool_count = 0;\n+    for (size_t i = 0; i < txhashes.size(); i++) {\n+        if (txhashes[i].IsNull()) {\n+            if (vtx_missing.size() <= tx_missing_offset)\n+                return READ_STATUS_INVALID;\n+            block.vtx[i] = vtx_missing[tx_missing_offset++];\n+            missing_count++;\n+        } else {\n+            if (prefilledit != prefilledtxn.end() && prefilledit->index == i) {\n+                block.vtx[i] = prefilledit->tx;\n+                prefilledit++;\n+                prefilled_count++;\n+            } else {\n+                assert(pool->lookup(txhashes[i], block.vtx[i], true));\n+                mempool_count++;\n+            }\n+        }\n+    }\n+    assert(prefilledit == prefilledtxn.end());\n+    if (vtx_missing.size() == tx_missing_offset) {\n+        LogPrint(\"cmpctblock\", \"Successfully reconstructed block %s with %lu txn prefilled, %lu txn from mempool and %lu txn requested\\n\", header.GetHash().ToString(), prefilled_count, mempool_count, missing_count);\n+        if (vtx_missing.size() < 5) {\n+            BOOST_FOREACH(const CTransaction& tx, vtx_missing)\n+                LogPrint(\"cmpctblock\", \"Reconstructed block %s required tx %s\\n\", header.GetHash().ToString(), tx.GetHash().ToString());\n+        }\n+    }\n+    return vtx_missing.size() == tx_missing_offset ? READ_STATUS_OK : READ_STATUS_INVALID;\n+}\n+\n+PartiallyDownloadedBlock::~PartiallyDownloadedBlock() {\n+    if (!header.IsNull()) {\n+        std::vector<PrefilledTransaction>::const_iterator prefilledit = prefilledtxn.begin();\n+        for (size_t i = 0; i < txhashes.size(); i++) {\n+            if (!txhashes[i].IsNull()) {\n+                if (prefilledit != prefilledtxn.end() && prefilledit->index == i)\n+                    prefilledit++;\n+                else\n+                    pool->ReleaseTxLock(txhashes[i]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r65925840",
      "id" : 65925840,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 166,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/65925840",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66210588"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66210588"
         }
      },
      "body" : "nit: You can early return here instead of using a boolean.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-08T08:18:30Z",
      "diff_hunk" : "@@ -432,6 +460,31 @@ void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n     }\n }\n \n+void MaybeSetPeerAsAnnouncingHeaderAndIDs(const CNodeState* nodestate, CNode* pfrom) {\n+    if (nodestate->fProvidesHeaderAndIDs) {\n+        bool fAlreadyAnnouncing = false;\n+        BOOST_FOREACH(const NodeId nodeid, lNodesAnnouncingHeaderAndIDs)\n+            if (nodeid == pfrom->GetId())\n+                fAlreadyAnnouncing = true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66210588",
      "id" : 66210588,
      "original_commit_id" : "53012f994c101fe515ccd3c20ee99ef88d3db870",
      "original_position" : 103,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66210588",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66212626"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66212626"
         }
      },
      "body" : "Are locks recursive ?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-08T08:32:00Z",
      "diff_hunk" : "@@ -5140,6 +5266,161 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        bool fUseShortIDs = pindex->pprev->nStatus & BLOCK_HAVE_DATA;\n+        while (fUseShortIDs) {\n+            std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+            bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt);\n+                if (!queuedBlockIt) {\n+                    // MarkBlockAsInFlight does this in case the block was already in flight\n+                    // using compact blocks from the same peer\n+                    LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\");\n+                    return true;\n+                }\n+\n+                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n+                ReadStatus status = partialBlock.InitData(cmpctblock);\n+                if (status == READ_STATUS_INVALID) {\n+                    Misbehaving(pfrom->GetId(), 100);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\", pfrom->id);\n+                    return true;\n+                } else if (status == READ_STATUS_FAILED) {\n+                    // Duplicate txindexes, handle just the header\n+                    fUseShortIDs = false;\n+                    break;\n+                }\n+\n+                BlockTransactionsRequest req;\n+                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {\n+                    if (!partialBlock.IsTxAvailable(i))\n+                        req.indexes.push_back(i);\n+                }\n+                if (req.indexes.empty()) {\n+                    vector<CTransaction> empty_txn;\n+                    CBlock block;\n+                    status = partialBlock.FillBlock(block, empty_txn);\n+                    if (status == READ_STATUS_OK) {\n+                        CValidationState state;\n+                        ProcessNewBlock(state, chainparams, pfrom, &block, false, NULL);\n+                        int nDoS;\n+                        if (state.IsInvalid(nDoS)) {\n+                            assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+                            pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                                               state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), block.GetHash());\n+                            if (nDoS > 0) {\n+                                LOCK(cs_main);\n+                                Misbehaving(pfrom->GetId(), nDoS);\n+                            }\n+                        }\n+                    } else {\n+                        Misbehaving(pfrom->GetId(), 100); // There should be no way to hit this\n+                        LogPrintf(\"Peer %d sent us invalid compact block which we should have been able to reconstruct\", pfrom->id);\n+                        return true;\n+                    }\n+                } else {\n+                    req.blockhash = pindex->GetBlockHash();\n+                    pfrom->PushMessage(NetMsgType::GETBLOCKTXN, req);\n+                }\n+            }\n+            break;\n+        }\n+        if (!fUseShortIDs) {\n+            // Dirty hack to process as if it were just a headers message\n+            std::vector<CBlock> headers;\n+            headers.push_back(cmpctblock.header);\n+            CDataStream vHeadersMsg(SER_NETWORK, PROTOCOL_VERSION);\n+            vHeadersMsg << headers;\n+            return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66212626",
      "id" : 66212626,
      "original_commit_id" : "53012f994c101fe515ccd3c20ee99ef88d3db870",
      "original_position" : 366,
      "path" : "src/main.cpp",
      "position" : 421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66212626",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66213351"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66213351"
         }
      },
      "body" : "nit: typo rquset, also should add a space after '//'",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-08T08:35:39Z",
      "diff_hunk" : "@@ -5140,6 +5266,161 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        bool fUseShortIDs = pindex->pprev->nStatus & BLOCK_HAVE_DATA;\n+        while (fUseShortIDs) {\n+            std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+            bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt);\n+                if (!queuedBlockIt) {\n+                    // MarkBlockAsInFlight does this in case the block was already in flight\n+                    // using compact blocks from the same peer\n+                    LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\");\n+                    return true;\n+                }\n+\n+                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n+                ReadStatus status = partialBlock.InitData(cmpctblock);\n+                if (status == READ_STATUS_INVALID) {\n+                    Misbehaving(pfrom->GetId(), 100);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\", pfrom->id);\n+                    return true;\n+                } else if (status == READ_STATUS_FAILED) {\n+                    // Duplicate txindexes, handle just the header\n+                    fUseShortIDs = false;\n+                    break;\n+                }\n+\n+                BlockTransactionsRequest req;\n+                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {\n+                    if (!partialBlock.IsTxAvailable(i))\n+                        req.indexes.push_back(i);\n+                }\n+                if (req.indexes.empty()) {\n+                    vector<CTransaction> empty_txn;\n+                    CBlock block;\n+                    status = partialBlock.FillBlock(block, empty_txn);\n+                    if (status == READ_STATUS_OK) {\n+                        CValidationState state;\n+                        ProcessNewBlock(state, chainparams, pfrom, &block, false, NULL);\n+                        int nDoS;\n+                        if (state.IsInvalid(nDoS)) {\n+                            assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+                            pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                                               state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), block.GetHash());\n+                            if (nDoS > 0) {\n+                                LOCK(cs_main);\n+                                Misbehaving(pfrom->GetId(), nDoS);\n+                            }\n+                        }\n+                    } else {\n+                        Misbehaving(pfrom->GetId(), 100); // There should be no way to hit this\n+                        LogPrintf(\"Peer %d sent us invalid compact block which we should have been able to reconstruct\", pfrom->id);\n+                        return true;\n+                    }\n+                } else {\n+                    req.blockhash = pindex->GetBlockHash();\n+                    pfrom->PushMessage(NetMsgType::GETBLOCKTXN, req);\n+                }\n+            }\n+            break;\n+        }\n+        if (!fUseShortIDs) {\n+            // Dirty hack to process as if it were just a headers message\n+            std::vector<CBlock> headers;\n+            headers.push_back(cmpctblock.header);\n+            CDataStream vHeadersMsg(SER_NETWORK, PROTOCOL_VERSION);\n+            vHeadersMsg << headers;\n+            return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams);\n+        }\n+\n+        CheckBlockIndex(chainparams.GetConsensus());\n+    }\n+\n+    else if (strCommand == NetMsgType::BLOCKTXN && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        BlockTransactions resp;\n+        vRecv >> resp;\n+\n+        map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n+        if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n+                it->second.first != pfrom->GetId()) {\n+            LogPrint(\"net\", \"Peer %d sent us block transactions for block we didn't requset\", pfrom->id); //...or we timed out",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66213351",
      "id" : 66213351,
      "original_commit_id" : "53012f994c101fe515ccd3c20ee99ef88d3db870",
      "original_position" : 380,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66213351",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66219767"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66219767"
         }
      },
      "body" : "nit: typo \"didnt\" and \"Its\"",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-08T09:11:28Z",
      "diff_hunk" : "@@ -5140,6 +5266,161 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        bool fUseShortIDs = pindex->pprev->nStatus & BLOCK_HAVE_DATA;\n+        while (fUseShortIDs) {\n+            std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+            bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt);\n+                if (!queuedBlockIt) {\n+                    // MarkBlockAsInFlight does this in case the block was already in flight\n+                    // using compact blocks from the same peer\n+                    LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\");\n+                    return true;\n+                }\n+\n+                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n+                ReadStatus status = partialBlock.InitData(cmpctblock);\n+                if (status == READ_STATUS_INVALID) {\n+                    Misbehaving(pfrom->GetId(), 100);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\", pfrom->id);\n+                    return true;\n+                } else if (status == READ_STATUS_FAILED) {\n+                    // Duplicate txindexes, handle just the header\n+                    fUseShortIDs = false;\n+                    break;\n+                }\n+\n+                BlockTransactionsRequest req;\n+                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {\n+                    if (!partialBlock.IsTxAvailable(i))\n+                        req.indexes.push_back(i);\n+                }\n+                if (req.indexes.empty()) {\n+                    vector<CTransaction> empty_txn;\n+                    CBlock block;\n+                    status = partialBlock.FillBlock(block, empty_txn);\n+                    if (status == READ_STATUS_OK) {\n+                        CValidationState state;\n+                        ProcessNewBlock(state, chainparams, pfrom, &block, false, NULL);\n+                        int nDoS;\n+                        if (state.IsInvalid(nDoS)) {\n+                            assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+                            pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                                               state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), block.GetHash());\n+                            if (nDoS > 0) {\n+                                LOCK(cs_main);\n+                                Misbehaving(pfrom->GetId(), nDoS);\n+                            }\n+                        }\n+                    } else {\n+                        Misbehaving(pfrom->GetId(), 100); // There should be no way to hit this\n+                        LogPrintf(\"Peer %d sent us invalid compact block which we should have been able to reconstruct\", pfrom->id);\n+                        return true;\n+                    }\n+                } else {\n+                    req.blockhash = pindex->GetBlockHash();\n+                    pfrom->PushMessage(NetMsgType::GETBLOCKTXN, req);\n+                }\n+            }\n+            break;\n+        }\n+        if (!fUseShortIDs) {\n+            // Dirty hack to process as if it were just a headers message\n+            std::vector<CBlock> headers;\n+            headers.push_back(cmpctblock.header);\n+            CDataStream vHeadersMsg(SER_NETWORK, PROTOCOL_VERSION);\n+            vHeadersMsg << headers;\n+            return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams);\n+        }\n+\n+        CheckBlockIndex(chainparams.GetConsensus());\n+    }\n+\n+    else if (strCommand == NetMsgType::BLOCKTXN && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        BlockTransactions resp;\n+        vRecv >> resp;\n+\n+        map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n+        if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n+                it->second.first != pfrom->GetId()) {\n+            LogPrint(\"net\", \"Peer %d sent us block transactions for block we didn't requset\", pfrom->id); //...or we timed out\n+            return true;\n+        }\n+\n+        PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n+        CBlock block;\n+        ReadStatus status = partialBlock.FillBlock(block, resp.txn);\n+        if (status == READ_STATUS_INVALID) {\n+            Misbehaving(pfrom->GetId(), 100);\n+            LogPrintf(\"Peer %d sent us invalid compact block/non-matching block transactions\", pfrom->id);\n+            return true;\n+        } else if (status == READ_STATUS_FAILED) {\n+            // Might have collided, fall back to getdata now :(\n+            std::vector<CInv> invs;\n+            invs.push_back(CInv(MSG_BLOCK, resp.blockhash));\n+            pfrom->PushMessage(NetMsgType::GETDATA, invs);\n+        } else {\n+            CValidationState state;\n+            ProcessNewBlock(state, chainparams, pfrom, &block, false, NULL);\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+                if (state.CorruptionPossible()) {\n+                    // Its possible there was a collision we didnt detect...request the block",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66219767",
      "id" : 66219767,
      "original_commit_id" : "53012f994c101fe515ccd3c20ee99ef88d3db870",
      "original_position" : 403,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66219767",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "body" : "Code Review ACK (except small nits about typo and one question about recursive lock, as you are calling ProcessMessage recursively)\r\n\r\nI'll compile and test it myself. (my tests will be in C# though)",
      "created_at" : "2016-06-08T09:14:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-224533796",
      "id" : 224533796,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8068",
      "updated_at" : "2016-06-08T09:14:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/224533796",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66226140"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66226140"
         }
      },
      "body" : "Yes. Otherwise we'd have ~infinity deadlocks.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-08T09:52:14Z",
      "diff_hunk" : "@@ -5140,6 +5266,161 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        bool fUseShortIDs = pindex->pprev->nStatus & BLOCK_HAVE_DATA;\n+        while (fUseShortIDs) {\n+            std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+            bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt);\n+                if (!queuedBlockIt) {\n+                    // MarkBlockAsInFlight does this in case the block was already in flight\n+                    // using compact blocks from the same peer\n+                    LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\");\n+                    return true;\n+                }\n+\n+                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n+                ReadStatus status = partialBlock.InitData(cmpctblock);\n+                if (status == READ_STATUS_INVALID) {\n+                    Misbehaving(pfrom->GetId(), 100);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\", pfrom->id);\n+                    return true;\n+                } else if (status == READ_STATUS_FAILED) {\n+                    // Duplicate txindexes, handle just the header\n+                    fUseShortIDs = false;\n+                    break;\n+                }\n+\n+                BlockTransactionsRequest req;\n+                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {\n+                    if (!partialBlock.IsTxAvailable(i))\n+                        req.indexes.push_back(i);\n+                }\n+                if (req.indexes.empty()) {\n+                    vector<CTransaction> empty_txn;\n+                    CBlock block;\n+                    status = partialBlock.FillBlock(block, empty_txn);\n+                    if (status == READ_STATUS_OK) {\n+                        CValidationState state;\n+                        ProcessNewBlock(state, chainparams, pfrom, &block, false, NULL);\n+                        int nDoS;\n+                        if (state.IsInvalid(nDoS)) {\n+                            assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+                            pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                                               state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), block.GetHash());\n+                            if (nDoS > 0) {\n+                                LOCK(cs_main);\n+                                Misbehaving(pfrom->GetId(), nDoS);\n+                            }\n+                        }\n+                    } else {\n+                        Misbehaving(pfrom->GetId(), 100); // There should be no way to hit this\n+                        LogPrintf(\"Peer %d sent us invalid compact block which we should have been able to reconstruct\", pfrom->id);\n+                        return true;\n+                    }\n+                } else {\n+                    req.blockhash = pindex->GetBlockHash();\n+                    pfrom->PushMessage(NetMsgType::GETBLOCKTXN, req);\n+                }\n+            }\n+            break;\n+        }\n+        if (!fUseShortIDs) {\n+            // Dirty hack to process as if it were just a headers message\n+            std::vector<CBlock> headers;\n+            headers.push_back(cmpctblock.header);\n+            CDataStream vHeadersMsg(SER_NETWORK, PROTOCOL_VERSION);\n+            vHeadersMsg << headers;\n+            return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66226140",
      "id" : 66226140,
      "original_commit_id" : "53012f994c101fe515ccd3c20ee99ef88d3db870",
      "original_position" : 366,
      "path" : "src/main.cpp",
      "position" : 421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66226140",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66508975"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66508975"
         }
      },
      "body" : "Won't this put us in an infinite loop if our peer has a broken implementation?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-09T19:47:10Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66508975",
      "id" : 66508975,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66508975",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66535697"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66535697"
         }
      },
      "body" : "Yes, but do we care? I'm not sure how to fix this without adding a bunch more per-node state, but I'm sure there are other infinite loops somewhere in the protocol if people are broken in the right way. ",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-09T22:48:14Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66535697",
      "id" : 66535697,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66535697",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66549905"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66549905"
         }
      },
      "body" : "Well my guess is that this isn't a theoretical problem, but an actual one -- I just started grepping the debug logs on one of my nodes, and I'm seeing roughly 1 message/day of the form \"ERROR: AcceptBlockHeader: prev block not found\".  I didn't check in depth, but I believe that corresponds to the condition that the handling of getheaders messages is broken, which would mean the infinite loop behavior would be triggered.\r\n\r\nNot obvious to me what the best solution is.  We could add more per-node state, perhaps a single `bool fBadHeadersImplementation` that is set to false whenever a valid headers message is processed from a peer, and when processing a headers message that doesn't connect, set it to true and request more headers, unless it's already true, in which case we give up?  But I haven't tried to implement so not sure how tricky this would be...",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-10T01:31:05Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66549905",
      "id" : 66549905,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66549905",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66619669"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66619669"
         }
      },
      "body" : "What is the reasoning for uint16 here? Local space savings? ( I know this practically isn't a big deal due to realistic near future blocksizes but still)",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-10T14:14:52Z",
      "diff_hunk" : "@@ -0,0 +1,198 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+#include <memory>\n+\n+class CTxMemPool;\n+\n+class TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding\n+    }\n+};\n+\n+struct BlockTransactionsRequest {\n+    uint256 blockhash;\n+    std::vector<uint32_t> indexes;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(blockhash);\n+        uint64_t indexes_size = (uint64_t)indexes.size();\n+        READWRITE(COMPACTSIZE(indexes_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (indexes.size() < indexes_size) {\n+                indexes.resize(std::min((uint64_t)(1000 + indexes.size()), indexes_size));\n+                for (; i < indexes.size(); i++) {\n+                    uint64_t index = 0;\n+                    READWRITE(COMPACTSIZE(index));\n+                    indexes[i] = index;\n+                }\n+            }\n+\n+            uint32_t offset = 0;\n+            for (size_t i = 0; i < indexes.size(); i++) {\n+                if (uint64_t(indexes[i]) + uint64_t(offset) > std::numeric_limits<uint32_t>::max())\n+                    throw std::ios_base::failure(\"indexes overflowed 32-bits\");\n+                indexes[i] = indexes[i] + offset;\n+                offset = indexes[i] + 1;\n+            }\n+        } else {\n+            for (size_t i = 0; i < indexes.size(); i++) {\n+                uint64_t index = indexes[i] - (i == 0 ? 0 : (indexes[i - 1] + 1));\n+                READWRITE(COMPACTSIZE(index));\n+            }\n+        }\n+    }\n+};\n+\n+struct BlockTransactions {\n+    uint256 blockhash;\n+    std::vector<CTransaction> txn;\n+\n+    BlockTransactions() {}\n+    BlockTransactions(const BlockTransactionsRequest& req) :\n+        blockhash(req.blockhash), txn(req.indexes.size()) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(blockhash);\n+        uint64_t txn_size = (uint64_t)txn.size();\n+        READWRITE(COMPACTSIZE(txn_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (txn.size() < txn_size) {\n+                txn.resize(std::min((uint64_t)(1000 + txn.size()), txn_size));\n+                for (; i < txn.size(); i++)\n+                    READWRITE(REF(TransactionCompressor(txn[i])));\n+            }\n+        } else {\n+            for (size_t i = 0; i < txn.size(); i++)\n+                READWRITE(REF(TransactionCompressor(txn[i])));\n+        }\n+    }\n+};\n+\n+struct PrefilledTransaction {\n+    // Used as an offset since last prefilled tx in CBlockHeaderAndShortTxIDs,\n+    // as a proper transaction-in-block-index in PartiallyDownloadedBlock\n+    uint16_t index;\n+    CTransaction tx;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        uint64_t idx = index;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66619669",
      "id" : 66619669,
      "original_commit_id" : "27d56369d58ab8d46c18e9267c2df5a03062a801",
      "original_position" : 105,
      "path" : "src/blockencodings.h",
      "position" : 113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66619669",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=3",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66661338"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66661338"
         }
      },
      "body" : "Can't we just apply a small ban score each time?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-10T18:37:03Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66661338",
      "id" : 66661338,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66661338",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7275704?v=3",
         "events_url" : "https://api.github.com/users/btcdrak/events{/privacy}",
         "followers_url" : "https://api.github.com/users/btcdrak/followers",
         "following_url" : "https://api.github.com/users/btcdrak/following{/other_user}",
         "gists_url" : "https://api.github.com/users/btcdrak/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/btcdrak",
         "id" : 7275704,
         "login" : "btcdrak",
         "organizations_url" : "https://api.github.com/users/btcdrak/orgs",
         "received_events_url" : "https://api.github.com/users/btcdrak/received_events",
         "repos_url" : "https://api.github.com/users/btcdrak/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/btcdrak/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/btcdrak/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/btcdrak"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66662351"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66662351"
         }
      },
      "body" : "Though it doesn't have to be done now,  it would be good to simply mark both txn that collide in the compact block as missing instead of immediately falling back.  I've been testing in this way, and finding that even with 16-bit short IDs a super-majority of blocks are successfully reconstructed with only a relatively small number of gettxn. ",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-10T18:43:47Z",
      "diff_hunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint64_t nonce_e = htole64(nonce); // Serialization makes everything host-endian, but we want LE\n+    hasher.Write((unsigned char*)&nonce_e, sizeof(nonce_e));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::shared_ptr<const CTransaction>(new CTransaction(cmpctblock.prefilledtxn[i].tx));\n+    }\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    std::map<uint64_t, uint16_t> shorttxids;\n+    uint16_t index_offset = 0;\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (txn_available[i + index_offset])\n+            index_offset++;\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+    }\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66662351",
      "id" : 66662351,
      "original_commit_id" : "c270f63c318e6588aa2f8e3d7cd556d156924781",
      "original_position" : 85,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66662351",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66663232"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66663232"
         }
      },
      "body" : "Dunno, easier to be careful about using the \"right\" types so that any assumptions you might make later about range of a value dont blow up in your face...probably no real reason for this, but...it just is",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-10T18:49:39Z",
      "diff_hunk" : "@@ -0,0 +1,198 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+#include <memory>\n+\n+class CTxMemPool;\n+\n+class TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding\n+    }\n+};\n+\n+struct BlockTransactionsRequest {\n+    uint256 blockhash;\n+    std::vector<uint32_t> indexes;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(blockhash);\n+        uint64_t indexes_size = (uint64_t)indexes.size();\n+        READWRITE(COMPACTSIZE(indexes_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (indexes.size() < indexes_size) {\n+                indexes.resize(std::min((uint64_t)(1000 + indexes.size()), indexes_size));\n+                for (; i < indexes.size(); i++) {\n+                    uint64_t index = 0;\n+                    READWRITE(COMPACTSIZE(index));\n+                    indexes[i] = index;\n+                }\n+            }\n+\n+            uint32_t offset = 0;\n+            for (size_t i = 0; i < indexes.size(); i++) {\n+                if (uint64_t(indexes[i]) + uint64_t(offset) > std::numeric_limits<uint32_t>::max())\n+                    throw std::ios_base::failure(\"indexes overflowed 32-bits\");\n+                indexes[i] = indexes[i] + offset;\n+                offset = indexes[i] + 1;\n+            }\n+        } else {\n+            for (size_t i = 0; i < indexes.size(); i++) {\n+                uint64_t index = indexes[i] - (i == 0 ? 0 : (indexes[i - 1] + 1));\n+                READWRITE(COMPACTSIZE(index));\n+            }\n+        }\n+    }\n+};\n+\n+struct BlockTransactions {\n+    uint256 blockhash;\n+    std::vector<CTransaction> txn;\n+\n+    BlockTransactions() {}\n+    BlockTransactions(const BlockTransactionsRequest& req) :\n+        blockhash(req.blockhash), txn(req.indexes.size()) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(blockhash);\n+        uint64_t txn_size = (uint64_t)txn.size();\n+        READWRITE(COMPACTSIZE(txn_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (txn.size() < txn_size) {\n+                txn.resize(std::min((uint64_t)(1000 + txn.size()), txn_size));\n+                for (; i < txn.size(); i++)\n+                    READWRITE(REF(TransactionCompressor(txn[i])));\n+            }\n+        } else {\n+            for (size_t i = 0; i < txn.size(); i++)\n+                READWRITE(REF(TransactionCompressor(txn[i])));\n+        }\n+    }\n+};\n+\n+struct PrefilledTransaction {\n+    // Used as an offset since last prefilled tx in CBlockHeaderAndShortTxIDs,\n+    // as a proper transaction-in-block-index in PartiallyDownloadedBlock\n+    uint16_t index;\n+    CTransaction tx;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        uint64_t idx = index;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66663232",
      "id" : 66663232,
      "original_commit_id" : "27d56369d58ab8d46c18e9267c2df5a03062a801",
      "original_position" : 105,
      "path" : "src/blockencodings.h",
      "position" : 113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66663232",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66663860"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66663860"
         }
      },
      "body" : "Well the point of this was also to ensure that peers can enable us to do headers-sync without them needing to keep lots of state about where our blockchain is. The fact that headers messages /must/ connect seems rather insane to me from a protocol-design perspective (also because its not written that way in the BIP). \r\n\r\nWithin that context, the only state you could add to fix this is to try to track when a headers message was a response to a getheaders like the above, where we expect that it must connect or the peer is actually violating the spec.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-10T18:54:06Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66663860",
      "id" : 66663860,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66663860",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66664155"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66664155"
         }
      },
      "body" : "Added a //TODO note so that someone who goes through and cleans up all the optimizations later can track them.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-10T18:55:59Z",
      "diff_hunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint64_t nonce_e = htole64(nonce); // Serialization makes everything host-endian, but we want LE\n+    hasher.Write((unsigned char*)&nonce_e, sizeof(nonce_e));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::shared_ptr<const CTransaction>(new CTransaction(cmpctblock.prefilledtxn[i].tx));\n+    }\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    std::map<uint64_t, uint16_t> shorttxids;\n+    uint16_t index_offset = 0;\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (txn_available[i + index_offset])\n+            index_offset++;\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+    }\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66664155",
      "id" : 66664155,
      "original_commit_id" : "c270f63c318e6588aa2f8e3d7cd556d156924781",
      "original_position" : 85,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66664155",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66728455"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66728455"
         }
      },
      "body" : "Using `std::make_shared(cmpctblock.prefilledtxn[i].tx)` is slightly more efficient, as it allocates the reference counter and the CTransaction in a single malloc, while the normal std::shared_ptr constructor needs two separate ones.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T22:04:22Z",
      "diff_hunk" : "@@ -0,0 +1,147 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint64_t nonce_e = htole64(nonce); // Serialization makes everything host-endian, but we want LE\n+    hasher.Write((unsigned char*)&nonce_e, sizeof(nonce_e));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::shared_ptr<const CTransaction>(new CTransaction(cmpctblock.prefilledtxn[i].tx));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66728455",
      "id" : 66728455,
      "original_commit_id" : "c63626aeae2ed8f3174108b26ce940ac25951071",
      "original_position" : 74,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66728455",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66728565"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66728565"
         }
      },
      "body" : "I'd rather say \"// Future transaction compression standards could be implemented here\" rather than TODO, as there is no actionable change you could make right now.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T22:10:24Z",
      "diff_hunk" : "@@ -0,0 +1,197 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+class CTxMemPool;\n+\n+class TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66728565",
      "id" : 66728565,
      "original_commit_id" : "e3820046f98058144bb219af342d2b1f14e25008",
      "original_position" : 22,
      "path" : "src/blockencodings.h",
      "position" : 25,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66728565",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729306"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729306"
         }
      },
      "body" : "Is it necessary that we treat a non-connecting header as an inv? If the peer is not tracking any headers tree and just relaying headers, requesting anything from them won't do us any good anyway, and that seems to be the only use case for this?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T22:58:14Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729306",
      "id" : 66729306,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729306",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729475"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729475"
         }
      },
      "body" : "What is the reason for this? I think we should check early and dosban peers who getdata a CMPCT_BLOCK that was not recently inved.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:11:59Z",
      "diff_hunk" : "@@ -4512,6 +4518,15 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // else\n                             // no response\n                     }\n+                    else if (inv.type == MSG_CMPCT_BLOCK)\n+                    {\n+                        // Note that while we will respond to all MSG_CMPCT_BLOCK requests here,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729475",
      "id" : 66729475,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 44,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729475",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729707"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729707"
         }
      },
      "body" : "I don't think this test should be here. The block below (that builds vHeaders) can skip things from vBlockHashesToAnnounce.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:28:10Z",
      "diff_hunk" : "@@ -5802,7 +5862,9 @@ bool SendMessages(CNode* pto)\n             // add all to the inv queue.\n             LOCK(pto->cs_inventory);\n             vector<CBlock> vHeaders;\n-            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            bool fRevertToInv = ((!state.fPreferHeaders &&\n+                                 (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729707",
      "id" : 66729707,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 119,
      "path" : "src/main.cpp",
      "position" : 519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729707",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729737"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729737"
         }
      },
      "body" : "... continued. This if block could be replaced by the if inside of it, and making it reset vHeaders. No code movement for the normal headers inv is necessary in that case.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:29:38Z",
      "diff_hunk" : "@@ -5854,6 +5916,33 @@ bool SendMessages(CNode* pto)\n                     }\n                 }\n             }\n+            if (!fRevertToInv && !vHeaders.empty()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729737",
      "id" : 66729737,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 128,
      "path" : "src/main.cpp",
      "position" : 528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729737",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729795"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729795"
         }
      },
      "body" : "s/COMPRBLOCK/CMPCTBLOCK/",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:33:21Z",
      "diff_hunk" : "@@ -197,8 +198,9 @@ namespace {\n     /** Blocks that are in flight, and that are in the queue to be downloaded. Protected by cs_main. */\n     struct QueuedBlock {\n         uint256 hash;\n-        CBlockIndex* pindex;     //!< Optional.\n-        bool fValidatedHeaders;  //!< Whether this block has validated headers at the time of request.\n+        CBlockIndex* pindex;                                     //!< Optional.\n+        bool fValidatedHeaders;                                  //!< Whether this block has validated headers at the time of request.\n+        std::unique_ptr<PartiallyDownloadedBlock> partialBlock;  //!< Optional, used for COMPRBLOCK downloads",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729795",
      "id" : 66729795,
      "original_commit_id" : "1340078929876d4ae4118964e7df758ae1c49372",
      "original_position" : 16,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729795",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729990"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729990"
         }
      },
      "body" : "An auto type may be worth it here.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:46:53Z",
      "diff_hunk" : "@@ -387,25 +389,42 @@ bool MarkBlockAsReceived(const uint256& hash) {\n }\n \n // Requires cs_main.\n-void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL) {\n+// When pit is set it is assumed a PartiallyDownloadedBlock will be used\n+// pit is only set if a new PartiallyDownloadedBlock was created\n+// pit will only be valid as long as the same cs_main lock is being held\n+void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL, list<QueuedBlock>::iterator **pit = NULL) {\n     CNodeState *state = State(nodeid);\n     assert(state != NULL);\n \n+    // Short-circuit most stuff in case its from the same node\n+    map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729990",
      "id" : 66729990,
      "original_commit_id" : "1340078929876d4ae4118964e7df758ae1c49372",
      "original_position" : 33,
      "path" : "src/main.cpp",
      "position" : 58,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729990",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729997"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729997"
         }
      },
      "body" : "The current code requires that you track the state of each of your peer's headers chain or risk getting DoS banned (which is not mentioned in the spec, and is something which we actually do not fully do currently without races - resulting in these prints appearing occasionally in debug.log). I'd say its a pretty non-trivial bug.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:47:09Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66729997",
      "id" : 66729997,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66729997",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730022"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66730022"
         }
      },
      "body" : "Sorry if I'm not clear. I suggest changing it so that we don't DoS in that case, but also don't respond with a getheaders. Or rather, I'm wondering whether that suffices for your use case.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:49:12Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730022",
      "id" : 66730022,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66730022",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730069"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66730069"
         }
      },
      "body" : "That's pretty unintuitive behaviour, and I don't think it's necessary to put that much decision logic in this function. I think it could just return a `QueuedBlock*` always, and then the caller can then insert a new partialBlock if needed.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:52:19Z",
      "diff_hunk" : "@@ -387,25 +389,42 @@ bool MarkBlockAsReceived(const uint256& hash) {\n }\n \n // Requires cs_main.\n-void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL) {\n+// When pit is set it is assumed a PartiallyDownloadedBlock will be used\n+// pit is only set if a new PartiallyDownloadedBlock was created\n+// pit will only be valid as long as the same cs_main lock is being held",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730069",
      "id" : 66730069,
      "original_commit_id" : "1340078929876d4ae4118964e7df758ae1c49372",
      "original_position" : 27,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66730069",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730088"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66730088"
         }
      },
      "body" : "I tend to prefer not auto-typing when I'm gonna actually use some part of the type (ie I'd like to ensure there be a compiler error if  I'm accessing a variable and it changes type).",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-12T23:53:43Z",
      "diff_hunk" : "@@ -387,25 +389,42 @@ bool MarkBlockAsReceived(const uint256& hash) {\n }\n \n // Requires cs_main.\n-void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL) {\n+// When pit is set it is assumed a PartiallyDownloadedBlock will be used\n+// pit is only set if a new PartiallyDownloadedBlock was created\n+// pit will only be valid as long as the same cs_main lock is being held\n+void MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, CBlockIndex *pindex = NULL, list<QueuedBlock>::iterator **pit = NULL) {\n     CNodeState *state = State(nodeid);\n     assert(state != NULL);\n \n+    // Short-circuit most stuff in case its from the same node\n+    map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730088",
      "id" : 66730088,
      "original_commit_id" : "1340078929876d4ae4118964e7df758ae1c49372",
      "original_position" : 33,
      "path" : "src/main.cpp",
      "position" : 58,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66730088",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730648"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66730648"
         }
      },
      "body" : "Perhaps this part can be factored out into a separate function, that can be called from the codepath for CMPCTBLOCKs that don't have any missing txn?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T00:24:20Z",
      "diff_hunk" : "@@ -5205,6 +5234,159 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        if (pindex->pprev->nStatus & BLOCK_HAVE_DATA) {\n+            std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+            bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt);\n+                if (!queuedBlockIt) {\n+                    // MarkBlockAsInFlight does this in case the block was already in flight\n+                    // using compact blocks from the same peer\n+                    LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\");\n+                    return true;\n+                }\n+\n+                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n+                ReadStatus status = partialBlock.InitData(cmpctblock);\n+                if (status == READ_STATUS_INVALID) {\n+                    Misbehaving(pfrom->GetId(), 100);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\", pfrom->id);\n+                    return true;\n+                } else if (status == READ_STATUS_FAILED) {\n+                    // Duplicate txindexes, the block is now in-flight, so just request it\n+                    std::vector<CInv> vInv(1);\n+                    vInv[0] = CInv(MSG_BLOCK, cmpctblock.header.GetHash());\n+                    pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n+                    return true;\n+                }\n+\n+                BlockTransactionsRequest req;\n+                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {\n+                    if (!partialBlock.IsTxAvailable(i))\n+                        req.indexes.push_back(i);\n+                }\n+                if (req.indexes.empty()) {\n+                    vector<CTransaction> empty_txn;\n+                    CBlock block;\n+                    status = partialBlock.FillBlock(block, empty_txn);\n+                    if (status == READ_STATUS_OK) {\n+                        CValidationState state;\n+                        ProcessNewBlock(state, chainparams, pfrom, &block, false, NULL);\n+                        int nDoS;\n+                        if (state.IsInvalid(nDoS)) {\n+                            assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+                            pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                                               state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), block.GetHash());\n+                            if (nDoS > 0) {\n+                                LOCK(cs_main);\n+                                Misbehaving(pfrom->GetId(), nDoS);\n+                            }\n+                        }\n+                    } else {\n+                        Misbehaving(pfrom->GetId(), 100); // There should be no way to hit this\n+                        LogPrintf(\"Peer %d sent us invalid compact block which we should have been able to reconstruct\", pfrom->id);\n+                    }\n+                } else {\n+                    req.blockhash = pindex->GetBlockHash();\n+                    pfrom->PushMessage(NetMsgType::GETBLOCKTXN, req);\n+                }\n+            }\n+        } else {\n+            // Dirty hack to process as if it were just a headers message\n+            std::vector<CBlock> headers;\n+            headers.push_back(cmpctblock.header);\n+            CDataStream vHeadersMsg(SER_NETWORK, PROTOCOL_VERSION);\n+            vHeadersMsg << headers;\n+            return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams);\n+        }\n+\n+        CheckBlockIndex(chainparams.GetConsensus());\n+    }\n+\n+    else if (strCommand == NetMsgType::BLOCKTXN && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        BlockTransactions resp;\n+        vRecv >> resp;\n+\n+        map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n+        if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n+                it->second.first != pfrom->GetId()) {\n+            LogPrint(\"net\", \"Peer %d sent us block transactions for block we didn't requset\", pfrom->id); //...or we timed out\n+            return true;\n+        }\n+\n+        PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n+        CBlock block;\n+        ReadStatus status = partialBlock.FillBlock(block, resp.txn);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66730648",
      "id" : 66730648,
      "original_commit_id" : "1340078929876d4ae4118964e7df758ae1c49372",
      "original_position" : 212,
      "path" : "src/main.cpp",
      "position" : 441,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66730648",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66735226"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66735226"
         }
      },
      "body" : "There is no DoS score involved in a request for which we did not send an inv (ie something which is buried in our chain), only for those which request something with !BLOCK_HAVE_DATA. For those, we definitely wont even send a CMPCTBLOCK, because its covered by the surrounding if statement. \r\n\r\nAs for not sending the compact block if the block is >= 10 deep, yes, I can add an if statement and simply not respond to the getdata for those.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T02:53:23Z",
      "diff_hunk" : "@@ -4512,6 +4518,15 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // else\n                             // no response\n                     }\n+                    else if (inv.type == MSG_CMPCT_BLOCK)\n+                    {\n+                        // Note that while we will respond to all MSG_CMPCT_BLOCK requests here,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66735226",
      "id" : 66735226,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 44,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66735226",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66735956"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66735956"
         }
      },
      "body" : "For now I swapped in the same call-headers-msg code from CMPCTBLOCK handling into the CMPCTBLOCK code  call ::BLOCKTXN handling. Its a dirty hack to serialize and then immediately deserialize a message, but its a short message so it doesnt cost much, and I'm assuming the network stack will be (properly) rewritten soonish anyway, so then it can be called like the individual function it should be.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T03:11:22Z",
      "diff_hunk" : "@@ -5205,6 +5234,159 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        if (pindex->pprev->nStatus & BLOCK_HAVE_DATA) {\n+            std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+            bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt);\n+                if (!queuedBlockIt) {\n+                    // MarkBlockAsInFlight does this in case the block was already in flight\n+                    // using compact blocks from the same peer\n+                    LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\");\n+                    return true;\n+                }\n+\n+                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n+                ReadStatus status = partialBlock.InitData(cmpctblock);\n+                if (status == READ_STATUS_INVALID) {\n+                    Misbehaving(pfrom->GetId(), 100);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\", pfrom->id);\n+                    return true;\n+                } else if (status == READ_STATUS_FAILED) {\n+                    // Duplicate txindexes, the block is now in-flight, so just request it\n+                    std::vector<CInv> vInv(1);\n+                    vInv[0] = CInv(MSG_BLOCK, cmpctblock.header.GetHash());\n+                    pfrom->PushMessage(NetMsgType::GETDATA, vInv);\n+                    return true;\n+                }\n+\n+                BlockTransactionsRequest req;\n+                for (size_t i = 0; i < cmpctblock.BlockTxCount(); i++) {\n+                    if (!partialBlock.IsTxAvailable(i))\n+                        req.indexes.push_back(i);\n+                }\n+                if (req.indexes.empty()) {\n+                    vector<CTransaction> empty_txn;\n+                    CBlock block;\n+                    status = partialBlock.FillBlock(block, empty_txn);\n+                    if (status == READ_STATUS_OK) {\n+                        CValidationState state;\n+                        ProcessNewBlock(state, chainparams, pfrom, &block, false, NULL);\n+                        int nDoS;\n+                        if (state.IsInvalid(nDoS)) {\n+                            assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+                            pfrom->PushMessage(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n+                                               state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), block.GetHash());\n+                            if (nDoS > 0) {\n+                                LOCK(cs_main);\n+                                Misbehaving(pfrom->GetId(), nDoS);\n+                            }\n+                        }\n+                    } else {\n+                        Misbehaving(pfrom->GetId(), 100); // There should be no way to hit this\n+                        LogPrintf(\"Peer %d sent us invalid compact block which we should have been able to reconstruct\", pfrom->id);\n+                    }\n+                } else {\n+                    req.blockhash = pindex->GetBlockHash();\n+                    pfrom->PushMessage(NetMsgType::GETBLOCKTXN, req);\n+                }\n+            }\n+        } else {\n+            // Dirty hack to process as if it were just a headers message\n+            std::vector<CBlock> headers;\n+            headers.push_back(cmpctblock.header);\n+            CDataStream vHeadersMsg(SER_NETWORK, PROTOCOL_VERSION);\n+            vHeadersMsg << headers;\n+            return ProcessMessage(pfrom, NetMsgType::HEADERS, vHeadersMsg, nTimeReceived, chainparams);\n+        }\n+\n+        CheckBlockIndex(chainparams.GetConsensus());\n+    }\n+\n+    else if (strCommand == NetMsgType::BLOCKTXN && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        BlockTransactions resp;\n+        vRecv >> resp;\n+\n+        map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n+        if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n+                it->second.first != pfrom->GetId()) {\n+            LogPrint(\"net\", \"Peer %d sent us block transactions for block we didn't requset\", pfrom->id); //...or we timed out\n+            return true;\n+        }\n+\n+        PartiallyDownloadedBlock& partialBlock = *it->second.second->partialBlock;\n+        CBlock block;\n+        ReadStatus status = partialBlock.FillBlock(block, resp.txn);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66735956",
      "id" : 66735956,
      "original_commit_id" : "1340078929876d4ae4118964e7df758ae1c49372",
      "original_position" : 212,
      "path" : "src/main.cpp",
      "position" : 441,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66735956",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66738999"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66738999"
         }
      },
      "body" : "I don't immediately see how to resolve this in the way you're suggesting.  Because I want to share the code in the first if (!fRevertToInv) block I need to change the definition of fRevertToInv (or the condition for that block) slightly.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T04:24:18Z",
      "diff_hunk" : "@@ -5802,7 +5862,9 @@ bool SendMessages(CNode* pto)\n             // add all to the inv queue.\n             LOCK(pto->cs_inventory);\n             vector<CBlock> vHeaders;\n-            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            bool fRevertToInv = ((!state.fPreferHeaders &&\n+                                 (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66738999",
      "id" : 66738999,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 119,
      "path" : "src/main.cpp",
      "position" : 519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66738999",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66739056"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66739056"
         }
      },
      "body" : "I think this may be possible by bending over backwards to change fRevertToInv in the right way between the !fRevertToInv and fRevertToInv conditionals, but I think that just makes the already hard-to-read code even worse, which is not worth saving a tiny bit of code movement to me.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T04:25:43Z",
      "diff_hunk" : "@@ -5854,6 +5916,33 @@ bool SendMessages(CNode* pto)\n                     }\n                 }\n             }\n+            if (!fRevertToInv && !vHeaders.empty()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66739056",
      "id" : 66739056,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 128,
      "path" : "src/main.cpp",
      "position" : 528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66739056",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66739275"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66739275"
         }
      },
      "body" : "Differing philosophy, I guess...Indeed, this already isnt an issue for the CMPCTBLOCK handling, but I really don't like the idea that our peer might notify us that they have some blocks available and we will simply ignore them because they aren't keeping track of our chainstate. Can we use hashLastUnknownBlock to track if we hit the infinite-loop condition without adding additional state here?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T04:33:33Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66739275",
      "id" : 66739275,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66739275",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66806224"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66806224"
         }
      },
      "body" : "I don't think the xor helps at all. Groups of short ids that were close together (and thus had a high chance of ending up in the same bucket) remain close together.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T14:55:52Z",
      "diff_hunk" : "@@ -0,0 +1,181 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint64_t nonce_e = htole64(nonce); // Serialization makes everything host-endian, but we want LE\n+    hasher.Write((unsigned char*)&nonce_e, sizeof(nonce_e));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+struct SixtyFourBitHasher {\n+    uint64_t rand;\n+    SixtyFourBitHasher() : rand(uint64_t(insecure_rand()) | (uint64_t(insecure_rand()) << 32)) {}\n+    inline uint64_t operator()(uint64_t thing) const { return thing ^ rand; }\n+};\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::make_shared<CTransaction>(cmpctblock.prefilledtxn[i].tx);\n+    }\n+    prefilled_count = cmpctblock.prefilledtxn.size();\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    // TODO: Instead of using a simple XOR for hashing here, we could just\n+    // limit the number of elements per bucket. Because well-formed cmpctblock\n+    // messages will have a (relatively) uniform distribution of short IDs, any\n+    // highly-uneven distribution of elements can be safely treated as a read failure.\n+    std::unordered_map<uint64_t, uint16_t, SixtyFourBitHasher> shorttxids;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66806224",
      "id" : 66806224,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 91,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66806224",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66806934"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66806934"
         }
      },
      "body" : "Thinking more about this, I think it is fine. Assuming the peer responds with a headers chain that indeed matches the locator we send, the same condition won't trigger again.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T14:59:21Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66806934",
      "id" : 66806934,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66806934",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66807276"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66807276"
         }
      },
      "body" : "A better suggestion than what I said before: just replace this whole block with `stream << header << nonce`.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T15:00:30Z",
      "diff_hunk" : "@@ -0,0 +1,181 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint64_t nonce_e = htole64(nonce); // Serialization makes everything host-endian, but we want LE",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66807276",
      "id" : 66807276,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 37,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66807276",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66808314"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66808314"
         }
      },
      "body" : "Why is this moved?",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T15:06:22Z",
      "diff_hunk" : "@@ -3356,6 +3397,10 @@ bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& sta\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n         return state.Invalid(false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n \n+    // Check timestamp",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66808314",
      "id" : 66808314,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 172,
      "path" : "src/main.cpp",
      "position" : 172,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66808314",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66811617"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66811617"
         }
      },
      "body" : "I mean like here: https://github.com/sipa/bitcoin/commit/526a02c114a5f34fef053d3550438ebb9e741b42",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T15:22:32Z",
      "diff_hunk" : "@@ -5802,7 +5862,9 @@ bool SendMessages(CNode* pto)\n             // add all to the inv queue.\n             LOCK(pto->cs_inventory);\n             vector<CBlock> vHeaders;\n-            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            bool fRevertToInv = ((!state.fPreferHeaders &&\n+                                 (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66811617",
      "id" : 66811617,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 119,
      "path" : "src/main.cpp",
      "position" : 519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66811617",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835159"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66835159"
         }
      },
      "body" : "LOL, I must've been really tired when I thought that one through....anyway, I'll do the bucket-count thing.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T17:43:07Z",
      "diff_hunk" : "@@ -0,0 +1,181 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint64_t nonce_e = htole64(nonce); // Serialization makes everything host-endian, but we want LE\n+    hasher.Write((unsigned char*)&nonce_e, sizeof(nonce_e));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+struct SixtyFourBitHasher {\n+    uint64_t rand;\n+    SixtyFourBitHasher() : rand(uint64_t(insecure_rand()) | (uint64_t(insecure_rand()) << 32)) {}\n+    inline uint64_t operator()(uint64_t thing) const { return thing ^ rand; }\n+};\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::make_shared<CTransaction>(cmpctblock.prefilledtxn[i].tx);\n+    }\n+    prefilled_count = cmpctblock.prefilledtxn.size();\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    // TODO: Instead of using a simple XOR for hashing here, we could just\n+    // limit the number of elements per bucket. Because well-formed cmpctblock\n+    // messages will have a (relatively) uniform distribution of short IDs, any\n+    // highly-uneven distribution of elements can be safely treated as a read failure.\n+    std::unordered_map<uint64_t, uint16_t, SixtyFourBitHasher> shorttxids;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835159",
      "id" : 66835159,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 91,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66835159",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835192"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66835192"
         }
      },
      "body" : "Heh, good point.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T17:43:17Z",
      "diff_hunk" : "@@ -0,0 +1,181 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint64_t nonce_e = htole64(nonce); // Serialization makes everything host-endian, but we want LE",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835192",
      "id" : 66835192,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 37,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66835192",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835600"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66835600"
         }
      },
      "body" : "I believe that was exactly Suhas' concern - that a peer might respond to a headers request with a chain that was disconnected from our locator.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T17:46:02Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835600",
      "id" : 66835600,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66835600",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835690"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66835690"
         }
      },
      "body" : "To prevent yet more includes and the crazy-looking GetAdjustedTime call from within the GetBlock stuff. See https://github.com/bitcoin/bitcoin/pull/8068#issuecomment-224781229",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T17:46:33Z",
      "diff_hunk" : "@@ -3356,6 +3397,10 @@ bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& sta\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n         return state.Invalid(false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n \n+    // Check timestamp",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66835690",
      "id" : 66835690,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 172,
      "path" : "src/main.cpp",
      "position" : 172,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66835690",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66868501"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66868501"
         }
      },
      "body" : "Fair enough.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T21:08:41Z",
      "diff_hunk" : "@@ -3356,6 +3397,10 @@ bool ContextualCheckBlockHeader(const CBlockHeader& block, CValidationState& sta\n     if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n         return state.Invalid(false, REJECT_INVALID, \"time-too-old\", \"block's timestamp is too early\");\n \n+    // Check timestamp",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66868501",
      "id" : 66868501,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 172,
      "path" : "src/main.cpp",
      "position" : 172,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66868501",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66869150"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66869150"
         }
      },
      "body" : "nit of some incoherences: \r\n\r\n1. ushort were used in PrefilledTransaction to represent an index but here it is uint. \r\n2. PrefilledTransaction->index represent a differential index, but BlockTransactionsRequest->indexes represent absolute indexes (because the translation from diff to absolute is done during seria/deseria)",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T21:12:30Z",
      "diff_hunk" : "@@ -0,0 +1,198 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+#include <memory>\n+\n+class CTxMemPool;\n+\n+class TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding\n+    }\n+};\n+\n+struct BlockTransactionsRequest {\n+    uint256 blockhash;\n+    std::vector<uint32_t> indexes;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66869150",
      "id" : 66869150,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 30,
      "path" : "src/blockencodings.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66869150",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66869151"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66869151"
         }
      },
      "body" : "What would work is multiplying by a random odd 64-bit integer, but I agree - bucket counting sounds better. You could do a chi-square test.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T21:12:30Z",
      "diff_hunk" : "@@ -0,0 +1,181 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint64_t nonce_e = htole64(nonce); // Serialization makes everything host-endian, but we want LE\n+    hasher.Write((unsigned char*)&nonce_e, sizeof(nonce_e));\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+struct SixtyFourBitHasher {\n+    uint64_t rand;\n+    SixtyFourBitHasher() : rand(uint64_t(insecure_rand()) | (uint64_t(insecure_rand()) << 32)) {}\n+    inline uint64_t operator()(uint64_t thing) const { return thing ^ rand; }\n+};\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::make_shared<CTransaction>(cmpctblock.prefilledtxn[i].tx);\n+    }\n+    prefilled_count = cmpctblock.prefilledtxn.size();\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    // TODO: Instead of using a simple XOR for hashing here, we could just\n+    // limit the number of elements per bucket. Because well-formed cmpctblock\n+    // messages will have a (relatively) uniform distribution of short IDs, any\n+    // highly-uneven distribution of elements can be safely treated as a read failure.\n+    std::unordered_map<uint64_t, uint16_t, SixtyFourBitHasher> shorttxids;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66869151",
      "id" : 66869151,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 91,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66869151",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66871970"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66871970"
         }
      },
      "body" : "maybe should check\r\n\r\n```\r\nif(index > std::numeric_limits<uint32_t>::max())\r\n                    throw std::ios_base::failure(\"indexes overflowed 32-bits\");\r\n```",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-13T21:29:27Z",
      "diff_hunk" : "@@ -0,0 +1,198 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_BLOCK_ENCODINGS_H\n+#define BITCOIN_BLOCK_ENCODINGS_H\n+\n+#include \"primitives/block.h\"\n+\n+#include <memory>\n+\n+class CTxMemPool;\n+\n+class TransactionCompressor {\n+private:\n+    CTransaction& tx;\n+public:\n+    TransactionCompressor(CTransaction& txIn) : tx(txIn) {}\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(tx); //TODO: Compress tx encoding\n+    }\n+};\n+\n+struct BlockTransactionsRequest {\n+    uint256 blockhash;\n+    std::vector<uint32_t> indexes;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action, int nType, int nVersion) {\n+        READWRITE(blockhash);\n+        uint64_t indexes_size = (uint64_t)indexes.size();\n+        READWRITE(COMPACTSIZE(indexes_size));\n+        if (ser_action.ForRead()) {\n+            size_t i = 0;\n+            while (indexes.size() < indexes_size) {\n+                indexes.resize(std::min((uint64_t)(1000 + indexes.size()), indexes_size));\n+                for (; i < indexes.size(); i++) {\n+                    uint64_t index = 0;\n+                    READWRITE(COMPACTSIZE(index));\n+                    indexes[i] = index;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r66871970",
      "id" : 66871970,
      "original_commit_id" : "39298a29b6f2652fd59592f24fa3f5a0c5339e37",
      "original_position" : 46,
      "path" : "src/blockencodings.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/66871970",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67007859"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67007859"
         }
      },
      "body" : "Ping? I think the code I linked above is simpler and easier to read.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-14T16:39:50Z",
      "diff_hunk" : "@@ -5802,7 +5862,9 @@ bool SendMessages(CNode* pto)\n             // add all to the inv queue.\n             LOCK(pto->cs_inventory);\n             vector<CBlock> vHeaders;\n-            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            bool fRevertToInv = ((!state.fPreferHeaders &&\n+                                 (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67007859",
      "id" : 67007859,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 119,
      "path" : "src/main.cpp",
      "position" : 519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67007859",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67020645"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67020645"
         }
      },
      "body" : "How accurate was your simulation? If I approximate the chance as buckets*P[binomial(n,1.0/buckets)], where n<=buckets (due to max_load_factor=1.0 by default for unordered_map), this would randomly fail about once every 9000 transmissions for n=10000 buckets=10000.\r\n\r\nAccording to this approximation, if we want the random failure chance to be less than once in a billion, you need:\r\n* `> 10` for up to 13 transactions\r\n* `> 11` for up to 23 transactions\r\n* `> 12` for up to 56 transactions\r\n* `> 13` for up to 291 transactions\r\n* `> 14` for up to 3423 transactions\r\n* `> 15` for up to 53645 transactions\r\n* `> 16` for up to 913429 transactions\r\n\r\n",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-14T17:47:56Z",
      "diff_hunk" : "@@ -75,12 +76,20 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n     prefilled_count = cmpctblock.prefilledtxn.size();\n \n     // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n-    std::map<uint64_t, uint16_t> shorttxids;\n+    // Because well-formed cmpctblock messages will have a (relatively) uniform distribution\n+    // of short IDs, any highly-uneven distribution of elements can be safely treated as a\n+    // READ_STATUS_FAILED.\n+    std::unordered_map<uint64_t, uint16_t> shorttxids(cmpctblock.shorttxids.size());\n     uint16_t index_offset = 0;\n     for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n         while (txn_available[i + index_offset])\n             index_offset++;\n         shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+        // The math for a max bucket size of 10 is rather complicated, but simulation\n+        // shows that, for blocks of up to 10k transactions, any individual bucket having\n+        // more than 10 entries is highly unlikely.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67020645",
      "id" : 67020645,
      "original_commit_id" : "da8ae90dc107efa9ce36f970c7a45659869e5742",
      "original_position" : 24,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67020645",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67030264"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67030264"
         }
      },
      "body" : "Yes, I just looked at the first example of \"prev block not found\" in the debug log of one my long-running listening nodes, and it's a peer that fails to send connecting headers on initial startup:\r\n\r\n```\r\n2016-05-30 12:50:07 Added connection to [redacted] peer=963241\r\n2016-05-30 12:50:07 received: version (102 bytes) peer=963241\r\n2016-05-30 12:50:07 send version message: version 70012, blocks=414057, us=0.0.0.0:8333, them=[redacted], peer=963241\r\n2016-05-30 12:50:07 sending: version (102 bytes) peer=963241\r\n2016-05-30 12:50:07 sending: verack (0 bytes) peer=963241\r\n2016-05-30 12:50:07 receive version message: /[redacted subver I've never heard of before]/: version 70002, blocks=16863, us=[redacted], peer=963241, peeraddr=[redacted]\r\n2016-05-30 12:50:07 sending: ping (8 bytes) peer=963241\r\n2016-05-30 12:50:07 sending: addr (31 bytes) peer=963241\r\n2016-05-30 12:50:07 initial getheaders (414056) to peer=963241 (startheight:16863)\r\n2016-05-30 12:50:07 sending: getheaders (997 bytes) peer=963241\r\n2016-05-30 12:50:07 sending: inv (37 bytes) peer=963241\r\n2016-05-30 12:50:08 sending: inv (37 bytes) peer=963241\r\n2016-05-30 12:50:08 received: verack (0 bytes) peer=963241\r\n2016-05-30 12:50:08 received: getaddr (0 bytes) peer=963241\r\n2016-05-30 12:50:08 received: ping (8 bytes) peer=963241\r\n2016-05-30 12:50:08 sending: pong (8 bytes) peer=963241\r\n2016-05-30 12:50:08 received: pong (8 bytes) peer=963241\r\n2016-05-30 12:50:08 received: headers (162003 bytes) peer=963241\r\n2016-05-30 12:50:08 ERROR: AcceptBlockHeader: prev block not found\r\n2016-05-30 12:50:08 ProcessMessages(headers, 162003 bytes) FAILED peer=963241\r\n```\r\n\r\nGiven that no new information was exchanged in the less than 2 seconds this interaction took, I think this would result in an infinite loop where my peer would send me ~160kb of data every 2 seconds...",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-14T18:36:55Z",
      "diff_hunk" : "@@ -5170,6 +5170,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n             return true;\n         }\n \n+        if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect, instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67030264",
      "id" : 67030264,
      "original_commit_id" : "b351d55e3904eda6e900ba2139bf18feafa91ea8",
      "original_position" : 7,
      "path" : "src/main.cpp",
      "position" : 478,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67030264",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67042310"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67042310"
         }
      },
      "body" : "This requires fPreferHeaders in order for fPreferHeaderAndIDs to work, which I was deliberately trying to avoid.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-14T19:42:45Z",
      "diff_hunk" : "@@ -5802,7 +5862,9 @@ bool SendMessages(CNode* pto)\n             // add all to the inv queue.\n             LOCK(pto->cs_inventory);\n             vector<CBlock> vHeaders;\n-            bool fRevertToInv = (!state.fPreferHeaders || pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n+            bool fRevertToInv = ((!state.fPreferHeaders &&\n+                                 (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67042310",
      "id" : 67042310,
      "original_commit_id" : "20ec1a307a84bd9f68faaef602b58892638833aa",
      "original_position" : 119,
      "path" : "src/main.cpp",
      "position" : 519,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67042310",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67273405"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67273405"
         }
      },
      "body" : "I think there's an off by one here.  If shorttxids.size() == 0, and prefilledtxn.size() == 1, then sending a compact block with prefilledtxn[0].index = 1 would pass this check, but cause an out-of-bounds memory access below.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T01:11:43Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header << nonce;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67273405",
      "id" : 67273405,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 68,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67273405",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67273833"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67273833"
         }
      },
      "body" : "comment nit: i was convinced there were all kinds of potential for overflows until I found the sanity check on the prefilledtxn index values that is done in deserialization (which also explained why you have this uint16_t max check, which was inexplicable from looking at the surrounding code).  Adding a short comment explaining the logic would be helpful to future code readers.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T01:16:41Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header << nonce;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67273833",
      "id" : 67273833,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 66,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67273833",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67273846"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67273846"
         }
      },
      "body" : "nit: this could be shortened using `cmpctblock.BlockTxCount()`",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T01:16:53Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header << nonce;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67273846",
      "id" : 67273846,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 58,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67273846",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67274625"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67274625"
         }
      },
      "body" : "Agree with @sipa about making this a `vector<bool>`!",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T01:23:09Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header << nonce;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::make_shared<CTransaction>(cmpctblock.prefilledtxn[i].tx);\n+    }\n+    prefilled_count = cmpctblock.prefilledtxn.size();\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    // Because well-formed cmpctblock messages will have a (relatively) uniform distribution\n+    // of short IDs, any highly-uneven distribution of elements can be safely treated as a\n+    // READ_STATUS_FAILED.\n+    std::unordered_map<uint64_t, uint16_t> shorttxids(cmpctblock.shorttxids.size());\n+    uint16_t index_offset = 0;\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (txn_available[i + index_offset])\n+            index_offset++;\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+        // The math for a max bucket size of 10 is rather complicated, but simulation\n+        // shows that, for blocks of up to 10k transactions, any individual bucket having\n+        // more than 10 entries is highly unlikely.\n+        if (shorttxids.bucket_size(shorttxids.bucket(cmpctblock.shorttxids[i])) > 10)\n+            return READ_STATUS_FAILED;\n+    }\n+    // TODO: in the shortid-collision case, we should instead request both transactions\n+    // which collided. Falling back to full-block-request here is overkill.\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())\n+        return READ_STATUS_FAILED; // Short ID collision\n+\n+    char have_txn[txn_available.size() / 8 + 1];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67274625",
      "id" : 67274625,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 99,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67274625",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67277374"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67277374"
         }
      },
      "body" : "I think HAVE_DATA is the wrong check if we are a pruning node.  We should do `if (pindex->nTx > 0)` instead.\r\n\r\nOn further thought, `pindex->nTx > 0` isn't right either, if there are any scenarios where a pruning node might re-request (via cmpctblock) a previously validated block in order to reorg to the chain that block is on.  I think elsewhere in the code, we catch this case by checking to see if the block is requested, and rely on the download logic being smart enough to not request useless blocks.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T02:02:32Z",
      "diff_hunk" : "@@ -5163,6 +5270,144 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67277374",
      "id" : 67277374,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 358,
      "path" : "src/main.cpp",
      "position" : 358,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67277374",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67277972"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67277972"
         }
      },
      "body" : "Again, here we should instead check if `pindex->pprev->nTx > 0`, so that this will work in the pruning case (it probably doesn't actually matter much in this specific case, but I think it's better to not use HAVE_DATA to minimize future errors).\r\n\r\nAlso, I think before we try to work on reconstructing the block and potentially requesting it, we should have a check that either we requested this CMPCTBLOCK, or that the header is valid and has more work than our tip.  Otherwise I believe we'd be vulnerable to a fill-up-your-disk attack.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T02:12:19Z",
      "diff_hunk" : "@@ -5163,6 +5270,144 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        if (pindex->pprev->nStatus & BLOCK_HAVE_DATA) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67277972",
      "id" : 67277972,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 368,
      "path" : "src/main.cpp",
      "position" : 368,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67277972",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67279075"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67279075"
         }
      },
      "body" : "We should clear the block as no longer being in flight.  Otherwise we're relying on the `Misbehaving()` to cause a disconnect, which would eventually clear the state -- but this seems error prone, eg if the node happens to be whitelisted.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T02:29:25Z",
      "diff_hunk" : "@@ -5163,6 +5270,144 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv,\n     }\n \n \n+    else if (strCommand == NetMsgType::CMPCTBLOCK && !fImporting && !fReindex) // Ignore blocks received while importing\n+    {\n+        CBlockHeaderAndShortTxIDs cmpctblock;\n+        vRecv >> cmpctblock;\n+\n+        LOCK(cs_main);\n+\n+        if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n+            // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n+            if (!IsInitialBlockDownload())\n+                pfrom->PushMessage(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256());\n+            return true;\n+        }\n+\n+        CBlockIndex *pindex = NULL;\n+        CValidationState state;\n+        if (!AcceptBlockHeader(cmpctblock.header, state, chainparams, &pindex)) {\n+            int nDoS;\n+            if (state.IsInvalid(nDoS)) {\n+                if (nDoS > 0)\n+                    Misbehaving(pfrom->GetId(), nDoS);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\", pfrom->id);\n+                return true;\n+            }\n+        }\n+\n+        // If AcceptBlockHeader returned true, it set pindex\n+        assert(pindex);\n+        if (pindex->nStatus & BLOCK_HAVE_DATA)\n+            return true;\n+\n+        UpdateBlockAvailability(pfrom->GetId(), pindex->GetBlockHash());\n+\n+        // If we're not close to tip yet, give up and let parallel block fetch work its magic\n+        if (!CanDirectFetch(chainparams.GetConsensus()))\n+            return true;\n+\n+        CNodeState *nodestate = State(pfrom->GetId());\n+        if (pindex->pprev->nStatus & BLOCK_HAVE_DATA) {\n+            std::map<uint256, pair<NodeId, list<QueuedBlock>::iterator> >::iterator blockInFlightIt = mapBlocksInFlight.find(pindex->GetBlockHash());\n+            bool fAlreadyInFlight = blockInFlightIt != mapBlocksInFlight.end();\n+            if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n+                 (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n+                list<QueuedBlock>::iterator *queuedBlockIt = NULL;\n+                if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt)) {\n+                    if (!(*queuedBlockIt)->partialBlock)\n+                        (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n+                    else {\n+                        // The block was already in flight using compact blocks from the same peer\n+                        LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\");\n+                        return true;\n+                    }\n+                }\n+\n+                PartiallyDownloadedBlock& partialBlock = *(*queuedBlockIt)->partialBlock;\n+                ReadStatus status = partialBlock.InitData(cmpctblock);\n+                if (status == READ_STATUS_INVALID) {\n+                    Misbehaving(pfrom->GetId(), 100);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\", pfrom->id);\n+                    return true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67279075",
      "id" : 67279075,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 389,
      "path" : "src/main.cpp",
      "position" : 389,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67279075",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=3",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67413739"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67413739"
         }
      },
      "body" : "I really dont like doing a malloc() for such a small buffer :/",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T20:00:16Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header << nonce;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::make_shared<CTransaction>(cmpctblock.prefilledtxn[i].tx);\n+    }\n+    prefilled_count = cmpctblock.prefilledtxn.size();\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    // Because well-formed cmpctblock messages will have a (relatively) uniform distribution\n+    // of short IDs, any highly-uneven distribution of elements can be safely treated as a\n+    // READ_STATUS_FAILED.\n+    std::unordered_map<uint64_t, uint16_t> shorttxids(cmpctblock.shorttxids.size());\n+    uint16_t index_offset = 0;\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (txn_available[i + index_offset])\n+            index_offset++;\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+        // The math for a max bucket size of 10 is rather complicated, but simulation\n+        // shows that, for blocks of up to 10k transactions, any individual bucket having\n+        // more than 10 entries is highly unlikely.\n+        if (shorttxids.bucket_size(shorttxids.bucket(cmpctblock.shorttxids[i])) > 10)\n+            return READ_STATUS_FAILED;\n+    }\n+    // TODO: in the shortid-collision case, we should instead request both transactions\n+    // which collided. Falling back to full-block-request here is overkill.\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())\n+        return READ_STATUS_FAILED; // Short ID collision\n+\n+    char have_txn[txn_available.size() / 8 + 1];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67413739",
      "id" : 67413739,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 99,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67413739",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67414301"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67414301"
         }
      },
      "body" : "You're already doing a malloc for each shortid in the unordered_map above.",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T20:03:41Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header << nonce;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::make_shared<CTransaction>(cmpctblock.prefilledtxn[i].tx);\n+    }\n+    prefilled_count = cmpctblock.prefilledtxn.size();\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    // Because well-formed cmpctblock messages will have a (relatively) uniform distribution\n+    // of short IDs, any highly-uneven distribution of elements can be safely treated as a\n+    // READ_STATUS_FAILED.\n+    std::unordered_map<uint64_t, uint16_t> shorttxids(cmpctblock.shorttxids.size());\n+    uint16_t index_offset = 0;\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (txn_available[i + index_offset])\n+            index_offset++;\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+        // The math for a max bucket size of 10 is rather complicated, but simulation\n+        // shows that, for blocks of up to 10k transactions, any individual bucket having\n+        // more than 10 entries is highly unlikely.\n+        if (shorttxids.bucket_size(shorttxids.bucket(cmpctblock.shorttxids[i])) > 10)\n+            return READ_STATUS_FAILED;\n+    }\n+    // TODO: in the shortid-collision case, we should instead request both transactions\n+    // which collided. Falling back to full-block-request here is overkill.\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())\n+        return READ_STATUS_FAILED; // Short ID collision\n+\n+    char have_txn[txn_available.size() / 8 + 1];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67414301",
      "id" : 67414301,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 99,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67414301",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67418447"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67418447"
         }
      },
      "body" : "True, but I didnt want to implement my own unordered_map...a vector\\<bool\\> is easy :p",
      "commit_id" : "1f0656944924884223b5d77a7d9cb044c36b760f",
      "created_at" : "2016-06-16T20:30:57Z",
      "diff_hunk" : "@@ -0,0 +1,177 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"blockencodings.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n+#include \"chainparams.h\"\n+#include \"hash.h\"\n+#include \"random.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"main.h\"\n+#include \"util.h\"\n+\n+#include <unordered_map>\n+\n+#define MIN_TRANSACTION_SIZE 60\n+\n+CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block) :\n+        nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n+        shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n+    FillShortTxIDSelector();\n+    //TODO: Use our mempool prior to block acceptance to predictively fill more than just the coinbase\n+    prefilledtxn[0] = {0, block.vtx[0]};\n+    for (size_t i = 1; i < block.vtx.size(); i++) {\n+        const CTransaction& tx = block.vtx[i];\n+        shorttxids[i - 1] = GetShortID(tx.GetHash());\n+    }\n+}\n+\n+void CBlockHeaderAndShortTxIDs::FillShortTxIDSelector() const {\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n+    stream << header << nonce;\n+    CSHA256 hasher;\n+    hasher.Write((unsigned char*)&(*stream.begin()), stream.end() - stream.begin());\n+    uint256 shorttxidhash;\n+    hasher.Finalize(shorttxidhash.begin());\n+    shorttxidk0 = shorttxidhash.GetUint64(0);\n+    shorttxidk1 = shorttxidhash.GetUint64(1);\n+}\n+\n+uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n+    static_assert(SHORTTXIDS_LENGTH == 6, \"shorttxids calculation assumes 6-byte shorttxids\");\n+    return SipHashUint256(shorttxidk0, shorttxidk1, txhash) & 0xffffffffffffL;\n+}\n+\n+\n+\n+ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, size_t max_mempool_txn_iterations) {\n+    if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n+        return READ_STATUS_INVALID;\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_SIZE / MIN_TRANSACTION_SIZE)\n+        return READ_STATUS_INVALID;\n+\n+    assert(header.IsNull() && txn_available.empty());\n+    header = cmpctblock.header;\n+    txn_available.resize(cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size());\n+\n+    int32_t lastprefilledindex = -1;\n+    for (size_t i = 0; i < cmpctblock.prefilledtxn.size(); i++) {\n+        if (cmpctblock.prefilledtxn[i].tx.IsNull())\n+            return READ_STATUS_INVALID;\n+\n+        lastprefilledindex += cmpctblock.prefilledtxn[i].index + 1;\n+        if (lastprefilledindex > std::numeric_limits<uint16_t>::max())\n+            return READ_STATUS_INVALID;\n+        if ((uint32_t)lastprefilledindex > cmpctblock.shorttxids.size() + i + 1) {\n+            // If we are inserting a tx at an index greater than our full list of shorttxids\n+            // plus the number of prefilled txn we've inserted, then we have txn for which we\n+            // have neither a prefilled txn or a shorttxid!\n+            return READ_STATUS_INVALID;\n+        }\n+        txn_available[lastprefilledindex] = std::make_shared<CTransaction>(cmpctblock.prefilledtxn[i].tx);\n+    }\n+    prefilled_count = cmpctblock.prefilledtxn.size();\n+\n+    // Calculate map of txids -> positions and check mempool to see what we have (or dont)\n+    // Because well-formed cmpctblock messages will have a (relatively) uniform distribution\n+    // of short IDs, any highly-uneven distribution of elements can be safely treated as a\n+    // READ_STATUS_FAILED.\n+    std::unordered_map<uint64_t, uint16_t> shorttxids(cmpctblock.shorttxids.size());\n+    uint16_t index_offset = 0;\n+    for (size_t i = 0; i < cmpctblock.shorttxids.size(); i++) {\n+        while (txn_available[i + index_offset])\n+            index_offset++;\n+        shorttxids[cmpctblock.shorttxids[i]] = i + index_offset;\n+        // The math for a max bucket size of 10 is rather complicated, but simulation\n+        // shows that, for blocks of up to 10k transactions, any individual bucket having\n+        // more than 10 entries is highly unlikely.\n+        if (shorttxids.bucket_size(shorttxids.bucket(cmpctblock.shorttxids[i])) > 10)\n+            return READ_STATUS_FAILED;\n+    }\n+    // TODO: in the shortid-collision case, we should instead request both transactions\n+    // which collided. Falling back to full-block-request here is overkill.\n+    if (shorttxids.size() != cmpctblock.shorttxids.size())\n+        return READ_STATUS_FAILED; // Short ID collision\n+\n+    char have_txn[txn_available.size() / 8 + 1];",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8068#discussion_r67418447",
      "id" : 67418447,
      "original_commit_id" : "a4a2c32aa5a7d9bca3abb8741c7ae57c6a5c830e",
      "original_position" : 99,
      "path" : "src/blockencodings.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8068",
      "updated_at" : "2016-06-16T20:38:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/67418447",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   }
]
