[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Are there demos of scripts based on this/BIP117 anywhere? eg has someone sat down and rewritten the Lightning scripts or TumbleBit scripts to use this stuff to compare the cost/privacy tradeoffs? What about example usage for hiding multisig?",
      "created_at" : "2018-01-09T21:42:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356423600",
      "id" : 356423600,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-09T21:42:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356423600",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "There are some examples inside the BIPs:\r\n\r\nhttps://github.com/bitcoin/bips/blob/master/bip-0116.mediawiki\r\nhttps://github.com/bitcoin/bips/blob/master/bip-0117.mediawiki\r\n\r\nIt is specifically anticipated that ALL instances of MAST would be of the following:\r\n\r\n> redeemScript: `[TOALTSTACK]*N OVER HASH256 <root> 1 MERKLEBRANCHVERIFY 2DROP 2DROP`\r\n> witness: `<policyScript> <proof> <arg1> ... <argN>`",
      "created_at" : "2018-01-09T22:15:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356432048",
      "id" : 356432048,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-09T22:15:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356432048",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/69154?v=4",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Hmm, I was hoping for somewhat larger scripts. Specifically, do you have a list of scripts which are cheaper to do using a merkle-hidden tail call than normally outside of large-multisig examples?",
      "created_at" : "2018-01-09T22:49:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356440036",
      "id" : 356440036,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-09T22:49:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356440036",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Basically every script where you are eliding, at minimum, a hash or pubkey push. Sorry for the obtuseness, but it seems like that describes just about anything and it didn't seem appropriate to overload the BIP with examples of everything beyond what was necessary to illustrate the concept. I would certainly like a lightning developer to show how those scripts could be reformulated to use tail-call semantics, but I'm not up to speed on the latest lightning standards.",
      "created_at" : "2018-01-09T23:02:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356442915",
      "id" : 356442915,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-09T23:02:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356442915",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/69154?v=4",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Hmm, well my primary motivation for asking was to get a better sense of the cost of using MBV+tail-call in practice. Comparing the cost of LN + TumbleBit scripts seems like an obvious route to figure that out, as it seems to me the only obvious user of something like this would be small-n large-m multisig, which seems somewhat of a waste.",
      "created_at" : "2018-01-09T23:05:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356443498",
      "id" : 356443498,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-09T23:05:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356443498",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "It seems rather to me that the obvious user of something like this is 'everybody' for the fungibility improvement.",
      "created_at" : "2018-01-09T23:06:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356443782",
      "id" : 356443782,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-09T23:06:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356443782",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/69154?v=4",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Hence my concern - ideally \"everyone\" would use something like this for fungibility reasons, but I'm highly skeptical anyone will pay a material difference in fees to do so. Obviously I'm not suggesting we go through all the fun of SegWit again to adjust the discount to make a MAST extra branch free, but getting a good idea of exactly what that cost is for common protocols would be useful.",
      "created_at" : "2018-01-09T23:08:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356444255",
      "id" : 356444255,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-09T23:08:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356444255",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I think your intuition for the cost savings is off. Right now even a 2-of-3 multisig ends up costing about the same as a MAST of 2-of-2 vs having an extra (unused) pubkey. Likewise the 2of2 -or- CSV 1of1. And when we switch to Schnorr signatures basically any multisig becomes cheaper in the MAST construct because they all reduce to a MAST of 1of1's.",
      "created_at" : "2018-01-09T23:13:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356445236",
      "id" : 356445236,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-09T23:13:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356445236",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/69154?v=4",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Concept ACK",
      "created_at" : "2018-01-10T01:26:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356469403",
      "id" : 356469403,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-10T01:26:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356469403",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/35275673?v=4",
         "events_url" : "https://api.github.com/users/Beyonderx/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Beyonderx/followers",
         "following_url" : "https://api.github.com/users/Beyonderx/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Beyonderx/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Beyonderx",
         "id" : 35275673,
         "login" : "Beyonderx",
         "organizations_url" : "https://api.github.com/users/Beyonderx/orgs",
         "received_events_url" : "https://api.github.com/users/Beyonderx/received_events",
         "repos_url" : "https://api.github.com/users/Beyonderx/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Beyonderx/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Beyonderx/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Beyonderx"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Conceptual question here: am i reading the code right or is the branch size limited to 9997 branches? Imho, having arbitrarily long branching trees could allow for really interesting stuff",
      "created_at" : "2018-01-11T12:28:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356920088",
      "id" : 356920088,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-11T12:28:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356920088",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/453214?v=4",
         "events_url" : "https://api.github.com/users/chiguireitor/events{/privacy}",
         "followers_url" : "https://api.github.com/users/chiguireitor/followers",
         "following_url" : "https://api.github.com/users/chiguireitor/following{/other_user}",
         "gists_url" : "https://api.github.com/users/chiguireitor/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/chiguireitor",
         "id" : 453214,
         "login" : "chiguireitor",
         "organizations_url" : "https://api.github.com/users/chiguireitor/orgs",
         "received_events_url" : "https://api.github.com/users/chiguireitor/received_events",
         "repos_url" : "https://api.github.com/users/chiguireitor/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/chiguireitor/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/chiguireitor/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/chiguireitor"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@chiguireitor I believe the 9997 cap is basically representing the maximum depth in the tree. I think that shrinks if you want to pick multiple entries, though. I could be wrong. @maaku?",
      "created_at" : "2018-01-11T13:56:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356940840",
      "id" : 356940840,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-11T13:56:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356940840",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I had to grep the diff to figure out what @chiguireitor was referring to. I assume it is the comment about MAX_STACK_SIZE limiting the number of elements that can be proven from a Merkle tree at once. That number is actually an error, as it should be 997, not 9997 as MAX_STACK_SIZE is a constant limit of 1,000 elements and 3 of those elements are the count parameter, the root hash, and the proof. It's worth noting that a separate limit, the 520 byte push limitation, prevents pushing a proof for a fully expanded Merkle tree of more than about 1380 elements anyway, so even if the MAX_STACK_SIZE limit were avoided you'd hit another one soon enough.\r\n\r\nHowever I think there is some confusion on @chiguireitor's part. Why would you want to prove 1,000+ items from a tree at once? This is the maximum number of elements that you can prove at one time, NOT the maximum number of elements that can be in a tree, for which there is no practical limit. The 520 byte push limitation prevents you from proving a hash more than 16 levels deep in a tree, but MERKLEBRANCHVERIFY calls can be chained allowing for verification of extremely deep trees, much larger than could be practically constructed. A single chained validation allows for trees consisting of billions of elements, that would take hours to construct on a reasonably powerful CPU.",
      "created_at" : "2018-01-11T14:33:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356951184",
      "id" : 356951184,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-11T14:33:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356951184",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/69154?v=4",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Yeah, my bad. Makes sense now, it's just limiting the \"next\" level of the tree, so in fact, it's not limiting the overall tree structure at all, excellent.",
      "created_at" : "2018-01-11T15:05:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-356960972",
      "id" : 356960972,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-11T15:05:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/356960972",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/453214?v=4",
         "events_url" : "https://api.github.com/users/chiguireitor/events{/privacy}",
         "followers_url" : "https://api.github.com/users/chiguireitor/followers",
         "following_url" : "https://api.github.com/users/chiguireitor/following{/other_user}",
         "gists_url" : "https://api.github.com/users/chiguireitor/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/chiguireitor",
         "id" : 453214,
         "login" : "chiguireitor",
         "organizations_url" : "https://api.github.com/users/chiguireitor/orgs",
         "received_events_url" : "https://api.github.com/users/chiguireitor/received_events",
         "repos_url" : "https://api.github.com/users/chiguireitor/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/chiguireitor/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/chiguireitor/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/chiguireitor"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Code will go to 0.16 and softfork signalling will start 0.16.1?",
      "created_at" : "2018-01-16T08:49:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-357891958",
      "id" : 357891958,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-16T08:49:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/357891958",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/11314444?v=4",
         "events_url" : "https://api.github.com/users/martin-lizner/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martin-lizner/followers",
         "following_url" : "https://api.github.com/users/martin-lizner/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martin-lizner/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martin-lizner",
         "id" : 11314444,
         "login" : "martin-lizner",
         "organizations_url" : "https://api.github.com/users/martin-lizner/orgs",
         "received_events_url" : "https://api.github.com/users/martin-lizner/received_events",
         "repos_url" : "https://api.github.com/users/martin-lizner/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martin-lizner/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martin-lizner/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martin-lizner"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@martin-lizner There is no consensus yet on whether this code will be merged or not. It's still being debated (e.g. on the mailing list and such).",
      "created_at" : "2018-01-16T09:01:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#issuecomment-357894817",
      "id" : 357894817,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/12131",
      "updated_at" : "2018-01-16T09:01:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/357894817",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r164653795"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/164653795"
         }
      },
      "author_association" : "NONE",
      "body" : "> `uint64_t* len`\r\n\r\nIt's `uint64_t* bytes` in the sha256.h\r\n\r\n~ thanks to @gubatron ",
      "commit_id" : "1af2099f6ec54d3df050c16b1016ee6c0b279290",
      "created_at" : "2018-01-30T06:52:54Z",
      "diff_hunk" : "@@ -231,6 +243,11 @@ void CSHA256::Finalize(unsigned char hash[OUTPUT_SIZE])\n     WriteBE64(sizedesc, bytes << 3);\n     Write(pad, 1 + ((119 - (bytes % 64)) % 64));\n     Write(sizedesc, 8);\n+    Midstate(hash, NULL, NULL);\n+}\n+\n+void CSHA256::Midstate(unsigned char hash[OUTPUT_SIZE], uint64_t* len, unsigned char* buffer)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r164653795",
      "id" : 164653795,
      "original_commit_id" : "1af2099f6ec54d3df050c16b1016ee6c0b279290",
      "original_position" : 26,
      "path" : "src/crypto/sha256.cpp",
      "position" : 26,
      "pull_request_review_id" : 92456590,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131",
      "updated_at" : "2018-01-30T06:52:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/164653795",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/23437045?v=4",
         "events_url" : "https://api.github.com/users/DesWurstes/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DesWurstes/followers",
         "following_url" : "https://api.github.com/users/DesWurstes/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DesWurstes/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DesWurstes",
         "id" : 23437045,
         "login" : "DesWurstes",
         "organizations_url" : "https://api.github.com/users/DesWurstes/orgs",
         "received_events_url" : "https://api.github.com/users/DesWurstes/received_events",
         "repos_url" : "https://api.github.com/users/DesWurstes/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DesWurstes/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DesWurstes/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DesWurstes"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r175299607"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/175299607"
         }
      },
      "author_association" : "MEMBER",
      "body" : "should error be returned here for invalid MerkleTree structure?",
      "commit_id" : "1af2099f6ec54d3df050c16b1016ee6c0b279290",
      "created_at" : "2018-03-18T18:56:44Z",
      "diff_hunk" : "@@ -1022,6 +1025,142 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                 }\n                 break;\n \n+                case OP_MERKLEBRANCHVERIFY:\n+                {\n+                    if (!(flags & SCRIPT_VERIFY_MERKLEBRANCHVERIFY)) {\n+                        // not enabled; treat as a NOP4\n+                        if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n+                            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS);\n+                        }\n+                        break;\n+                    }\n+\n+                    // ([...verify hashes...] proof root {2*count+prehash})\n+                    if (stack.size() < 3) {\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+                    }\n+\n+                    valtype& vchCount = stacktop(-1);\n+                    valtype& vchRoot  = stacktop(-2);\n+                    valtype& vchProof = stacktop(-3);\n+\n+                    // vchCount is a minimally encoded CScriptNum\n+                    // encoding 2*N plus a Boolean value in the low\n+                    // order bit encoding whether the leaf elements\n+                    // are pre-hashed.\n+                    bool prehashed = false;\n+                    std::size_t count = 0;\n+                    try {\n+                        // MAX_STACK_SIZE prevents count from ever\n+                        // being more than 997, which also means the\n+                        // first parameter can never be more than two\n+                        // bytes, when minimally serialized.\n+                        auto param = CScriptNum(vchCount, true, 2).getint();\n+                        if (param < 0) {\n+                            return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG1);\n+                        }\n+                        prehashed = param & 1;\n+                        count = param >> 1;\n+                    } catch (scriptnum_error e) {\n+                        // param is more than 2 bytes or not minimally encoded\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG1);\n+                    } catch (...) {\n+                        // Belt and suspenders. It should not be\n+                        // possible for other exceptions to be thrown,\n+                        // but in case that assessment is wrong or\n+                        // ever changes, let's not mask other\n+                        // exceptions.\n+                        throw;\n+                    }\n+\n+                    // There are count=N many leaf objects passed on\n+                    // the stack after the first three parameters\n+                    // which are always present.\n+                    if (stack.size() < (3 + count)) {\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+                    }\n+\n+                    // vchRoot is a standard 32-byte hash. Note that\n+                    // this hash is pushed as data and not minimally\n+                    // encoded.\n+                    if (vchRoot.size() != 32) {\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG2);\n+                    }\n+                    const uint256 root = uint256(vchRoot);\n+\n+                    // The third argument is a MerkleProof, which we\n+                    // deserialize as part of the MerkleTree structure\n+                    // we are building to validate the entire root.\n+                    MerkleTree branch;\n+                    CDataStream proofStream(vchProof, SER_NETWORK, PROTOCOL_VERSION);\n+                    try {\n+                        Unserialize(proofStream, branch.m_proof);\n+                    } catch (const std::bad_alloc e) {\n+                        throw; // Don't mask a transient out-of-memory exception\n+                    } catch (...) {\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+                    if (!proofStream.empty()) {\n+                        // Extra bytes remaining after the MerkleProof\n+                        // was deserialized, which could be a source\n+                        // of witness malleability.\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+                    if (branch.m_proof.m_path.dirty()) {\n+                        // Extra bits in the final byte of the packed\n+                        // serialization of the Merkle branch's path,\n+                        // which would otherwise be another source of\n+                        // witness malleability.\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+                    if ((!branch.m_proof.m_path.empty() || count || !branch.m_proof.m_skip.empty()) &&\n+                        ((count + branch.m_proof.m_skip.size()) != (branch.m_proof.m_path.size() + 1)))\n+                    {\n+                        // It is a property of any binary tree that\n+                        // the number of leaf nodes is precisely one\n+                        // more than the number of internal nodes.\n+                        // This acts as an early-out check of whether\n+                        // this is a well-formed proof. Note that the\n+                        // special case of a 0-node, 0-verify, 0-skip\n+                        // tree is exempted from this requirement.\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+\n+                    // The remaining _count_ items on the stack are\n+                    // the verify hashes, or the actual leaf values\n+                    // which are hashed with double-SHA256 to get the\n+                    // verify hashes if _prehashed_ is clear.\n+                    branch.m_verify.reserve(count);\n+                    for (int i = 0; i < (int)count; ++i) {\n+                        // -1 through -3 are the count+prehashed, root\n+                        // hash, and MerkleProof we already extracted.\n+                        valtype& vchLeaf = stacktop(-4 - i);\n+                        if (prehashed) {\n+                            // Require 32-byte hash values, no\n+                            // truncation of ending bytes.\n+                            if (vchLeaf.size() != 32) {\n+                                return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG);\n+                            }\n+                            branch.m_verify.emplace_back(uint256(vchLeaf));\n+                        } else {\n+                            branch.m_verify.emplace_back();\n+                            CHash256().Write(vchLeaf.data(), vchLeaf.size()).Finalize(branch.m_verify.back().begin());\n+                        }\n+                    }\n+\n+                    // Compute Merkle root hash\n+                    uint256 result = branch.GetHash();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r175299607",
      "id" : 175299607,
      "original_commit_id" : "1af2099f6ec54d3df050c16b1016ee6c0b279290",
      "original_position" : 153,
      "path" : "src/script/interpreter.cpp",
      "position" : 153,
      "pull_request_review_id" : 104807405,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131",
      "updated_at" : "2018-03-18T18:56:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/175299607",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/8403418?v=4",
         "events_url" : "https://api.github.com/users/jl2012/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jl2012/followers",
         "following_url" : "https://api.github.com/users/jl2012/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jl2012/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jl2012",
         "id" : 8403418,
         "login" : "jl2012",
         "organizations_url" : "https://api.github.com/users/jl2012/orgs",
         "received_events_url" : "https://api.github.com/users/jl2012/received_events",
         "repos_url" : "https://api.github.com/users/jl2012/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jl2012/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jl2012"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r175364673"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/175364673"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@maaku Is there a reason why you presumed `!invalid` on this one? If not I think we should check validity and return error on `invalid=true`.",
      "commit_id" : "1af2099f6ec54d3df050c16b1016ee6c0b279290",
      "created_at" : "2018-03-19T09:03:46Z",
      "diff_hunk" : "@@ -1022,6 +1025,142 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n                 }\n                 break;\n \n+                case OP_MERKLEBRANCHVERIFY:\n+                {\n+                    if (!(flags & SCRIPT_VERIFY_MERKLEBRANCHVERIFY)) {\n+                        // not enabled; treat as a NOP4\n+                        if (flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n+                            return set_error(serror, SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS);\n+                        }\n+                        break;\n+                    }\n+\n+                    // ([...verify hashes...] proof root {2*count+prehash})\n+                    if (stack.size() < 3) {\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+                    }\n+\n+                    valtype& vchCount = stacktop(-1);\n+                    valtype& vchRoot  = stacktop(-2);\n+                    valtype& vchProof = stacktop(-3);\n+\n+                    // vchCount is a minimally encoded CScriptNum\n+                    // encoding 2*N plus a Boolean value in the low\n+                    // order bit encoding whether the leaf elements\n+                    // are pre-hashed.\n+                    bool prehashed = false;\n+                    std::size_t count = 0;\n+                    try {\n+                        // MAX_STACK_SIZE prevents count from ever\n+                        // being more than 997, which also means the\n+                        // first parameter can never be more than two\n+                        // bytes, when minimally serialized.\n+                        auto param = CScriptNum(vchCount, true, 2).getint();\n+                        if (param < 0) {\n+                            return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG1);\n+                        }\n+                        prehashed = param & 1;\n+                        count = param >> 1;\n+                    } catch (scriptnum_error e) {\n+                        // param is more than 2 bytes or not minimally encoded\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG1);\n+                    } catch (...) {\n+                        // Belt and suspenders. It should not be\n+                        // possible for other exceptions to be thrown,\n+                        // but in case that assessment is wrong or\n+                        // ever changes, let's not mask other\n+                        // exceptions.\n+                        throw;\n+                    }\n+\n+                    // There are count=N many leaf objects passed on\n+                    // the stack after the first three parameters\n+                    // which are always present.\n+                    if (stack.size() < (3 + count)) {\n+                        return set_error(serror, SCRIPT_ERR_INVALID_STACK_OPERATION);\n+                    }\n+\n+                    // vchRoot is a standard 32-byte hash. Note that\n+                    // this hash is pushed as data and not minimally\n+                    // encoded.\n+                    if (vchRoot.size() != 32) {\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG2);\n+                    }\n+                    const uint256 root = uint256(vchRoot);\n+\n+                    // The third argument is a MerkleProof, which we\n+                    // deserialize as part of the MerkleTree structure\n+                    // we are building to validate the entire root.\n+                    MerkleTree branch;\n+                    CDataStream proofStream(vchProof, SER_NETWORK, PROTOCOL_VERSION);\n+                    try {\n+                        Unserialize(proofStream, branch.m_proof);\n+                    } catch (const std::bad_alloc e) {\n+                        throw; // Don't mask a transient out-of-memory exception\n+                    } catch (...) {\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+                    if (!proofStream.empty()) {\n+                        // Extra bytes remaining after the MerkleProof\n+                        // was deserialized, which could be a source\n+                        // of witness malleability.\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+                    if (branch.m_proof.m_path.dirty()) {\n+                        // Extra bits in the final byte of the packed\n+                        // serialization of the Merkle branch's path,\n+                        // which would otherwise be another source of\n+                        // witness malleability.\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+                    if ((!branch.m_proof.m_path.empty() || count || !branch.m_proof.m_skip.empty()) &&\n+                        ((count + branch.m_proof.m_skip.size()) != (branch.m_proof.m_path.size() + 1)))\n+                    {\n+                        // It is a property of any binary tree that\n+                        // the number of leaf nodes is precisely one\n+                        // more than the number of internal nodes.\n+                        // This acts as an early-out check of whether\n+                        // this is a well-formed proof. Note that the\n+                        // special case of a 0-node, 0-verify, 0-skip\n+                        // tree is exempted from this requirement.\n+                        return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG3);\n+                    }\n+\n+                    // The remaining _count_ items on the stack are\n+                    // the verify hashes, or the actual leaf values\n+                    // which are hashed with double-SHA256 to get the\n+                    // verify hashes if _prehashed_ is clear.\n+                    branch.m_verify.reserve(count);\n+                    for (int i = 0; i < (int)count; ++i) {\n+                        // -1 through -3 are the count+prehashed, root\n+                        // hash, and MerkleProof we already extracted.\n+                        valtype& vchLeaf = stacktop(-4 - i);\n+                        if (prehashed) {\n+                            // Require 32-byte hash values, no\n+                            // truncation of ending bytes.\n+                            if (vchLeaf.size() != 32) {\n+                                return set_error(serror, SCRIPT_ERR_BAD_DECODE_ARG);\n+                            }\n+                            branch.m_verify.emplace_back(uint256(vchLeaf));\n+                        } else {\n+                            branch.m_verify.emplace_back();\n+                            CHash256().Write(vchLeaf.data(), vchLeaf.size()).Finalize(branch.m_verify.back().begin());\n+                        }\n+                    }\n+\n+                    // Compute Merkle root hash\n+                    uint256 result = branch.GetHash();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r175364673",
      "id" : 175364673,
      "in_reply_to_id" : 175299607,
      "original_commit_id" : "1af2099f6ec54d3df050c16b1016ee6c0b279290",
      "original_position" : 153,
      "path" : "src/script/interpreter.cpp",
      "position" : 153,
      "pull_request_review_id" : 104879230,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131",
      "updated_at" : "2018-03-19T09:03:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/175364673",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/250224?v=4",
         "events_url" : "https://api.github.com/users/kallewoof/events{/privacy}",
         "followers_url" : "https://api.github.com/users/kallewoof/followers",
         "following_url" : "https://api.github.com/users/kallewoof/following{/other_user}",
         "gists_url" : "https://api.github.com/users/kallewoof/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/kallewoof",
         "id" : 250224,
         "login" : "kallewoof",
         "organizations_url" : "https://api.github.com/users/kallewoof/orgs",
         "received_events_url" : "https://api.github.com/users/kallewoof/received_events",
         "repos_url" : "https://api.github.com/users/kallewoof/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/kallewoof/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/kallewoof"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r175815214"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/175815214"
         }
      },
      "author_association" : "MEMBER",
      "body" : "inline?",
      "commit_id" : "1af2099f6ec54d3df050c16b1016ee6c0b279290",
      "created_at" : "2018-03-20T15:39:30Z",
      "diff_hunk" : "@@ -35,4 +93,1361 @@ uint256 BlockWitnessMerkleRoot(const CBlock& block, bool* mutated = nullptr);\n  */\n std::vector<uint256> BlockMerkleBranch(const CBlock& block, uint32_t position);\n \n+/*\n+ * Each link of a Merkle tree can have one of three values in a proof\n+ * object:\n+ *\n+ *   DESCEND: This link connects to another sub-tree, which must be\n+ *     processed. The root of this sub-tree is the hash value of the\n+ *     link.\n+ *\n+ *   VERIFY: This hash value of this link must be provided at\n+ *     validation time. Computation of the Merkle root and comparison\n+ *     with a reference value provides a batch confirmation as to\n+ *     whether ALL the provided VERIFY hashes are correct.\n+ *\n+ *   SKIP: The hash value of this link is provided as part of the\n+ *     proof.\n+ */\n+enum class MerkleLink : unsigned char { DESCEND, VERIFY, SKIP };\n+\n+/*\n+ * An internal node can have up to eight different structures, the\n+ * product of the 3 possible MerkleLink states the left and right\n+ * branches can have, with the exception of the {SKIP, SKIP} state\n+ * which would be pruned as a SKIP hash in the parent node.\n+ *\n+ * This means nodes can be represented as a 3-bit integer, and packed\n+ * 8 nodes to each 3 byte sequence. The MerkleNode class uses an\n+ * unsigned char to represent the unpacked code, whereas the\n+ * MerkleNodeReference class is used to access a 3-bit code value\n+ * within a packed representation.\n+ */\n+struct MerkleNode\n+{\n+    typedef unsigned char code_type;\n+\n+protected:\n+    code_type m_code;\n+\n+    static const std::array<MerkleLink, 8> m_left_from_code;\n+    static const std::array<MerkleLink, 8> m_right_from_code;\n+\n+    static code_type _get_code(MerkleLink left, MerkleLink right);\n+\n+public:\n+    explicit MerkleNode(MerkleLink left, MerkleLink right) : m_code(_get_code(left, right)) { }\n+\n+    explicit MerkleNode(code_type code) : m_code(code) { }\n+\n+    /* Note that a code value of 0 is a {VERIFY, SKIP} node. */\n+    MerkleNode() : m_code(0) { }\n+\n+    /* The default behavior is adequate. */\n+    MerkleNode(const MerkleNode&) = default;\n+    MerkleNode(MerkleNode&&) = default;\n+    MerkleNode& operator=(const MerkleNode&) = default;\n+    MerkleNode& operator=(MerkleNode&&) = default;\n+\n+    /*\n+     * Ideally this would perhaps be operator int() and operator=(),\n+     * however C++ does not let us mark an assingment operator as\n+     * explicit. This unfortunately defeats many of the protections\n+     * against bugs that strong typing would give us as any integer or\n+     * Boolean value could be mistakenly assigned and interpreted as a\n+     * code, and therefore assignable to a MerkleNode, probably\n+     * generating a memory access exception if the value is not\n+     * between 0 and 7.\n+     */\n+    inline code_type GetCode() const\n+      { return m_code; }\n+\n+    inline MerkleNode& SetCode(code_type code)\n+    {\n+        m_code = code;\n+        return *this;\n+    }\n+\n+    /*\n+     * The getters and setters for the left and right MerkleLinks\n+     * simply recalculate the code value using tables. The code values\n+     * line up such that this could be done with arithmetic and\n+     * shifts, but it is probably of similar efficiency.\n+     */\n+    inline MerkleLink GetLeft() const\n+      { return m_left_from_code[m_code]; }\n+\n+    inline MerkleNode& SetLeft(MerkleLink left)\n+    {\n+        m_code = _get_code(left, m_right_from_code[m_code]);\n+        return *this;\n+    }\n+\n+    inline MerkleLink GetRight() const\n+      { return m_right_from_code[m_code]; }\n+\n+    inline MerkleNode& SetRight(MerkleLink right)\n+    {\n+        m_code = _get_code(m_left_from_code[m_code], right);\n+        return *this;\n+    }\n+\n+    /* Equality */\n+    inline bool operator==(MerkleNode other) const\n+      { return (m_code == other.m_code); }\n+    inline bool operator!=(MerkleNode other) const\n+      { return !(*this == other); }\n+\n+    /* Relational */\n+    inline bool operator<(MerkleNode other) const\n+      { return (m_code < other.m_code); }\n+    inline bool operator<=(MerkleNode other) const\n+      { return !(other < *this); }\n+    inline bool operator>=(MerkleNode other) const\n+      { return !(*this < other); }\n+    inline bool operator>(MerkleNode other) const\n+      { return (other < *this); }\n+\n+    /* Needs access to m_{left,right}_from_code and _get_code() */\n+    friend struct MerkleNodeReference;\n+};\n+\n+/*\n+ * Now we begin constructing the necessary infrastructure for\n+ * supporting an STL-like container for packed 3-bit code\n+ * representations of MerkleNode values. This is parallels the way\n+ * that std::vector<bool> is specialized, with the added complication\n+ * of a non-power-of-2 packed size.\n+ */\n+\n+/*\n+ * First we build a \"reference\" class which is able to address the\n+ * location of a packed 3-bit value, and to read and write that value\n+ * without affecting its neighbors.\n+ *\n+ * Then we will make use of this MerkleNode reference type to\n+ * construct an STL-compatible iterator class (technically two, since\n+ * the class const_iterator is not a const instance of the class\n+ * iterator, for reasons).\n+ */\n+struct MerkleNodeReference\n+{\n+    /*\n+     * Nodes are stored with a tightly packed 3-bit encoding, the\n+     * code. This allows up to 8 node specifications to fit within 3\n+     * bytes:\n+     *\n+     *    -- Node index\n+     *   /\n+     *   00011122 23334445 55666777\n+     *    byte 0   byte 1   byte 2\n+     *   76543210 76543210 76543210\n+     *                            /\n+     *                Bit Index --\n+     *\n+     * A reference to a particular node consists of a pointer to the\n+     * beginning of this 3 byte sequence, and the index (between 0 and\n+     * 7) of the node.\n+     */\n+    typedef unsigned char base_type;\n+    typedef unsigned char offset_type;\n+\n+protected:\n+    base_type* m_base;\n+    offset_type m_offset;\n+\n+    /*\n+     * The parameterized constructor is protected because MerkleNode\n+     * references should only ever be created by the friended iterator\n+     * and container code.\n+     */\n+    MerkleNodeReference(base_type* base, offset_type offset) : m_base(base), m_offset(offset) { }\n+\n+    /*\n+     * We're emulating a reference, not a pointer, and it doesn't make\n+     * sense to have a default-constructable reference.\n+     */\n+    MerkleNodeReference() = delete;\n+\n+public:\n+    /*\n+     * The default copy constructors are sufficient. Note that these\n+     * create a new reference object that points to the same packed\n+     * MerkleNode value.\n+     */\n+    MerkleNodeReference(const MerkleNodeReference& other) = default;\n+    MerkleNodeReference(MerkleNodeReference&& other) = default;\n+\n+    /*\n+     * Copy assignment operators are NOT the default behavior:\n+     * assigning one reference to another copies the underlying\n+     * values, to make the MerkleNodeReference objects behave like\n+     * references. It is NOT the same as the copy constructor, which\n+     * copies the reference itself.\n+     */\n+    inline MerkleNodeReference& operator=(const MerkleNodeReference& other)\n+      { return SetCode(other.GetCode()); }\n+    inline MerkleNodeReference& operator=(MerkleNodeReference&& other)\n+      { return SetCode(other.GetCode()); }\n+\n+public:\n+    /* Read a 3-bit code value */\n+    MerkleNode::code_type GetCode() const;\n+\n+    /* Write a 3-bit code value */\n+    MerkleNodeReference& SetCode(MerkleNode::code_type code);\n+\n+    /* Read and write the MerkleLink values individually. */\n+    inline MerkleLink GetLeft() const\n+      { return MerkleNode::m_left_from_code[GetCode()]; }\n+    inline MerkleNodeReference& SetLeft(MerkleLink left)\n+      { return SetCode(MerkleNode::_get_code(left, GetRight())); }\n+\n+    MerkleLink GetRight() const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/12131#discussion_r175815214",
      "id" : 175815214,
      "original_commit_id" : "1af2099f6ec54d3df050c16b1016ee6c0b279290",
      "original_position" : 289,
      "path" : "src/consensus/merkle.h",
      "position" : 289,
      "pull_request_review_id" : 105407279,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/12131",
      "updated_at" : "2018-03-20T15:39:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/175815214",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/8403418?v=4",
         "events_url" : "https://api.github.com/users/jl2012/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jl2012/followers",
         "following_url" : "https://api.github.com/users/jl2012/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jl2012/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jl2012",
         "id" : 8403418,
         "login" : "jl2012",
         "organizations_url" : "https://api.github.com/users/jl2012/orgs",
         "received_events_url" : "https://api.github.com/users/jl2012/received_events",
         "repos_url" : "https://api.github.com/users/jl2012/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jl2012/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jl2012/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jl2012"
      }
   }
]
