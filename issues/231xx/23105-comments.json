[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "The same issue comes up in machine learning:  every path through a forest of decision trees looks alike, because the code's just a loop through a structure that's the real code.\r\n\r\nPeople have done various things on this I don't recall offhand, not sure any that are out there work way better than libFuzzer value profiles, unless custom targeted.\r\n\r\nOne idea I had but have never explored is to use some kind of annotation on key structures that, in a fuzz build, expands to explicit coverage targets somehow.  I suspect in C++ a modest annotation + evil template magic could do this.  My (very unsupported) guess is that -use_value_profiles=1 is not great at this because it has no way to know which state is noise and which is important.  I have an NSF proposal in (no clue if we'll get funded) that has adding support for this kind of thing to DeepState as a major component.\r\n\r\nWriting an #IF_FUZZ hand \"fake coverage\" that won't get optimized away for critical targets might be doable in some cases, like here?",
      "created_at" : "2021-09-27T14:58:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/23105#issuecomment-927957459",
      "id" : 927957459,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23105",
      "node_id" : "IC_kwDOABII5843T4HT",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-27T14:58:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/927957459",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/967816?v=4",
         "events_url" : "https://api.github.com/users/agroce/events{/privacy}",
         "followers_url" : "https://api.github.com/users/agroce/followers",
         "following_url" : "https://api.github.com/users/agroce/following{/other_user}",
         "gists_url" : "https://api.github.com/users/agroce/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/agroce",
         "id" : 967816,
         "login" : "agroce",
         "node_id" : "MDQ6VXNlcjk2NzgxNg==",
         "organizations_url" : "https://api.github.com/users/agroce/orgs",
         "received_events_url" : "https://api.github.com/users/agroce/received_events",
         "repos_url" : "https://api.github.com/users/agroce/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/agroce/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/agroce/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/agroce"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@MarcoFalke \r\n\r\n# Input size control\r\n\r\nLimit the maximum size (libFuzzer flag: `-max_len=N`). In my experience the vast majority of bugs for most fuzzers (in general) can be constructed with very small files (in the order of several hundreds of bytes). I think OSS-Fuzz uses a `max_len` of 1 megabyte which is far too large for most targets. The benefit of limiting the max input size to 4KB or smaller is that the search space in terms of volume becomes much smaller, each mutation has more chance of making a meaningful change and hitting a bug. `-max_len=4096` is often demonstrably faster in finding bugs than say `-max_len=1048576` The only downside of a hard limit is that you will miss bugs which can only be expressed with an input larger than the hard limit.\r\n\r\nlibFuzzer by default favors smaller inputs and gradually move towards larger inputs. This is controlled by the `len_control` flag:\r\n\r\n```\r\n len_control                         \t100\tTry generating small inputs first, then try larger inputs over time.  Specifies the rate at which the length limit is increased (smaller == faster).  If 0, immediately try inputs with size up to max_len. Default value is 0, if LLVMFuzzerCustomMutator is used.\r\n```\r\n\r\nSo if a hard limit is not desirable you can consider tweaking `len_control`.\r\n\r\n# Extra counters\r\n\r\nYou can use an additional coverage signal by defining (at the global scope, and use `extern \"C\" {}` when using C++):\r\n\r\n```cpp\r\nextern \"C\" {\r\n__attribute__((section(\"__libfuzzer_extra_counters\")))\r\nuint8_t bitcoin_extra_counters[1024];\r\n}\r\n```\r\n\r\nlibFuzzer will see this on startup and use its contents as an additional signal. You don't need to memset it to 0 each iteration, libFuzzer does that for you.\r\n\r\nYou can use some arbitrary logic to signal progress to libFuzzer, e.g.\r\n\r\n```cpp\r\nextern \"C\" {\r\n__attribute__((section(\"__libfuzzer_extra_counters\")))\r\nuint64_t  bitcoin_multisig_size;\r\n}\r\n```\r\n\r\nand in the script code\r\n\r\n```cpp\r\nbitcoin_multisig_size = multisig_size;\r\n```\r\n\r\nAlternatively or additionally you can consider hashing some core characteristics of the script environment, for example opcode + program counter + stack size, e.g.:\r\n\r\n```cpp\r\nextern \"C\" {\r\n__attribute__((section(\"__libfuzzer_extra_counters\")))\r\nuint8_t bitcoin_extra_counters[65535];\r\n}\r\n```\r\n\r\nand in the script instruction loop:\r\n\r\n```c\r\nbitcoin_extra_counters[ (op^pc^stack.size()) % 65535 ] ++;\r\n```\r\n\r\nor something to that effect.\r\n\r\nThis ought to signal the VM state more accurately to libFuzzer and should expedite the bug finding.\r\n\r\nSome fuzzers even work *exclusively* using extra counters, such as go-fuzz in libFuzzer mode: https://github.com/dvyukov/go-fuzz/blob/4980593459a186bd2a389fe4557a260cce742594/go-fuzz-build/main.go#L857-L863\r\nAnd this works very well.",
      "created_at" : "2021-09-27T17:10:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/23105#issuecomment-928081803",
      "id" : 928081803,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23105",
      "node_id" : "IC_kwDOABII5843UWeL",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-27T17:15:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/928081803",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6846644?v=4",
         "events_url" : "https://api.github.com/users/guidovranken/events{/privacy}",
         "followers_url" : "https://api.github.com/users/guidovranken/followers",
         "following_url" : "https://api.github.com/users/guidovranken/following{/other_user}",
         "gists_url" : "https://api.github.com/users/guidovranken/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/guidovranken",
         "id" : 6846644,
         "login" : "guidovranken",
         "node_id" : "MDQ6VXNlcjY4NDY2NDQ=",
         "organizations_url" : "https://api.github.com/users/guidovranken/orgs",
         "received_events_url" : "https://api.github.com/users/guidovranken/received_events",
         "repos_url" : "https://api.github.com/users/guidovranken/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/guidovranken/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/guidovranken/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/guidovranken"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I looked at this specific fuzzer and found that none of the files in the https://github.com/bitcoin-core/qa-assets/tree/main/fuzz_seed_corpus/script directory hit this block: https://github.com/bitcoin/bitcoin/blob/e826b22da252e0599c61d21c98ff89f366b3120f/src/script/standard.cpp#L284-L296\r\n\r\nSpecifically, no input satisfies this condition:\r\n\r\nhttps://github.com/bitcoin/bitcoin/blob/e826b22da252e0599c61d21c98ff89f366b3120f/src/script/standard.cpp#L141\r\n\r\nSo in this particular case the problem seems to be that the fuzzer is not able to construct a multisig script in the first place, and a custom mutator might help.",
      "created_at" : "2021-09-28T06:00:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/23105#issuecomment-928878717",
      "id" : 928878717,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23105",
      "node_id" : "IC_kwDOABII5843XZB9",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-28T06:00:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/928878717",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6846644?v=4",
         "events_url" : "https://api.github.com/users/guidovranken/events{/privacy}",
         "followers_url" : "https://api.github.com/users/guidovranken/followers",
         "following_url" : "https://api.github.com/users/guidovranken/following{/other_user}",
         "gists_url" : "https://api.github.com/users/guidovranken/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/guidovranken",
         "id" : 6846644,
         "login" : "guidovranken",
         "node_id" : "MDQ6VXNlcjY4NDY2NDQ=",
         "organizations_url" : "https://api.github.com/users/guidovranken/orgs",
         "received_events_url" : "https://api.github.com/users/guidovranken/received_events",
         "repos_url" : "https://api.github.com/users/guidovranken/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/guidovranken/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/guidovranken/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/guidovranken"
      }
   }
]
