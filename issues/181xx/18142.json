{
   "assignee" : null,
   "assignees" : [],
   "author_association" : "MEMBER",
   "body" : "Multiple people, or even just one person with multiple devices, want to setup a multi-sig wallet. The end result is a [descriptor wallet](https://github.com/bitcoin/bitcoin/pull/16528), perhaps [miniscript enhanced](https://github.com/bitcoin/bitcoin/pull/16800).\r\n\r\nProblem: how do you coordinate this setup? See Electrum thread about the same issue: https://github.com/spesmilo/electrum/issues/5715\r\n\r\nBonus points: it should also work with a protocol like MuSig that requires more than one round of communication.\r\n\r\n## Current situation\r\n\r\nI made a [tutorial and screencast](https://nthkey.com/tutorial) of a setup flow, in this case using two signers: a ColdCard  and an iOs app that I'm working on. It's based on the flow ColdCard uses to setup a multisig between two of their devices. [Specter wallet](https://github.com/cryptoadvance) uses a similar flow and the same file format, last time I checked.\r\n\r\nThe general idea there is for each cosigner to export a (JSON) file with information about their public keys, and for the other signers to import that. Derivation paths are standardised (see also #16895). All participating devices will derive the same addresses; the user just needs to enter the (same) threshold on all devices.\r\n\r\nThe above is pretty easy to implement.\r\n\r\n## Flexible signer policies\r\n\r\nThe above approach requires everyone to contribute a single key. Individual participants can't do fancy stuff like having their own internal multisig setup or some backup key after a timeout. Yet this could be very useful, e.g. imagine a user with two hardware wallets who wants to use an external service provider as the third key. That service provider may have some super fancy setup, but they don't want to ship custom software to the user, let alone merge their special sauce into Bitcoin Core. What if you could use the Green Address service, but with your favourite orange QT wallet?\r\n\r\nA more flexible setup could use miniscript, where each participant provides a policy language snippet they want to use. These are then aggregated with `thresh(M, policy1, policy2, ... policyN)`. The result is then compiled by a coordinator (one of the participants) and shared with the others. Each participant could use a simple public key, or some super convoluted scheme. The cool thing about miniscript if that each participant can verify, without understanding the policy of the others, that they indeed control 1/Nth.\r\n\r\nIIUC the plan is to [combine](https://github.com/bitcoin/bitcoin/pull/16800) the powers of miniscript and output descriptors, and eventually add that to the wallet. Hopefully this allows for putting xpubs and origin info in both the policy language and the miniscript itself.\r\n\r\nThere is no current plan to add the policy language to miniscript compiler to Bitcoin Core, but we can start with a naive concatenation of participant miniscripts. Also AFAIK existing hardware wallets don't support anything other than plain OP_CHECKMULTISIG (`thresh_m(2, xpub1, xpub2, xpub3))` anyway.\r\n\r\nIdeally the whole thing is small enough to copy-paste or put in a QR code (e.g. bech32-ish encoded).\r\n\r\n## Wallet composition file?\r\n\r\nWhat I have in mind is to (wait for someone else to) design a (binary) format, perhaps similar to PSBT, to compose a wallet interactively.\r\n\r\nIt would start with a coordinator. They populate the file with the \"shape\" of the wallet (YAML for illustrative purposes): \r\n\r\n```yaml\r\n- descriptor: null\r\n- policy: thresh_m(2, participant_1, participant_2, participant_3))\r\n- participant_1:\r\n   - policy: null\r\n- participant_2:\r\n   - policy: null\r\n- participant_3:\r\n   - policy: null\r\n```\r\n\r\nThen the first participant, probably the coordinator, fills in their details:\r\n\r\n```yaml\r\n- descriptor: null\r\n- policy: thresh_m(2, participant_1, participant_2, participant_3))\r\n- participant_1:\r\n   - policy: c:pk([00000000]/m/48h/0h/0h/2h/xpub_1/{0,1}/*)\r\n- participant_2:\r\n   - policy: null\r\n- participant_3:\r\n   - policy: null\r\n```\r\n\r\nThe file is then passed to participants 2 and 3. Participant 3 will have all the info it needs to construct a final descriptor (set), and it can prompt the user to \"commit\" to that wallet:\r\n\r\n```yaml\r\n- descriptor: multi(2, [00000000]/m/48h/0h/0h/2h/xpub_1/{0,1}/*, ......)\r\n- policy: ...\r\netc...\r\n```\r\n\r\n(`{0,1}` is a fake descriptor syntax; for now you need a separate receive and change descriptor)\r\n\r\nEach participant needs to \"commit\" to the wallet, in the sense of storing it in their memory. This lets them display receive addresses, and it lets them check the change address before signing a transaction.\r\n\r\nIt then passes it to the other participants. If the devices all have screens, the user can now compare the first receive address as a sanity check.\r\n\r\nBitcoin Core should be able to import this a watch-only descriptor wallet (or maybe it has one of the keys). If any of the devices isn't smart / powerful enough to figure out the descriptor, then it needs to go back to the coordinator first. Additional fields can be added e.g. to include nonces for a musig pubkey generation ritual. Also additional fields could contain friendly names for the participants.",
   "closed_at" : null,
   "closed_by" : null,
   "comments" : 0,
   "comments_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18142/comments",
   "created_at" : "2020-02-13T20:20:45Z",
   "events_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18142/events",
   "html_url" : "https://github.com/bitcoin/bitcoin/issues/18142",
   "id" : 564928115,
   "labels" : [
      {
         "color" : "7cf575",
         "default" : false,
         "description" : null,
         "id" : 64583,
         "name" : "Feature",
         "node_id" : "MDU6TGFiZWw2NDU4Mw==",
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/labels/Feature"
      }
   ],
   "labels_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18142/labels{/name}",
   "locked" : false,
   "milestone" : null,
   "node_id" : "MDU6SXNzdWU1NjQ5MjgxMTU=",
   "number" : 18142,
   "repository_url" : "https://api.github.com/repos/bitcoin/bitcoin",
   "state" : "open",
   "title" : "Coordinate multi-sig wallet",
   "updated_at" : "2020-02-13T20:20:45Z",
   "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18142",
   "user" : {
      "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
      "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
      "followers_url" : "https://api.github.com/users/Sjors/followers",
      "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
      "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
      "gravatar_id" : "",
      "html_url" : "https://github.com/Sjors",
      "id" : 10217,
      "login" : "Sjors",
      "node_id" : "MDQ6VXNlcjEwMjE3",
      "organizations_url" : "https://api.github.com/users/Sjors/orgs",
      "received_events_url" : "https://api.github.com/users/Sjors/received_events",
      "repos_url" : "https://api.github.com/users/Sjors/repos",
      "site_admin" : false,
      "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
      "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
      "type" : "User",
      "url" : "https://api.github.com/users/Sjors"
   }
}
