[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.",
      "created_at" : "2020-02-22T09:26:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#issuecomment-589936663",
      "id" : 589936663,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18191",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTkzNjY2Mw==",
      "updated_at" : "2020-03-06T22:08:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589936663",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384107992"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384107992"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Github won't let me leave a comment up at line 106, so I'm leaving it here.  I think the change in this commit of trying to not include things in `exclude` is broken, because it's possible you'll have a cache entry hit for something that is excluded, and then because things that are in the cache get swapped at line 106 to an entry in the vector that `already_traversed` is advanced past, you'll never pop it before you get down to this loop.\r\n\r\nI tend to think that this improvement to leaving things out from exclude isn't worth it; seems like quite a bit of added complexity to this logic without an obvious performance improvement.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-02-25T20:28:03Z",
      "diff_hunk" : "@@ -108,18 +122,23 @@ void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const s\n     int64_t modify_size = 0;\n     CAmount modify_fee = 0;\n     int64_t modify_count = 0;\n+    // All entries in the update_cache have\n+    // already been checked against excluded list\n     for (txiter child_it : update_cache) {\n         const CTxMemPoolEntry& child = *child_it;\n-        if (!exclude.count(child.GetTx().GetHash())) {\n-            modify_size += child.GetTxSize();\n-            modify_fee += child.GetModifiedFee();\n-            modify_count++;\n-            mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n-        }\n+        modify_size += child.GetTxSize();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384107992",
      "id" : 384107992,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwNzk5Mg==",
      "original_commit_id" : "ec237cf8c640f9e85c3c7aad0d3eb243a346b1f9",
      "original_position" : 58,
      "path" : "src/txmempool.cpp",
      "position" : 85,
      "pull_request_review_id" : 364424930,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-06T19:45:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384107992",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384108456"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384108456"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I overlooked this issue in #18120 -- is this the regression you're referring to in the commit message?",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-02-25T20:28:59Z",
      "diff_hunk" : "@@ -108,18 +122,23 @@ void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const s\n     int64_t modify_size = 0;\n     CAmount modify_fee = 0;\n     int64_t modify_count = 0;\n+    // All entries in the update_cache have\n+    // already been checked against excluded list\n     for (txiter child_it : update_cache) {\n         const CTxMemPoolEntry& child = *child_it;\n-        if (!exclude.count(child.GetTx().GetHash())) {\n-            modify_size += child.GetTxSize();\n-            modify_fee += child.GetModifiedFee();\n-            modify_count++;\n-            mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n-        }\n+        modify_size += child.GetTxSize();\n+        modify_fee += child.GetModifiedFee();\n+        modify_count++;\n+        mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n     }\n     mapTx.modify(update_it, update_descendant_state(modify_size, modify_fee, modify_count));\n     // share the cache (if there is one)\n-    if (!update_cache.empty()) cache.emplace(update_it, std::move(update_cache));\n+    if (!update_cache.empty()) {\n+        // Ask to shrink to fit if we're using space poorly\n+        if (update_cache.size() > 100 && update_cache.capacity() > 2 * update_cache.size())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384108456",
      "id" : 384108456,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwODQ1Ng==",
      "original_commit_id" : "ec237cf8c640f9e85c3c7aad0d3eb243a346b1f9",
      "original_position" : 68,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 364424930,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-06T19:45:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384108456",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384734328"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384734328"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Nope this is *as a result* of the fix, we sometimes now have a cache that is too big because we remove things from the cache if they are in exclude. We could not do this -- and then it would still be possible for the cache entries to have an excess of O(direct children in exlcude), rather than O(exclude) without this patch, and an excess of 100 or not more than 2*size with this patch. It also only does anything on systems that implement shrink_to_fit fwiw.\r\n\r\n\r\nI'll tag you on the relevant line....",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-02-26T20:04:19Z",
      "diff_hunk" : "@@ -108,18 +122,23 @@ void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const s\n     int64_t modify_size = 0;\n     CAmount modify_fee = 0;\n     int64_t modify_count = 0;\n+    // All entries in the update_cache have\n+    // already been checked against excluded list\n     for (txiter child_it : update_cache) {\n         const CTxMemPoolEntry& child = *child_it;\n-        if (!exclude.count(child.GetTx().GetHash())) {\n-            modify_size += child.GetTxSize();\n-            modify_fee += child.GetModifiedFee();\n-            modify_count++;\n-            mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n-        }\n+        modify_size += child.GetTxSize();\n+        modify_fee += child.GetModifiedFee();\n+        modify_count++;\n+        mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n     }\n     mapTx.modify(update_it, update_descendant_state(modify_size, modify_fee, modify_count));\n     // share the cache (if there is one)\n-    if (!update_cache.empty()) cache.emplace(update_it, std::move(update_cache));\n+    if (!update_cache.empty()) {\n+        // Ask to shrink to fit if we're using space poorly\n+        if (update_cache.size() > 100 && update_cache.capacity() > 2 * update_cache.size())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384734328",
      "id" : 384734328,
      "in_reply_to_id" : 384108456,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczNDMyOA==",
      "original_commit_id" : "ec237cf8c640f9e85c3c7aad0d3eb243a346b1f9",
      "original_position" : 68,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 365203421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-06T19:45:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384734328",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384735187"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384735187"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "We hold the invariant that everything in the cache is not excluded? So how would this have a bug?",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-02-26T20:05:45Z",
      "diff_hunk" : "@@ -108,18 +122,23 @@ void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const s\n     int64_t modify_size = 0;\n     CAmount modify_fee = 0;\n     int64_t modify_count = 0;\n+    // All entries in the update_cache have\n+    // already been checked against excluded list\n     for (txiter child_it : update_cache) {\n         const CTxMemPoolEntry& child = *child_it;\n-        if (!exclude.count(child.GetTx().GetHash())) {\n-            modify_size += child.GetTxSize();\n-            modify_fee += child.GetModifiedFee();\n-            modify_count++;\n-            mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n-        }\n+        modify_size += child.GetTxSize();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384735187",
      "id" : 384735187,
      "in_reply_to_id" : 384107992,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczNTE4Nw==",
      "original_commit_id" : "ec237cf8c640f9e85c3c7aad0d3eb243a346b1f9",
      "original_position" : 58,
      "path" : "src/txmempool.cpp",
      "position" : 85,
      "pull_request_review_id" : 365204339,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-06T19:45:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384735187",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384740067"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384740067"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ah I see what you're saying. See comment above, will fix.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-02-26T20:15:44Z",
      "diff_hunk" : "@@ -108,18 +122,23 @@ void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const s\n     int64_t modify_size = 0;\n     CAmount modify_fee = 0;\n     int64_t modify_count = 0;\n+    // All entries in the update_cache have\n+    // already been checked against excluded list\n     for (txiter child_it : update_cache) {\n         const CTxMemPoolEntry& child = *child_it;\n-        if (!exclude.count(child.GetTx().GetHash())) {\n-            modify_size += child.GetTxSize();\n-            modify_fee += child.GetModifiedFee();\n-            modify_count++;\n-            mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n-        }\n+        modify_size += child.GetTxSize();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384740067",
      "id" : 384740067,
      "in_reply_to_id" : 384107992,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0MDA2Nw==",
      "original_commit_id" : "ec237cf8c640f9e85c3c7aad0d3eb243a346b1f9",
      "original_position" : 58,
      "path" : "src/txmempool.cpp",
      "position" : 85,
      "pull_request_review_id" : 365210436,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-06T19:45:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384740067",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed and updated comment.",
      "created_at" : "2020-03-03T04:46:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#issuecomment-593765658",
      "id" : 593765658,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18191",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5Mzc2NTY1OA==",
      "updated_at" : "2020-03-03T04:46:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/593765658",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Sorry for all the line noise; I realized I forgot to add a continue, and then decided that I could DRY up the code a bit. I'm pretty happy with the final version, I think it's a bit easier to view because we don't treat update_it special from other iterators we walk (other than it not going into the cache line).\r\n\r\nI can squash this all down into one commit and replace #18120.",
      "created_at" : "2020-03-03T05:55:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#issuecomment-593781580",
      "id" : 593781580,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18191",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5Mzc4MTU4MA==",
      "updated_at" : "2020-03-03T05:55:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/593781580",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK.",
      "created_at" : "2020-03-29T17:43:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#issuecomment-605673033",
      "id" : 605673033,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18191",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwNTY3MzAzMw==",
      "updated_at" : "2020-03-29T17:43:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/605673033",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r399846953"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399846953"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm confused with \"... have already been checked against _excluded list_\". Which list?",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-29T20:10:36Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }\n         }\n+\n+        // finish loop here!\n+        if (next_idx_to_walk >= new_cache_line.size()) break;\n+\n+        // Prepare for next iteration:\n+        next_it = new_cache_line[next_idx_to_walk];\n+        ++next_idx_to_walk;\n+    } while (true);\n+\n+    // new_cache_line now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    // All entries in the new_cache_line have\n+    // already been checked against excluded list",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r399846953",
      "id" : 399846953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0Njk1Mw==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 82,
      "path" : "src/txmempool.cpp",
      "position" : 82,
      "pull_request_review_id" : 383450072,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-29T20:10:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399846953",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r399892304"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399892304"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "mapMemPoolDescebdabtsToUpdate grows to contain the set of things to exclude while processing.\r\n\r\nPreviously this list was explicitly constructed, now it's implicit",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T02:02:59Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }\n         }\n+\n+        // finish loop here!\n+        if (next_idx_to_walk >= new_cache_line.size()) break;\n+\n+        // Prepare for next iteration:\n+        next_it = new_cache_line[next_idx_to_walk];\n+        ++next_idx_to_walk;\n+    } while (true);\n+\n+    // new_cache_line now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    // All entries in the new_cache_line have\n+    // already been checked against excluded list",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r399892304",
      "id" : 399892304,
      "in_reply_to_id" : 399846953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg5MjMwNA==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 82,
      "path" : "src/txmempool.cpp",
      "position" : 82,
      "pull_request_review_id" : 383491437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T02:02:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399892304",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "IIUC, the first pass of the `do ... while (true);` loop just emplaces all of the direct descendants of `update_it` tx, i.e., its children, to the `new_cache_line`, and taints their `m_epoch`. All of the following loop passes process grand children, grand-grand children and so on. And two thing are confusing to me:\r\n\r\n1) the following comment: https://github.com/bitcoin/bitcoin/blob/32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a/src/txmempool.cpp#L79-L80\r\n\r\nI'd suggest to remove it completely.\r\n\r\n2) the following variable name: https://github.com/bitcoin/bitcoin/blob/32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a/src/txmempool.cpp#L87\r\n\r\nI'd suggest:\r\n- s/`cached_grand_children`/`cached_descendants`/\r\n- s/`grand_child_it`/`descendant_it`/\r\n- s/`the grand child`/`the descendant`/ in the comment\r\n\r\nEDIT: I realized, that you mean \"children\" and \"grandchildren\" relative to an element of the `new_cache_line`. So, ignore my suggestion (2).",
      "created_at" : "2020-03-30T08:41:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#issuecomment-605863701",
      "id" : 605863701,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18191",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwNTg2MzcwMQ==",
      "updated_at" : "2020-03-30T08:56:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/605863701",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400041234"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400041234"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Previously this list was explicitly constructed, now it's implicit\r\n\r\nYes. And the new logic does not apply any rule or list \"to exclude\" an element. It seems, the comments should avoid any \"excluding\" notions, and describe the logic in terms of \"including\" or \"conditional including\".",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T09:14:53Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }\n         }\n+\n+        // finish loop here!\n+        if (next_idx_to_walk >= new_cache_line.size()) break;\n+\n+        // Prepare for next iteration:\n+        next_it = new_cache_line[next_idx_to_walk];\n+        ++next_idx_to_walk;\n+    } while (true);\n+\n+    // new_cache_line now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    // All entries in the new_cache_line have\n+    // already been checked against excluded list",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400041234",
      "id" : 400041234,
      "in_reply_to_id" : 399846953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MTIzNA==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 82,
      "path" : "src/txmempool.cpp",
      "position" : 82,
      "pull_request_review_id" : 383667748,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T09:14:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400041234",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400057301"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400057301"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The internal loop seems redundant. Could this work:\r\n```\r\n    do {\r\n        for (const txiter child_it : GetMemPoolChildren(next_it)) {\r\n            if (visited(child_it)) continue;\r\n            new_cache_line.emplace_back(child_it);\r\n        }\r\n\r\n        // finish loop here!\r\n        if (next_idx_to_walk >= new_cache_line.size()) break;\r\n\r\n        // Prepare for next iteration:\r\n        next_it = new_cache_line[next_idx_to_walk];\r\n        ++next_idx_to_walk;\r\n    } while (true);\r\n```\r\n?\r\n\r\nUPDATED: ... or even\r\n```\r\n    txiter next_it = update_it;\r\n    for (size_t next_idx_to_walk = 0; next_idx_to_walk < new_cache_line.size(); ++next_idx_to_walk) {\r\n        for (const txiter child_it : GetMemPoolChildren(next_it)) {\r\n            if (visited(child_it)) continue;\r\n            new_cache_line.emplace_back(child_it);\r\n        }\r\n        next_it = new_cache_line[next_idx_to_walk];\r\n    }\r\n```",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T09:40:20Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400057301",
      "id" : 400057301,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA1NzMwMQ==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 65,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 383687369,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T10:14:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400057301",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400085843"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400085843"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why a new variable is needed? `child_it->GetTxSize()` and `child_it->GetModifiedFee()` seems to work well, no?",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T10:27:46Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }\n         }\n+\n+        // finish loop here!\n+        if (next_idx_to_walk >= new_cache_line.size()) break;\n+\n+        // Prepare for next iteration:\n+        next_it = new_cache_line[next_idx_to_walk];\n+        ++next_idx_to_walk;\n+    } while (true);\n+\n+    // new_cache_line now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    // All entries in the new_cache_line have\n+    // already been checked against excluded list\n+    for (txiter child_it : new_cache_line) {\n+        const CTxMemPoolEntry& child = *child_it;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400085843",
      "id" : 400085843,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA4NTg0Mw==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 84,
      "path" : "src/txmempool.cpp",
      "position" : 84,
      "pull_request_review_id" : 383722330,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T10:27:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400085843",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400476700"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400476700"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "No because then we aren't using the cached traversal at all.\r\n\r\nIt could be correct, but has some algorithmic complexity blowups.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T20:34:29Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400476700",
      "id" : 400476700,
      "in_reply_to_id" : 400057301,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ3NjcwMA==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 65,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 384208947,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T20:34:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400476700",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400478978"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400478978"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It would work but I have a preference to access through a const ref where possible to avoid using non const APIs where not explicitly offered.\r\n\r\nNo performance overhead of this, it shouldn't even allocate a variable in the code.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T20:38:37Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }\n         }\n+\n+        // finish loop here!\n+        if (next_idx_to_walk >= new_cache_line.size()) break;\n+\n+        // Prepare for next iteration:\n+        next_it = new_cache_line[next_idx_to_walk];\n+        ++next_idx_to_walk;\n+    } while (true);\n+\n+    // new_cache_line now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    // All entries in the new_cache_line have\n+    // already been checked against excluded list\n+    for (txiter child_it : new_cache_line) {\n+        const CTxMemPoolEntry& child = *child_it;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400478978",
      "id" : 400478978,
      "in_reply_to_id" : 400085843,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ3ODk3OA==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 84,
      "path" : "src/txmempool.cpp",
      "position" : 84,
      "pull_request_review_id" : 384210609,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T20:38:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400478978",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400480589"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400480589"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "You update is still not using the cache lines....",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T20:41:41Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400480589",
      "id" : 400480589,
      "in_reply_to_id" : 400057301,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4MDU4OQ==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 65,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 384213894,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T20:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400480589",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400494926"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400494926"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> It could be correct, but has some algorithmic complexity blowups.\r\n\r\nHow it could be, if every element is visited once only?",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T21:08:15Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400494926",
      "id" : 400494926,
      "in_reply_to_id" : 400057301,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ5NDkyNg==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 65,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 384231611,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T21:08:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400494926",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400529948"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400529948"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm saying \"could be\" because I haven't bothered to actually check your code above for correctness, given the glaring issue that it doesn't use the caches which leads to unacceptable algorithmic complexity.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T22:22:18Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400529948",
      "id" : 400529948,
      "in_reply_to_id" : 400057301,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyOTk0OA==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 65,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 384274377,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T22:22:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400529948",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400532152"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400532152"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Well the list does exist -- it's vHashesToUpdate. We just don't need to actually check or construct it because it's an implicit invariant held by the code.\r\n\r\nI can't comment on the semantic difference between excluding or conditional including, but it does seem that what we're doing is excluding.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T22:27:36Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }\n         }\n+\n+        // finish loop here!\n+        if (next_idx_to_walk >= new_cache_line.size()) break;\n+\n+        // Prepare for next iteration:\n+        next_it = new_cache_line[next_idx_to_walk];\n+        ++next_idx_to_walk;\n+    } while (true);\n+\n+    // new_cache_line now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    // All entries in the new_cache_line have\n+    // already been checked against excluded list",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400532152",
      "id" : 400532152,
      "in_reply_to_id" : 399846953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUzMjE1Mg==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 82,
      "path" : "src/txmempool.cpp",
      "position" : 82,
      "pull_request_review_id" : 384276918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T22:27:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400532152",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400532974"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400532974"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In any case this comment & the function comment serve to document what the expected invariant is for the caller, so I prefer to leave this comment.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T22:29:31Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }\n         }\n+\n+        // finish loop here!\n+        if (next_idx_to_walk >= new_cache_line.size()) break;\n+\n+        // Prepare for next iteration:\n+        next_it = new_cache_line[next_idx_to_walk];\n+        ++next_idx_to_walk;\n+    } while (true);\n+\n+    // new_cache_line now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    // All entries in the new_cache_line have\n+    // already been checked against excluded list",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400532974",
      "id" : 400532974,
      "in_reply_to_id" : 399846953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUzMjk3NA==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 82,
      "path" : "src/txmempool.cpp",
      "position" : 82,
      "pull_request_review_id" : 384277819,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T22:29:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400532974",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400594651"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400594651"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I guess to pull up -- I do agree that the loop is a bit atypical in structure, but I do think that it's the most straightforward to reason about because it's pretty critical when certain checks or variable updates happen.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-31T01:46:11Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400594651",
      "id" : 400594651,
      "in_reply_to_id" : 400057301,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU5NDY1MQ==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 65,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 384348791,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-31T01:46:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400594651",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   }
]
