[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.",
      "created_at" : "2020-02-22T09:26:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#issuecomment-589936663",
      "id" : 589936663,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18191",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU4OTkzNjY2Mw==",
      "updated_at" : "2020-03-06T22:08:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/589936663",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384107992"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384107992"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Github won't let me leave a comment up at line 106, so I'm leaving it here.  I think the change in this commit of trying to not include things in `exclude` is broken, because it's possible you'll have a cache entry hit for something that is excluded, and then because things that are in the cache get swapped at line 106 to an entry in the vector that `already_traversed` is advanced past, you'll never pop it before you get down to this loop.\r\n\r\nI tend to think that this improvement to leaving things out from exclude isn't worth it; seems like quite a bit of added complexity to this logic without an obvious performance improvement.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-02-25T20:28:03Z",
      "diff_hunk" : "@@ -108,18 +122,23 @@ void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const s\n     int64_t modify_size = 0;\n     CAmount modify_fee = 0;\n     int64_t modify_count = 0;\n+    // All entries in the update_cache have\n+    // already been checked against excluded list\n     for (txiter child_it : update_cache) {\n         const CTxMemPoolEntry& child = *child_it;\n-        if (!exclude.count(child.GetTx().GetHash())) {\n-            modify_size += child.GetTxSize();\n-            modify_fee += child.GetModifiedFee();\n-            modify_count++;\n-            mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n-        }\n+        modify_size += child.GetTxSize();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384107992",
      "id" : 384107992,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwNzk5Mg==",
      "original_commit_id" : "ec237cf8c640f9e85c3c7aad0d3eb243a346b1f9",
      "original_position" : 58,
      "path" : "src/txmempool.cpp",
      "position" : 85,
      "pull_request_review_id" : 364424930,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-06T19:45:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384107992",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384108456"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384108456"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I overlooked this issue in #18120 -- is this the regression you're referring to in the commit message?",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-02-25T20:28:59Z",
      "diff_hunk" : "@@ -108,18 +122,23 @@ void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const s\n     int64_t modify_size = 0;\n     CAmount modify_fee = 0;\n     int64_t modify_count = 0;\n+    // All entries in the update_cache have\n+    // already been checked against excluded list\n     for (txiter child_it : update_cache) {\n         const CTxMemPoolEntry& child = *child_it;\n-        if (!exclude.count(child.GetTx().GetHash())) {\n-            modify_size += child.GetTxSize();\n-            modify_fee += child.GetModifiedFee();\n-            modify_count++;\n-            mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n-        }\n+        modify_size += child.GetTxSize();\n+        modify_fee += child.GetModifiedFee();\n+        modify_count++;\n+        mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n     }\n     mapTx.modify(update_it, update_descendant_state(modify_size, modify_fee, modify_count));\n     // share the cache (if there is one)\n-    if (!update_cache.empty()) cache.emplace(update_it, std::move(update_cache));\n+    if (!update_cache.empty()) {\n+        // Ask to shrink to fit if we're using space poorly\n+        if (update_cache.size() > 100 && update_cache.capacity() > 2 * update_cache.size())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384108456",
      "id" : 384108456,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwODQ1Ng==",
      "original_commit_id" : "ec237cf8c640f9e85c3c7aad0d3eb243a346b1f9",
      "original_position" : 68,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 364424930,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-06T19:45:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384108456",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384734328"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384734328"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Nope this is *as a result* of the fix, we sometimes now have a cache that is too big because we remove things from the cache if they are in exclude. We could not do this -- and then it would still be possible for the cache entries to have an excess of O(direct children in exlcude), rather than O(exclude) without this patch, and an excess of 100 or not more than 2*size with this patch. It also only does anything on systems that implement shrink_to_fit fwiw.\r\n\r\n\r\nI'll tag you on the relevant line....",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-02-26T20:04:19Z",
      "diff_hunk" : "@@ -108,18 +122,23 @@ void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const s\n     int64_t modify_size = 0;\n     CAmount modify_fee = 0;\n     int64_t modify_count = 0;\n+    // All entries in the update_cache have\n+    // already been checked against excluded list\n     for (txiter child_it : update_cache) {\n         const CTxMemPoolEntry& child = *child_it;\n-        if (!exclude.count(child.GetTx().GetHash())) {\n-            modify_size += child.GetTxSize();\n-            modify_fee += child.GetModifiedFee();\n-            modify_count++;\n-            mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n-        }\n+        modify_size += child.GetTxSize();\n+        modify_fee += child.GetModifiedFee();\n+        modify_count++;\n+        mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n     }\n     mapTx.modify(update_it, update_descendant_state(modify_size, modify_fee, modify_count));\n     // share the cache (if there is one)\n-    if (!update_cache.empty()) cache.emplace(update_it, std::move(update_cache));\n+    if (!update_cache.empty()) {\n+        // Ask to shrink to fit if we're using space poorly\n+        if (update_cache.size() > 100 && update_cache.capacity() > 2 * update_cache.size())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384734328",
      "id" : 384734328,
      "in_reply_to_id" : 384108456,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczNDMyOA==",
      "original_commit_id" : "ec237cf8c640f9e85c3c7aad0d3eb243a346b1f9",
      "original_position" : 68,
      "path" : "src/txmempool.cpp",
      "position" : null,
      "pull_request_review_id" : 365203421,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-06T19:45:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384734328",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384735187"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384735187"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "We hold the invariant that everything in the cache is not excluded? So how would this have a bug?",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-02-26T20:05:45Z",
      "diff_hunk" : "@@ -108,18 +122,23 @@ void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const s\n     int64_t modify_size = 0;\n     CAmount modify_fee = 0;\n     int64_t modify_count = 0;\n+    // All entries in the update_cache have\n+    // already been checked against excluded list\n     for (txiter child_it : update_cache) {\n         const CTxMemPoolEntry& child = *child_it;\n-        if (!exclude.count(child.GetTx().GetHash())) {\n-            modify_size += child.GetTxSize();\n-            modify_fee += child.GetModifiedFee();\n-            modify_count++;\n-            mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n-        }\n+        modify_size += child.GetTxSize();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384735187",
      "id" : 384735187,
      "in_reply_to_id" : 384107992,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDczNTE4Nw==",
      "original_commit_id" : "ec237cf8c640f9e85c3c7aad0d3eb243a346b1f9",
      "original_position" : 58,
      "path" : "src/txmempool.cpp",
      "position" : 85,
      "pull_request_review_id" : 365204339,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-06T19:45:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384735187",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384740067"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384740067"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Ah I see what you're saying. See comment above, will fix.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-02-26T20:15:44Z",
      "diff_hunk" : "@@ -108,18 +122,23 @@ void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache, const s\n     int64_t modify_size = 0;\n     CAmount modify_fee = 0;\n     int64_t modify_count = 0;\n+    // All entries in the update_cache have\n+    // already been checked against excluded list\n     for (txiter child_it : update_cache) {\n         const CTxMemPoolEntry& child = *child_it;\n-        if (!exclude.count(child.GetTx().GetHash())) {\n-            modify_size += child.GetTxSize();\n-            modify_fee += child.GetModifiedFee();\n-            modify_count++;\n-            mapTx.modify(child_it, update_ancestor_state(update_it->GetTxSize(), update_it->GetModifiedFee(), 1, update_it->GetSigOpCost()));\n-        }\n+        modify_size += child.GetTxSize();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r384740067",
      "id" : 384740067,
      "in_reply_to_id" : 384107992,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0MDA2Nw==",
      "original_commit_id" : "ec237cf8c640f9e85c3c7aad0d3eb243a346b1f9",
      "original_position" : 58,
      "path" : "src/txmempool.cpp",
      "position" : 85,
      "pull_request_review_id" : 365210436,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-06T19:45:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/384740067",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed and updated comment.",
      "created_at" : "2020-03-03T04:46:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#issuecomment-593765658",
      "id" : 593765658,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18191",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5Mzc2NTY1OA==",
      "updated_at" : "2020-03-03T04:46:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/593765658",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Sorry for all the line noise; I realized I forgot to add a continue, and then decided that I could DRY up the code a bit. I'm pretty happy with the final version, I think it's a bit easier to view because we don't treat update_it special from other iterators we walk (other than it not going into the cache line).\r\n\r\nI can squash this all down into one commit and replace #18120.",
      "created_at" : "2020-03-03T05:55:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#issuecomment-593781580",
      "id" : 593781580,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18191",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5Mzc4MTU4MA==",
      "updated_at" : "2020-03-03T05:55:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/593781580",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK.",
      "created_at" : "2020-03-29T17:43:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#issuecomment-605673033",
      "id" : 605673033,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18191",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwNTY3MzAzMw==",
      "updated_at" : "2020-03-29T17:43:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/605673033",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r399846953"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399846953"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm confused with \"... have already been checked against _excluded list_\". Which list?",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-29T20:10:36Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }\n         }\n+\n+        // finish loop here!\n+        if (next_idx_to_walk >= new_cache_line.size()) break;\n+\n+        // Prepare for next iteration:\n+        next_it = new_cache_line[next_idx_to_walk];\n+        ++next_idx_to_walk;\n+    } while (true);\n+\n+    // new_cache_line now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    // All entries in the new_cache_line have\n+    // already been checked against excluded list",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r399846953",
      "id" : 399846953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg0Njk1Mw==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 82,
      "path" : "src/txmempool.cpp",
      "position" : 82,
      "pull_request_review_id" : 383450072,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-29T20:10:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399846953",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r399892304"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399892304"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "mapMemPoolDescebdabtsToUpdate grows to contain the set of things to exclude while processing.\r\n\r\nPreviously this list was explicitly constructed, now it's implicit",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T02:02:59Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }\n         }\n+\n+        // finish loop here!\n+        if (next_idx_to_walk >= new_cache_line.size()) break;\n+\n+        // Prepare for next iteration:\n+        next_it = new_cache_line[next_idx_to_walk];\n+        ++next_idx_to_walk;\n+    } while (true);\n+\n+    // new_cache_line now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    // All entries in the new_cache_line have\n+    // already been checked against excluded list",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r399892304",
      "id" : 399892304,
      "in_reply_to_id" : 399846953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg5MjMwNA==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 82,
      "path" : "src/txmempool.cpp",
      "position" : 82,
      "pull_request_review_id" : 383491437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T02:02:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/399892304",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "IIUC, the first pass of the `do ... while (true);` loop just emplaces all of the direct descendants of `update_it` tx, i.e., its children, to the `new_cache_line`, and taints their `m_epoch`. All of the following loop passes process grand children, grand-grand children and so on. And two thing are confusing to me:\r\n\r\n1) the following comment: https://github.com/bitcoin/bitcoin/blob/32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a/src/txmempool.cpp#L79-L80\r\n\r\nI'd suggest to remove it completely.\r\n\r\n2) the following variable name: https://github.com/bitcoin/bitcoin/blob/32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a/src/txmempool.cpp#L87\r\n\r\nI'd suggest:\r\n- s/`cached_grand_children`/`cached_descendants`/\r\n- s/`grand_child_it`/`descendant_it`/\r\n- s/`the grand child`/`the descendant`/ in the comment\r\n\r\nEDIT: I realized, that you mean \"children\" and \"grandchildren\" relative to an element of the `new_cache_line`. So, ignore my suggestion (2).",
      "created_at" : "2020-03-30T08:41:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#issuecomment-605863701",
      "id" : 605863701,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18191",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwNTg2MzcwMQ==",
      "updated_at" : "2020-03-30T08:56:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/605863701",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400041234"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400041234"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Previously this list was explicitly constructed, now it's implicit\r\n\r\nYes. And the new logic does not apply any rule or list \"to exclude\" an element. It seems, the comments should avoid any \"excluding\" notions, and describe the logic in terms of \"including\" or \"conditional including\".",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T09:14:53Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }\n         }\n+\n+        // finish loop here!\n+        if (next_idx_to_walk >= new_cache_line.size()) break;\n+\n+        // Prepare for next iteration:\n+        next_it = new_cache_line[next_idx_to_walk];\n+        ++next_idx_to_walk;\n+    } while (true);\n+\n+    // new_cache_line now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    // All entries in the new_cache_line have\n+    // already been checked against excluded list",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400041234",
      "id" : 400041234,
      "in_reply_to_id" : 399846953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA0MTIzNA==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 82,
      "path" : "src/txmempool.cpp",
      "position" : 82,
      "pull_request_review_id" : 383667748,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T09:14:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400041234",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400057301"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400057301"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The internal loop seems redundant. Could this work:\r\n```\r\n    do {\r\n        for (const txiter child_it : GetMemPoolChildren(next_it)) {\r\n            if (visited(child_it)) continue;\r\n            new_cache_line.emplace_back(child_it);\r\n        }\r\n\r\n        // finish loop here!\r\n        if (next_idx_to_walk >= new_cache_line.size()) break;\r\n\r\n        // Prepare for next iteration:\r\n        next_it = new_cache_line[next_idx_to_walk];\r\n        ++next_idx_to_walk;\r\n    } while (true);\r\n```\r\n?\r\n\r\nUPDATED: ... or even\r\n```\r\n    txiter next_it = update_it;\r\n    for (size_t next_idx_to_walk = 0; next_idx_to_walk < new_cache_line.size(); ++next_idx_to_walk) {\r\n        for (const txiter child_it : GetMemPoolChildren(next_it)) {\r\n            if (visited(child_it)) continue;\r\n            new_cache_line.emplace_back(child_it);\r\n        }\r\n        next_it = new_cache_line[next_idx_to_walk];\r\n    }\r\n```",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T09:40:20Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400057301",
      "id" : 400057301,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA1NzMwMQ==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 65,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 383687369,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T10:14:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400057301",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400085843"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400085843"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why a new variable is needed? `child_it->GetTxSize()` and `child_it->GetModifiedFee()` seems to work well, no?",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T10:27:46Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }\n         }\n+\n+        // finish loop here!\n+        if (next_idx_to_walk >= new_cache_line.size()) break;\n+\n+        // Prepare for next iteration:\n+        next_it = new_cache_line[next_idx_to_walk];\n+        ++next_idx_to_walk;\n+    } while (true);\n+\n+    // new_cache_line now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    // All entries in the new_cache_line have\n+    // already been checked against excluded list\n+    for (txiter child_it : new_cache_line) {\n+        const CTxMemPoolEntry& child = *child_it;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400085843",
      "id" : 400085843,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDA4NTg0Mw==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 84,
      "path" : "src/txmempool.cpp",
      "position" : 84,
      "pull_request_review_id" : 383722330,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T10:27:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400085843",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400476700"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400476700"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "No because then we aren't using the cached traversal at all.\r\n\r\nIt could be correct, but has some algorithmic complexity blowups.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T20:34:29Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400476700",
      "id" : 400476700,
      "in_reply_to_id" : 400057301,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ3NjcwMA==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 65,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 384208947,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T20:34:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400476700",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400478978"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400478978"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It would work but I have a preference to access through a const ref where possible to avoid using non const APIs where not explicitly offered.\r\n\r\nNo performance overhead of this, it shouldn't even allocate a variable in the code.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T20:38:37Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }\n         }\n+\n+        // finish loop here!\n+        if (next_idx_to_walk >= new_cache_line.size()) break;\n+\n+        // Prepare for next iteration:\n+        next_it = new_cache_line[next_idx_to_walk];\n+        ++next_idx_to_walk;\n+    } while (true);\n+\n+    // new_cache_line now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    // All entries in the new_cache_line have\n+    // already been checked against excluded list\n+    for (txiter child_it : new_cache_line) {\n+        const CTxMemPoolEntry& child = *child_it;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400478978",
      "id" : 400478978,
      "in_reply_to_id" : 400085843,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ3ODk3OA==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 84,
      "path" : "src/txmempool.cpp",
      "position" : 84,
      "pull_request_review_id" : 384210609,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T20:38:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400478978",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400480589"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400480589"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "You update is still not using the cache lines....",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T20:41:41Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400480589",
      "id" : 400480589,
      "in_reply_to_id" : 400057301,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ4MDU4OQ==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 65,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 384213894,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T20:41:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400480589",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400494926"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400494926"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> It could be correct, but has some algorithmic complexity blowups.\r\n\r\nHow it could be, if every element is visited once only?",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T21:08:15Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400494926",
      "id" : 400494926,
      "in_reply_to_id" : 400057301,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQ5NDkyNg==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 65,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 384231611,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T21:08:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400494926",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400529948"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400529948"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm saying \"could be\" because I haven't bothered to actually check your code above for correctness, given the glaring issue that it doesn't use the caches which leads to unacceptable algorithmic complexity.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T22:22:18Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400529948",
      "id" : 400529948,
      "in_reply_to_id" : 400057301,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUyOTk0OA==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 65,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 384274377,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T22:22:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400529948",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400532152"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400532152"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Well the list does exist -- it's vHashesToUpdate. We just don't need to actually check or construct it because it's an implicit invariant held by the code.\r\n\r\nI can't comment on the semantic difference between excluding or conditional including, but it does seem that what we're doing is excluding.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T22:27:36Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }\n         }\n+\n+        // finish loop here!\n+        if (next_idx_to_walk >= new_cache_line.size()) break;\n+\n+        // Prepare for next iteration:\n+        next_it = new_cache_line[next_idx_to_walk];\n+        ++next_idx_to_walk;\n+    } while (true);\n+\n+    // new_cache_line now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    // All entries in the new_cache_line have\n+    // already been checked against excluded list",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400532152",
      "id" : 400532152,
      "in_reply_to_id" : 399846953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUzMjE1Mg==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 82,
      "path" : "src/txmempool.cpp",
      "position" : 82,
      "pull_request_review_id" : 384276918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T22:27:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400532152",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400532974"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400532974"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In any case this comment & the function comment serve to document what the expected invariant is for the caller, so I prefer to leave this comment.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-30T22:29:31Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }\n         }\n+\n+        // finish loop here!\n+        if (next_idx_to_walk >= new_cache_line.size()) break;\n+\n+        // Prepare for next iteration:\n+        next_it = new_cache_line[next_idx_to_walk];\n+        ++next_idx_to_walk;\n+    } while (true);\n+\n+    // new_cache_line now contains all in-mempool descendants of update_it,\n+    // compute updates now.\n+    int64_t modify_size = 0;\n+    CAmount modify_fee = 0;\n+    int64_t modify_count = 0;\n+    // All entries in the new_cache_line have\n+    // already been checked against excluded list",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400532974",
      "id" : 400532974,
      "in_reply_to_id" : 399846953,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUzMjk3NA==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 82,
      "path" : "src/txmempool.cpp",
      "position" : 82,
      "pull_request_review_id" : 384277819,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-30T22:29:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400532974",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400594651"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400594651"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I guess to pull up -- I do agree that the loop is a bit atypical in structure, but I do think that it's the most straightforward to reason about because it's pretty critical when certain checks or variable updates happen.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-31T01:46:11Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400594651",
      "id" : 400594651,
      "in_reply_to_id" : 400057301,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU5NDY1MQ==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 65,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 384348791,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-31T01:46:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400594651",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400781249"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400781249"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> \"... it doesn't use the caches...\"\r\n\r\nCorrected:\r\n```\r\n    txiter next_it = update_it;\r\n    for (size_t next_idx_to_walk = 0; next_idx_to_walk < new_cache_line.size(); ++next_idx_to_walk) {\r\n        for (const txiter child_it : GetMemPoolChildren(next_it)) {\r\n            if (visited(child_it)) continue;\r\n            if (cache.find(child_it) != cache.end()) continue;\r\n            new_cache_line.emplace_back(child_it);\r\n        }\r\n        next_it = new_cache_line[next_idx_to_walk];\r\n    }\r\n```",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-31T09:47:19Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r400781249",
      "id" : 400781249,
      "in_reply_to_id" : 400057301,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc4MTI0OQ==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 65,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 384570872,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-31T09:47:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/400781249",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r401181019"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/401181019"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "So now the code checks if there is a cache, and then continues... but you're now both not using the cache, and incorrect. If you find a cache line for a child then you must include all of it's cache entries into the new_cache_line otherwise a future call will skip updating descendants properly.\r\n\r\nThe code that is in the PR is (I believe) correct & does not have superfluous lines. If there was a good simplification of that logic I'd be for it, but I think that it already sort of is at the minimal correct form. There's not an extra internal loop to get rid of. ",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-03-31T20:05:10Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r401181019",
      "id" : 401181019,
      "in_reply_to_id" : 400057301,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTE4MTAxOQ==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_position" : 65,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 385063635,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "updated_at" : "2020-03-31T20:05:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/401181019",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r402878779"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/402878779"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Code in the PR passes the test from #18485. \r\nAll my suggestions fail the test.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-04-03T09:30:45Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {\n+                    if (visited(grand_child_it)) continue;\n+                    // place on the back and then swap into the next_idx_to_walk index\n+                    // so we don't walk it ourselves (whoever put the grand\n+                    // child in the cache must have already traversed this, so it must\n+                    // not be excluded)\n+                    new_cache_line.emplace_back(grand_child_it);\n+                    std::swap(new_cache_line[next_idx_to_walk], new_cache_line.back());\n+                    ++next_idx_to_walk;\n                 }\n-            } else if (!setAllDescendants.count(childEntry)) {\n+            } else {\n                 // Schedule for later processing\n-                stageEntries.insert(childEntry);\n+                // Element must not be excluded, or it would be in the cache already.\n+                new_cache_line.emplace_back(child_it);\n             }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r402878779",
      "id" : 402878779,
      "in_reply_to_id" : 400057301,
      "line" : 103,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3ODc3OQ==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_line" : 103,
      "original_position" : 65,
      "original_start_line" : 87,
      "path" : "src/txmempool.cpp",
      "position" : 65,
      "pull_request_review_id" : 387099072,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "side" : "RIGHT",
      "start_line" : 87,
      "start_side" : "RIGHT",
      "updated_at" : "2020-04-03T09:30:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/402878779",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429649340"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429649340"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n        for (const txiter& child_it : GetMemPoolChildren(next_it)) {\r\n```\r\n\r\nto avoid these compile warnings:\r\n```\r\ntxmempool.cpp:78:27: warning: loop variable 'child_it' of type 'const CTxMemPool::txiter' (aka 'const hashed_index_iterator<hashed_index_node<ordered_index_node<boost::multi_index::detail::null_augment_policy, ordered_index_node<boost::multi_index::detail::null_augment_policy, ordered_index_node<boost::multi_index::detail::null_augment_policy, index_node_base<CTxMemPoolEntry, std::allocator<CTxMemPoolEntry> > > > >, boost::multi_index::detail::hashed_unique_tag>, bucket_array<std::allocator<CTxMemPoolEntry> >, boost::multi_index::detail::hashed_index_global_iterator_tag>') creates a copy from type 'const CTxMemPool::txiter' [-Wrange-loop-analysis]\r\n        for (const txiter child_it : GetMemPoolChildren(next_it)) {\r\n                          ^\r\ntxmempool.cpp:78:14: note: use reference type 'const CTxMemPool::txiter &' (aka 'const hashed_index_iterator<hashed_index_node<ordered_index_node<boost::multi_index::detail::null_augment_policy, ordered_index_node<boost::multi_index::detail::null_augment_policy, ordered_index_node<boost::multi_index::detail::null_augment_policy, index_node_base<CTxMemPoolEntry, std::allocator<CTxMemPoolEntry> > > > >, boost::multi_index::detail::hashed_unique_tag>, bucket_array<std::allocator<CTxMemPoolEntry> >, boost::multi_index::detail::hashed_index_global_iterator_tag> &') to prevent copying\r\n        for (const txiter child_it : GetMemPoolChildren(next_it)) {\r\n```",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-05-24T15:44:52Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429649340",
      "id" : 429649340,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0OTM0MA==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_line" : 78,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 38,
      "pull_request_review_id" : 417369693,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-24T15:44:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429649340",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429649352"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429649352"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n                for (const txiter& grand_child_it : cached_grand_children->second) {\r\n```\r\n\r\nto avoid these compile warnings:\r\n```\r\ntxmempool.cpp:89:35: warning: loop variable 'grand_child_it' of type 'const CTxMemPool::txiter' (aka 'const hashed_index_iterator<hashed_index_node<ordered_index_node<boost::multi_index::detail::null_augment_policy, ordered_index_node<boost::multi_index::detail::null_augment_policy, ordered_index_node<boost::multi_index::detail::null_augment_policy, index_node_base<CTxMemPoolEntry, std::allocator<CTxMemPoolEntry> > > > >, boost::multi_index::detail::hashed_unique_tag>, bucket_array<std::allocator<CTxMemPoolEntry> >, boost::multi_index::detail::hashed_index_global_iterator_tag>') creates a copy from type 'const CTxMemPool::txiter' [-Wrange-loop-analysis]\r\n                for (const txiter grand_child_it : cached_grand_children->second) {\r\n                                  ^\r\ntxmempool.cpp:89:22: note: use reference type 'const CTxMemPool::txiter &' (aka 'const hashed_index_iterator<hashed_index_node<ordered_index_node<boost::multi_index::detail::null_augment_policy, ordered_index_node<boost::multi_index::detail::null_augment_policy, ordered_index_node<boost::multi_index::detail::null_augment_policy, index_node_base<CTxMemPoolEntry, std::allocator<CTxMemPoolEntry> > > > >, boost::multi_index::detail::hashed_unique_tag>, bucket_array<std::allocator<CTxMemPoolEntry> >, boost::multi_index::detail::hashed_index_global_iterator_tag> &') to prevent copying\r\n                for (const txiter grand_child_it : cached_grand_children->second) {\r\n```\r\n",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-05-24T15:44:56Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {\n+            // N.B. children can also be grand children, so guarding\n+            // here is neccessary\n+            if (visited(child_it)) continue;\n+            // if it exists in the cache, copy cached descendants\n+            // - All elements in cache are not excluded, no need to check when adding.\n+            // - All keys in the cache are already excluded, no need to add\n+            //   `child_it` to the new_cache_line (but not all excluded keys\n+            //   are in the cache yet!)\n+            cacheMap::iterator cached_grand_children = cache.find(child_it);\n+            if (cached_grand_children != cache.end()) {\n+                for (const txiter grand_child_it : cached_grand_children->second) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429649352",
      "id" : 429649352,
      "line" : 89,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY0OTM1Mg==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_line" : 89,
      "original_position" : 49,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 49,
      "pull_request_review_id" : 417369697,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-24T15:44:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429649352",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429650512"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429650512"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Suppose you compiled with clang?",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-05-24T15:57:10Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429650512",
      "id" : 429650512,
      "in_reply_to_id" : 429649340,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1MDUxMg==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_line" : 78,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 38,
      "pull_request_review_id" : 417370657,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-24T15:57:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429650512",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429652758"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429652758"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, this was a clang warning (I often compile with both gcc and clang for anything non-trivial as they seem to have complementary results).",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-05-24T16:23:56Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429652758",
      "id" : 429652758,
      "in_reply_to_id" : 429649340,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY1Mjc1OA==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_line" : 78,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 38,
      "pull_request_review_id" : 417372580,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-24T16:23:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429652758",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429673764"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429673764"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Hmm I think specifically we *do* want copying here because it's an iter, which in boost::multiindex should be just a pointer, so a reference to an iter implies extra unnecessary indirection?\r\n\r\n@sipa is probably most familiar with multiindex innards to know if this is correct.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-05-24T20:48:37Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429673764",
      "id" : 429673764,
      "in_reply_to_id" : 429649340,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3Mzc2NA==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_line" : 78,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 38,
      "pull_request_review_id" : 417390343,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-24T20:48:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429673764",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429675967"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429675967"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, `CTxMemPool::txiter` is just a single pointer, a copy would be desirable here.\r\n\r\nHowever, I suspect that the compiler will figure this out, and produce pretty much equal code for both.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-05-24T21:13:08Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429675967",
      "id" : 429675967,
      "in_reply_to_id" : 429649340,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3NTk2Nw==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_line" : 78,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 38,
      "pull_request_review_id" : 417392452,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-24T21:13:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429675967",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429678707"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429678707"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks sipa.\r\n\r\nMy preference is to leave the code as is if the behavior is correct & desirable (even if the compiler is likely to optimize out the indirection), as the warning seems to be just an aggressive warning from clang, unless a warning is excessively bad. The right solution seems to be to annotate somehow that txiter is a copyable type. How can this be done?",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-05-24T21:52:42Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429678707",
      "id" : 429678707,
      "in_reply_to_id" : 429649340,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3ODcwNw==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_line" : 78,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 38,
      "pull_request_review_id" : 417394920,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-24T21:52:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429678707",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429680012"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429680012"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It seems there are two solutions: not mark the loop variable const (if you want something mutable, a copy is needed anyway), or upgrade to clang 10.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-05-24T22:11:22Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429680012",
      "id" : 429680012,
      "in_reply_to_id" : 429649340,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY4MDAxMg==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_line" : 78,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 38,
      "pull_request_review_id" : 417396000,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-24T22:11:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429680012",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429680491"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429680491"
         }
      },
      "author_association" : "MEMBER",
      "body" : "FWIW, at -O2, clang 9 compiles both to the same code.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-05-24T22:17:38Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429680491",
      "id" : 429680491,
      "in_reply_to_id" : 429649340,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY4MDQ5MQ==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_line" : 78,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 38,
      "pull_request_review_id" : 417396432,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-24T22:17:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429680491",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429681119"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429681119"
         }
      },
      "author_association" : "MEMBER",
      "body" : "txiter is already const (it would be illegal to modify a mempool entry by the iterator). I don't think we write 'const txiter' anywhere",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-05-24T22:27:20Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429681119",
      "id" : 429681119,
      "in_reply_to_id" : 429649340,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY4MTExOQ==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_line" : 78,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 38,
      "pull_request_review_id" : 417397020,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-24T22:27:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429681119",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429681657"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429681657"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's a const_iterator. The `const` here just prevents modifying the txiter object, not what it points to. It's a vaguely sensible thing to do when you know a variable isn't going to be modified.",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-05-24T22:35:06Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429681657",
      "id" : 429681657,
      "in_reply_to_id" : 429649340,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY4MTY1Nw==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_line" : 78,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 38,
      "pull_request_review_id" : 417397518,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-24T22:35:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429681657",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429683092"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429683092"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "@MarcoFalke this is not quite true, it's perfectly legal to modify through the iterator via at least two means:\r\n\r\n1) Const cast -- the txiter is known to be non const *somewhere* so updating is fine\r\n2) Mutable fields -- the txiter epochs are mutable, same with the vtxhashesidx\r\n\r\nIn this case we are modifying the epochs via the mutable fields even though it's const.\r\n",
      "commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "created_at" : "2020-05-24T22:54:59Z",
      "diff_hunk" : "@@ -57,46 +57,75 @@ size_t CTxMemPoolEntry::GetTxSize() const\n // Update the given tx for any in-mempool descendants.\n // Assumes that setMemPoolChildren is correct for the given tx and all\n // descendants.\n-void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendants, const std::set<uint256> &setExclude)\n+void CTxMemPool::UpdateForDescendants(txiter update_it, cacheMap& cache)\n {\n-    setEntries stageEntries, setAllDescendants;\n-    stageEntries = GetMemPoolChildren(updateIt);\n-\n-    while (!stageEntries.empty()) {\n-        const txiter cit = *stageEntries.begin();\n-        setAllDescendants.insert(cit);\n-        stageEntries.erase(cit);\n-        const setEntries &setChildren = GetMemPoolChildren(cit);\n-        for (txiter childEntry : setChildren) {\n-            cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n-            if (cacheIt != cachedDescendants.end()) {\n-                // We've already calculated this one, just add the entries for this set\n-                // but don't traverse again.\n-                for (txiter cacheEntry : cacheIt->second) {\n-                    setAllDescendants.insert(cacheEntry);\n+    const auto epoch = GetFreshEpoch();\n+    // set up the new_cache_line to contain all of our transaction's children (note --\n+    // already de-duplicated in case multiple outputs of ours are spent in one\n+    // transaction).\n+    // Always creates a new cache line entry.\n+    vecEntries& new_cache_line = cache[update_it];\n+    assert(new_cache_line.empty());\n+    // next_idx_to_walk index keeps track of the elements that we've\n+    // already expanded.\n+    // Invariants:\n+    // If index is < next_idx_to_walk, we've already walked it.\n+    // If index is >= next_idx_to_walk, we need to walk it.\n+    // If next_idx_to_walk >= new_cache_line.size(), we're finished.\n+    size_t next_idx_to_walk = 0;\n+    txiter next_it = update_it;\n+    do {\n+        for (const txiter child_it : GetMemPoolChildren(next_it)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18191#discussion_r429683092",
      "id" : 429683092,
      "in_reply_to_id" : 429649340,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY4MzA5Mg==",
      "original_commit_id" : "32985d34a0a0cfd4ff8c4d96ff461778eaf72a8a",
      "original_line" : 78,
      "original_position" : 38,
      "original_start_line" : null,
      "path" : "src/txmempool.cpp",
      "position" : 38,
      "pull_request_review_id" : 417398761,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18191",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-05-24T22:54:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/429683092",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   }
]
