[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187078556"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187078556"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe add batch support?",
      "commit_id" : "84a3c730ce4c65890591ddc863c59d7dfc2339cb",
      "created_at" : "2018-05-09T15:24:18Z",
      "diff_hunk" : "@@ -271,3 +274,40 @@ void BCLog::Logger::ShrinkDebugFile()\n     else if (file != nullptr)\n         fclose(file);\n }\n+\n+namespace async_logging {\n+    using LogArgs = std::string;\n+    RingBuffer<LogArgs, 1024> log_buffer;\n+    std::unique_ptr<std::thread> flush_logs_thread;\n+    std::once_flag flush_logs_thread_started;\n+\n+    static void ConsumeLogs()\n+    {\n+        std::unique_ptr<LogArgs> next_log_line;\n+        while (next_log_line = log_buffer.PollForOne()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187078556",
      "id" : 187078556,
      "original_commit_id" : "f3f96027ebf05c267fb19e4bd37562c35dc025e3",
      "original_position" : 24,
      "path" : "src/logging.cpp",
      "position" : 24,
      "pull_request_review_id" : 118785692,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200",
      "updated_at" : "2018-05-10T18:37:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187078556",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK.\r\n\r\nMy thoughts on your open questions:\r\n\r\n- Do we want this behavior by default?\r\n[JN] Yes\r\n- Do we want to allow an opt-out configuration option that makes log processing synchronous again\r\n[JN] Yes\r\n- The ring buffer implementation allows either overwriting existing data or blocking when at full capacity. In the case of logging, I've set it to block and wait for capacity instead of dropping messages. Does this seem right?\r\n[JN] I think there are at least three options here:\r\n    1. overwrite existing data\r\n    2. drop new messages\r\n    3. block\r\nI'd go with (2), but push a final message to the ring buffer saying `Logging buffer full - dropping new log messages`, and then when the ring buffer is accepting messages again, push a message saying `Logging buffer accepting new messages`. That makes it very clear to anyone reading the log that messages were dropped between timestamp A and timestamp B.",
      "created_at" : "2018-05-09T15:32:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#issuecomment-387779854",
      "id" : 387779854,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13200",
      "updated_at" : "2018-05-09T15:32:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/387779854",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK!\r\n\r\nAgree with @jnewbery regarding the open questions.\r\n\r\nBenchmarks would be interesting.",
      "created_at" : "2018-05-09T17:48:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#issuecomment-387820199",
      "id" : 387820199,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13200",
      "updated_at" : "2018-05-09T17:48:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/387820199",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Wouldn't blocking be the status-quo and thus preferable for now?",
      "created_at" : "2018-05-09T18:17:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#issuecomment-387829283",
      "id" : 387829283,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13200",
      "updated_at" : "2018-05-09T18:17:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/387829283",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187192208"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187192208"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Do we really need the size type template parameter? Especially if you are passing an int through as a value. `size_t` makes more sense to me since std::array is size_t and signed sizes (int) also make no sense.",
      "commit_id" : "84a3c730ce4c65890591ddc863c59d7dfc2339cb",
      "created_at" : "2018-05-09T22:17:09Z",
      "diff_hunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RINGBUFFER_H\n+#define BITCOIN_RINGBUFFER_H\n+\n+#include <array>\n+#include <atomic>\n+#include <cassert>\n+#include <chrono>\n+#include <condition_variable>\n+#include <functional>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * A threadsafe circular buffer.\n+ *\n+ * Allows optional blocking behavior instead of overwriting when at capacity.\n+ */\n+template<typename ET, int S, typename ST=int>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187192208",
      "id" : 187192208,
      "original_commit_id" : "3c13cef1550f4a1f03d6f46119474aff658156b3",
      "original_position" : 23,
      "path" : "src/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 118924109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200",
      "updated_at" : "2018-05-10T18:37:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187192208",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6394033?v=4",
         "events_url" : "https://api.github.com/users/donaloconnor/events{/privacy}",
         "followers_url" : "https://api.github.com/users/donaloconnor/followers",
         "following_url" : "https://api.github.com/users/donaloconnor/following{/other_user}",
         "gists_url" : "https://api.github.com/users/donaloconnor/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/donaloconnor",
         "id" : 6394033,
         "login" : "donaloconnor",
         "organizations_url" : "https://api.github.com/users/donaloconnor/orgs",
         "received_events_url" : "https://api.github.com/users/donaloconnor/received_events",
         "repos_url" : "https://api.github.com/users/donaloconnor/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/donaloconnor/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/donaloconnor/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/donaloconnor"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187192592"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187192592"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "constexpr ? I guess inline helps some here.",
      "commit_id" : "84a3c730ce4c65890591ddc863c59d7dfc2339cb",
      "created_at" : "2018-05-09T22:19:09Z",
      "diff_hunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RINGBUFFER_H\n+#define BITCOIN_RINGBUFFER_H\n+\n+#include <array>\n+#include <atomic>\n+#include <cassert>\n+#include <chrono>\n+#include <condition_variable>\n+#include <functional>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * A threadsafe circular buffer.\n+ *\n+ * Allows optional blocking behavior instead of overwriting when at capacity.\n+ */\n+template<typename ET, int S, typename ST=int>\n+class RingBuffer\n+{\n+public:\n+    using value_type = ET;\n+    using size_type = ST;\n+\n+    RingBuffer() : m_size(0), m_insert_at_idx(0), m_read_at_idx(0), m_stop_waiting(false) { }\n+    ~RingBuffer() { }\n+\n+    /** @return the number of elements in the buffer. */\n+    inline size_type Size() const {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return m_size;\n+    }\n+    inline size_type MaxSize() const { return S; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187192592",
      "id" : 187192592,
      "original_commit_id" : "3c13cef1550f4a1f03d6f46119474aff658156b3",
      "original_position" : 38,
      "path" : "src/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 118924109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200",
      "updated_at" : "2018-05-10T18:37:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187192592",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6394033?v=4",
         "events_url" : "https://api.github.com/users/donaloconnor/events{/privacy}",
         "followers_url" : "https://api.github.com/users/donaloconnor/followers",
         "following_url" : "https://api.github.com/users/donaloconnor/following{/other_user}",
         "gists_url" : "https://api.github.com/users/donaloconnor/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/donaloconnor",
         "id" : 6394033,
         "login" : "donaloconnor",
         "organizations_url" : "https://api.github.com/users/donaloconnor/orgs",
         "received_events_url" : "https://api.github.com/users/donaloconnor/received_events",
         "repos_url" : "https://api.github.com/users/donaloconnor/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/donaloconnor/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/donaloconnor/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/donaloconnor"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187193169"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187193169"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "it doesn't make sense why having these (`m_insert_at_idx`and `m_read_at_idx`) as std::atomic is necessary if they are protected by the mutex",
      "commit_id" : "84a3c730ce4c65890591ddc863c59d7dfc2339cb",
      "created_at" : "2018-05-09T22:22:18Z",
      "diff_hunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RINGBUFFER_H\n+#define BITCOIN_RINGBUFFER_H\n+\n+#include <array>\n+#include <atomic>\n+#include <cassert>\n+#include <chrono>\n+#include <condition_variable>\n+#include <functional>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * A threadsafe circular buffer.\n+ *\n+ * Allows optional blocking behavior instead of overwriting when at capacity.\n+ */\n+template<typename ET, int S, typename ST=int>\n+class RingBuffer\n+{\n+public:\n+    using value_type = ET;\n+    using size_type = ST;\n+\n+    RingBuffer() : m_size(0), m_insert_at_idx(0), m_read_at_idx(0), m_stop_waiting(false) { }\n+    ~RingBuffer() { }\n+\n+    /** @return the number of elements in the buffer. */\n+    inline size_type Size() const {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return m_size;\n+    }\n+    inline size_type MaxSize() const { return S; }\n+\n+    value_type PopFront()\n+    {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return AssumeLockedPopFront();\n+    }\n+\n+    /**\n+     * Push an element into the buffer.\n+     *\n+     * @arg no_overwrite  If true, block and wait to write instead of overwriting existing data.\n+     */\n+    size_type PushBack(value_type v, bool no_overwrite = true)\n+    {\n+        std::unique_lock<std::mutex> lock(m_lock);\n+        if (no_overwrite && m_size == S) {\n+            m_read_condvar.wait(lock, [this]() { return this->m_size < S; });\n+        }\n+        m_buffer[m_insert_at_idx] = v;\n+\n+        // We're overwriting existing data, so increment the read index too.\n+        if (m_size > 0 && m_insert_at_idx == m_read_at_idx) m_read_at_idx = IncrementIdx(m_read_at_idx);\n+        if (m_size < S) ++m_size;\n+        m_insert_at_idx = IncrementIdx(m_insert_at_idx);\n+\n+        return m_size;\n+    }\n+\n+    /** Interrupt anyone waiting for reads. */\n+    void SignalStopWaiting() {\n+        m_stop_waiting.store(true);\n+    }\n+\n+    /**\n+     * Block until the buffer has content to process, polling periodically, and\n+     * then return a pointer to an element. Allow interrupts by using SignalStopWaiting().\n+     *\n+     * @return false if the poll was interrupted without executing func.\n+     */\n+    std::unique_ptr<value_type> PollForOne(int poll_interval_ms = 200)\n+    {\n+        while (!m_stop_waiting.load()) {\n+            {\n+                std::unique_lock<std::mutex> lock(m_lock);\n+                if (m_size > 0) {\n+                    return std::unique_ptr<value_type>(new value_type(AssumeLockedPopFront()));\n+                }\n+            }\n+            std::this_thread::sleep_for(std::chrono::milliseconds(poll_interval_ms));\n+        }\n+        return nullptr;\n+    }\n+\n+    /** @return all values currently in the buffer after popping them. */\n+    std::vector<value_type> PopAll()\n+    {\n+        std::unique_lock<std::mutex> lock(m_lock);\n+        std::vector<value_type> values;\n+\n+        while (m_size > 0 && m_read_at_idx != m_insert_at_idx) {\n+            values.push_back(AssumeLockedPopFront());\n+        }\n+        return std::move(values);\n+    }\n+\n+private:\n+    std::array<value_type, S> m_buffer;\n+\n+    /** Number of elements in the buffer. */\n+    size_type m_size;\n+\n+    /** Index at which the next insertion will happen. */\n+    std::atomic<ST> m_insert_at_idx;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187193169",
      "id" : 187193169,
      "original_commit_id" : "3c13cef1550f4a1f03d6f46119474aff658156b3",
      "original_position" : 111,
      "path" : "src/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 118924109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200",
      "updated_at" : "2018-05-10T18:37:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187193169",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6394033?v=4",
         "events_url" : "https://api.github.com/users/donaloconnor/events{/privacy}",
         "followers_url" : "https://api.github.com/users/donaloconnor/followers",
         "following_url" : "https://api.github.com/users/donaloconnor/following{/other_user}",
         "gists_url" : "https://api.github.com/users/donaloconnor/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/donaloconnor",
         "id" : 6394033,
         "login" : "donaloconnor",
         "organizations_url" : "https://api.github.com/users/donaloconnor/orgs",
         "received_events_url" : "https://api.github.com/users/donaloconnor/received_events",
         "repos_url" : "https://api.github.com/users/donaloconnor/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/donaloconnor/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/donaloconnor/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/donaloconnor"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187193683"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187193683"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "if the object is movable it will be moved and the value will be empty already but if it's not movable and it's copied then I guess there's no big deal letting the data present? Seems unnecessary to construct an empty object in a free slot again.",
      "commit_id" : "84a3c730ce4c65890591ddc863c59d7dfc2339cb",
      "created_at" : "2018-05-09T22:25:00Z",
      "diff_hunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RINGBUFFER_H\n+#define BITCOIN_RINGBUFFER_H\n+\n+#include <array>\n+#include <atomic>\n+#include <cassert>\n+#include <chrono>\n+#include <condition_variable>\n+#include <functional>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * A threadsafe circular buffer.\n+ *\n+ * Allows optional blocking behavior instead of overwriting when at capacity.\n+ */\n+template<typename ET, int S, typename ST=int>\n+class RingBuffer\n+{\n+public:\n+    using value_type = ET;\n+    using size_type = ST;\n+\n+    RingBuffer() : m_size(0), m_insert_at_idx(0), m_read_at_idx(0), m_stop_waiting(false) { }\n+    ~RingBuffer() { }\n+\n+    /** @return the number of elements in the buffer. */\n+    inline size_type Size() const {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return m_size;\n+    }\n+    inline size_type MaxSize() const { return S; }\n+\n+    value_type PopFront()\n+    {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return AssumeLockedPopFront();\n+    }\n+\n+    /**\n+     * Push an element into the buffer.\n+     *\n+     * @arg no_overwrite  If true, block and wait to write instead of overwriting existing data.\n+     */\n+    size_type PushBack(value_type v, bool no_overwrite = true)\n+    {\n+        std::unique_lock<std::mutex> lock(m_lock);\n+        if (no_overwrite && m_size == S) {\n+            m_read_condvar.wait(lock, [this]() { return this->m_size < S; });\n+        }\n+        m_buffer[m_insert_at_idx] = v;\n+\n+        // We're overwriting existing data, so increment the read index too.\n+        if (m_size > 0 && m_insert_at_idx == m_read_at_idx) m_read_at_idx = IncrementIdx(m_read_at_idx);\n+        if (m_size < S) ++m_size;\n+        m_insert_at_idx = IncrementIdx(m_insert_at_idx);\n+\n+        return m_size;\n+    }\n+\n+    /** Interrupt anyone waiting for reads. */\n+    void SignalStopWaiting() {\n+        m_stop_waiting.store(true);\n+    }\n+\n+    /**\n+     * Block until the buffer has content to process, polling periodically, and\n+     * then return a pointer to an element. Allow interrupts by using SignalStopWaiting().\n+     *\n+     * @return false if the poll was interrupted without executing func.\n+     */\n+    std::unique_ptr<value_type> PollForOne(int poll_interval_ms = 200)\n+    {\n+        while (!m_stop_waiting.load()) {\n+            {\n+                std::unique_lock<std::mutex> lock(m_lock);\n+                if (m_size > 0) {\n+                    return std::unique_ptr<value_type>(new value_type(AssumeLockedPopFront()));\n+                }\n+            }\n+            std::this_thread::sleep_for(std::chrono::milliseconds(poll_interval_ms));\n+        }\n+        return nullptr;\n+    }\n+\n+    /** @return all values currently in the buffer after popping them. */\n+    std::vector<value_type> PopAll()\n+    {\n+        std::unique_lock<std::mutex> lock(m_lock);\n+        std::vector<value_type> values;\n+\n+        while (m_size > 0 && m_read_at_idx != m_insert_at_idx) {\n+            values.push_back(AssumeLockedPopFront());\n+        }\n+        return std::move(values);\n+    }\n+\n+private:\n+    std::array<value_type, S> m_buffer;\n+\n+    /** Number of elements in the buffer. */\n+    size_type m_size;\n+\n+    /** Index at which the next insertion will happen. */\n+    std::atomic<ST> m_insert_at_idx;\n+\n+    /** Index of the next element to read. */\n+    std::atomic<ST> m_read_at_idx;\n+\n+    /** Set to signal that we should stop waiting for elements in, e.g., PollForOne(). */\n+    std::atomic<bool> m_stop_waiting;\n+\n+    /** Notifies when a read has happened. */\n+    std::condition_variable m_read_condvar;\n+\n+    /** Protects access to m_buffer, m_size, m_insert_at_idx, m_read_at_idx. */\n+    mutable std::mutex m_lock;\n+\n+    /**\n+     * Pop an element off the front of the buffer and return it. Assumes caller\n+     * holds m_lock.\n+     */\n+    value_type AssumeLockedPopFront()\n+    {\n+        assert(m_size > 0);\n+\n+        value_type data = std::move(m_buffer[m_read_at_idx]);\n+        m_buffer[m_read_at_idx] = value_type();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187193683",
      "id" : 187193683,
      "original_commit_id" : "3c13cef1550f4a1f03d6f46119474aff658156b3",
      "original_position" : 134,
      "path" : "src/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 118924109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200",
      "updated_at" : "2018-05-10T18:37:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187193683",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6394033?v=4",
         "events_url" : "https://api.github.com/users/donaloconnor/events{/privacy}",
         "followers_url" : "https://api.github.com/users/donaloconnor/followers",
         "following_url" : "https://api.github.com/users/donaloconnor/following{/other_user}",
         "gists_url" : "https://api.github.com/users/donaloconnor/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/donaloconnor",
         "id" : 6394033,
         "login" : "donaloconnor",
         "organizations_url" : "https://api.github.com/users/donaloconnor/orgs",
         "received_events_url" : "https://api.github.com/users/donaloconnor/received_events",
         "repos_url" : "https://api.github.com/users/donaloconnor/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/donaloconnor/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/donaloconnor/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/donaloconnor"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187194522"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187194522"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think having a move version of PushBack with const v& ref push back would make more sense to avoid unnecessary copying.\r\n`PushBack(value_type&& v)` and `PushBack(const value_type& v)` ",
      "commit_id" : "84a3c730ce4c65890591ddc863c59d7dfc2339cb",
      "created_at" : "2018-05-09T22:28:50Z",
      "diff_hunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RINGBUFFER_H\n+#define BITCOIN_RINGBUFFER_H\n+\n+#include <array>\n+#include <atomic>\n+#include <cassert>\n+#include <chrono>\n+#include <condition_variable>\n+#include <functional>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * A threadsafe circular buffer.\n+ *\n+ * Allows optional blocking behavior instead of overwriting when at capacity.\n+ */\n+template<typename ET, int S, typename ST=int>\n+class RingBuffer\n+{\n+public:\n+    using value_type = ET;\n+    using size_type = ST;\n+\n+    RingBuffer() : m_size(0), m_insert_at_idx(0), m_read_at_idx(0), m_stop_waiting(false) { }\n+    ~RingBuffer() { }\n+\n+    /** @return the number of elements in the buffer. */\n+    inline size_type Size() const {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return m_size;\n+    }\n+    inline size_type MaxSize() const { return S; }\n+\n+    value_type PopFront()\n+    {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return AssumeLockedPopFront();\n+    }\n+\n+    /**\n+     * Push an element into the buffer.\n+     *\n+     * @arg no_overwrite  If true, block and wait to write instead of overwriting existing data.\n+     */\n+    size_type PushBack(value_type v, bool no_overwrite = true)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187194522",
      "id" : 187194522,
      "original_commit_id" : "3c13cef1550f4a1f03d6f46119474aff658156b3",
      "original_position" : 51,
      "path" : "src/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 118924109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200",
      "updated_at" : "2018-05-10T18:37:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187194522",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6394033?v=4",
         "events_url" : "https://api.github.com/users/donaloconnor/events{/privacy}",
         "followers_url" : "https://api.github.com/users/donaloconnor/followers",
         "following_url" : "https://api.github.com/users/donaloconnor/following{/other_user}",
         "gists_url" : "https://api.github.com/users/donaloconnor/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/donaloconnor",
         "id" : 6394033,
         "login" : "donaloconnor",
         "organizations_url" : "https://api.github.com/users/donaloconnor/orgs",
         "received_events_url" : "https://api.github.com/users/donaloconnor/received_events",
         "repos_url" : "https://api.github.com/users/donaloconnor/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/donaloconnor/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/donaloconnor/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/donaloconnor"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187197537"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187197537"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`LogArgs& s` to avoid copies",
      "commit_id" : "84a3c730ce4c65890591ddc863c59d7dfc2339cb",
      "created_at" : "2018-05-09T22:45:26Z",
      "diff_hunk" : "@@ -271,3 +274,40 @@ void BCLog::Logger::ShrinkDebugFile()\n     else if (file != nullptr)\n         fclose(file);\n }\n+\n+namespace async_logging {\n+    using LogArgs = std::string;\n+    RingBuffer<LogArgs, 1024> log_buffer;\n+    std::unique_ptr<std::thread> flush_logs_thread;\n+    std::once_flag flush_logs_thread_started;\n+\n+    static void ConsumeLogs()\n+    {\n+        std::unique_ptr<LogArgs> next_log_line;\n+        while (next_log_line = log_buffer.PollForOne()) {\n+            g_logger->LogPrintStr(*next_log_line);\n+        }\n+    }\n+\n+    void FlushAll()\n+    {\n+        for (LogArgs s : log_buffer.PopAll()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187197537",
      "id" : 187197537,
      "original_commit_id" : "4e8af464b39e23ce048c37d85d471dd5a8685ba1",
      "original_position" : 31,
      "path" : "src/logging.cpp",
      "position" : null,
      "pull_request_review_id" : 118924109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200",
      "updated_at" : "2018-05-10T18:37:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187197537",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6394033?v=4",
         "events_url" : "https://api.github.com/users/donaloconnor/events{/privacy}",
         "followers_url" : "https://api.github.com/users/donaloconnor/followers",
         "following_url" : "https://api.github.com/users/donaloconnor/following{/other_user}",
         "gists_url" : "https://api.github.com/users/donaloconnor/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/donaloconnor",
         "id" : 6394033,
         "login" : "donaloconnor",
         "organizations_url" : "https://api.github.com/users/donaloconnor/orgs",
         "received_events_url" : "https://api.github.com/users/donaloconnor/received_events",
         "repos_url" : "https://api.github.com/users/donaloconnor/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/donaloconnor/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/donaloconnor/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/donaloconnor"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187199539"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187199539"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I feel we should use dynamic/heap memory for this for the following reasons:\r\n\r\n1. This is only allocated once on start up and is of fixed size.\r\n2. Passing a large value to this array can potentially have 2 problems:\r\n   1. In the stack it can overflow (if used later by someone else)\r\n   2. In global/static data it will grow the executable size. \r\n\r\nAnyway just what I feel. Maybe std::array is okay in this case though. I'm just imagining uses of this class further down the line ",
      "commit_id" : "84a3c730ce4c65890591ddc863c59d7dfc2339cb",
      "created_at" : "2018-05-09T22:57:46Z",
      "diff_hunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RINGBUFFER_H\n+#define BITCOIN_RINGBUFFER_H\n+\n+#include <array>\n+#include <atomic>\n+#include <cassert>\n+#include <chrono>\n+#include <condition_variable>\n+#include <functional>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * A threadsafe circular buffer.\n+ *\n+ * Allows optional blocking behavior instead of overwriting when at capacity.\n+ */\n+template<typename ET, int S, typename ST=int>\n+class RingBuffer\n+{\n+public:\n+    using value_type = ET;\n+    using size_type = ST;\n+\n+    RingBuffer() : m_size(0), m_insert_at_idx(0), m_read_at_idx(0), m_stop_waiting(false) { }\n+    ~RingBuffer() { }\n+\n+    /** @return the number of elements in the buffer. */\n+    inline size_type Size() const {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return m_size;\n+    }\n+    inline size_type MaxSize() const { return S; }\n+\n+    value_type PopFront()\n+    {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return AssumeLockedPopFront();\n+    }\n+\n+    /**\n+     * Push an element into the buffer.\n+     *\n+     * @arg no_overwrite  If true, block and wait to write instead of overwriting existing data.\n+     */\n+    size_type PushBack(value_type v, bool no_overwrite = true)\n+    {\n+        std::unique_lock<std::mutex> lock(m_lock);\n+        if (no_overwrite && m_size == S) {\n+            m_read_condvar.wait(lock, [this]() { return this->m_size < S; });\n+        }\n+        m_buffer[m_insert_at_idx] = v;\n+\n+        // We're overwriting existing data, so increment the read index too.\n+        if (m_size > 0 && m_insert_at_idx == m_read_at_idx) m_read_at_idx = IncrementIdx(m_read_at_idx);\n+        if (m_size < S) ++m_size;\n+        m_insert_at_idx = IncrementIdx(m_insert_at_idx);\n+\n+        return m_size;\n+    }\n+\n+    /** Interrupt anyone waiting for reads. */\n+    void SignalStopWaiting() {\n+        m_stop_waiting.store(true);\n+    }\n+\n+    /**\n+     * Block until the buffer has content to process, polling periodically, and\n+     * then return a pointer to an element. Allow interrupts by using SignalStopWaiting().\n+     *\n+     * @return false if the poll was interrupted without executing func.\n+     */\n+    std::unique_ptr<value_type> PollForOne(int poll_interval_ms = 200)\n+    {\n+        while (!m_stop_waiting.load()) {\n+            {\n+                std::unique_lock<std::mutex> lock(m_lock);\n+                if (m_size > 0) {\n+                    return std::unique_ptr<value_type>(new value_type(AssumeLockedPopFront()));\n+                }\n+            }\n+            std::this_thread::sleep_for(std::chrono::milliseconds(poll_interval_ms));\n+        }\n+        return nullptr;\n+    }\n+\n+    /** @return all values currently in the buffer after popping them. */\n+    std::vector<value_type> PopAll()\n+    {\n+        std::unique_lock<std::mutex> lock(m_lock);\n+        std::vector<value_type> values;\n+\n+        while (m_size > 0 && m_read_at_idx != m_insert_at_idx) {\n+            values.push_back(AssumeLockedPopFront());\n+        }\n+        return std::move(values);\n+    }\n+\n+private:\n+    std::array<value_type, S> m_buffer;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187199539",
      "id" : 187199539,
      "original_commit_id" : "4e8af464b39e23ce048c37d85d471dd5a8685ba1",
      "original_position" : 105,
      "path" : "src/ringbuffer.h",
      "position" : 104,
      "pull_request_review_id" : 118924109,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200",
      "updated_at" : "2018-05-10T18:37:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187199539",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6394033?v=4",
         "events_url" : "https://api.github.com/users/donaloconnor/events{/privacy}",
         "followers_url" : "https://api.github.com/users/donaloconnor/followers",
         "following_url" : "https://api.github.com/users/donaloconnor/following{/other_user}",
         "gists_url" : "https://api.github.com/users/donaloconnor/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/donaloconnor",
         "id" : 6394033,
         "login" : "donaloconnor",
         "organizations_url" : "https://api.github.com/users/donaloconnor/orgs",
         "received_events_url" : "https://api.github.com/users/donaloconnor/received_events",
         "repos_url" : "https://api.github.com/users/donaloconnor/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/donaloconnor/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/donaloconnor/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/donaloconnor"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187394393"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187394393"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good catch. Shouldn't `const value_type&` bind to both rvalues and lvalues, though?",
      "commit_id" : "84a3c730ce4c65890591ddc863c59d7dfc2339cb",
      "created_at" : "2018-05-10T17:07:29Z",
      "diff_hunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RINGBUFFER_H\n+#define BITCOIN_RINGBUFFER_H\n+\n+#include <array>\n+#include <atomic>\n+#include <cassert>\n+#include <chrono>\n+#include <condition_variable>\n+#include <functional>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * A threadsafe circular buffer.\n+ *\n+ * Allows optional blocking behavior instead of overwriting when at capacity.\n+ */\n+template<typename ET, int S, typename ST=int>\n+class RingBuffer\n+{\n+public:\n+    using value_type = ET;\n+    using size_type = ST;\n+\n+    RingBuffer() : m_size(0), m_insert_at_idx(0), m_read_at_idx(0), m_stop_waiting(false) { }\n+    ~RingBuffer() { }\n+\n+    /** @return the number of elements in the buffer. */\n+    inline size_type Size() const {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return m_size;\n+    }\n+    inline size_type MaxSize() const { return S; }\n+\n+    value_type PopFront()\n+    {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return AssumeLockedPopFront();\n+    }\n+\n+    /**\n+     * Push an element into the buffer.\n+     *\n+     * @arg no_overwrite  If true, block and wait to write instead of overwriting existing data.\n+     */\n+    size_type PushBack(value_type v, bool no_overwrite = true)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187394393",
      "id" : 187394393,
      "in_reply_to_id" : 187194522,
      "original_commit_id" : "3c13cef1550f4a1f03d6f46119474aff658156b3",
      "original_position" : 51,
      "path" : "src/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 119167054,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200",
      "updated_at" : "2018-05-10T18:37:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187394393",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187423121"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187423121"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yep, agree. Fixed.",
      "commit_id" : "84a3c730ce4c65890591ddc863c59d7dfc2339cb",
      "created_at" : "2018-05-10T18:47:14Z",
      "diff_hunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RINGBUFFER_H\n+#define BITCOIN_RINGBUFFER_H\n+\n+#include <array>\n+#include <atomic>\n+#include <cassert>\n+#include <chrono>\n+#include <condition_variable>\n+#include <functional>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * A threadsafe circular buffer.\n+ *\n+ * Allows optional blocking behavior instead of overwriting when at capacity.\n+ */\n+template<typename ET, int S, typename ST=int>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187423121",
      "id" : 187423121,
      "in_reply_to_id" : 187192208,
      "original_commit_id" : "3c13cef1550f4a1f03d6f46119474aff658156b3",
      "original_position" : 23,
      "path" : "src/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 119202230,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200",
      "updated_at" : "2018-05-10T18:47:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187423121",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187423152"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187423152"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "84a3c730ce4c65890591ddc863c59d7dfc2339cb",
      "created_at" : "2018-05-10T18:47:20Z",
      "diff_hunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RINGBUFFER_H\n+#define BITCOIN_RINGBUFFER_H\n+\n+#include <array>\n+#include <atomic>\n+#include <cassert>\n+#include <chrono>\n+#include <condition_variable>\n+#include <functional>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * A threadsafe circular buffer.\n+ *\n+ * Allows optional blocking behavior instead of overwriting when at capacity.\n+ */\n+template<typename ET, int S, typename ST=int>\n+class RingBuffer\n+{\n+public:\n+    using value_type = ET;\n+    using size_type = ST;\n+\n+    RingBuffer() : m_size(0), m_insert_at_idx(0), m_read_at_idx(0), m_stop_waiting(false) { }\n+    ~RingBuffer() { }\n+\n+    /** @return the number of elements in the buffer. */\n+    inline size_type Size() const {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return m_size;\n+    }\n+    inline size_type MaxSize() const { return S; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187423152",
      "id" : 187423152,
      "in_reply_to_id" : 187192592,
      "original_commit_id" : "3c13cef1550f4a1f03d6f46119474aff658156b3",
      "original_position" : 38,
      "path" : "src/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 119202274,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200",
      "updated_at" : "2018-05-10T18:47:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187423152",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187423208"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187423208"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good point, fixed.",
      "commit_id" : "84a3c730ce4c65890591ddc863c59d7dfc2339cb",
      "created_at" : "2018-05-10T18:47:28Z",
      "diff_hunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RINGBUFFER_H\n+#define BITCOIN_RINGBUFFER_H\n+\n+#include <array>\n+#include <atomic>\n+#include <cassert>\n+#include <chrono>\n+#include <condition_variable>\n+#include <functional>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * A threadsafe circular buffer.\n+ *\n+ * Allows optional blocking behavior instead of overwriting when at capacity.\n+ */\n+template<typename ET, int S, typename ST=int>\n+class RingBuffer\n+{\n+public:\n+    using value_type = ET;\n+    using size_type = ST;\n+\n+    RingBuffer() : m_size(0), m_insert_at_idx(0), m_read_at_idx(0), m_stop_waiting(false) { }\n+    ~RingBuffer() { }\n+\n+    /** @return the number of elements in the buffer. */\n+    inline size_type Size() const {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return m_size;\n+    }\n+    inline size_type MaxSize() const { return S; }\n+\n+    value_type PopFront()\n+    {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return AssumeLockedPopFront();\n+    }\n+\n+    /**\n+     * Push an element into the buffer.\n+     *\n+     * @arg no_overwrite  If true, block and wait to write instead of overwriting existing data.\n+     */\n+    size_type PushBack(value_type v, bool no_overwrite = true)\n+    {\n+        std::unique_lock<std::mutex> lock(m_lock);\n+        if (no_overwrite && m_size == S) {\n+            m_read_condvar.wait(lock, [this]() { return this->m_size < S; });\n+        }\n+        m_buffer[m_insert_at_idx] = v;\n+\n+        // We're overwriting existing data, so increment the read index too.\n+        if (m_size > 0 && m_insert_at_idx == m_read_at_idx) m_read_at_idx = IncrementIdx(m_read_at_idx);\n+        if (m_size < S) ++m_size;\n+        m_insert_at_idx = IncrementIdx(m_insert_at_idx);\n+\n+        return m_size;\n+    }\n+\n+    /** Interrupt anyone waiting for reads. */\n+    void SignalStopWaiting() {\n+        m_stop_waiting.store(true);\n+    }\n+\n+    /**\n+     * Block until the buffer has content to process, polling periodically, and\n+     * then return a pointer to an element. Allow interrupts by using SignalStopWaiting().\n+     *\n+     * @return false if the poll was interrupted without executing func.\n+     */\n+    std::unique_ptr<value_type> PollForOne(int poll_interval_ms = 200)\n+    {\n+        while (!m_stop_waiting.load()) {\n+            {\n+                std::unique_lock<std::mutex> lock(m_lock);\n+                if (m_size > 0) {\n+                    return std::unique_ptr<value_type>(new value_type(AssumeLockedPopFront()));\n+                }\n+            }\n+            std::this_thread::sleep_for(std::chrono::milliseconds(poll_interval_ms));\n+        }\n+        return nullptr;\n+    }\n+\n+    /** @return all values currently in the buffer after popping them. */\n+    std::vector<value_type> PopAll()\n+    {\n+        std::unique_lock<std::mutex> lock(m_lock);\n+        std::vector<value_type> values;\n+\n+        while (m_size > 0 && m_read_at_idx != m_insert_at_idx) {\n+            values.push_back(AssumeLockedPopFront());\n+        }\n+        return std::move(values);\n+    }\n+\n+private:\n+    std::array<value_type, S> m_buffer;\n+\n+    /** Number of elements in the buffer. */\n+    size_type m_size;\n+\n+    /** Index at which the next insertion will happen. */\n+    std::atomic<ST> m_insert_at_idx;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187423208",
      "id" : 187423208,
      "in_reply_to_id" : 187193169,
      "original_commit_id" : "3c13cef1550f4a1f03d6f46119474aff658156b3",
      "original_position" : 111,
      "path" : "src/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 119202339,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200",
      "updated_at" : "2018-05-10T18:47:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187423208",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187423274"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187423274"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree, fixed.",
      "commit_id" : "84a3c730ce4c65890591ddc863c59d7dfc2339cb",
      "created_at" : "2018-05-10T18:47:39Z",
      "diff_hunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RINGBUFFER_H\n+#define BITCOIN_RINGBUFFER_H\n+\n+#include <array>\n+#include <atomic>\n+#include <cassert>\n+#include <chrono>\n+#include <condition_variable>\n+#include <functional>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * A threadsafe circular buffer.\n+ *\n+ * Allows optional blocking behavior instead of overwriting when at capacity.\n+ */\n+template<typename ET, int S, typename ST=int>\n+class RingBuffer\n+{\n+public:\n+    using value_type = ET;\n+    using size_type = ST;\n+\n+    RingBuffer() : m_size(0), m_insert_at_idx(0), m_read_at_idx(0), m_stop_waiting(false) { }\n+    ~RingBuffer() { }\n+\n+    /** @return the number of elements in the buffer. */\n+    inline size_type Size() const {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return m_size;\n+    }\n+    inline size_type MaxSize() const { return S; }\n+\n+    value_type PopFront()\n+    {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return AssumeLockedPopFront();\n+    }\n+\n+    /**\n+     * Push an element into the buffer.\n+     *\n+     * @arg no_overwrite  If true, block and wait to write instead of overwriting existing data.\n+     */\n+    size_type PushBack(value_type v, bool no_overwrite = true)\n+    {\n+        std::unique_lock<std::mutex> lock(m_lock);\n+        if (no_overwrite && m_size == S) {\n+            m_read_condvar.wait(lock, [this]() { return this->m_size < S; });\n+        }\n+        m_buffer[m_insert_at_idx] = v;\n+\n+        // We're overwriting existing data, so increment the read index too.\n+        if (m_size > 0 && m_insert_at_idx == m_read_at_idx) m_read_at_idx = IncrementIdx(m_read_at_idx);\n+        if (m_size < S) ++m_size;\n+        m_insert_at_idx = IncrementIdx(m_insert_at_idx);\n+\n+        return m_size;\n+    }\n+\n+    /** Interrupt anyone waiting for reads. */\n+    void SignalStopWaiting() {\n+        m_stop_waiting.store(true);\n+    }\n+\n+    /**\n+     * Block until the buffer has content to process, polling periodically, and\n+     * then return a pointer to an element. Allow interrupts by using SignalStopWaiting().\n+     *\n+     * @return false if the poll was interrupted without executing func.\n+     */\n+    std::unique_ptr<value_type> PollForOne(int poll_interval_ms = 200)\n+    {\n+        while (!m_stop_waiting.load()) {\n+            {\n+                std::unique_lock<std::mutex> lock(m_lock);\n+                if (m_size > 0) {\n+                    return std::unique_ptr<value_type>(new value_type(AssumeLockedPopFront()));\n+                }\n+            }\n+            std::this_thread::sleep_for(std::chrono::milliseconds(poll_interval_ms));\n+        }\n+        return nullptr;\n+    }\n+\n+    /** @return all values currently in the buffer after popping them. */\n+    std::vector<value_type> PopAll()\n+    {\n+        std::unique_lock<std::mutex> lock(m_lock);\n+        std::vector<value_type> values;\n+\n+        while (m_size > 0 && m_read_at_idx != m_insert_at_idx) {\n+            values.push_back(AssumeLockedPopFront());\n+        }\n+        return std::move(values);\n+    }\n+\n+private:\n+    std::array<value_type, S> m_buffer;\n+\n+    /** Number of elements in the buffer. */\n+    size_type m_size;\n+\n+    /** Index at which the next insertion will happen. */\n+    std::atomic<ST> m_insert_at_idx;\n+\n+    /** Index of the next element to read. */\n+    std::atomic<ST> m_read_at_idx;\n+\n+    /** Set to signal that we should stop waiting for elements in, e.g., PollForOne(). */\n+    std::atomic<bool> m_stop_waiting;\n+\n+    /** Notifies when a read has happened. */\n+    std::condition_variable m_read_condvar;\n+\n+    /** Protects access to m_buffer, m_size, m_insert_at_idx, m_read_at_idx. */\n+    mutable std::mutex m_lock;\n+\n+    /**\n+     * Pop an element off the front of the buffer and return it. Assumes caller\n+     * holds m_lock.\n+     */\n+    value_type AssumeLockedPopFront()\n+    {\n+        assert(m_size > 0);\n+\n+        value_type data = std::move(m_buffer[m_read_at_idx]);\n+        m_buffer[m_read_at_idx] = value_type();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187423274",
      "id" : 187423274,
      "in_reply_to_id" : 187193683,
      "original_commit_id" : "3c13cef1550f4a1f03d6f46119474aff658156b3",
      "original_position" : 134,
      "path" : "src/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 119202417,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200",
      "updated_at" : "2018-05-10T18:47:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187423274",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187423322"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187423322"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "84a3c730ce4c65890591ddc863c59d7dfc2339cb",
      "created_at" : "2018-05-10T18:47:49Z",
      "diff_hunk" : "@@ -0,0 +1,145 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RINGBUFFER_H\n+#define BITCOIN_RINGBUFFER_H\n+\n+#include <array>\n+#include <atomic>\n+#include <cassert>\n+#include <chrono>\n+#include <condition_variable>\n+#include <functional>\n+#include <mutex>\n+#include <thread>\n+#include <vector>\n+\n+/**\n+ * A threadsafe circular buffer.\n+ *\n+ * Allows optional blocking behavior instead of overwriting when at capacity.\n+ */\n+template<typename ET, int S, typename ST=int>\n+class RingBuffer\n+{\n+public:\n+    using value_type = ET;\n+    using size_type = ST;\n+\n+    RingBuffer() : m_size(0), m_insert_at_idx(0), m_read_at_idx(0), m_stop_waiting(false) { }\n+    ~RingBuffer() { }\n+\n+    /** @return the number of elements in the buffer. */\n+    inline size_type Size() const {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return m_size;\n+    }\n+    inline size_type MaxSize() const { return S; }\n+\n+    value_type PopFront()\n+    {\n+        std::lock_guard<std::mutex> lock(m_lock);\n+        return AssumeLockedPopFront();\n+    }\n+\n+    /**\n+     * Push an element into the buffer.\n+     *\n+     * @arg no_overwrite  If true, block and wait to write instead of overwriting existing data.\n+     */\n+    size_type PushBack(value_type v, bool no_overwrite = true)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187423322",
      "id" : 187423322,
      "in_reply_to_id" : 187194522,
      "original_commit_id" : "3c13cef1550f4a1f03d6f46119474aff658156b3",
      "original_position" : 51,
      "path" : "src/ringbuffer.h",
      "position" : null,
      "pull_request_review_id" : 119202481,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200",
      "updated_at" : "2018-05-10T18:47:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187423322",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187423354"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187423354"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good catch, fixed.",
      "commit_id" : "84a3c730ce4c65890591ddc863c59d7dfc2339cb",
      "created_at" : "2018-05-10T18:47:56Z",
      "diff_hunk" : "@@ -271,3 +274,40 @@ void BCLog::Logger::ShrinkDebugFile()\n     else if (file != nullptr)\n         fclose(file);\n }\n+\n+namespace async_logging {\n+    using LogArgs = std::string;\n+    RingBuffer<LogArgs, 1024> log_buffer;\n+    std::unique_ptr<std::thread> flush_logs_thread;\n+    std::once_flag flush_logs_thread_started;\n+\n+    static void ConsumeLogs()\n+    {\n+        std::unique_ptr<LogArgs> next_log_line;\n+        while (next_log_line = log_buffer.PollForOne()) {\n+            g_logger->LogPrintStr(*next_log_line);\n+        }\n+    }\n+\n+    void FlushAll()\n+    {\n+        for (LogArgs s : log_buffer.PopAll()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13200#discussion_r187423354",
      "id" : 187423354,
      "in_reply_to_id" : 187197537,
      "original_commit_id" : "4e8af464b39e23ce048c37d85d471dd5a8685ba1",
      "original_position" : 31,
      "path" : "src/logging.cpp",
      "position" : null,
      "pull_request_review_id" : 119202517,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13200",
      "updated_at" : "2018-05-10T18:47:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/187423354",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   }
]
