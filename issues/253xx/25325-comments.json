[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--021abf342d371248e50ceaed478a90ca-->\n### Reviews\nSee [the guideline](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#code-review) for information on the review process.\n| Type | Reviewers |\n| ---- | --------- |\n| Stale ACK | [sipa](https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1407124835), [jonatack](https://github.com/bitcoin/bitcoin/pull/25325#pullrequestreview-1298020717) |\n\nIf your review is incorrectly listed, please react with ð to this comment and the bot will ignore it on the next update.\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#26940](https://github.com/bitcoin/bitcoin/pull/26940) (test: create random and coins utils, add amount helper, dedupe add_coin by jonatack)\n* [#26615](https://github.com/bitcoin/bitcoin/pull/26615) (test: Make `mempool_tests/MempoolSizeLimitTest` allocation-neutral by hebasto)\n* [#26153](https://github.com/bitcoin/bitcoin/pull/26153) (Reduce wasted pseudorandom bytes in ChaCha20 + various improvements by sipa)\n* [#25361](https://github.com/bitcoin/bitcoin/pull/25361) (BIP324: Cipher suite by dhruv)\n* [#24748](https://github.com/bitcoin/bitcoin/pull/24748) (test/BIP324: functional tests for v2 P2P encryption by stratospher)\n* [#24545](https://github.com/bitcoin/bitcoin/pull/24545) (BIP324: Enable v2 P2P encrypted transport by dhruv)\n* [#23561](https://github.com/bitcoin/bitcoin/pull/23561) (BIP324: Handshake prerequisites by dhruv)\n* [#23233](https://github.com/bitcoin/bitcoin/pull/23233) (BIP324: Add encrypted p2p transport {de}serializer by dhruv)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.\n",
      "created_at" : "2022-06-10T17:46:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1152596519",
      "id" : 1152596519,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585Eszon",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1152596519/reactions"
      },
      "updated_at" : "2023-02-15T18:04:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1152596519",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "rebased to 9205b60 with minor fixes in `pool.h` so it is usable in `boost::unordered_map`",
      "created_at" : "2022-06-19T05:15:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1159619246",
      "id" : 1159619246,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585FHmKu",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1159619246/reactions"
      },
      "updated_at" : "2022-06-19T05:15:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1159619246",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953055591"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953055591"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No need for passing `seedval` by reference.",
      "commit_id" : "9205b60ba9667d08ec4f73763ace3f37990635c9",
      "created_at" : "2022-08-23T19:55:02Z",
      "diff_hunk" : "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+#define BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+\n+#include <cstdint>\n+#include <limits>\n+\n+/** xoroshiro128++ PRNG. Extremely fast, not appropriate for cryptographic purposes.\n+ *\n+ * Memory footprint is 128bit, period is 2^128 - 1.\n+ * This class is not thread-safe.\n+ *\n+ * Reference implementation available at https://prng.di.unimi.it/xoroshiro128plusplus.c\n+ * See https://prng.di.unimi.it/\n+ */\n+class XoRoShiRo128PlusPlus\n+{\n+    uint64_t m_s0;\n+    uint64_t m_s1;\n+\n+    [[nodiscard]] constexpr static uint64_t rotl(uint64_t x, int n)\n+    {\n+        return (x << n) | (x >> (64 - n));\n+    }\n+\n+    [[nodiscard]] constexpr static uint64_t SplitMix64(uint64_t& seedval) noexcept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953055591",
      "id" : 953055591,
      "line" : 30,
      "node_id" : "PRRC_kwDOABII5844znln",
      "original_commit_id" : "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "original_line" : 30,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/test/util/xoroshiro128plusplus.h",
      "position" : 30,
      "pull_request_review_id" : 1082762327,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953055591/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-08-23T19:55:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953055591",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953062958"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953062958"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Pretty sure this was not written by Satoshi, or in 2010.",
      "commit_id" : "9205b60ba9667d08ec4f73763ace3f37990635c9",
      "created_at" : "2022-08-23T20:04:37Z",
      "diff_hunk" : "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953062958",
      "id" : 953062958,
      "line" : 1,
      "node_id" : "PRRC_kwDOABII5844zpYu",
      "original_commit_id" : "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "original_line" : 1,
      "original_position" : 1,
      "original_start_line" : null,
      "path" : "src/test/util/xoroshiro128plusplus.h",
      "position" : 1,
      "pull_request_review_id" : 1082773235,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953062958/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-08-23T20:04:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953062958",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953067528"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953067528"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Actually this it is necessary because `seedval` is modified, see the constructor in line 42 where `m_s0` and `m_s1` are initialized. I could use a pointer instead of reference or add a comment to make that more clear?",
      "commit_id" : "9205b60ba9667d08ec4f73763ace3f37990635c9",
      "created_at" : "2022-08-23T20:10:49Z",
      "diff_hunk" : "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+#define BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+\n+#include <cstdint>\n+#include <limits>\n+\n+/** xoroshiro128++ PRNG. Extremely fast, not appropriate for cryptographic purposes.\n+ *\n+ * Memory footprint is 128bit, period is 2^128 - 1.\n+ * This class is not thread-safe.\n+ *\n+ * Reference implementation available at https://prng.di.unimi.it/xoroshiro128plusplus.c\n+ * See https://prng.di.unimi.it/\n+ */\n+class XoRoShiRo128PlusPlus\n+{\n+    uint64_t m_s0;\n+    uint64_t m_s1;\n+\n+    [[nodiscard]] constexpr static uint64_t rotl(uint64_t x, int n)\n+    {\n+        return (x << n) | (x >> (64 - n));\n+    }\n+\n+    [[nodiscard]] constexpr static uint64_t SplitMix64(uint64_t& seedval) noexcept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953067528",
      "id" : 953067528,
      "in_reply_to_id" : 953055591,
      "line" : 30,
      "node_id" : "PRRC_kwDOABII5844zqgI",
      "original_commit_id" : "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "original_line" : 30,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/test/util/xoroshiro128plusplus.h",
      "position" : 30,
      "pull_request_review_id" : 1082780041,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953067528/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-08-23T20:10:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953067528",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953069117"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953069117"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oh, no, I just didn't pay attention to how it was used. My mistake.",
      "commit_id" : "9205b60ba9667d08ec4f73763ace3f37990635c9",
      "created_at" : "2022-08-23T20:13:00Z",
      "diff_hunk" : "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+#define BITCOIN_TEST_UTIL_XOROSHIRO128PLUSPLUS_H\n+\n+#include <cstdint>\n+#include <limits>\n+\n+/** xoroshiro128++ PRNG. Extremely fast, not appropriate for cryptographic purposes.\n+ *\n+ * Memory footprint is 128bit, period is 2^128 - 1.\n+ * This class is not thread-safe.\n+ *\n+ * Reference implementation available at https://prng.di.unimi.it/xoroshiro128plusplus.c\n+ * See https://prng.di.unimi.it/\n+ */\n+class XoRoShiRo128PlusPlus\n+{\n+    uint64_t m_s0;\n+    uint64_t m_s1;\n+\n+    [[nodiscard]] constexpr static uint64_t rotl(uint64_t x, int n)\n+    {\n+        return (x << n) | (x >> (64 - n));\n+    }\n+\n+    [[nodiscard]] constexpr static uint64_t SplitMix64(uint64_t& seedval) noexcept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r953069117",
      "id" : 953069117,
      "in_reply_to_id" : 953055591,
      "line" : 30,
      "node_id" : "PRRC_kwDOABII5844zq49",
      "original_commit_id" : "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "original_line" : 30,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/test/util/xoroshiro128plusplus.h",
      "position" : 30,
      "pull_request_review_id" : 1082783050,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953069117/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-08-23T20:13:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/953069117",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r973734050"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/973734050"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "That's how rumors start! Maybe it was Satoshi? ;-) I'll update that.",
      "commit_id" : "9205b60ba9667d08ec4f73763ace3f37990635c9",
      "created_at" : "2022-09-18T15:00:16Z",
      "diff_hunk" : "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r973734050",
      "id" : 973734050,
      "in_reply_to_id" : 953062958,
      "line" : 1,
      "node_id" : "PRRC_kwDOABII5846CgCi",
      "original_commit_id" : "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "original_line" : 1,
      "original_position" : 1,
      "original_start_line" : null,
      "path" : "src/test/util/xoroshiro128plusplus.h",
      "position" : 1,
      "pull_request_review_id" : 1111554848,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/973734050/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-18T15:00:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/973734050",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "In a semi-related event, I've recently created a big benchmark of a lot of different hashmaps. See here: https://martin.ankerl.com/2022/08/27/hashmap-bench-01/\r\n\r\nSome findings that I think are relevant for this PR:\r\n\r\n* I have added the `PoolAllocator` developed here to the benchmarks and combined it with both `std::unordered_map` and `boost::unordered_map` and it works without any problems.\r\n* boost has completely reworked the hashmap and released that in version 1.80. Just changing the map to that implementation will probably provide some speedup. [More info here](https://www.boost.org/doc/libs/1_80_0/libs/unordered/doc/html/unordered.html#benchmarks).\r\n* Both `boost::unordered_map` and `std::unordered_map` benefit a lot memory-wise from the `PoolAllocator`.\r\n* Boost has it's own pool allocator: `boost::container::pmr::unsynchronized_pool_resource` It behaves relatively similar to PoolAllocator, although slower in my benchmarks. So this might be an alternative to the `PoolAllocator`.\r\n* Other implementations like `gtl::parallel_flat_hash_map` are much faster and have low memory overhead, so they might be a good choice performance wise, although they carry much more risk because usage is not so widespread.",
      "created_at" : "2022-09-18T15:13:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1250328856",
      "id" : 1250328856,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585KhoEY",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1250328856/reactions"
      },
      "updated_at" : "2022-09-18T15:13:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1250328856",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased to [f1b20f0](https://github.com/bitcoin/bitcoin/commit/f1b20f04644ddc07bd9bbfc066f9701d54139d52) to fix copyright header in `xoroshiro128plusplus.h`. Nothing else changed.",
      "created_at" : "2022-09-24T06:11:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1256876909",
      "id" : 1256876909,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585K6mtt",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1256876909/reactions"
      },
      "updated_at" : "2022-09-24T06:11:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1256876909",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r979171391"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/979171391"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done",
      "commit_id" : "f1b20f04644ddc07bd9bbfc066f9701d54139d52",
      "created_at" : "2022-09-24T06:11:46Z",
      "diff_hunk" : "@@ -0,0 +1,72 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r979171391",
      "id" : 979171391,
      "in_reply_to_id" : 953062958,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5846XPg_",
      "original_commit_id" : "afa98fe23088f6cdc9ae1f234926517d63307a91",
      "original_line" : 1,
      "original_position" : 1,
      "original_start_line" : null,
      "path" : "src/test/util/xoroshiro128plusplus.h",
      "position" : null,
      "pull_request_review_id" : 1119175139,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/979171391/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-24T06:11:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/979171391",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2022-10-19T09:31:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1283707743",
      "id" : 1283707743,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585Mg9Nf",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1283707743/reactions"
      },
      "updated_at" : "2022-10-19T09:31:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1283707743",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebase to 509d97a fixes merge conflict in `Makefile.test_util.include`, fixes a comment, adds benchmark priority, fix Win64 64bit shift warning.",
      "created_at" : "2022-10-21T15:58:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1287155740",
      "id" : 1287155740,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585MuHAc",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1287155740/reactions"
      },
      "updated_at" : "2022-10-21T17:22:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1287155740",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1004102333"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004102333"
         }
      },
      "author_association" : "MEMBER",
      "body" : "de694ed10bfa623596a41e35c95c13e757787b07: consider deleting copy ctor and copy assignment operators\r\n```diff\r\ndiff --git a/src/support/allocators/pool.h b/src/support/allocators/pool.h\r\nindex 5c04bb31e..00bd1ed90 100644\r\n--- a/src/support/allocators/pool.h\r\n+++ b/src/support/allocators/pool.h\r\n@@ -269,6 +269,9 @@ public:\r\n     {\r\n         return m_chunk_size_bytes;\r\n     }\r\n+\r\n+    PoolResource(const PoolResource&) = delete;\r\n+    PoolResource& operator=(const PoolResource&) = delete;\r\n };\r\n```",
      "commit_id" : "509d97a7a97dfbf83bdd7d723e68159ce83ff5dd",
      "created_at" : "2022-10-25T07:27:36Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1004102333",
      "id" : 1004102333,
      "line" : 70,
      "node_id" : "PRRC_kwDOABII58472WK9",
      "original_commit_id" : "de694ed10bfa623596a41e35c95c13e757787b07",
      "original_line" : 70,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 70,
      "pull_request_review_id" : 1154271326,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004102333/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-25T08:09:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004102333",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1004112858"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004112858"
         }
      },
      "author_association" : "MEMBER",
      "body" : "de694ed10bfa623596a41e35c95c13e757787b07: maybe use templates instead of `void*`?\r\n```diff\r\ndiff --git a/src/support/allocators/pool.h b/src/support/allocators/pool.h\r\nindex 5c04bb31e..38c5f9d62 100644\r\n--- a/src/support/allocators/pool.h\r\n+++ b/src/support/allocators/pool.h\r\n@@ -139,7 +139,8 @@ class PoolResource final\r\n     /**\r\n      * Replaces node with placement constructed ListNode that points to the previous node\r\n      */\r\n-    void PlacementAddToList(void* p, ListNode*& node)\r\n+    template <typename T>\r\n+    void PlacementAddToList(T* p, ListNode*& node)\r\n     {\r\n         node = new (p) ListNode{node};\r\n     }\r\n@@ -232,7 +233,8 @@ public:\r\n     /**\r\n      * Returns a block to the freelists, or deletes the block when it did not come from the cunks.\r\n      */\r\n-    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\r\n+    template <typename T>\r\n+    void Deallocate(T* p, std::size_t bytes, std::size_t alignment) noexcept\r\n     {\r\n         if (IsFreeListUsable(bytes, alignment)) {\r\n             const std::size_t num_alignments = NumElemAlignBytes(bytes);\r\n```",
      "commit_id" : "509d97a7a97dfbf83bdd7d723e68159ce83ff5dd",
      "created_at" : "2022-10-25T07:38:21Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1004112858",
      "id" : 1004112858,
      "line" : 142,
      "node_id" : "PRRC_kwDOABII58472Yva",
      "original_commit_id" : "de694ed10bfa623596a41e35c95c13e757787b07",
      "original_line" : 142,
      "original_position" : 142,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 142,
      "pull_request_review_id" : 1154271326,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004112858/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-25T08:09:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004112858",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1004137199"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004137199"
         }
      },
      "author_association" : "MEMBER",
      "body" : "de694ed10bfa623596a41e35c95c13e757787b07: might slightly improve performance but haven't benchmarked\r\n```suggestion\r\n    std::vector<std::byte*> m_allocated_chunks{};\r\n```",
      "commit_id" : "509d97a7a97dfbf83bdd7d723e68159ce83ff5dd",
      "created_at" : "2022-10-25T08:02:29Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1004137199",
      "id" : 1004137199,
      "line" : 101,
      "node_id" : "PRRC_kwDOABII58472erv",
      "original_commit_id" : "509d97a7a97dfbf83bdd7d723e68159ce83ff5dd",
      "original_line" : 101,
      "original_position" : 101,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 101,
      "pull_request_review_id" : 1154271326,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004137199/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-25T08:09:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1004137199",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22493292?v=4",
         "events_url" : "https://api.github.com/users/aureleoules/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aureleoules/followers",
         "following_url" : "https://api.github.com/users/aureleoules/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aureleoules/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aureleoules",
         "id" : 22493292,
         "login" : "aureleoules",
         "node_id" : "MDQ6VXNlcjIyNDkzMjky",
         "organizations_url" : "https://api.github.com/users/aureleoules/orgs",
         "received_events_url" : "https://api.github.com/users/aureleoules/received_events",
         "repos_url" : "https://api.github.com/users/aureleoules/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aureleoules/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aureleoules/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aureleoules"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1009306384"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1009306384"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think it's better to leave this as void*, because I don't want any overloaded operator new or operator delete called depending on the type.",
      "commit_id" : "509d97a7a97dfbf83bdd7d723e68159ce83ff5dd",
      "created_at" : "2022-10-31T11:25:10Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1009306384",
      "id" : 1009306384,
      "in_reply_to_id" : 1004112858,
      "line" : 142,
      "node_id" : "PRRC_kwDOABII5848KMsQ",
      "original_commit_id" : "de694ed10bfa623596a41e35c95c13e757787b07",
      "original_line" : 142,
      "original_position" : 142,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 142,
      "pull_request_review_id" : 1161718255,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1009306384/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-10-31T11:25:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1009306384",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2022-11-19T01:44:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1320735162",
      "id" : 1320735162,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585OuNG6",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1320735162/reactions"
      },
      "updated_at" : "2022-11-19T01:44:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1320735162",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2022-11-30T01:21:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1331525171",
      "id" : 1331525171,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585PXXYz",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1331525171/reactions"
      },
      "updated_at" : "2022-11-30T01:21:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1331525171",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1036283541"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036283541"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'll add these when I rebase to fix the merge conflict :+1: ",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2022-11-30T17:55:51Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1036283541",
      "id" : 1036283541,
      "in_reply_to_id" : 1004102333,
      "line" : 70,
      "node_id" : "PRRC_kwDOABII5849xG6V",
      "original_commit_id" : "de694ed10bfa623596a41e35c95c13e757787b07",
      "original_line" : 70,
      "original_position" : 70,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 70,
      "pull_request_review_id" : 1199784602,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036283541/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-30T17:55:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036283541",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1036285674"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036285674"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I thought std::list is more fitting here, because I don't need random access, and only every once in a while one element is added. The list is only iterated once when bitcoind shutsdown. So it's not at all performance relevant here",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2022-11-30T17:57:55Z",
      "diff_hunk" : "@@ -0,0 +1,352 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1036285674",
      "id" : 1036285674,
      "in_reply_to_id" : 1004137199,
      "line" : 101,
      "node_id" : "PRRC_kwDOABII5849xHbq",
      "original_commit_id" : "509d97a7a97dfbf83bdd7d723e68159ce83ff5dd",
      "original_line" : 101,
      "original_position" : 101,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 101,
      "pull_request_review_id" : 1199787521,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036285674/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-11-30T17:57:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1036285674",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, this approach is much easier to be convinced about, I feel. Happy to see that most of the performance gains carry over.\r\n\r\nI've ran a partial reindex under valgrind with this PR (to height 592178, which took several days), to really stress test it. No issues. I'll do a more in-depth code review soon.",
      "created_at" : "2022-12-05T19:19:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1338010318",
      "id" : 1338010318,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585PwGrO",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1338010318/reactions"
      },
      "updated_at" : "2022-12-05T19:19:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1338010318",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081878044"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081878044"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo: space before `3`",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:22:38Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081878044",
      "id" : 1081878044,
      "line" : 64,
      "node_id" : "PRRC_kwDOABII585AfCYc",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 64,
      "original_position" : 64,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 64,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081878044/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081878044",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081883320"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081883320"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Allocators don't need to be able to handle allocations of size 0, so I think the `+ 1` could be dropped here (shifting the indices down by 1).",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:27:33Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081883320",
      "id" : 1081883320,
      "line" : 107,
      "node_id" : "PRRC_kwDOABII585AfDq4",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 107,
      "original_position" : 107,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 107,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081883320/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081883320",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081894944"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081894944"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I know there are rules that make move constructors/assignment operators not automatically appear when copy equivalents are specified, but I'd still prefer explicitly disabling those too.",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:38:52Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081894944",
      "id" : 1081894944,
      "line" : 193,
      "node_id" : "PRRC_kwDOABII585AfGgg",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 193,
      "original_position" : 193,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 193,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081894944/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081894944",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081903348"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081903348"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It seems this comment would be more appropriate if put a few lines higher. The placement here makes it look like it's related to the freelist empty test.",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:47:10Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081903348",
      "id" : 1081903348,
      "line" : 215,
      "node_id" : "PRRC_kwDOABII585AfIj0",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 215,
      "original_position" : 215,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 215,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081903348/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081903348",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081909031"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909031"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This comment seems like it should be moved up as well.",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:52:49Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081909031",
      "id" : 1081909031,
      "line" : 223,
      "node_id" : "PRRC_kwDOABII585AfJ8n",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 223,
      "original_position" : 223,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 223,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909031/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909031",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081909200"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909200"
         }
      },
      "author_association" : "MEMBER",
      "body" : "And this one too.",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:53:03Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081909200",
      "id" : 1081909200,
      "line" : 230,
      "node_id" : "PRRC_kwDOABII585AfJ_Q",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 230,
      "original_position" : 230,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 230,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909200/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909200",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081909913"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909913"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think there is an upstream resource; it's just handled by the default allocator.",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:53:45Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081909913",
      "id" : 1081909913,
      "line" : 234,
      "node_id" : "PRRC_kwDOABII585AfKKZ",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 234,
      "original_position" : 234,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 234,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909913/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081909913",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081910140"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081910140"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo: `cunks`.",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:54:01Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the cunks.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081910140",
      "id" : 1081910140,
      "line" : 239,
      "node_id" : "PRRC_kwDOABII585AfKN8",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 239,
      "original_position" : 239,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 239,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081910140/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081910140",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081910577"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081910577"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Likewise, no upstream resource here?",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:54:37Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the cunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to the upstream resource.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081910577",
      "id" : 1081910577,
      "line" : 249,
      "node_id" : "PRRC_kwDOABII585AfKUx",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 249,
      "original_position" : 249,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 249,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081910577/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081910577",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081913776"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081913776"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This seems like a debugging leftover.",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T21:58:43Z",
      "diff_hunk" : "@@ -0,0 +1,127 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+#define BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+\n+#include <support/allocators/pool.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+/**\n+ * Helper to get access to private parts of PoolResource. Used in unit tests and in the fuzzer\n+ */\n+class PoolResourceTester\n+{\n+    struct PtrAndBytes {\n+        uintptr_t ptr;\n+        std::size_t size;\n+\n+        PtrAndBytes(const void* p, std::size_t s)\n+            : ptr(reinterpret_cast<uintptr_t>(p)), size(s)\n+        {\n+        }\n+\n+        /**\n+         * defines a sort ordering by the pointer value\n+         */\n+        friend bool operator<(PtrAndBytes const& a, PtrAndBytes const& b)\n+        {\n+            return a.ptr < b.ptr;\n+        }\n+    };\n+\n+public:\n+    /**\n+     * Extracts the number of elements per freelist\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::vector<std::size_t> FreeListSizes(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        auto sizes = std::vector<std::size_t>();\n+        for (const auto* ptr : resource.m_free_lists) {\n+            size_t size = 0;\n+            while (ptr != nullptr) {\n+                ++size;\n+                ptr = ptr->m_next;\n+            }\n+            sizes.push_back(size);\n+        }\n+        return sizes;\n+    }\n+\n+    /**\n+     * How many bytes are still available from the last allocated chunk\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::size_t AvailableMemoryFromChunk(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        return resource.m_available_memory_end - resource.m_available_memory_it;\n+    }\n+\n+    /**\n+     * Once all blocks are given back to the resource, tests that the freelists are consistent:\n+     *\n+     * * All data in the freelists must come from the chunks\n+     * * Memory doesn't overlap\n+     * * Each byte in the chunks can be accounted for in either the freelist or as available bytes.\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static void CheckAllDataAccountedFor(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        // collect all free blocks by iterating all freelists\n+        std::vector<PtrAndBytes> free_blocks;\n+        for (std::size_t freelist_idx = 0; freelist_idx < resource.m_free_lists.size(); ++freelist_idx) {\n+            std::size_t bytes = freelist_idx * resource.ELEM_ALIGN_BYTES;\n+            auto* ptr = resource.m_free_lists[freelist_idx];\n+            while (ptr != nullptr) {\n+                free_blocks.emplace_back(ptr, bytes);\n+                ptr = ptr->m_next;\n+            }\n+        }\n+        // also add whatever has not yet been used for blocks\n+        auto num_available_bytes = resource.m_available_memory_end - resource.m_available_memory_it;\n+        if (num_available_bytes > 0) {\n+            free_blocks.emplace_back(resource.m_available_memory_it, num_available_bytes);\n+        }\n+\n+        // collect all chunks\n+        std::vector<PtrAndBytes> chunks;\n+        for (std::byte* ptr : resource.m_allocated_chunks) {\n+            chunks.emplace_back(ptr, resource.ChunkSizeBytes());\n+        }\n+\n+        // now we have all the data from all freelists on the one hand side, and all chunks on the other hand side.\n+        // To check if all of them match, sort by address and iterate.\n+        std::sort(free_blocks.begin(), free_blocks.end());\n+        std::sort(chunks.begin(), chunks.end());\n+\n+        auto chunk_it = chunks.begin();\n+        auto chunk_ptr_remaining = chunk_it->ptr;\n+        auto chunk_size_remaining = chunk_it->size;\n+        for (const auto& free_block : free_blocks) {\n+            if (chunk_size_remaining == 0) {\n+                assert(chunk_it != chunks.end());\n+                ++chunk_it;\n+                assert(chunk_it != chunks.end());\n+                chunk_ptr_remaining = chunk_it->ptr;\n+                chunk_size_remaining = chunk_it->size;\n+            }\n+            // std::cout << \"free_block=(\" << (void*)free_block.ptr << \", \" << free_block.size << \"), chunk=(\" << (void*)chunk_ptr_remaining << \", \" << chunk_size_remaining << \")\" << std::endl;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081913776",
      "id" : 1081913776,
      "line" : 115,
      "node_id" : "PRRC_kwDOABII585AfLGw",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 115,
      "original_position" : 115,
      "original_start_line" : null,
      "path" : "src/test/util/poolresourcetester.h",
      "position" : 115,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081913776/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081913776",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081922160"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081922160"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could this use `std::forward_list`?",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T22:09:09Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081922160",
      "id" : 1081922160,
      "line" : 101,
      "node_id" : "PRRC_kwDOABII585AfNJw",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 101,
      "original_position" : 101,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 101,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081922160/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081922160",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081923544"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081923544"
         }
      },
      "author_association" : "MEMBER",
      "body" : "A comment to explain where this estimation formula comes from would be useful (or encapsulate the `sizeof(void*) * 3` constant as a static member of the resource?).",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T22:10:36Z",
      "diff_hunk" : "@@ -166,6 +167,23 @@ static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n     return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n }\n \n+template <class Key, class T, class Hash, class Pred, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+static inline size_t DynamicUsage(const std::unordered_map<Key,\n+                                                           T,\n+                                                           Hash,\n+                                                           Pred,\n+                                                           PoolAllocator<std::pair<const Key, T>,\n+                                                                         MAX_BLOCK_SIZE_BYTES,\n+                                                                         ALIGN_BYTES>>& m)\n+{\n+    auto* pool_resource = m.get_allocator().resource();\n+\n+    size_t estimated_list_node_size = MallocUsage(sizeof(void*) * 3);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081923544",
      "id" : 1081923544,
      "line" : 181,
      "node_id" : "PRRC_kwDOABII585AfNfY",
      "original_commit_id" : "ecc73d72c72287b8e630266dc5bd08786dc85780",
      "original_line" : 181,
      "original_position" : 23,
      "original_start_line" : null,
      "path" : "src/memusage.h",
      "position" : 23,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081923544/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081923544",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081925749"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081925749"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: use variable names following the style guide when introducing new ones (e.g. `m_cache_coins_memory_resource`).",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-19T22:12:55Z",
      "diff_hunk" : "@@ -217,7 +226,8 @@ class CCoinsViewCache : public CCoinsViewBacked\n      * declared as \"const\".\n      */\n     mutable uint256 hashBlock;\n-    mutable CCoinsMap cacheCoins;\n+    mutable CCoinsMapMemoryResource cacheCoinsMemoryResource{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1081925749",
      "id" : 1081925749,
      "line" : 229,
      "node_id" : "PRRC_kwDOABII585AfOB1",
      "original_commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "original_line" : 229,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/coins.h",
      "position" : 30,
      "pull_request_review_id" : 1262647120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081925749/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-19T22:13:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1081925749",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082378917"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082378917"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm not 100% sure that is the case\r\n\r\nIn https://eel.is/c++draft/allocator.requirements#general-39 it states that \"the return value is unspecified\", so it it seems to me that it can be any value, but it doesn't say that the behavior is unspecified. So it could return any pointer or even `nullptr`\r\n\r\nIn http://eel.is/c++draft/basic.stc.dynamic.allocation#2 it says \"The effect of indirecting through a pointer returned from a request for zero size is undefined\", so one might return any value, but it must not be dereferenced (which seems logic, with 0 elements there's nothing to dereference). The footnote here says \"C++ differs from C in requiring a zero request to return a non-null pointer\", so this too seems like a pointer should be returned\r\n\r\nSo I think `allocate(0)` is not forbidden",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-20T11:15:37Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082378917",
      "id" : 1082378917,
      "in_reply_to_id" : 1081883320,
      "line" : 107,
      "node_id" : "PRRC_kwDOABII585Ag8ql",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 107,
      "original_position" : 107,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 107,
      "pull_request_review_id" : 1263376994,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082378917/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T11:15:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082378917",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082384437"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082384437"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'll remove the comment, it doesn't make much sense",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-20T11:22:43Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082384437",
      "id" : 1082384437,
      "in_reply_to_id" : 1081903348,
      "line" : 215,
      "node_id" : "PRRC_kwDOABII585Ag-A1",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 215,
      "original_position" : 215,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 215,
      "pull_request_review_id" : 1263391388,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082384437/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T11:22:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082384437",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082385811"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082385811"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The location seems ok to me, when that line is reached we know the freelist is empty so we need to get memory from the chunk",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-20T11:24:27Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082385811",
      "id" : 1082385811,
      "in_reply_to_id" : 1081909031,
      "line" : 223,
      "node_id" : "PRRC_kwDOABII585Ag-WT",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 223,
      "original_position" : 223,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 223,
      "pull_request_review_id" : 1263395000,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082385811/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T11:24:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082385811",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082387056"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082387056"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think that line fits too, this comments on  the `m_available_memory_it + round_bytes`",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-20T11:25:56Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082387056",
      "id" : 1082387056,
      "in_reply_to_id" : 1081909200,
      "line" : 230,
      "node_id" : "PRRC_kwDOABII585Ag-pw",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 230,
      "original_position" : 230,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 230,
      "pull_request_review_id" : 1263398108,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082387056/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T11:25:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082387056",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082577659"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082577659"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I could, but itt would be less convenient, because forward_list doesn't even have a `size()` which I use in `NumAllocatedChunks()`",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-20T14:03:44Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082577659",
      "id" : 1082577659,
      "in_reply_to_id" : 1081922160,
      "line" : 101,
      "node_id" : "PRRC_kwDOABII585AhtL7",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 101,
      "original_position" : 101,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 101,
      "pull_request_review_id" : 1263645793,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082577659/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T14:03:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082577659",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082640705"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082640705"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fair enough.",
      "commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "created_at" : "2023-01-20T14:45:49Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082640705",
      "id" : 1082640705,
      "in_reply_to_id" : 1081883320,
      "line" : 107,
      "node_id" : "PRRC_kwDOABII585Ah8lB",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 107,
      "original_position" : 107,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 107,
      "pull_request_review_id" : 1263736203,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082640705/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T14:45:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082640705",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082683009"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082683009"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I see; it'd reduce memory usage very slightly, but if it comes with extra complexity it's probably not worth it.",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-20T15:12:56Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082683009",
      "id" : 1082683009,
      "in_reply_to_id" : 1081922160,
      "line" : 101,
      "node_id" : "PRRC_kwDOABII585AiG6B",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 101,
      "original_position" : 101,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 101,
      "pull_request_review_id" : 1263783313,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082683009/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T15:12:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082683009",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082685605"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082685605"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ok, it's just a tiny nit of course. Given the somewhat out of place comment above I wondered if perhaps a few more comments somehow got misplaced.",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-20T15:15:15Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082685605",
      "id" : 1082685605,
      "in_reply_to_id" : 1081909031,
      "line" : 223,
      "node_id" : "PRRC_kwDOABII585AiHil",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 223,
      "original_position" : 223,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 223,
      "pull_request_review_id" : 1263787310,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082685605/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T15:15:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082685605",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082685801"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082685801"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ok.",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-20T15:15:22Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1082685801",
      "id" : 1082685801,
      "in_reply_to_id" : 1081909200,
      "line" : 230,
      "node_id" : "PRRC_kwDOABII585AiHlp",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 230,
      "original_position" : 230,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 230,
      "pull_request_review_id" : 1263787539,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082685801/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-20T15:15:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1082685801",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083220507"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083220507"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Noticed while running `make check` and looking for `pool_tests` in the output: the following minor change in the first commit  2bbe0f8eeae274fc30d924c6762cbb7a392f3b32 will run the tests in the expected order.\r\n\r\n<details><summary>suggestion</summary><p>\r\n\r\n```diff\r\n   test/net_tests.cpp \\\r\n   test/netbase_tests.cpp \\\r\n-  test/pool_tests.cpp \\\r\n   test/orphanage_tests.cpp \\\r\n   test/pmt_tests.cpp \\\r\n   test/policy_fee_tests.cpp \\\r\n   test/policyestimator_tests.cpp \\\r\n+  test/pool_tests.cpp \\\r\n   test/pow_tests.cpp \\\r\n```\r\n\r\ncurrently\r\n\r\n```\r\nRunning tests: net_peer_eviction_tests from test/net_peer_eviction_tests.cpp\r\nRunning tests: net_tests from test/net_tests.cpp\r\nRunning tests: netbase_tests from test/netbase_tests.cpp\r\nRunning tests: pool_tests from test/pool_tests.cpp\r\nRunning tests: orphanage_tests from test/orphanage_tests.cpp\r\nRunning tests: pmt_tests from test/pmt_tests.cpp\r\nRunning tests: policy_fee_tests from test/policy_fee_tests.cpp\r\n```\r\n\r\nafter\r\n\r\n```\r\nRunning tests: pmt_tests from test/pmt_tests.cpp\r\nRunning tests: policy_fee_tests from test/policy_fee_tests.cpp\r\nRunning tests: policyestimator_tests from test/policyestimator_tests.cpp\r\nRunning tests: pool_tests from test/pool_tests.cpp\r\nRunning tests: pow_tests from test/pow_tests.cpp\r\nRunning tests: prevector_tests from test/prevector_tests.cpp\r\nRunning tests: raii_event_tests from test/raii_event_tests.cpp\r\n```\r\n</p></details>\r\n",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T01:33:47Z",
      "diff_hunk" : "@@ -112,6 +112,7 @@ BITCOIN_TESTS =\\\n   test/net_peer_eviction_tests.cpp \\\n   test/net_tests.cpp \\\n   test/netbase_tests.cpp \\\n+  test/pool_tests.cpp \\",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083220507",
      "id" : 1083220507,
      "line" : 115,
      "node_id" : "PRRC_kwDOABII585AkKIb",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 115,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/Makefile.test.include",
      "position" : 4,
      "pull_request_review_id" : 1264557141,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083220507/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T01:43:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083220507",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083249932"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249932"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in rebase to 80722d8",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T06:09:41Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083249932",
      "id" : 1083249932,
      "in_reply_to_id" : 1081878044,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585AkRUM",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 64,
      "original_position" : 64,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1264592811,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249932/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T06:09:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249932",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083249938"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249938"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in rebase to 80722d8",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T06:09:49Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083249938",
      "id" : 1083249938,
      "in_reply_to_id" : 1081903348,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585AkRUS",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 215,
      "original_position" : 215,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1264592818,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249938/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T06:09:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249938",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083249976"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249976"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in rebase to 80722d8",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T06:10:05Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083249976",
      "id" : 1083249976,
      "in_reply_to_id" : 1081909913,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585AkRU4",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 234,
      "original_position" : 234,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1264592846,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249976/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T06:10:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083249976",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250008"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250008"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in rebase to 80722d8",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T06:10:12Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the cunks.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250008",
      "id" : 1083250008,
      "in_reply_to_id" : 1081910140,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585AkRVY",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 239,
      "original_position" : 239,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1264592853,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250008/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T06:10:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250008",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250013"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250013"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in rebase to 80722d8",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T06:10:18Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+\n+            // If alignment is lower than BLOCK_ALIGNMENT_BYTES, we need to allocate a bit more.\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => forward allocation to the upstream resource.\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the cunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to the upstream resource.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250013",
      "id" : 1083250013,
      "in_reply_to_id" : 1081910577,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585AkRVd",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 249,
      "original_position" : 249,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1264592861,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250013/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T06:10:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250013",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250035"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250035"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in rebase to 80722d8",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T06:10:29Z",
      "diff_hunk" : "@@ -217,7 +226,8 @@ class CCoinsViewCache : public CCoinsViewBacked\n      * declared as \"const\".\n      */\n     mutable uint256 hashBlock;\n-    mutable CCoinsMap cacheCoins;\n+    mutable CCoinsMapMemoryResource cacheCoinsMemoryResource{};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250035",
      "id" : 1083250035,
      "in_reply_to_id" : 1081925749,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585AkRVz",
      "original_commit_id" : "d7dd33e8db4db430925f524d6224cad1a18ebe7b",
      "original_line" : 229,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/coins.h",
      "position" : null,
      "pull_request_review_id" : 1264592876,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250035/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T06:10:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250035",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250755"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250755"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Interesting that the order here has any effect on the order of tests, I would have expected that the test suite orders alphabetically. I'll add this to my next update",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T06:18:17Z",
      "diff_hunk" : "@@ -112,6 +112,7 @@ BITCOIN_TESTS =\\\n   test/net_peer_eviction_tests.cpp \\\n   test/net_tests.cpp \\\n   test/netbase_tests.cpp \\\n+  test/pool_tests.cpp \\",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250755",
      "id" : 1083250755,
      "in_reply_to_id" : 1083220507,
      "line" : 115,
      "node_id" : "PRRC_kwDOABII585AkRhD",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 115,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/Makefile.test.include",
      "position" : 4,
      "pull_request_review_id" : 1264593480,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250755/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T06:18:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250755",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250811"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250811"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "removed in rebase to 80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-21T06:18:49Z",
      "diff_hunk" : "@@ -0,0 +1,127 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+#define BITCOIN_TEST_UTIL_POOLRESOURCETESTER_H\n+\n+#include <support/allocators/pool.h>\n+\n+#include <algorithm>\n+#include <cassert>\n+#include <cstddef>\n+#include <cstdint>\n+#include <vector>\n+\n+/**\n+ * Helper to get access to private parts of PoolResource. Used in unit tests and in the fuzzer\n+ */\n+class PoolResourceTester\n+{\n+    struct PtrAndBytes {\n+        uintptr_t ptr;\n+        std::size_t size;\n+\n+        PtrAndBytes(const void* p, std::size_t s)\n+            : ptr(reinterpret_cast<uintptr_t>(p)), size(s)\n+        {\n+        }\n+\n+        /**\n+         * defines a sort ordering by the pointer value\n+         */\n+        friend bool operator<(PtrAndBytes const& a, PtrAndBytes const& b)\n+        {\n+            return a.ptr < b.ptr;\n+        }\n+    };\n+\n+public:\n+    /**\n+     * Extracts the number of elements per freelist\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::vector<std::size_t> FreeListSizes(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        auto sizes = std::vector<std::size_t>();\n+        for (const auto* ptr : resource.m_free_lists) {\n+            size_t size = 0;\n+            while (ptr != nullptr) {\n+                ++size;\n+                ptr = ptr->m_next;\n+            }\n+            sizes.push_back(size);\n+        }\n+        return sizes;\n+    }\n+\n+    /**\n+     * How many bytes are still available from the last allocated chunk\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static std::size_t AvailableMemoryFromChunk(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        return resource.m_available_memory_end - resource.m_available_memory_it;\n+    }\n+\n+    /**\n+     * Once all blocks are given back to the resource, tests that the freelists are consistent:\n+     *\n+     * * All data in the freelists must come from the chunks\n+     * * Memory doesn't overlap\n+     * * Each byte in the chunks can be accounted for in either the freelist or as available bytes.\n+     */\n+    template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+    static void CheckAllDataAccountedFor(const PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& resource)\n+    {\n+        // collect all free blocks by iterating all freelists\n+        std::vector<PtrAndBytes> free_blocks;\n+        for (std::size_t freelist_idx = 0; freelist_idx < resource.m_free_lists.size(); ++freelist_idx) {\n+            std::size_t bytes = freelist_idx * resource.ELEM_ALIGN_BYTES;\n+            auto* ptr = resource.m_free_lists[freelist_idx];\n+            while (ptr != nullptr) {\n+                free_blocks.emplace_back(ptr, bytes);\n+                ptr = ptr->m_next;\n+            }\n+        }\n+        // also add whatever has not yet been used for blocks\n+        auto num_available_bytes = resource.m_available_memory_end - resource.m_available_memory_it;\n+        if (num_available_bytes > 0) {\n+            free_blocks.emplace_back(resource.m_available_memory_it, num_available_bytes);\n+        }\n+\n+        // collect all chunks\n+        std::vector<PtrAndBytes> chunks;\n+        for (std::byte* ptr : resource.m_allocated_chunks) {\n+            chunks.emplace_back(ptr, resource.ChunkSizeBytes());\n+        }\n+\n+        // now we have all the data from all freelists on the one hand side, and all chunks on the other hand side.\n+        // To check if all of them match, sort by address and iterate.\n+        std::sort(free_blocks.begin(), free_blocks.end());\n+        std::sort(chunks.begin(), chunks.end());\n+\n+        auto chunk_it = chunks.begin();\n+        auto chunk_ptr_remaining = chunk_it->ptr;\n+        auto chunk_size_remaining = chunk_it->size;\n+        for (const auto& free_block : free_blocks) {\n+            if (chunk_size_remaining == 0) {\n+                assert(chunk_it != chunks.end());\n+                ++chunk_it;\n+                assert(chunk_it != chunks.end());\n+                chunk_ptr_remaining = chunk_it->ptr;\n+                chunk_size_remaining = chunk_it->size;\n+            }\n+            // std::cout << \"free_block=(\" << (void*)free_block.ptr << \", \" << free_block.size << \"), chunk=(\" << (void*)chunk_ptr_remaining << \", \" << chunk_size_remaining << \")\" << std::endl;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1083250811",
      "id" : 1083250811,
      "in_reply_to_id" : 1081913776,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585AkRh7",
      "original_commit_id" : "4ee892b57cdae1272f329b2ee9e765cbf453db9b",
      "original_line" : 115,
      "original_position" : 115,
      "original_start_line" : null,
      "path" : "src/test/util/poolresourcetester.h",
      "position" : null,
      "pull_request_review_id" : 1264593524,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250811/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-21T06:18:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1083250811",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1084564591"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1084564591"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I believe this is technically speaking UB: it may construct an out-of-bounds pointer; even without dereferencing, doing so is UB (unless it's the exactly-one-past-the-end pointer). It's of course fine in practice, but I think the proper way to write it is `round_bytes > m_available_memory_end - m_available_memory_it`.\r\n\r\nFrom https://en.cppreference.com/w/cpp/language/operator_arithmetic:\r\n\r\n> If the pointer `P` points to the ith element of an array, then the expressions `P + n`, `n + P`, and `P - n` are pointers of the same type that point to the i+nth, i+nth, and i-nth element of the same array, respectively. The result of pointer addition may also be a one-past-the-end pointer (that is, pointer `P` such that the expression `P - 1` points to the last element of the array). Any other situations (that is, attempts to generate a pointer that isn't pointing at an element of the same array or one past the end) invoke undefined behavior. \r\n\r\n",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-23T21:16:40Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1084564591",
      "id" : 1084564591,
      "line" : 225,
      "node_id" : "PRRC_kwDOABII585ApSRv",
      "original_commit_id" : "2bbe0f8eeae274fc30d924c6762cbb7a392f3b32",
      "original_line" : 225,
      "original_position" : 225,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 225,
      "pull_request_review_id" : 1266351016,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1084564591/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-23T22:16:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1084564591",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085963632"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085963632"
         }
      },
      "author_association" : "MEMBER",
      "body" : "2bbe0f8eeae274f Is the public helper member `PoolResource::IsEqual()` intended to be used (it's currently not)?",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-24T21:37:32Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085963632",
      "id" : 1085963632,
      "line" : 261,
      "node_id" : "PRRC_kwDOABII585Aun1w",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 261,
      "original_position" : 261,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 261,
      "pull_request_review_id" : 1268371465,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085963632/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-24T22:08:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085963632",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085967553"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085967553"
         }
      },
      "author_association" : "MEMBER",
      "body" : "2bbe0f8eeae274 it looks like `CHUNK_SIZE_BYTES` should be `m_chunk_size_bytes` or `ChunkSizeBytes()`\r\n```suggestion\r\n     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() +  m_chunk_size_bytes`\r\n```\r\n",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-24T21:41:52Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085967553",
      "id" : 1085967553,
      "line" : 117,
      "node_id" : "PRRC_kwDOABII585AuozB",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 117,
      "pull_request_review_id" : 1268371465,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085967553/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-24T22:10:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085967553",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085970688"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085970688"
         }
      },
      "author_association" : "MEMBER",
      "body" : "2bbe0f8eeae274f `BLOCK_ALIGNMENT_BYTES` is undefined (maybe `n * block alignment bytes`?)",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-24T21:44:45Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085970688",
      "id" : 1085970688,
      "line" : 105,
      "node_id" : "PRRC_kwDOABII585AupkA",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 105,
      "original_position" : 105,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 105,
      "pull_request_review_id" : 1268371465,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085970688/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-25T21:52:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085970688",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085971981"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085971981"
         }
      },
      "author_association" : "MEMBER",
      "body" : "2bbe0f8eeae274fc30d924c6762cbb7a392f3b32\r\n```suggestion\r\n        // if any available memory remains, put it in the freelist.\r\n```",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-24T21:45:56Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085971981",
      "id" : 1085971981,
      "line" : 155,
      "node_id" : "PRRC_kwDOABII585Aup4N",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 155,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 155,
      "pull_request_review_id" : 1268371465,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085971981/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-24T22:08:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085971981",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085974737"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085974737"
         }
      },
      "author_association" : "MEMBER",
      "body" : "2bbe0f8eeae274fc30d924c6762cbb7a392f3b32\r\n```suggestion\r\n     * How many multiples of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\r\n```",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-24T21:48:35Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085974737",
      "id" : 1085974737,
      "line" : 123,
      "node_id" : "PRRC_kwDOABII585AuqjR",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 123,
      "original_position" : 123,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 123,
      "pull_request_review_id" : 1268371465,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085974737/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-24T22:08:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085974737",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085980287"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085980287"
         }
      },
      "author_association" : "MEMBER",
      "body" : "2bbe0f8eeae274f missing headers (algorithm for `std::max` and iterator for `std::distance`)\r\n\r\n<details><summary>diffs</summary><p>\r\n\r\n```diff\r\n+#include <algorithm>\r\n #include <array>\r\n #include <cassert>\r\n #include <cstddef>\r\n+#include <iterator>\r\n #include <list>\r\n```\r\n\r\nand also in src/bench/pool.cpp\r\n\r\n```diff\r\n+#include <functional>\r\n #include <unordered_map>\r\n+#include <utility>\r\n```\r\n</p></details>\r\n",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-24T21:53:56Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1085980287",
      "id" : 1085980287,
      "line" : 11,
      "node_id" : "PRRC_kwDOABII585Aur5_",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 11,
      "original_position" : 11,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 11,
      "pull_request_review_id" : 1268371465,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085980287/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-24T22:26:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1085980287",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1086981056"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1086981056"
         }
      },
      "author_association" : "MEMBER",
      "body" : "https://github.com/bitcoin/bitcoin/commit/2bbe0f8eeae274fc30d924c6762cbb7a392f3b32 Question, are these user-defined copy-constructor and copy-assignment operators actually needed, and if yes, should the move operators be specified as well? \r\n\r\n<details><summary>Rationale</summary><p>\r\n\r\nPer https://en.cppreference.com/w/cpp/language/rule_of_three#rule-of-five, \"Because the presence of a user-defined destructor, copy-constructor, or copy-assignment operator prevents implicit definition of the [move constructor](https://en.cppreference.com/w/cpp/language/move_constructor) and the [move assignment operator](https://en.cppreference.com/w/cpp/language/move_operator), any class for which move semantics are desirable, has to declare all five special member functions. Unlike Rule of Three, failing to provide move constructor and move assignment is usually not an error, but a missed optimization opportunity.\"\r\n\r\n</p></details>\r\n",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-25T17:57:15Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1086981056",
      "id" : 1086981056,
      "line" : 305,
      "node_id" : "PRRC_kwDOABII585AygPA",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 305,
      "original_position" : 305,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 305,
      "pull_request_review_id" : 1269855171,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1086981056/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-25T21:50:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1086981056",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1086988389"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1086988389"
         }
      },
      "author_association" : "MEMBER",
      "body" : "https://github.com/bitcoin/bitcoin/commit/2bbe0f8eeae274fc30d924c6762cbb7a392f3b32 Noting that these two `==` and `!=` template methods don't appear to be otherwise used in this PR.",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-25T18:02:41Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;\n+\n+    template <class U>\n+    PoolAllocator(const PoolAllocator<U, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& other) noexcept\n+        : m_resource(other.resource())\n+    {\n+    }\n+\n+    /**\n+     * The rebind struct here is mandatory because we use non type template arguments for\n+     * PoolAllocator. See https://en.cppreference.com/w/cpp/named_req/Allocator#cite_note-2\n+     */\n+    template <typename U>\n+    struct rebind {\n+        using other = PoolAllocator<U, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+    };\n+\n+    /**\n+     * Forwards each call to the resource.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        return static_cast<T*>(m_resource->Allocate(n * sizeof(T), alignof(T)));\n+    }\n+\n+    /**\n+     * Forwards each call to the resource.\n+     */\n+    void deallocate(T* p, size_t n) noexcept\n+    {\n+        m_resource->Deallocate(p, n * sizeof(T), alignof(T));\n+    }\n+\n+    ResourceType* resource() const noexcept\n+    {\n+        return m_resource;\n+    }\n+};\n+\n+template <class T1, class T2, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+bool operator==(const PoolAllocator<T1, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& a,\n+                const PoolAllocator<T2, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& b) noexcept\n+{\n+    return a.resource() == b.resource();\n+}\n+\n+template <class T1, class T2, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+bool operator!=(const PoolAllocator<T1, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& a,\n+                const PoolAllocator<T2, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& b) noexcept\n+{",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1086988389",
      "id" : 1086988389,
      "line" : 354,
      "node_id" : "PRRC_kwDOABII585AyiBl",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 354,
      "original_position" : 354,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 354,
      "pull_request_review_id" : 1269855171,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1086988389/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-25T21:50:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1086988389",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1087172548"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1087172548"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nice. (In practice on my particular system, `86 / 100` is the lowest value that passes.)",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-25T21:07:15Z",
      "diff_hunk" : "@@ -0,0 +1,176 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);\n+\n+    uint8_t num_allocs = 200;\n+\n+    auto data = std::vector<Span<uint8_t>>();\n+\n+    // allocate an increasing number of bytes\n+    for (uint8_t num_bytes = 1; num_bytes < num_allocs; ++num_bytes) {\n+        uint8_t* bytes = new (resource.Allocate(num_bytes, 1)) uint8_t[num_bytes];\n+        BOOST_TEST(bytes != nullptr);\n+        data.emplace_back(bytes, num_bytes);\n+\n+        // set each byte to i\n+        std::fill(bytes, bytes + num_bytes, num_bytes);\n+    }\n+\n+    // now that we got all allocated, test if all still have the correct values, and give everything back to the allocator\n+    uint8_t val = 1;\n+    for (auto const& span : data) {\n+        for (auto x : span) {\n+            BOOST_TEST(val == x);\n+        }\n+        std::destroy(span.data(), span.data() + span.size());\n+        resource.Deallocate(span.data(), span.size(), 1);\n+        ++val;\n+    }\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+}\n+\n+BOOST_AUTO_TEST_CASE(random_allocations)\n+{\n+    struct PtrSizeAlignment {\n+        void* ptr;\n+        size_t bytes;\n+        size_t alignment;\n+    };\n+\n+    // makes a bunch of random allocations and gives all of them back in random order.\n+    auto resource = PoolResource<128, 8>(65536);\n+    std::vector<PtrSizeAlignment> ptr_size_alignment{};\n+    for (size_t i = 0; i < 1000; ++i) {\n+        // make it a bit more likely to allocate than deallocate\n+        if (ptr_size_alignment.empty() || 0 != InsecureRandRange(4)) {\n+            // allocate a random item\n+            std::size_t alignment = std::size_t{1} << InsecureRandRange(7);           // 1, 2, ..., 128\n+            std::size_t size = (InsecureRandRange(2000) / alignment + 1) * alignment; // multiple of alignment\n+            void* ptr = resource.Allocate(size, alignment);\n+            BOOST_TEST(ptr != nullptr);\n+            BOOST_TEST((reinterpret_cast<uintptr_t>(ptr) & (alignment - 1)) == 0);\n+            ptr_size_alignment.push_back({ptr, size, alignment});\n+        } else {\n+            // deallocate a random item\n+            auto& x = ptr_size_alignment[InsecureRandRange(ptr_size_alignment.size())];\n+            resource.Deallocate(x.ptr, x.bytes, x.alignment);\n+            x = ptr_size_alignment.back();\n+            ptr_size_alignment.pop_back();\n+        }\n+    }\n+\n+    // deallocate all the rest\n+    for (auto const& x : ptr_size_alignment) {\n+        resource.Deallocate(x.ptr, x.bytes, x.alignment);\n+    }\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+}\n+\n+BOOST_AUTO_TEST_CASE(memusage_test)\n+{\n+    auto std_map = std::unordered_map<int, int>{};\n+\n+    using Map = std::unordered_map<int,\n+                                   int,\n+                                   std::hash<int>,\n+                                   std::equal_to<int>,\n+                                   PoolAllocator<std::pair<const int, int>,\n+                                                 sizeof(std::pair<const int, int>) + sizeof(void*) * 4,\n+                                                 alignof(void*)>>;\n+    auto resource = Map::allocator_type::ResourceType(1024);\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    {\n+        auto resource_map = Map{0, std::hash<int>{}, std::equal_to<int>{}, &resource};\n+\n+        // can't have the same resource usage\n+        BOOST_TEST(memusage::DynamicUsage(std_map) != memusage::DynamicUsage(resource_map));\n+\n+        for (size_t i = 0; i < 10000; ++i) {\n+            std_map[i];\n+            resource_map[i];\n+        }\n+\n+        // Eventually the resource_map should have a much lower memory usage because it has less malloc overhead\n+        BOOST_TEST(memusage::DynamicUsage(resource_map) <= memusage::DynamicUsage(std_map) * 90 / 100);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1087172548",
      "id" : 1087172548,
      "line" : 170,
      "node_id" : "PRRC_kwDOABII585AzO_E",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 170,
      "original_position" : 170,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : 170,
      "pull_request_review_id" : 1269855171,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1087172548/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-25T21:50:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1087172548",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089264098"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089264098"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nice find, I'll change the `if`",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-27T18:02:27Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089264098",
      "id" : 1089264098,
      "in_reply_to_id" : 1084564591,
      "line" : 225,
      "node_id" : "PRRC_kwDOABII585A7Nni",
      "original_commit_id" : "2bbe0f8eeae274fc30d924c6762cbb7a392f3b32",
      "original_line" : 225,
      "original_position" : 225,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 225,
      "pull_request_review_id" : 1273173146,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089264098/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-27T18:02:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089264098",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089267866"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089267866"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Right, this is unused; I originally used this in the `operator==`. I'll remove it",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-27T18:06:59Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089267866",
      "id" : 1089267866,
      "in_reply_to_id" : 1085963632,
      "line" : 261,
      "node_id" : "PRRC_kwDOABII585A7Oia",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 261,
      "original_position" : 261,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 261,
      "pull_request_review_id" : 1273179379,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089267866/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-27T18:07:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089267866",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089285815"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089285815"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "right, also the .get() is no more",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-27T18:26:03Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089285815",
      "id" : 1089285815,
      "in_reply_to_id" : 1085967553,
      "line" : 117,
      "node_id" : "PRRC_kwDOABII585A7S63",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 117,
      "pull_request_review_id" : 1273216602,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089285815/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-27T18:26:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089285815",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089290030"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089290030"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It should be `n*ELEM_ALIGN_BYTES`",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-27T18:31:02Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089290030",
      "id" : 1089290030,
      "in_reply_to_id" : 1085970688,
      "line" : 105,
      "node_id" : "PRRC_kwDOABII585A7T8u",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 105,
      "original_position" : 105,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 105,
      "pull_request_review_id" : 1273228793,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089290030/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-27T18:31:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089290030",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089291634"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089291634"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think the savings are a bit less than 86/100 on 32bit due to 32bit alignment, that's why I have the number a bit on the high side here",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-27T18:32:56Z",
      "diff_hunk" : "@@ -0,0 +1,176 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <memusage.h>\n+#include <support/allocators/pool.h>\n+#include <test/util/poolresourcetester.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <cstdint>\n+#include <unordered_map>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(pool_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(basic_allocating)\n+{\n+    auto resource = PoolResource<8, 8>();\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    // first chunk is already allocated\n+    size_t expected_bytes_available = resource.ChunkSizeBytes();\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // chunk is used, no more allocation\n+    void* block = resource.Allocate(8, 8);\n+    expected_bytes_available -= 8;\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    resource.Deallocate(block, 8, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+\n+    // alignment is too small, but the best fitting freelist is used. Nothing is allocated.\n+    block = resource.Allocate(8, 1);\n+    BOOST_TEST(0 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 1);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because alignment is too big\n+    block = resource.Allocate(8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 8, 16);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    // can't use chunk because size is too big\n+    block = resource.Allocate(16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+\n+    resource.Deallocate(block, 16, 8);\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+    BOOST_TEST(1 == PoolResourceTester::FreeListSizes(resource)[1]);\n+    BOOST_TEST(expected_bytes_available == PoolResourceTester::AvailableMemoryFromChunk(resource));\n+}\n+\n+// Allocates from 0 to n bytes were n > the PoolResource's data, and each should work\n+BOOST_AUTO_TEST_CASE(allocate_any_byte)\n+{\n+    auto resource = PoolResource<128, 8>(1024);\n+    auto counts = PoolResourceTester::FreeListSizes(resource);\n+\n+    uint8_t num_allocs = 200;\n+\n+    auto data = std::vector<Span<uint8_t>>();\n+\n+    // allocate an increasing number of bytes\n+    for (uint8_t num_bytes = 1; num_bytes < num_allocs; ++num_bytes) {\n+        uint8_t* bytes = new (resource.Allocate(num_bytes, 1)) uint8_t[num_bytes];\n+        BOOST_TEST(bytes != nullptr);\n+        data.emplace_back(bytes, num_bytes);\n+\n+        // set each byte to i\n+        std::fill(bytes, bytes + num_bytes, num_bytes);\n+    }\n+\n+    // now that we got all allocated, test if all still have the correct values, and give everything back to the allocator\n+    uint8_t val = 1;\n+    for (auto const& span : data) {\n+        for (auto x : span) {\n+            BOOST_TEST(val == x);\n+        }\n+        std::destroy(span.data(), span.data() + span.size());\n+        resource.Deallocate(span.data(), span.size(), 1);\n+        ++val;\n+    }\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+}\n+\n+BOOST_AUTO_TEST_CASE(random_allocations)\n+{\n+    struct PtrSizeAlignment {\n+        void* ptr;\n+        size_t bytes;\n+        size_t alignment;\n+    };\n+\n+    // makes a bunch of random allocations and gives all of them back in random order.\n+    auto resource = PoolResource<128, 8>(65536);\n+    std::vector<PtrSizeAlignment> ptr_size_alignment{};\n+    for (size_t i = 0; i < 1000; ++i) {\n+        // make it a bit more likely to allocate than deallocate\n+        if (ptr_size_alignment.empty() || 0 != InsecureRandRange(4)) {\n+            // allocate a random item\n+            std::size_t alignment = std::size_t{1} << InsecureRandRange(7);           // 1, 2, ..., 128\n+            std::size_t size = (InsecureRandRange(2000) / alignment + 1) * alignment; // multiple of alignment\n+            void* ptr = resource.Allocate(size, alignment);\n+            BOOST_TEST(ptr != nullptr);\n+            BOOST_TEST((reinterpret_cast<uintptr_t>(ptr) & (alignment - 1)) == 0);\n+            ptr_size_alignment.push_back({ptr, size, alignment});\n+        } else {\n+            // deallocate a random item\n+            auto& x = ptr_size_alignment[InsecureRandRange(ptr_size_alignment.size())];\n+            resource.Deallocate(x.ptr, x.bytes, x.alignment);\n+            x = ptr_size_alignment.back();\n+            ptr_size_alignment.pop_back();\n+        }\n+    }\n+\n+    // deallocate all the rest\n+    for (auto const& x : ptr_size_alignment) {\n+        resource.Deallocate(x.ptr, x.bytes, x.alignment);\n+    }\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+}\n+\n+BOOST_AUTO_TEST_CASE(memusage_test)\n+{\n+    auto std_map = std::unordered_map<int, int>{};\n+\n+    using Map = std::unordered_map<int,\n+                                   int,\n+                                   std::hash<int>,\n+                                   std::equal_to<int>,\n+                                   PoolAllocator<std::pair<const int, int>,\n+                                                 sizeof(std::pair<const int, int>) + sizeof(void*) * 4,\n+                                                 alignof(void*)>>;\n+    auto resource = Map::allocator_type::ResourceType(1024);\n+\n+    PoolResourceTester::CheckAllDataAccountedFor(resource);\n+\n+    {\n+        auto resource_map = Map{0, std::hash<int>{}, std::equal_to<int>{}, &resource};\n+\n+        // can't have the same resource usage\n+        BOOST_TEST(memusage::DynamicUsage(std_map) != memusage::DynamicUsage(resource_map));\n+\n+        for (size_t i = 0; i < 10000; ++i) {\n+            std_map[i];\n+            resource_map[i];\n+        }\n+\n+        // Eventually the resource_map should have a much lower memory usage because it has less malloc overhead\n+        BOOST_TEST(memusage::DynamicUsage(resource_map) <= memusage::DynamicUsage(std_map) * 90 / 100);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089291634",
      "id" : 1089291634,
      "in_reply_to_id" : 1087172548,
      "line" : 170,
      "node_id" : "PRRC_kwDOABII585A7UVy",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 170,
      "original_position" : 170,
      "original_start_line" : null,
      "path" : "src/test/pool_tests.cpp",
      "position" : 170,
      "pull_request_review_id" : 1273232771,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089291634/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-27T18:32:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089291634",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089308331"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089308331"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It's not actually used anywhere currently, but this is needed when move-assigning containers that use the allocator. The containers need to check in a move-assignment if the allocators `operator==` returns true or false, and if they return true it means that both containers use the same resource and they can just destroy lhs and then move the pointers of rhs to lhs without copying elements. When they don't compare equal when the resource is different, all the objects in rhs need to be recreated.\r\n\r\nThe best explanation that I found for this stuff is this post from Howard Hinnant (he wrote `std::chrono` among other things) : https://stackoverflow.com/a/27472502/48181",
      "commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "created_at" : "2023-01-27T18:52:43Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;\n+\n+    template <class U>\n+    PoolAllocator(const PoolAllocator<U, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& other) noexcept\n+        : m_resource(other.resource())\n+    {\n+    }\n+\n+    /**\n+     * The rebind struct here is mandatory because we use non type template arguments for\n+     * PoolAllocator. See https://en.cppreference.com/w/cpp/named_req/Allocator#cite_note-2\n+     */\n+    template <typename U>\n+    struct rebind {\n+        using other = PoolAllocator<U, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+    };\n+\n+    /**\n+     * Forwards each call to the resource.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        return static_cast<T*>(m_resource->Allocate(n * sizeof(T), alignof(T)));\n+    }\n+\n+    /**\n+     * Forwards each call to the resource.\n+     */\n+    void deallocate(T* p, size_t n) noexcept\n+    {\n+        m_resource->Deallocate(p, n * sizeof(T), alignof(T));\n+    }\n+\n+    ResourceType* resource() const noexcept\n+    {\n+        return m_resource;\n+    }\n+};\n+\n+template <class T1, class T2, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+bool operator==(const PoolAllocator<T1, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& a,\n+                const PoolAllocator<T2, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& b) noexcept\n+{\n+    return a.resource() == b.resource();\n+}\n+\n+template <class T1, class T2, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+bool operator!=(const PoolAllocator<T1, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& a,\n+                const PoolAllocator<T2, MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>& b) noexcept\n+{",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089308331",
      "id" : 1089308331,
      "in_reply_to_id" : 1086988389,
      "line" : 354,
      "node_id" : "PRRC_kwDOABII585A7Yar",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 354,
      "original_position" : 354,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 354,
      "pull_request_review_id" : 1273277158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089308331/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-27T18:52:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089308331",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK e7158613dcafd0065a94b03c8013ee4ced8ec3e3 per `git range-diff 4b51290 80722d8 e715861`\r\n",
      "created_at" : "2023-01-27T21:30:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1407093805",
      "id" : 1407093805,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585T3owt",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1407093805/reactions"
      },
      "updated_at" : "2023-01-27T22:26:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1407093805",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089464988"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089464988"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Moving is useless for this class, as all it holds is a pointer as member variable. Copying and moving a pointer is the same.",
      "commit_id" : "e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-27T21:45:25Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089464988",
      "id" : 1089464988,
      "in_reply_to_id" : 1086981056,
      "line" : 296,
      "node_id" : "PRRC_kwDOABII585A7-qc",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 296,
      "original_position" : 305,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 296,
      "pull_request_review_id" : 1273528688,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089464988/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-27T21:45:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089464988",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089475233"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089475233"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Thanks. I wondered if the move constructor is used, because while this branch compiles for me (Clang 15 on ARM64) with the move assignment disabled (`PoolAllocator& operator=(PoolAllocator&&) noexcept = delete;`), it doesn't build with the move constructor disabled (`PoolAllocator(PoolAllocator&&) noexcept = delete;`).\r\n\r\n```\r\n./coins.h:230:33: note: in instantiation of member function 'std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher, std::equal_to<COutPoint>, PoolAllocator<std::pair<const COutPoint, CCoinsCacheEntry>, 128, 8>>::unordered_map' requested here\r\n    mutable CCoinsMap cacheCoins{0, CCoinsMap::hasher{}, CCoinsMap::key_equal{}, &m_cache_coins_memory_resource};\r\n                                ^\r\n./support/allocators/pool.h:297:5: note: 'PoolAllocator' has been explicitly marked deleted here\r\n    PoolAllocator(PoolAllocator&&) noexcept = delete;\r\n    ^\r\n1 error generated.\r\n```",
      "commit_id" : "e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-27T21:59:55Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089475233",
      "id" : 1089475233,
      "in_reply_to_id" : 1086981056,
      "line" : 296,
      "node_id" : "PRRC_kwDOABII585A8BKh",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 296,
      "original_position" : 305,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 296,
      "pull_request_review_id" : 1273544582,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089475233/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-27T21:59:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089475233",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-27T22:07:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1407124835",
      "id" : 1407124835,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585T3wVj",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1407124835/reactions"
      },
      "updated_at" : "2023-01-27T22:07:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1407124835",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646554"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646554"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "commit_id" : "e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-28T05:19:16Z",
      "diff_hunk" : "@@ -112,6 +112,7 @@ BITCOIN_TESTS =\\\n   test/net_peer_eviction_tests.cpp \\\n   test/net_tests.cpp \\\n   test/netbase_tests.cpp \\\n+  test/pool_tests.cpp \\",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646554",
      "id" : 1089646554,
      "in_reply_to_id" : 1083220507,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585A8q_a",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 115,
      "original_position" : 4,
      "original_start_line" : null,
      "path" : "src/Makefile.test.include",
      "position" : null,
      "pull_request_review_id" : 1273801553,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646554/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-28T05:19:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646554",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646562"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646562"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "commit_id" : "e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-28T05:19:22Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646562",
      "id" : 1089646562,
      "in_reply_to_id" : 1084564591,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585A8q_i",
      "original_commit_id" : "2bbe0f8eeae274fc30d924c6762cbb7a392f3b32",
      "original_line" : 225,
      "original_position" : 225,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1273801557,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646562/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-28T05:19:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646562",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646577"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646577"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "commit_id" : "e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-28T05:19:28Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646577",
      "id" : 1089646577,
      "in_reply_to_id" : 1085963632,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585A8q_x",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 261,
      "original_position" : 261,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1273801564,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646577/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-28T05:19:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646577",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646584"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646584"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "commit_id" : "e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-28T05:19:35Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646584",
      "id" : 1089646584,
      "in_reply_to_id" : 1085967553,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585A8q_4",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1273801573,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646584/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-28T05:19:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646584",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646608"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646608"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "commit_id" : "e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-28T05:19:42Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089646608",
      "id" : 1089646608,
      "in_reply_to_id" : 1085970688,
      "line" : null,
      "node_id" : "PRRC_kwDOABII585A8rAQ",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 105,
      "original_position" : 105,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : null,
      "pull_request_review_id" : 1273801589,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646608/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-28T05:19:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089646608",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089647580"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089647580"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think the problem with adding the `PoolAllocator(PoolAllocator&&) noexcept = delete;` is that it makes the function available for overload resolution, but if its chosen the compilation fails https://stackoverflow.com/a/35406415/48181",
      "commit_id" : "e7158613dcafd0065a94b03c8013ee4ced8ec3e3",
      "created_at" : "2023-01-28T05:23:43Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2022 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_POOL_H\n+\n+#include <array>\n+#include <cassert>\n+#include <cstddef>\n+#include <list>\n+#include <memory>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+/**\n+ * A memory resource similar to std::pmr::unsynchronized_pool_resource, but\n+ * optimized for node-based containers. It has the following properties:\n+ *\n+ * * Owns the allocated memory and frees it on destruction, even when deallocate\n+ *   has not been called on the allocated blocks.\n+ *\n+ * * Consists of a number of pools, each one for a different block size.\n+ *   Each pool holds blocks of uniform size in a freelist.\n+ *\n+ * * Exhausting memory in a freelist causes a new allocation of a fixed size chunk.\n+ *   This chunk is used to carve out blocks.\n+ *\n+ * * Block sizes or alignments that can not be served by the pools are allocated\n+ *   and deallocated by operator new().\n+ *\n+ * PoolResource is not thread-safe. It is intended to be used by PoolAllocator.\n+ *\n+ * @tparam MAX_BLOCK_SIZE_BYTES Maximum size to allocate with the pool. If larger\n+ *         sizes are requested, allocation falls back to new().\n+ *\n+ * @tparam ALIGN_BYTES Required alignment for the allocations.\n+ *\n+ * An example: If you create a PoolResource<128, 8>(262144) and perform a bunch of\n+ * allocations and deallocate 2 blocks with size 8 bytes, and 3 blocks with size 16,\n+ * the members will look like this:\n+ *\n+ *     m_free_lists                         m_allocated_chunks\n+ *        âââââ                                âââââ  âââââââââââââ-------âââââââ\n+ *        â   â  blocks                        â   âââºâ    262144 B             â\n+ *        â   â  âââââââ  âââââââ              âââ¬ââ  âââââââââââââ-------âââââââ\n+ *        â 1 âââºâ 8 B âââºâ 8 B â                â\n+ *        â   â  âââââââ  âââââââ                :\n+ *        â   â                                  â\n+ *        â   â  âââââââ  âââââââ  âââââââ       â¼\n+ *        â 2 âââºâ16 B âââºâ16 B âââºâ16 B â     âââââ  âââââââââââââââââââââââââââ\n+ *        â   â  âââââââ  âââââââ  âââââââ     â   âââºâ          â²              â â²\n+ *        â   â                                âââââ  ââââââââââââ¬âââââââââââââââ â\n+ *        â . â                                                  â    m_available_memory_end\n+ *        â . â                                         m_available_memory_it\n+ *        â . â\n+ *        â   â\n+ *        â   â\n+ *        â16 â\n+ *        âââââ\n+ *\n+ * Here m_free_lists[1] holds the 2 blocks of size 8 bytes, and m_free_lists[2]\n+ * holds the 3 blocks of size 16. The blocks came from the data stored in the\n+ * m_allocated_chunks list. Each chunk has bytes 262144. The last chunk has still\n+ * some memory available for the blocks, and when m_available_memory_it is at the\n+ * end, a new chunk will be allocated and added to the list.\n+ */\n+template <std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolResource final\n+{\n+    static_assert(ALIGN_BYTES > 0, \"ALIGN_BYTES must be nonzero\");\n+    static_assert((ALIGN_BYTES & (ALIGN_BYTES - 1)) == 0, \"ALIGN_BYTES must be a power of two\");\n+\n+    /**\n+     * In-place linked list of the allocations, used for the freelist.\n+     */\n+    struct ListNode {\n+        ListNode* m_next;\n+\n+        explicit ListNode(ListNode* next) : m_next(next) {}\n+    };\n+    static_assert(std::is_trivially_destructible_v<ListNode>, \"Make sure we don't need to manually call a destructor\");\n+\n+    /**\n+     * Internal alignment value. The larger of the requested ALIGN_BYTES and alignof(FreeList).\n+     */\n+    static constexpr std::size_t ELEM_ALIGN_BYTES = std::max(alignof(ListNode), ALIGN_BYTES);\n+    static_assert((ELEM_ALIGN_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"ELEM_ALIGN_BYTES must be a power of two\");\n+    static_assert(sizeof(ListNode) <= ELEM_ALIGN_BYTES, \"Units of size ELEM_SIZE_ALIGN need to be able to store a ListNode\");\n+    static_assert((MAX_BLOCK_SIZE_BYTES & (ELEM_ALIGN_BYTES - 1)) == 0, \"MAX_BLOCK_SIZE_BYTES needs to be a multiple of the alignment.\");\n+\n+    /**\n+     * Size in bytes to allocate per chunk\n+     */\n+    const size_t m_chunk_size_bytes;\n+\n+    /**\n+     * Contains all allocated pools of memory, used to free the data in the destructor.\n+     */\n+    std::list<std::byte*> m_allocated_chunks{};\n+\n+    /**\n+     * Single linked lists of all data that came from deallocating.\n+     * m_free_lists[n] will serve blocks of size n*BLOCK_ALIGNMENT_BYTES.\n+     */\n+    std::array<ListNode*, MAX_BLOCK_SIZE_BYTES / ELEM_ALIGN_BYTES + 1> m_free_lists{};\n+\n+    /**\n+     * Points to the beginning of available memory for carving out allocations.\n+     */\n+    std::byte* m_available_memory_it = nullptr;\n+\n+    /**\n+     * Points to the end of available memory for carving out allocations.\n+     *\n+     * That member variable is redundant, and is always equal to `m_allocated_chunks.back().get() + CHUNK_SIZE_BYTES`\n+     * whenever it is accessed, but `m_untouched_memory_end` caches this for clarity and efficiency.\n+     */\n+    std::byte* m_available_memory_end = nullptr;\n+\n+    /**\n+     * How many multiple of ELEM_ALIGN_BYTES are necessary to fit bytes. We use that result directly as an index\n+     * into m_free_lists.\n+     */\n+    [[nodiscard]] static constexpr std::size_t NumElemAlignBytes(std::size_t bytes)\n+    {\n+        return (bytes + ELEM_ALIGN_BYTES - 1) / ELEM_ALIGN_BYTES;\n+    }\n+\n+    /**\n+     * True when it is possible to make use of the freelist\n+     */\n+    [[nodiscard]] static constexpr bool IsFreeListUsable(std::size_t bytes, std::size_t alignment)\n+    {\n+        return alignment <= ELEM_ALIGN_BYTES && bytes <= MAX_BLOCK_SIZE_BYTES;\n+    }\n+\n+    /**\n+     * Replaces node with placement constructed ListNode that points to the previous node\n+     */\n+    void PlacementAddToList(void* p, ListNode*& node)\n+    {\n+        node = new (p) ListNode{node};\n+    }\n+\n+    /**\n+     * Allocate one full memory chunk which will be used to carve out allocations.\n+     * Also puts any leftover bytes into the freelist.\n+     *\n+     * Precondition: leftover bytes are either 0 or few enough to fit into a place in the freelist\n+     */\n+    void AllocateChunk()\n+    {\n+        // if there is still any available memory is left, put it into the freelist.\n+        size_t remaining_available_bytes = std::distance(m_available_memory_it, m_available_memory_end);\n+        if (0 != remaining_available_bytes) {\n+            PlacementAddToList(m_available_memory_it, m_free_lists[remaining_available_bytes / ELEM_ALIGN_BYTES]);\n+        }\n+\n+        void* storage = ::operator new (m_chunk_size_bytes, std::align_val_t{ELEM_ALIGN_BYTES});\n+        m_available_memory_it = new (storage) std::byte[m_chunk_size_bytes];\n+        m_available_memory_end = m_available_memory_it + m_chunk_size_bytes;\n+        m_allocated_chunks.emplace_back(m_available_memory_it);\n+    }\n+\n+    /**\n+     * Access to internals for testing purpose only\n+     */\n+    friend class PoolResourceTester;\n+\n+public:\n+    /**\n+     * Construct a new PoolResource object which allocates the first chunk.\n+     * chunk_size_bytes will be rounded up to next multiple of ELEM_ALIGN_BYTES.\n+     */\n+    explicit PoolResource(std::size_t chunk_size_bytes)\n+        : m_chunk_size_bytes(NumElemAlignBytes(chunk_size_bytes) * ELEM_ALIGN_BYTES)\n+    {\n+        assert(m_chunk_size_bytes >= MAX_BLOCK_SIZE_BYTES);\n+        AllocateChunk();\n+    }\n+\n+    /**\n+     * Construct a new Pool Resource object, defaults to 2^18=262144 chunk size.\n+     */\n+    PoolResource() : PoolResource(262144) {}\n+\n+    /**\n+     * Disable copy & move semantics, these are not supported for the resource.\n+     */\n+    PoolResource(const PoolResource&) = delete;\n+    PoolResource& operator=(const PoolResource&) = delete;\n+    PoolResource(PoolResource&&) = delete;\n+    PoolResource& operator=(PoolResource&&) = delete;\n+\n+    /**\n+     * Deallocates all memory allocated associated with the memory resource.\n+     */\n+    ~PoolResource()\n+    {\n+        for (std::byte* chunk : m_allocated_chunks) {\n+            std::destroy(chunk, chunk + m_chunk_size_bytes);\n+            ::operator delete ((void*)chunk, std::align_val_t{ELEM_ALIGN_BYTES});\n+        }\n+    }\n+\n+    /**\n+     * Allocates a block of bytes. If possible the freelist is used, otherwise allocation\n+     * is forwarded to ::operator new().\n+     */\n+    void* Allocate(std::size_t bytes, std::size_t alignment)\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            if (nullptr != m_free_lists[num_alignments]) {\n+                // we've already got data in the pool's freelist, unlink one element and return the pointer\n+                // to the unlinked memory. Since FreeList is trivially destructible we can just treat it as\n+                // uninitialized memory.\n+                return std::exchange(m_free_lists[num_alignments], m_free_lists[num_alignments]->m_next);\n+            }\n+\n+            // freelist is empty: get one allocation from allocated chunk memory.\n+            const size_t round_bytes = num_alignments * ELEM_ALIGN_BYTES;\n+            if (m_available_memory_it + round_bytes > m_available_memory_end) {\n+                // slow path, only happens when a new chunk needs to be allocated\n+                AllocateChunk();\n+            }\n+\n+            // Make sure we use the right amount of bytes for that freelist (might be rounded up),\n+            return std::exchange(m_available_memory_it, m_available_memory_it + round_bytes);\n+        }\n+\n+        // Can't use the pool => use operator new()\n+        return ::operator new (bytes, std::align_val_t{alignment});\n+    }\n+\n+    /**\n+     * Returns a block to the freelists, or deletes the block when it did not come from the chunks.\n+     */\n+    void Deallocate(void* p, std::size_t bytes, std::size_t alignment) noexcept\n+    {\n+        if (IsFreeListUsable(bytes, alignment)) {\n+            const std::size_t num_alignments = NumElemAlignBytes(bytes);\n+            // put the memory block into the linked list. We can placement construct the FreeList\n+            // into the memory since we can be sure the alignment is correct.\n+            PlacementAddToList(p, m_free_lists[num_alignments]);\n+        } else {\n+            // Can't use the pool => forward deallocation to ::operator delete().\n+            ::operator delete (p, std::align_val_t{alignment});\n+        }\n+    }\n+\n+    /**\n+     * Memory allocated by one resource cannot be deallocated by another, so return\n+     * true only for the same object.\n+     */\n+    bool IsEqual(const PoolResource& other) const noexcept\n+    {\n+        return this == &other;\n+    }\n+\n+    /**\n+     * Number of allocated chunks\n+     */\n+    [[nodiscard]] std::size_t NumAllocatedChunks() const\n+    {\n+        return m_allocated_chunks.size();\n+    }\n+\n+    /**\n+     * Size in bytes to allocate per chunk, currently hardcoded to a fixed size.\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+};\n+\n+\n+/**\n+ * Forwards all allocations/deallocations to the PoolResource.\n+ */\n+template <class T, std::size_t MAX_BLOCK_SIZE_BYTES, std::size_t ALIGN_BYTES>\n+class PoolAllocator\n+{\n+    PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>* m_resource;\n+\n+    template <typename U, std::size_t M, std::size_t A>\n+    friend class PoolAllocator;\n+\n+public:\n+    using value_type = T;\n+    using ResourceType = PoolResource<MAX_BLOCK_SIZE_BYTES, ALIGN_BYTES>;\n+\n+    /**\n+     * Not explicit so we can easily construct it with the correct resource\n+     */\n+    PoolAllocator(ResourceType* resource) noexcept\n+        : m_resource(resource)\n+    {\n+    }\n+\n+    PoolAllocator(const PoolAllocator& other) noexcept = default;\n+    PoolAllocator& operator=(const PoolAllocator& other) noexcept = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#discussion_r1089647580",
      "id" : 1089647580,
      "in_reply_to_id" : 1086981056,
      "line" : 296,
      "node_id" : "PRRC_kwDOABII585A8rPc",
      "original_commit_id" : "80722d838f9a5fdbbbd82f97d353e45b5d375ad8",
      "original_line" : 296,
      "original_position" : 305,
      "original_start_line" : null,
      "path" : "src/support/allocators/pool.h",
      "position" : 296,
      "pull_request_review_id" : 1273802345,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25325",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089647580/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2023-01-28T05:23:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1089647580",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for reviewing @jonatack and @sipa! I've addressed all comments with e715861",
      "created_at" : "2023-01-28T05:24:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1407297445",
      "id" : 1407297445,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585T4ael",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1407297445/reactions"
      },
      "updated_at" : "2023-01-28T05:24:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1407297445",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Needs (fairly trivial) rebase after merge of #17487.",
      "created_at" : "2023-01-30T16:21:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1408930176",
      "id" : 1408930176,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585T-pGA",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1408930176/reactions"
      },
      "updated_at" : "2023-01-30T16:21:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1408930176",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-01-30T17:05:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1408992234",
      "id" : 1408992234,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585T-4Pq",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1408992234/reactions"
      },
      "updated_at" : "2023-01-30T17:05:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1408992234",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased to resolve conflicts, diff should be viewable with `git range-diff 82903a7 e715861 f58a5eee6f`",
      "created_at" : "2023-01-30T17:21:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409017964",
      "id" : 1409017964,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585T--hs",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409017964/reactions"
      },
      "updated_at" : "2023-01-30T17:21:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409017964",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "<strike>re-ACK f58a5eee6ff69582d6e46e93dd52e07202d257a8</strike>\r\n\r\nThe unit test CI failures look unrelated -- I didn't reproduce them running `make check` locally (Clang 15 on ARM64). \r\n\r\nEdit: there are now more of the failures and some seem related.",
      "created_at" : "2023-01-30T17:53:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409063626",
      "id" : 1409063626,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585T_JrK",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409063626/reactions"
      },
      "updated_at" : "2023-01-30T19:00:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409063626",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Hm it looks like in some environments the new check fails:\r\n```\r\ncoins_tests.cpp(984): error: in \"coins_tests/ccoins_flush_behavior\": check view->DynamicMemoryUsage() < cache_usage has failed\r\n```\r\n\r\nI think the problem is this: The test from @jamesob assumes that memory usage goes down when the cache is flushed. But the pool is internally using chunks of 262144 bytes, and when flushed this memory block will be deallocated but might be allocated again right away when the map is created, so memory usage doesn't necessarily change. E.g. in Windows some control block is immediately allocated for the map, and this makes the pool allocator allocate its first chunk",
      "created_at" : "2023-01-30T18:12:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409090307",
      "id" : 1409090307,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585T_QMD",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409090307/reactions"
      },
      "updated_at" : "2023-01-30T18:33:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409090307",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Fixup LGTM modulo squashing. The remaining CI failures are due to https://cirrus-ci.com/task/5963593934438400 (that seems unrelated?) and to https://github.com/bitcoin/bitcoin/issues/27001 that should be fixed in https://github.com/bitcoin/bitcoin/pull/26998.",
      "created_at" : "2023-01-30T20:58:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409322773",
      "id" : 1409322773,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585UAI8V",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409322773/reactions"
      },
      "updated_at" : "2023-01-30T21:04:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409322773",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-01-30T23:33:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409521445",
      "id" : 1409521445,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585UA5cl",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409521445/reactions"
      },
      "updated_at" : "2023-01-30T23:33:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409521445",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Squashed and rebased again due to #26999\r\n\r\nSee the full range-diff after the 2 rebases: `git range-diff ceb74b8 e715861 c25a754b`\r\n\r\nBiggest change was updating the method `TestFlushBehavior` in coins_test.cpp",
      "created_at" : "2023-01-31T06:11:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1409824656",
      "id" : 1409824656,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585UCDeQ",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409824656/reactions"
      },
      "updated_at" : "2023-01-31T06:11:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1409824656",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "re-ACK 0007d69f249068a14b9b5a97d46ace9dabdc2c8b",
      "created_at" : "2023-01-31T22:16:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1411143425",
      "id" : 1411143425,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585UHFcB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1411143425/reactions"
      },
      "updated_at" : "2023-01-31T22:16:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1411143425",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "FWIW, I rebased this on top of #27011, and am running a few CPU cores on it. No issues so far.",
      "created_at" : "2023-02-02T20:56:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1414360875",
      "id" : 1414360875,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585UTW8r",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1414360875/reactions"
      },
      "updated_at" : "2023-02-02T20:56:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1414360875",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-02-13T15:34:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1428150986",
      "id" : 1428150986,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585VH9rK",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1428150986/reactions"
      },
      "updated_at" : "2023-02-13T15:34:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1428150986",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased due to #27011. Note that this adds a `/*deterministic=*/true` [here in test/fuzz/coins_view.cpp](https://github.com/bitcoin/bitcoin/pull/25325/commits/78f597be2879c39d9d2b98e21ed0120d2308de20#diff-1ef3b6a1936b50f3d5ec4a1786d9e2d63d1a3e1815b103e67f20601995f355b4R119), see `git range-diff 0007d69...78f597b`",
      "created_at" : "2023-02-14T08:04:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1429293948",
      "id" : 1429293948,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585VMUt8",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1429293948/reactions"
      },
      "updated_at" : "2023-02-14T08:04:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1429293948",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n",
      "created_at" : "2023-02-15T15:49:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1431581351",
      "id" : 1431581351,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585VVDKn",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1431581351/reactions"
      },
      "updated_at" : "2023-02-15T15:49:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1431581351",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "yet another rebase, only dropping the \"Add xoroshiro128++ PRNG\" commit which has already been added in #26153 (commit 5f05b27841af0bed1b6e7de5f46ffe33e5919e4d)",
      "created_at" : "2023-02-15T18:07:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25325#issuecomment-1431795348",
      "id" : 1431795348,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25325",
      "node_id" : "IC_kwDOABII585VV3aU",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1431795348/reactions"
      },
      "updated_at" : "2023-02-15T18:07:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1431795348",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   }
]
