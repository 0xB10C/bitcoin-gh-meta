[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833461415"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833461415"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think you can just assign to `orig_txid_2` to minimize the diff (also elsewhere)",
      "commit_id" : "44481fb3fd609ff520bc8d2736e0e57c55541924",
      "created_at" : "2022-03-23T16:15:23Z",
      "diff_hunk" : "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833461415",
      "id" : 833461415,
      "line" : 407,
      "node_id" : "PRRC_kwDOABII584xrZyn",
      "original_commit_id" : "a15663362368b8452bdb035815bb36f09fbd7689",
      "original_line" : 407,
      "original_position" : 268,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : 261,
      "pull_request_review_id" : 919057464,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833461415/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-23T16:15:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833461415",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833461590"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833461590"
         }
      },
      "author_association" : "MEMBER",
      "body" : "?",
      "commit_id" : "44481fb3fd609ff520bc8d2736e0e57c55541924",
      "created_at" : "2022-03-23T16:15:33Z",
      "diff_hunk" : "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # Flush old notifications until evicted tx original entry\n+        (hash_str, label, mempool_seq) = seq.receive_sequence()\n+        while hash_str != orig_tx['txid']:\n+<<<<<<< HEAD\n+>>>>>>> ec13426c0d (self_transfer)\n+=======\n+>>>>>>> ead059e477 ([move only] remove `is_wallet_compiled` checks)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833461590",
      "id" : 833461590,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xrZ1W",
      "original_commit_id" : "a15663362368b8452bdb035815bb36f09fbd7689",
      "original_line" : 417,
      "original_position" : 276,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : null,
      "pull_request_review_id" : 919057464,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833461590/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-23T16:15:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833461590",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833462771"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833462771"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "whoops! fixing",
      "commit_id" : "44481fb3fd609ff520bc8d2736e0e57c55541924",
      "created_at" : "2022-03-23T16:16:27Z",
      "diff_hunk" : "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # Flush old notifications until evicted tx original entry\n+        (hash_str, label, mempool_seq) = seq.receive_sequence()\n+        while hash_str != orig_tx['txid']:\n+<<<<<<< HEAD\n+>>>>>>> ec13426c0d (self_transfer)\n+=======\n+>>>>>>> ead059e477 ([move only] remove `is_wallet_compiled` checks)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833462771",
      "id" : 833462771,
      "in_reply_to_id" : 833461590,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584xraHz",
      "original_commit_id" : "a15663362368b8452bdb035815bb36f09fbd7689",
      "original_line" : 417,
      "original_position" : 276,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : null,
      "pull_request_review_id" : 919059221,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833462771/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-23T16:16:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833462771",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833492049"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833492049"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "fixed! in the other cases where i reassign, i belive its because i need both the txid, wtxid, and tx body. but ill double check",
      "commit_id" : "44481fb3fd609ff520bc8d2736e0e57c55541924",
      "created_at" : "2022-03-23T16:44:01Z",
      "diff_hunk" : "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833492049",
      "id" : 833492049,
      "in_reply_to_id" : 833461415,
      "line" : 407,
      "node_id" : "PRRC_kwDOABII584xrhRR",
      "original_commit_id" : "a15663362368b8452bdb035815bb36f09fbd7689",
      "original_line" : 407,
      "original_position" : 268,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : 261,
      "pull_request_review_id" : 919100082,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833492049/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-23T16:44:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833492049",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833559426"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833559426"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "okay, in https://github.com/bitcoin/bitcoin/pull/24653/commits/7f943aa1e0543765f499b2f50697281d5fe22adf ive got the diff down",
      "commit_id" : "44481fb3fd609ff520bc8d2736e0e57c55541924",
      "created_at" : "2022-03-23T17:47:44Z",
      "diff_hunk" : "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833559426",
      "id" : 833559426,
      "in_reply_to_id" : 833461415,
      "line" : 407,
      "node_id" : "PRRC_kwDOABII584xrxuC",
      "original_commit_id" : "a15663362368b8452bdb035815bb36f09fbd7689",
      "original_line" : 407,
      "original_position" : 268,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : 261,
      "pull_request_review_id" : 919196158,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833559426/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-23T17:47:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833559426",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7444140?v=4",
         "events_url" : "https://api.github.com/users/josibake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/josibake/followers",
         "following_url" : "https://api.github.com/users/josibake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/josibake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/josibake",
         "id" : 7444140,
         "login" : "josibake",
         "node_id" : "MDQ6VXNlcjc0NDQxNDA=",
         "organizations_url" : "https://api.github.com/users/josibake/orgs",
         "received_events_url" : "https://api.github.com/users/josibake/received_events",
         "repos_url" : "https://api.github.com/users/josibake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/josibake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/josibake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/josibake"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833947744"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833947744"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think this is fixed?",
      "commit_id" : "44481fb3fd609ff520bc8d2736e0e57c55541924",
      "created_at" : "2022-03-24T06:10:44Z",
      "diff_hunk" : "@@ -326,126 +324,126 @@ def test_sequence(self):\n         assert_equal((self.nodes[1].getblockhash(block_count), \"C\", None), seq.receive_sequence())\n \n         # Rest of test requires wallet functionality\n-        if self.is_wallet_compiled():\n-            self.log.info(\"Wait for tx from second node\")\n-            payment_txid = self.nodes[1].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=5.0, replaceable=True)\n-            self.sync_all()\n-            self.log.info(\"Testing sequence notifications with mempool sequence values\")\n-\n-            # Should receive the broadcasted txid.\n-            assert_equal((payment_txid, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            self.log.info(\"Testing RBF notification\")\n-            # Replace it to test eviction/addition notification\n-            rbf_info = self.nodes[1].bumpfee(payment_txid)\n-            self.sync_all()\n-            assert_equal((payment_txid, \"R\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n-            # though the mempool sequence number does go up by the number of transactions\n-            # removed from the mempool by the block mining it.\n-            mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n-            # Make sure the number of mined transactions matches the number of txs out of mempool\n-            mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n-            assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n-            seq_num += mempool_size_delta\n-            payment_txid_2 = self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-            self.sync_all()\n-            assert_equal((c_block, \"C\", None), seq.receive_sequence())\n-            assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Spot check getrawmempool results that they only show up when asked for\n-            assert type(self.nodes[0].getrawmempool()) is list\n-            assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n-            assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n-            assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n-            assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n-\n-            self.log.info(\"Testing reorg notifications\")\n-            # Manually invalidate the last block to test mempool re-entry\n-            # N.B. This part could be made more lenient in exact ordering\n-            # since it greatly depends on inner-workings of blocks/mempool\n-            # during \"deep\" re-orgs. Probably should \"re-construct\"\n-            # blockchain/mempool state from notifications instead.\n-            block_count = self.nodes[0].getblockcount()\n-            best_hash = self.nodes[0].getbestblockhash()\n-            self.nodes[0].invalidateblock(best_hash)\n-            sleep(2)  # Bit of room to make sure transaction things happened\n-\n-            # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n-            # of the time they were gathered.\n-            assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n-\n-            assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n-            assert_equal((rbf_info[\"txid\"], \"A\", seq_num), seq.receive_sequence())\n-            seq_num += 1\n-\n-            # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n-            self.nodes[0].reconsiderblock(best_hash)\n-            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n-\n-            self.log.info(\"Evict mempool transaction by block conflict\")\n-            orig_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # More to be simply mined\n-            more_tx = []\n-            for _ in range(5):\n-                more_tx.append(self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 0.1))\n-\n-            raw_tx = self.nodes[0].getrawtransaction(orig_txid)\n-            bump_info = self.nodes[0].bumpfee(orig_txid)\n-            # Mine the pre-bump tx\n-            txs_to_add = [raw_tx] + [self.nodes[0].getrawtransaction(txid) for txid in more_tx]\n-            block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n-            add_witness_commitment(block)\n-            block.solve()\n-            assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n-            tip = self.nodes[0].getbestblockhash()\n-            assert_equal(int(tip, 16), block.sha256)\n-            orig_txid_2 = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=1.0, replaceable=True)\n-\n-            # Flush old notifications until evicted tx original entry\n+        self.log.info(\"Wait for tx from second node\")\n+        payment_tx = self.wallet.send_self_transfer(from_node=self.nodes[1])\n+        self.sync_all()\n+        self.log.info(\"Testing sequence notifications with mempool sequence values\")\n+\n+        # Should receive the broadcasted txid.\n+        assert_equal((payment_tx['txid'], \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        self.log.info(\"Testing RBF notification\")\n+        # Replace it to test eviction/addition notification\n+        payment_tx['tx'].vout[0].nValue -= 1000\n+        rbf_txid = self.nodes[1].sendrawtransaction(payment_tx['tx'].serialize().hex())\n+        self.sync_all()\n+        assert_equal((payment_tx['txid'], \"R\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Doesn't get published when mined, make a block and tx to \"flush\" the possibility\n+        # though the mempool sequence number does go up by the number of transactions\n+        # removed from the mempool by the block mining it.\n+        mempool_size = len(self.nodes[0].getrawmempool())\n+        c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        # Make sure the number of mined transactions matches the number of txs out of mempool\n+        mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n+        assert_equal(len(self.nodes[0].getblock(c_block)[\"tx\"])-1, mempool_size_delta)\n+        seq_num += mempool_size_delta\n+        payment_txid_2 = self.wallet.send_self_transfer(from_node=self.nodes[1])['txid']\n+        self.sync_all()\n+        assert_equal((c_block, \"C\", None), seq.receive_sequence())\n+        assert_equal((payment_txid_2, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Spot check getrawmempool results that they only show up when asked for\n+        assert type(self.nodes[0].getrawmempool()) is list\n+        assert type(self.nodes[0].getrawmempool(mempool_sequence=False)) is list\n+        assert \"mempool_sequence\" not in self.nodes[0].getrawmempool(verbose=True)\n+        assert_raises_rpc_error(-8, \"Verbose results cannot contain mempool sequence values.\", self.nodes[0].getrawmempool, True, True)\n+        assert_equal(self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"], seq_num)\n+\n+        self.log.info(\"Testing reorg notifications\")\n+        # Manually invalidate the last block to test mempool re-entry\n+        # N.B. This part could be made more lenient in exact ordering\n+        # since it greatly depends on inner-workings of blocks/mempool\n+        # during \"deep\" re-orgs. Probably should \"re-construct\"\n+        # blockchain/mempool state from notifications instead.\n+        block_count = self.nodes[0].getblockcount()\n+        best_hash = self.nodes[0].getbestblockhash()\n+        self.nodes[0].invalidateblock(best_hash)\n+        sleep(2)  # Bit of room to make sure transaction things happened\n+\n+        # Make sure getrawmempool mempool_sequence results aren't \"queued\" but immediately reflective\n+        # of the time they were gathered.\n+        assert self.nodes[0].getrawmempool(mempool_sequence=True)[\"mempool_sequence\"] > seq_num\n+\n+        assert_equal((best_hash, \"D\", None), seq.receive_sequence())\n+        assert_equal((rbf_txid, \"A\", seq_num), seq.receive_sequence())\n+        seq_num += 1\n+\n+        # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n+        self.nodes[0].reconsiderblock(best_hash)\n+        self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        self.log.info(\"Evict mempool transaction by block conflict\")\n+        orig_tx = self.wallet.send_self_transfer(from_node=self.nodes[0])\n+\n+        # More to be simply mined\n+        more_tx = []\n+        for _ in range(5):\n+            more_tx.append(self.wallet.send_self_transfer(from_node=self.nodes[0]))\n+\n+        orig_tx['tx'].vout[0].nValue -= 1000\n+        bump_txid = self.nodes[0].sendrawtransaction(orig_tx['tx'].serialize().hex())\n+        # Mine the pre-bump tx\n+        txs_to_add = [orig_tx['hex']] + [tx['hex'] for tx in more_tx]\n+        block = create_block(int(self.nodes[0].getbestblockhash(), 16), create_coinbase(self.nodes[0].getblockcount()+1), txlist=txs_to_add)\n+        add_witness_commitment(block)\n+        block.solve()\n+        assert_equal(self.nodes[0].submitblock(block.serialize().hex()), None)\n+        tip = self.nodes[0].getbestblockhash()\n+        assert_equal(int(tip, 16), block.sha256)\n+        orig_tx_2 = self.wallet.send_self_transfer(from_node=self.nodes[0])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/24653#discussion_r833947744",
      "id" : 833947744,
      "in_reply_to_id" : 833461415,
      "line" : 407,
      "node_id" : "PRRC_kwDOABII584xtQhg",
      "original_commit_id" : "a15663362368b8452bdb035815bb36f09fbd7689",
      "original_line" : 407,
      "original_position" : 268,
      "original_start_line" : null,
      "path" : "test/functional/interface_zmq.py",
      "position" : 261,
      "pull_request_review_id" : 919754477,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/24653",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833947744/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-03-24T06:10:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/833947744",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   }
]
