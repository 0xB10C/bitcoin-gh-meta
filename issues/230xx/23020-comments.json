[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK\r\n\r\nThanks for working on this! Will review and test within the next days.",
      "created_at" : "2021-09-17T20:52:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-922074813",
      "id" : 922074813,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII58429b69",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-17T20:53:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/922074813",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK",
      "created_at" : "2021-09-20T20:18:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-923264745",
      "id" : 923264745,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5843B-bp",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-20T20:18:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/923264745",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "Concept ACK\r\n\r\nThis is great! Thanks",
      "created_at" : "2021-09-21T04:47:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-923620548",
      "id" : 923620548,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5843DVTE",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-21T04:47:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/923620548",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/24482484?v=4",
         "events_url" : "https://api.github.com/users/Rspigler/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Rspigler/followers",
         "following_url" : "https://api.github.com/users/Rspigler/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Rspigler/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Rspigler",
         "id" : 24482484,
         "login" : "Rspigler",
         "node_id" : "MDQ6VXNlcjI0NDgyNDg0",
         "organizations_url" : "https://api.github.com/users/Rspigler/orgs",
         "received_events_url" : "https://api.github.com/users/Rspigler/received_events",
         "repos_url" : "https://api.github.com/users/Rspigler/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Rspigler/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Rspigler/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Rspigler"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK\r\n\r\nHave you considered using the gpgme library (like https://github.com/bitcoin-core/bitcoin-maintainer-tools/blob/master/gitian-verify.py#L66 does) instead of parsing gpg command text output? I tried this approach and it became an awful mess, using the library is more robust, though it does introduce another Python dependency.",
      "created_at" : "2021-09-21T10:29:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-923848127",
      "id" : 923848127,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5843EM2_",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-21T11:34:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/923848127",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I guess I'm doing something wrong (on macOS 11.6)?\r\n\r\n```\r\n% contrib/verifybinaries/verify.py 22.0  \r\nWARNING: https://bitcoin.org failed to provide signature file. Continuing based solely upon https://bitcoincore.org.\r\nWARNING: https://bitcoin.org failed to provide SHA256SUMS file. Continuing based solely upon https://bitcoincore.org.\r\nTraceback (most recent call last):\r\n  File \"contrib/verifybinaries/verify.py\", line 568, in <module>\r\n    sys.exit(main(sys.argv[1:]))\r\n  File \"contrib/verifybinaries/verify.py\", line 418, in main\r\n    good, unknown, bad = parse_gpg_result(output.splitlines())\r\n  File \"contrib/verifybinaries/verify.py\", line 271, in parse_gpg_result\r\n    f\"failed to evaluate all signatures: found {all_found} \"\r\nRuntimeError: failed to evaluate all signatures: found 13 but expected 10\r\n```\r\n\r\nFor 0.21.1 the SHA256SUMS file is missing, only the signatures are there: https://bitcoincore.org/bin/bitcoin-core-0.21.1/\r\n\r\n```\r\n% contrib/verifybinaries/verify.py 0.21.1\r\nError: couldn't fetch SHA256SUMS file.\r\nwget output:\r\n  --2021-09-21 19:18:24--  https://bitcoincore.org/bin/bitcoin-core-0.21.1/SHA256SUMS\r\n  Herleiden van bitcoincore.org (bitcoincore.org)... 198.251.83.116, 107.191.99.5\r\n  Verbinding maken met bitcoincore.org (bitcoincore.org)|198.251.83.116|:443... verbonden.\r\n  HTTP-verzoek is verzonden; wachten op antwoord... 404 Not Found\r\n  2021-09-21 19:18:25 Fout 404: Not Found.\r\n  ```\r\n\r\nPS it would be nice to check the timestamp as well if opentimestamp is present.\r\n\r\n",
      "created_at" : "2021-09-21T17:21:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-924195592",
      "id" : 924195592,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5843FhsI",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-21T17:21:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/924195592",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Have you considered using the gpgme library\r\n\r\n@laanwj this is a good idea, I'll look into it. Initially I didn't want end users to have to futz with `pip` or extra Python package installation since it can get very confusing very fast for semi-technical users (and even just plain technical users), but it might be worth the complexity. I'll give that a shot and post the diff.\r\n\r\n> I guess I'm doing something wrong (on macOS 11.6)?\r\n\r\n@Sjors hm, interesting... I'm not able to reproduce on my Linux machine, but I'm betting there may be some formatting differences on different versions of GPG and/or macOS (which speaks to @laanwj's point about not relying on parsing output). Can you rerun with `--verbose` and send me the GPG output, either here or in DM?\r\n\r\n> For 0.21.1 the SHA256SUMS file is missing, only the signatures are there: https://bitcoincore.org/bin/bitcoin-core-0.21.1/\r\n\r\nOh, that's a really good point. We probably need to retain the legacy behavior for old releases. I'll work on this.",
      "created_at" : "2021-09-21T17:52:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-924221652",
      "id" : 924221652,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5843FoDU",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-21T17:52:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/924221652",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> PS it would be nice to check the timestamp as well if opentimestamp is present.\r\n\r\nLove that idea.",
      "created_at" : "2021-09-21T17:56:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-924224659",
      "id" : 924224659,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5843FoyT",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-21T17:56:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/924224659",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've pushed a fix for the first issue @Sjors discovered (signature miscounting) as well as a `logging` refactoring. A commit for legacy process support is coming soon, but this can still be tested with 22.0.",
      "created_at" : "2021-09-22T18:27:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-925180450",
      "id" : 925180450,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5843JSIi",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-22T18:27:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/925180450",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Much better, modulo somewhat scary warnings:\r\n```\r\n% contrib/verifybinaries/verify.py 22.0                                \r\n[WARNING] https://bitcoin.org failed to provide signature file. Continuing based solely upon https://bitcoincore.org.\r\n[WARNING] https://bitcoin.org failed to provide SHA256SUMS file. Continuing based solely upon https://bitcoincore.org.\r\n[WARNING] removing *-unsigned binaries (bitcoin-22.0-osx-unsigned.dmg, bitcoin-22.0-osx-unsigned.tar.gz, bitcoin-22.0-win-unsigned.tar.gz, bitcoin-22.0-win64-setup-unsigned.exe) from verification since https://bitcoincore.org does not host *-unsigned binaries\r\n[WARNING] removing *-debug binaries (bitcoin-22.0-aarch64-linux-gnu-debug.tar.gz, bitcoin-22.0-arm-linux-gnueabihf-debug.tar.gz, bitcoin-22.0-powerpc64-linux-gnu-debug.tar.gz, bitcoin-22.0-powerpc64le-linux-gnu-debug.tar.gz, bitcoin-22.0-riscv64-linux-gnu-debug.tar.gz, bitcoin-22.0-x86_64-linux-gnu-debug.tar.gz, bitcoin-22.0-win64-debug.zip) from verification since https://bitcoincore.org does not host *-debug binaries\r\n[WARNING] removing *-codesignatures binaries (bitcoin-22.0-codesignatures-22.0.tar.gz) from verification since https://bitcoincore.org does not host *-codesignatures binaries\r\nVERIFIED: bitcoin-22.0-aarch64-linux-gnu.tar.gz\r\nVERIFIED: bitcoin-22.0-arm-linux-gnueabihf.tar.gz\r\nVERIFIED: bitcoin-22.0.tar.gz\r\nVERIFIED: bitcoin-22.0-powerpc64-linux-gnu.tar.gz\r\nVERIFIED: bitcoin-22.0-powerpc64le-linux-gnu.tar.gz\r\nVERIFIED: bitcoin-22.0-riscv64-linux-gnu.tar.gz\r\nVERIFIED: bitcoin-22.0-osx-signed.dmg\r\nVERIFIED: bitcoin-22.0-osx64.tar.gz\r\nVERIFIED: bitcoin-22.0-x86_64-linux-gnu.tar.gz\r\nVERIFIED: bitcoin-22.0-win64-setup.exe\r\nVERIFIED: bitcoin-22.0-win64.zip\r\n```",
      "created_at" : "2021-09-22T18:31:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-925184375",
      "id" : 925184375,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5843JTF3",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-22T18:31:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/925184375",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've pushed an update (thanks to @Sjors' testing) that preserves the ability to verify binaries for releases older than 22.0, but still outputs verification results for everything in a uniform way. \r\n\r\nI've also included a change that associates the sha256 hash values along with the binary filenames in JSON output, which seems potentially useful.\r\n\r\n### 22.0 output\r\n```\r\n% ./contrib/verifybinaries/verify.py 22.0 --json --quiet --noninteractive\r\n[WARNING] https://bitcoin.org failed to provide file (https://bitcoin.org/bin/bitcoin-core-22.0/SHA256SUMS.asc). Continuing based solely upon https://bitcoincore.org.\r\n[WARNING] https://bitcoin.org failed to provide file (https://bitcoin.org/bin/bitcoin-core-22.0/SHA256SUMS). Continuing based solely upon https://bitcoincore.org.\r\n[WARNING] key 152812300785C96444D3334D17565732E08E5E41 for Andrew Chow (Official New Key) <achow101@gmail.com> is expired\r\n[WARNING] UNKNOWN SIGNATURE: SigData('82921A4B88FD454B7EB8CE3C796C4109063D4EAF', '', trusted=False, status='')\r\n{\r\n  \"good_trusted_sigs\": [\r\n    \"SigData('9DEAE0DC7063249FB05474681E4AED62986CD25D', 'Wladimir J. van der Laan <laanwj@visucore.com>', trusted=True, status='unknown')\",\r\n    \"SigData('152812300785C96444D3334D17565732E08E5E41', 'Andrew Chow (Official New Key) <achow101@gmail.com>', trusted=True, status='expired')\",\r\n    \"SigData('637DB1E23370F84AFF88CCE03152347D07DA627C', 'Stephan Oeste (it) <it@oeste.de>', trusted=True, status='unknown')\",\r\n    \"SigData('590B7292695AFFA5B672CBB2E13FC145CD3F4304', 'Antoine Poinsot <darosior@protonmail.com>', trusted=True, status='unknown')\",\r\n    \"SigData('D1DBF2C4B96F2DEBF4C16654410108112E7EA81F', 'Hennadii Stepanov (GitHub key) <32963518+hebasto@users.noreply.github.com>', trusted=True, status='unknown')\",\r\n    \"SigData('0AD83877C1F0CD1EE9BD660AD7CC770B81FD22A8', 'Ben Carman <benthecarman@live.com>', trusted=False, status='unknown')\",\r\n    \"SigData('9D3CC86A72F8494342EA5FD10A41BDC3F4FAFF1C', 'Aaron Clauson (sipsorcery) <aaron@sipsorcery.com>', trusted=False, status='unknown')\"\r\n  ],\r\n  \"good_untrusted_sigs\": [\r\n    \"SigData('0CCBAAFD76A2ECE2CCD3141DE2FFD5B1D88CA97D', '.0xB10C <0xb10c@gmail.com>', trusted=False, status='unknown')\",\r\n    \"SigData('28F5900B1BB5D1A4B6B6D1A9ED357015286A333D', 'Duncan Dean <duncangleeddean@gmail.com>', trusted=False, status='unknown')\",\r\n    \"SigData('CFB16E21C950F67FA95E558F2EEB9F5CC09526C1', 'Michael Ford (bitcoin-otc) <fanquake@gmail.com>', trusted=False, status='unknown')\",\r\n    \"SigData('6E01EEC9656903B0542B8F1003DB6322267C373B', 'Oliver Gugger <gugger@gmail.com>', trusted=False, status='unknown')\",\r\n    \"SigData('74E2DEF5D77260B98BC19438099BAD163C70FBFA', 'Will Clark <will8clark@gmail.com>', trusted=False, status='unknown')\"\r\n  ],\r\n  \"unknown_sigs\": [\r\n    \"SigData('82921A4B88FD454B7EB8CE3C796C4109063D4EAF', '', trusted=False, status='')\"\r\n  ],\r\n  \"bad_sigs\": [],\r\n  \"verified_binaries\": {\r\n    \"bitcoin-22.0-aarch64-linux-gnu.tar.gz\": \"ac718fed08570a81b3587587872ad85a25173afa5f9fbbd0c03ba4d1714cfa3e\",\r\n    \"bitcoin-22.0-arm-linux-gnueabihf.tar.gz\": \"b8713c6c5f03f5258b54e9f436e2ed6d85449aa24c2c9972f91963d413e86311\",\r\n    \"bitcoin-22.0.tar.gz\": \"d0e9d089b57048b1555efa7cd5a63a7ed042482045f6f33402b1df425bf9613b\",\r\n    \"bitcoin-22.0-powerpc64-linux-gnu.tar.gz\": \"2cca5f99007d060aca9d8c7cbd035dfe2f040dd8200b210ce32cdf858479f70d\",\r\n    \"bitcoin-22.0-powerpc64le-linux-gnu.tar.gz\": \"91b1e012975c5a363b5b5fcc81b5b7495e86ff703ec8262d4b9afcfec633c30d\",\r\n    \"bitcoin-22.0-riscv64-linux-gnu.tar.gz\": \"9cc3a62c469fe57e11485fdd32c916f10ce7a2899299855a2e479256ff49ff3c\",\r\n    \"bitcoin-22.0-osx-signed.dmg\": \"3b3e2680f7d9304c13bfebaf6445ada40d72324b4b3e0a07de9db807389a6c5b\",\r\n    \"bitcoin-22.0-osx64.tar.gz\": \"2744d199c3343b2d94faffdfb2c94d75a630ba27301a70e47b0ad30a7e0155e9\",\r\n    \"bitcoin-22.0-x86_64-linux-gnu.tar.gz\": \"59ebd25dd82a51638b7a6bb914586201e67db67b919b2a1ff08925a7936d1b16\",\r\n    \"bitcoin-22.0-win64-setup.exe\": \"9169989d649937c0f9ebccd3ab088501328aa319fe9e91fc7ea8e8cf0fcccede\",\r\n    \"bitcoin-22.0-win64.zip\": \"9485e4b52ed6cebfe474ab4d7d0c1be6d0bb879ba7246a8239326b2230a77eb1\"\r\n  }\r\n}\r\n```\r\n\r\n### 0.21.0 output\r\n\r\nNote that this fails because the `SHA256SUMS.asc` files differ between bitcoincore.org and bitcoin.org. This is the behavior of the script before this changeset (though now we display a unified diff of file contents), but we may want to change things to just ignore bitcoin.org in a case like this.\r\n\r\n```\r\n % ./contrib/verifybinaries/verify.py 0.21.0 --json --quiet --noninteractive\r\n[WARNING] found diff in files (SHA256SUMS.asc, SHA256SUMS.asc.2):\r\n  ---\r\n  +++\r\n  @@ -7,23 +7,23 @@\r\n   6223fd23d07133a6bfa2aa3d2554a09dc1d790d28ce67b0085d3fdcc1c126e05  bitcoin-0.21.0-osx.dmg\r\n   f8b2adfeae021a672effbc7bd40d5c48d6b94e53b2dd660f787340bf1a52e4e9  bitcoin-0.21.0-riscv64-linux-gnu.tar.gz\r\n   1a91202c62ee49fb64d57a52b8d6d01cd392fffcbef257b573800f9289655f37  bitcoin-0.21.0.tar.gz\r\n  -385a67cc4cf45558c05eb85fc500046cf033f816637fe0bff80d30debfca0128  bitcoin-0.21.0-win64-setup-unsigned.exe\r\n  +54050748ef4d4f000ea1ece472491b3e5fd546efc74ed52119354b2893f6624b  bitcoin-0.21.0-win64-setup.exe\r\n   1d0052c4ce80227fb6d0bc1c4e673ba21033e219c1f935d25f130ef7f43360d4  bitcoin-0.21.0-win64.zip\r\n   da7766775e3f9c98d7a9145429f2be8297c2672fe5b118fd3dc2411fb48e0032  bitcoin-0.21.0-x86_64-linux-gnu.tar.gz\r\n   -----BEGIN PGP SIGNATURE-----\r\n   Version: GnuPG v1.4.11 (GNU/Linux)\r\n\r\n  -iQIcBAEBCAAGBQJgXPg5AAoJEJDIAZ42wulkkl4P/jq29Je7Uqn75jkpvT8ilB8M\r\n  -5nM60ORBSsCyJHryS5sJeljLx/i8JTYkL10nUTpGDlFA3DOjM5MXgAHMJdYles7c\r\n  -PFO6TAqjrDWHgpc/HuPUCiF84N47u8xXcyWuoUjcgfLuV0K6l/1unCw6ISXZEdhy\r\n  -WTDZuqy+9lw9nWQA7VyIP+gfgMzgiH9P6x+ru9cYcXmimCv0TUtKp8iwUnW7QmrT\r\n  -aDtQJPs9sNWxjIa4WP5l4FKFlRErAyiHA24apQkOhn8YLSrIEATFE2t89HwvmIoV\r\n  -kv2BmQDrCUceC1OneFzmDP3JXJ0qa8wisw2gbUyO3EoSHfs/dlEG4+4NUQxtIwwX\r\n  -JQmaB7HII6UI86kIVIBWKA19hNiAxljSKgG7blP7+J2EKC+IDqZhuYHjpYCiJg5V\r\n  -2NSB3YE0sgKNyLPJN4OSA0h9nsBbEzHWm+BRgnkpPSsi2HSnczKzZwES31p9EGX1\r\n  -PYi4A1nk/kOFKCZh0uvaBKWR4h3MrLB9ABv3QqmkLeEJamLDfZPDC/35WRs9Z7kQ\r\n  -CUER5yMoJxq7aGjYSdd0jMxDL4akXRwf5DSN++voil3zWAqWS6XaH+9RtGmqFrZr\r\n  -uso8UR3RkAwgC5HQwgtEcyewA9xxz4MHx5UN5D+YzaejJvdDJBEa9oLry21EA34U\r\n  -071d1dTERe21zpnLj1EL\r\n  -=yP9G\r\n  +iQIcBAEBCAAGBQJgADqTAAoJEJDIAZ42wulkjtkQAJwlSTDinKsxZIMky3MeVhwB\r\n  +CmxxYiMLPQA8bwgxyc4RaTxUrqL2oExPOtfcDzcR1WbQe12niG40N/2yrtf66lG9\r\n  +KbSsQD6nKat9B3mCk9/jNkJHWmq5JJbOyfRs2mex75Lj7UHaPPrqh2rMfEewljed\r\n  +kHkDuaqeqYlTAh981WqLD+l5jnpQZqBSrcz3YTTvXWd7xKfFSVzqF/tD4CQFrPX2\r\n  +9b2BLzA/u+29Z3s+zio1l5c7fikNDd404T5U/y+NMOyCmgT4eiDGLQPlEpoGNq3w\r\n  +GYU7FNZUO9xXeatx4PI8qiq5mIK46UwfPUTeruTzNrHsME7YioUa87uSYKM8jqwP\r\n  +FSnbhYoUqCB/wPaKZwEF+2WzG88yj2+PzalVt8cnjRnTQ77COtHJqs8AjLWnVACF\r\n  +LluplM16xyiLn0FWkrEHyi5HlI+X+cqIiTtehojMBXIkHugIYMnT5XB9llh5OWXg\r\n  +Bp1UGupojLXYuMNF5R6cU5Iq+xJjbUiQ/PDm38MBlFlQ9RzRCYyZpMYZE3K9p789\r\n  +jpjdYdMPtzkYlIKD87S89JtE1s6i/SkTPhebyu/328rqkqnNKSCHnuB7Fy2iEKJj\r\n  +5kLs/LjY8yxSMuGeNl6LhWGKVZKy0AS/BztSHr2jgThfhN1BemFRcViSvcXhMeNw\r\n  +ka8Z9KLt/N0ziabBexAw\r\n  +=bi4p\r\n   -----END PGP SIGNATURE-----\r\n\r\n\r\n[ERROR] files not equal: SHA256SUMS.asc and SHA256SUMS.asc.2\r\n```\r\n\r\n### 0.20.0 output\r\n\r\nLegacy binary verifications rely solely on a successful GPG code, as was the behavior before this changeset.\r\n\r\n```\r\n% ./contrib/verifybinaries/verify.py 0.20.0 --json --quiet --noninteractive\r\n{\r\n  \"good_trusted_sigs\": [],\r\n  \"good_untrusted_sigs\": [\r\n    \"SigData('0x90C8019E36C2E964', 'Wladimir J. van der Laan (Bitcoin Core binary release signing key) <laanwj@gmail.com>', trusted=False, status='unknown')\"\r\n  ],\r\n  \"unknown_sigs\": [],\r\n  \"bad_sigs\": [],\r\n  \"verified_binaries\": {\r\n    \"bitcoin-0.20.0-aarch64-linux-gnu.tar.gz\": \"081b30b0f1af95656242c83eef30bbf7216b1a30fa8e8f29b3b160fe520d28f6\",\r\n    \"bitcoin-0.20.0-arm-linux-gnueabihf.tar.gz\": \"05014c7ff00f4496b1f389f0961d807e04505d8721d5c6f69567f2a0ec1985cc\",\r\n    \"bitcoin-0.20.0-osx64.tar.gz\": \"34f377fee2c7adf59981dde7e41215765d47b466f773cf2673137d30495b2675\",\r\n    \"bitcoin-0.20.0-osx.dmg\": \"a6e44b928d9ac04f11d43e920f4971fbdf1e77a8c28f7c14fafdd741ca7bc99f\",\r\n    \"bitcoin-0.20.0-riscv64-linux-gnu.tar.gz\": \"5b9cae3aa4197d1e557ff236754f489bce877ebba2267ce33af79b2ca4a13af6\",\r\n    \"bitcoin-0.20.0.tar.gz\": \"ec5a2358ee868d845115dc4fc3ed631ff063c57d5e0a713562d083c5c45efb28\",\r\n    \"bitcoin-0.20.0-win64-setup.exe\": \"0f1ea61a9aa9aba383a43bcdb5755b072cfff016b9c6bb0afa772a8685bcf7b0\",\r\n    \"bitcoin-0.20.0-win64.zip\": \"3e9ddfa05b7967e43fb502b735b6c4d716ec06f63ab7183df2e006ed4a6a431f\",\r\n    \"bitcoin-0.20.0-x86_64-linux-gnu.tar.gz\": \"35ec10f87b6bc1e44fd9cd1157e5dfa483eaf14d7d9a9c274774539e7824c427\"\r\n  }\r\n}\r\n```",
      "created_at" : "2021-09-22T23:32:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-925401609",
      "id" : 925401609,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5843KIIJ",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-22T23:32:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/925401609",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK - thanks for working on this.\r\n\r\n",
      "created_at" : "2021-09-23T08:46:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-925617977",
      "id" : 925617977,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5843K885",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-23T08:46:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/925617977",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/863730?v=4",
         "events_url" : "https://api.github.com/users/fanquake/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fanquake/followers",
         "following_url" : "https://api.github.com/users/fanquake/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fanquake/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fanquake",
         "id" : 863730,
         "login" : "fanquake",
         "node_id" : "MDQ6VXNlcjg2MzczMA==",
         "organizations_url" : "https://api.github.com/users/fanquake/orgs",
         "received_events_url" : "https://api.github.com/users/fanquake/received_events",
         "repos_url" : "https://api.github.com/users/fanquake/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fanquake/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fanquake"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Have you considered using the gpgme library (like https://github.com/bitcoin-core/bitcoin-maintainer-tools/blob/master/gitian-verify.py#L66 does) instead of parsing gpg command text output?\r\n\r\nSo I spent some time thinking about this and looking around at the various libraries that're available for GPG use. While using one of them would definitely save on a little complexity here, I'm somewhat wary of the trade-offs.\r\n\r\nOn top of the added installation complexity (apparently `gpgme` isn't just a `pip install` but requires `libgpgme` development headers to be installed as well), I have broader concerns about relying on Python dependencies for uses that are this sensitive.\r\n\r\nIf we use a third-party Python lib, we're opening up the trust model to encompass not just the Core repo and the Python runtime, but the author of the Python library and the PyPI servers. Obviously we could pin hashes, vendor the library, etc. etc. but I think that will ultimately be more work than the [70 odd lines of code](https://github.com/bitcoin/bitcoin/blob/a7ad989b075a1e4e50aa38e3e39531feeb83ccc3/contrib/verifybinaries/verify.py#L237-L302) that munge GPG output.\r\n\r\nIt strikes me that dealing with possible (and probably explicit) failure of this script on less common platforms because of unexpected GPG formatting is probably preferable to opening ourselves up to vulnerabilities based on third-party dependencies and packaging infrastructure. At least when it comes to something as important as verifying Bitcoin binaries.",
      "created_at" : "2021-09-24T19:31:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-926871883",
      "id" : 926871883,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5843PvFL",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-24T19:33:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/926871883",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I tend to agree that it's worth a bit of hassle to not have too many dependencies for this verify script.",
      "created_at" : "2021-09-27T09:34:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-927695179",
      "id" : 927695179,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5843S4FL",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-27T09:34:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/927695179",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Recently I worked on a Linux machine where `gpg` printed its verification results in its local language (German, in my case). In such a case, the verification script would obviously fail, as it expects English as output language. Can we find a way to cope with that? I didn't look deeper yet on what the output language depends on (I guess some typical locale environment variable like `LANGUAGE` or `LC_MESSAGES`). Maybe there is a command line flag that can enforce a certain language. In the worst case, we can always start up gpg with a shell script that overrides the locale settings temporarily. \r\n\r\nThis is one concern that we wouldn't need to take care of when using a library like `gpgme`, though I generally agree with the opinion that we want to keep the dependencies minimal (as expressed by @jamesob and @Sjors).",
      "created_at" : "2021-10-02T19:39:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-932810227",
      "id" : 932810227,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5843mY3z",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/932810227/reactions"
      },
      "updated_at" : "2021-10-02T19:39:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/932810227",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/91535?v=4",
         "events_url" : "https://api.github.com/users/theStack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theStack/followers",
         "following_url" : "https://api.github.com/users/theStack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theStack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theStack",
         "id" : 91535,
         "login" : "theStack",
         "node_id" : "MDQ6VXNlcjkxNTM1",
         "organizations_url" : "https://api.github.com/users/theStack/orgs",
         "received_events_url" : "https://api.github.com/users/theStack/received_events",
         "repos_url" : "https://api.github.com/users/theStack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theStack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theStack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theStack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> This is one concern that we wouldn't need to take care of when using a library like gpgme, though I generally agree with the opinion that we want to keep the dependencies minimal (as expressed by\r\n\r\nYes it would never run into language issues with libgpgme because it uses the GPG code directly, not through parsing text. And FWIW, libgpgme generally seems to already be installed on Ubuntu-ish machines (it's not like bitcoin would be the only thing using this). \r\nI agree about dependency concerns otherwise of course.\r\n\r\n> but I think that will ultimately be more work than the 70 odd lines of code that munge GPG output.\r\n\r\nWhat I'm mostly concerned about is that munging GPG output is conceptually brittle. It's not a good machine interface. A change in the text output from one version to another may cause the script to misbehave (likely it would fail safely, not dangerously, due to the exit code, but okay).",
      "created_at" : "2021-10-13T12:59:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-942279451",
      "id" : 942279451,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5844Kgsb",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/942279451/reactions"
      },
      "updated_at" : "2021-10-13T13:25:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/942279451",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> In such a case, the verification script would obviously fail, as it expects English as output language.\r\n\r\nAre you able to actually trigger such a failure at the moment? I think I saw some dutch in @Sjors' output, but the script worked fine. If you are I'd be curious to see it.\r\n\r\n> What I'm mostly concerned about is that munging GPG output is conceptually brittle.\r\n\r\nI don't want to push back too hard, but right now the script in master is plain broken. This actually works (despite maybe being brittle), and so I think it's worth considering for merge as-is. \r\n\r\nI'm happy to do a follow-up if we actually get reports of failures, or perhaps even before then if we find a decent way to handle the additional dependencies. Nothing in this approach precludes that, but incorporating libgpgme seems like a decent chunk of additional work given we'd now have to deal with packaging considerations. It'd be a shame for the perfect to be the enemy of the good in this case.",
      "created_at" : "2021-10-13T19:09:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-942632953",
      "id" : 942632953,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5844L2_5",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/942632953/reactions"
      },
      "updated_at" : "2021-10-13T19:09:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/942632953",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "One easy mitigation might be to specify the envvar `LANG=en` before each gpg call (https://stackoverflow.com/a/33961763/1611953).",
      "created_at" : "2021-10-13T19:50:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-942665347",
      "id" : 942665347,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5844L-6D",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/942665347/reactions"
      },
      "updated_at" : "2021-10-13T19:50:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/942665347",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Okay, I've verified that `LANGUAGE=x` does control output language for (my version of) gpg:\r\n```\r\n13:33:26 james@teller /home/james % LANGUAGE=en gpg --verify sigs.txt\r\ngpg: Signature made Thu 02 Sep 2021 01:52:57 PM EDT\r\ngpg:                using RSA key 4589779ADFC14F3327534EA8A3A31BAD5A2A5B10\r\ngpg: Good signature from \"Peter D. Gray <peter@coinkite.com>\" [unknown]\r\ngpg: WARNING: This key is not certified with a trusted signature!\r\ngpg:          There is no indication that the signature belongs to the owner.\r\nPrimary key fingerprint: 4589 779A DFC1 4F33 2753  4EA8 A3A3 1BAD 5A2A 5B10\r\n\r\n13:33:27 james@teller /home/james % LANGUAGE=fr gpg --verify sigs.txt\r\ngpg: Signature faite le Thu 02 Sep 2021 01:52:57 PM EDT\r\ngpg:                avec la clef RSA 4589779ADFC14F3327534EA8A3A31BAD5A2A5B10\r\ngpg: Bonne signature de Â«Â Peter D. Gray <peter@coinkite.com>Â Â» [inconnu]\r\ngpg: AttentionÂ : cette clef n'est pas certifiÃ©e avec une signature de confiance.\r\ngpg:             Rien n'indique que la signature appartient Ã  son propriÃ©taire.\r\nEmpreinte de clef principaleÂ : 4589 779A DFC1 4F33 2753  4EA8 A3A3 1BAD 5A2A 5B10\r\n```\r\nand also demonstrated that the script would have broken in that case, albeit explicitly.\r\n\r\nI've added a commit that specifies `LANGUAGE=en` before the gpg command and so avoids this issue. Thanks for raising the point! And FWIW I'm still not averse to using libgpgme at some point, but I do think more thought is required about how to manage the packaging complexity of that. I really don't like the idea of introducing PyPI and its servers into our process.",
      "created_at" : "2021-10-14T17:38:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-943575489",
      "id" : 943575489,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5844PdHB",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/943575489/reactions"
      },
      "updated_at" : "2021-10-14T17:38:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/943575489",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Gentle reminder here that the script in master is broken for 22.0 verification. It'd be great to either get this reviewed/merged or get some clear direction on what's needed to move this forward.\r\n\r\nI understand that parsing GPG text output is less than ideal, but I'm still of the opinion that the alternative of introducing a reliance on `gpgme` and all the packaging considerations that come along with it is less appealing. The downside of parsing text is potentially having explicit errors occur which users can report - this is opposed to the implicit risks of gpgme packaging and the disincentives that come along with a more onerous install process.",
      "created_at" : "2021-11-30T17:00:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-982831579",
      "id" : 982831579,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5846lNHb",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/982831579/reactions"
      },
      "updated_at" : "2021-11-30T17:00:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/982831579",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r765289101"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765289101"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Would maybe just say bitcoincore.org and bitcoin.org to be less mysterious",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-08T22:19:10Z",
      "diff_hunk" : "@@ -1,41 +1,94 @@\n ### Verify Binaries\n \n-#### Preparation:\n+#### Preparation\n \n-Make sure you obtain the proper release signing key and verify the fingerprint with several independent sources.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-```sh\n-$ gpg --fingerprint \"Bitcoin Core binary release signing key\"\n-pub   4096R/36C2E964 2015-06-24 [expires: YYYY-MM-DD]\n-      Key fingerprint = 01EA 5486 DE18 A882 D4C2  6845 90C8 019E 36C2 E964\n-uid                  Wladimir J. van der Laan (Bitcoin Core binary release signing key) <laanwj@gmail.com>\n-```\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin/bitcoin/tree/master/contrib/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation (you can use this script to do\n+this automatically, or you can do it yourself).\n+\n+You can obtain these keys by\n+  - (most laborious) through a browser using a key server (e.g. https://keyserver.ubuntu.com/),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - (easiest) you can run the packaged `verifybinaries.py` script to have it automatically\n+    retrieve unrecognized keys.\n+\n+#### Legacy verification\n+\n+Historically, the lead maintainer Wladimir J. van der Laan has provided the sole signing\n+key for releases, but since 22.0 Bitcoin release sum files are signed as described\n+above using a plurality of keys.\n+\n+Legacy verification is preserved for releases before v22.0; namely, GPG verification for\n+a checksum file based solely on a valid signature by the old release key\n+(`0x90C8019E36C2E964`).\n+\n+#### Usage\n+\n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from a number of sources, but chiefly\n+https://bitcoincore.org.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r765289101",
      "id" : 765289101,
      "line" : 38,
      "node_id" : "PRRC_kwDOABII584tnWKN",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 38,
      "original_position" : 46,
      "original_start_line" : 37,
      "path" : "contrib/verifybinaries/README.md",
      "position" : 46,
      "pull_request_review_id" : 827016327,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765289101/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 37,
      "start_side" : "RIGHT",
      "updated_at" : "2021-12-08T22:54:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765289101",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r765293018"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765293018"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Print the actual error? {e}",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-08T22:26:31Z",
      "diff_hunk" : "@@ -59,124 +194,457 @@ def download_with_wget(remote_file, local_file=None):\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError)\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r765293018",
      "id" : 765293018,
      "line" : 203,
      "node_id" : "PRRC_kwDOABII584tnXHa",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 203,
      "original_position" : 190,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 190,
      "pull_request_review_id" : 827016327,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765293018/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-08T22:54:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765293018",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r765297323"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765297323"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Previous version of this that used an arg list seemed better, because it avoided shell syntax that wouldn't work on windows and would have trouble with spaces and special characters.\r\n\r\nI don't think there should be an issue passing the LANGUAGE value if you just add `, env=dict(os.environ, LANGUAGE=\"en\")` to the subprocess call.\r\n\r\n",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-08T22:34:47Z",
      "diff_hunk" : "@@ -59,124 +194,457 @@ def download_with_wget(remote_file, local_file=None):\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError)\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    # Enforce English output since we're relying on output that contains natural language.\n+    # Use string-shell form (vs. args as list) because passing LANGUAGE via `env` doesn't\n+    # seem to work.\n+    args = (\n+        'LANGUAGE=en gpg --yes --decrypt '\n+        + (f' --output {output_filename} ' if output_filename else '')\n+        + signature_filename)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r765297323",
      "id" : 765297323,
      "line" : 219,
      "node_id" : "PRRC_kwDOABII584tnYKr",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 219,
      "original_position" : 206,
      "original_start_line" : 213,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 206,
      "pull_request_review_id" : 827016327,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765297323/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 213,
      "start_side" : "RIGHT",
      "updated_at" : "2021-12-08T22:54:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765297323",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r765303913"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765303913"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Would seem more readable and also more reassuring to do a fuller parse of GPG lines, instead of picking out little pieces of text. E.g.\r\n\r\n```python\r\nm = re.match(^\" *using RSA key (0x[0-9a-f]{18}|[0-9a-f]{40}$\")\r\n```\r\n\r\nIf you're just doing fragments like `'using RSA key' in line`, who is to say the script won't match the text `NOT using RSA key` and you just gave me a fake binary and ran away with my secret keys.",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-08T22:48:10Z",
      "diff_hunk" : "@@ -59,124 +194,457 @@ def download_with_wget(remote_file, local_file=None):\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError)\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    # Enforce English output since we're relying on output that contains natural language.\n+    # Use string-shell form (vs. args as list) because passing LANGUAGE via `env` doesn't\n+    # seem to work.\n+    args = (\n+        'LANGUAGE=en gpg --yes --decrypt '\n+        + (f' --output {output_filename} ' if output_filename else '')\n+        + signature_filename)\n+\n+    result = subprocess.run(args, shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n+    return result.returncode, result.stdout.decode().rstrip()\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self, key: str, name: str, trusted: bool, status: str):\n+        self.key = key\n+        self.name = name\n+        self.trusted = trusted\n+        self.status = status\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(output: str) -> ([SigData], [SigData], [SigData]):\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs = []\n+    unknown_sigs = []\n+    bad_sigs = []\n+    total_resolved_sigs = 0\n+    curr_key = None\n+\n+    for i, line in enumerate(output):\n+        if 'using RSA key' in line:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r765303913",
      "id" : 765303913,
      "line" : 253,
      "node_id" : "PRRC_kwDOABII584tnZxp",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 253,
      "original_position" : 240,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 240,
      "pull_request_review_id" : 827016327,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765303913/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-08T22:54:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/765303913",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766033525"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766033525"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Add exit code {gpg_retval}?",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-09T18:04:37Z",
      "diff_hunk" : "@@ -59,124 +194,457 @@ def download_with_wget(remote_file, local_file=None):\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError)\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    # Enforce English output since we're relying on output that contains natural language.\n+    # Use string-shell form (vs. args as list) because passing LANGUAGE via `env` doesn't\n+    # seem to work.\n+    args = (\n+        'LANGUAGE=en gpg --yes --decrypt '\n+        + (f' --output {output_filename} ' if output_filename else '')\n+        + signature_filename)\n+\n+    result = subprocess.run(args, shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n+    return result.returncode, result.stdout.decode().rstrip()\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self, key: str, name: str, trusted: bool, status: str):\n+        self.key = key\n+        self.name = name\n+        self.trusted = trusted\n+        self.status = status\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(output: str) -> ([SigData], [SigData], [SigData]):\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs = []\n+    unknown_sigs = []\n+    bad_sigs = []\n+    total_resolved_sigs = 0\n+    curr_key = None\n+\n+    for i, line in enumerate(output):\n+        if 'using RSA key' in line:\n+            if curr_key:\n+                raise RuntimeError(\n+                    f\"WARNING: encountered a new sig without resolving the last ({curr_key}) - \"\n+                    \"this could mean we have encountered a bad signature! check GPG output!\")\n+            curr_key = line.split('key ')[-1].strip()\n+            assert len(curr_key) == 40 or (len(curr_key) == 18 and curr_key.startswith('0x'))\n+\n+        if \"Can't check signature: No public key\" in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            unknown_sigs.append(SigData(curr_key, '', False, ''))\n+            curr_key = None\n+\n+        if 'Good signature from ' in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+\n+            # It's safe to index output[i + 1] because if we saw a good sig, there should\n+            # always be another line\n+            trusted = (\n+                'This key is not certified with a trusted signature' not in output[i + 1])\n+            good_sigs.append(SigData(curr_key, name, trusted, status))\n+            curr_key = None\n+\n+        if 'bad signature from' in line.lower():\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+            bad_sigs.append(SigData(curr_key, name, False, status))\n+            curr_key = None\n+\n+        # Track total signatures included\n+        if ': Signature made ' in line:\n+            total_resolved_sigs += 1\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n+def parse_gpg_from_line(line: str) -> (str, str):\n+    \"\"\"Returns name and expiration status.\"\"\"\n+    assert 'signature from' in line\n+\n+    name_end = line.split(' from ')[-1]\n+    m = re.search(r'(?P<name>\".+\") \\[(?P<status>\\w+)\\]', name_end)\n+    assert m\n+    (name, status) = m.groups()\n+    name = name.strip('\"\\'')\n+\n+    return (name, status)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"[{VERSIONPREFIX}]{VERSION_FORMAT} \"\n+            f\"(example: {VERSIONPREFIX}{VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def get_builder_keys(bitcoin_dir: Path) -> t.Dict[str, str]:\n+    \"\"\"\n+    Return a map of builder key to name from a local or remote source,\n+    in that order of preference.\n+    If we have them locally, compare them to the github repo.\n+    \"\"\"\n+    local_builder_keys = []\n+    local_builder_path = bitcoin_dir / 'contrib' / 'builder-keys' / 'keys.txt'\n+    if local_builder_path.exists():\n+        local_builder_keys = local_builder_path.read_text().splitlines()\n+\n+    success, gh_builder_keys = download_lines_with_urllib(BUILDER_KEYS_GH_URL)\n+    if not success:\n+        log.warning(f\"unable to retrieve builder keys from {BUILDER_KEYS_GH_URL}\")\n+\n+    if not (success or local_builder_keys):\n+        log.error(\"unable to retrieve builder keys locally or remotely\")\n+\n+    # check the local and remote builder keys against each other and report diff\n+    if local_builder_keys and gh_builder_keys:\n+        if local_builder_keys != gh_builder_keys:\n+            diff = indent(\n+                '\\n'.join(difflib.unified_diff(local_builder_keys, gh_builder_keys)))\n+            log.warning(f\"found diff (local vs. GH) in builder keys:\\n{diff}\\n\")\n+\n+    # Prefer local builder keys to those obtained remotely.\n+    builder_keys = local_builder_keys or gh_builder_keys or []\n+\n+    builder_key_map = {}\n+    for i in builder_keys:\n+        key, name = i.split(' ', 1)\n+        builder_key_map[key] = name\n+\n+    return builder_key_map\n+\n+\n+def check_multisig(\n+    sigfilename: str, args: argparse.Namespace, builder_key_map: t.Dict[str, str]\n+):\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    # Retrieve unknown keys that are in the repo builder list and then try GPG again.\n+    if unknown and not args.noninteractive and not args.skip_import_builders:\n+        for unsig in unknown:\n+            name = builder_key_map.get(unsig.key, '<unknown>')\n+            if input(f\" ? Retrieve key {unsig.key} for {name}? (y/N) \").lower() == \"y\":\n+                ran = subprocess.run(\n+                    f\"gpg --keyserver {args.keyserver} --recv-keys {unsig.key}\", shell=True)\n+\n+                if ran.returncode != 0:\n+                    log.warning(f\"failed to retrieve key {unsig.key} for {name}\")\n+\n+    return retval, output, good, unknown, bad\n+\n+\n+def check_single_sig(sigfilename: str, args: argparse.Namespace):\n+    retval, output = verify_with_gpg(sigfilename, SUMS_FILENAME)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    return retval, output, good, unknown, bad\n \n \n def main(args):\n-    # sanity check\n-    if len(args) < 1:\n-        print(\"Error: need to specify a version on the command line\")\n-        return 3\n+    args = parser.parse_args()\n+    if args.quiet:\n+        log.setLevel(logging.WARNING)\n+\n+    WORKINGDIR = Path(tempfile.gettempdir()) / f\"bitcoin_verify_binaries.{args.version}\"\n+\n+    def cleanup():\n+        log.info(\"cleaning up files\")\n+        os.chdir(Path.home())\n+        shutil.rmtree(WORKINGDIR)\n \n     # determine remote dir dependent on provided version string\n-    version_base, version_rc, os_filter = parse_version_string(args[0])\n+    version_base, version_rc, os_filter = parse_version_string(args.version)\n     remote_dir = f\"/bin/{VERSIONPREFIX}{version_base}/\"\n     if version_rc:\n         remote_dir += f\"test.{version_rc}/\"\n-    remote_sigfile = remote_dir + SIGNATUREFILENAME\n+    remote_sigs_path = remote_dir + SIGNATUREFILENAME\n+    remote_sums_path = remote_dir + SUMS_FILENAME\n \n+    bitcoin_dir_maybe = Path(args.bitcoin_src_path) if args.bitcoin_src_path else Path.cwd()\n     # create working directory\n     os.makedirs(WORKINGDIR, exist_ok=True)\n     os.chdir(WORKINGDIR)\n \n-    # fetch first signature file\n-    sigfile1 = SIGNATUREFILENAME\n-    success, output = download_with_wget(HOST1 + remote_sigfile, sigfile1)\n-    if not success:\n-        print(\"Error: couldn't fetch signature file. \"\n-              \"Have you specified the version number in the following format?\")\n-        print(f\"[{VERSIONPREFIX}]<version>[-rc[0-9]][-platform] \"\n-              f\"(example: {VERSIONPREFIX}0.21.0-rc3-osx)\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        return 4\n-\n-    # fetch second signature file\n-    sigfile2 = SIGNATUREFILENAME + \".2\"\n-    success, output = download_with_wget(HOST2 + remote_sigfile, sigfile2)\n-    if not success:\n-        print(\"bitcoin.org failed to provide signature file, \"\n-              \"but bitcoincore.org did?\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1])\n-        return 5\n-\n-    # ensure that both signature files are equal\n-    if not files_are_equal(sigfile1, sigfile2):\n-        print(\"bitcoin.org and bitcoincore.org signature files were not equal?\")\n-        print(f\"See files {WORKINGDIR}/{sigfile1} and {WORKINGDIR}/{sigfile2}\")\n-        return 6\n-\n-    # check signature and extract data into file\n-    retval, output = verify_with_gpg(sigfile1, HASHFILE)\n-    if retval != 0:\n-        if retval == 1:\n-            print(\"Bad signature.\")\n-        elif retval == 2:\n-            print(\"gpg error. Do you have the Bitcoin Core binary release \"\n-                  \"signing key installed?\")\n-        print(\"gpg output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1, sigfile2, HASHFILE])\n-        return 1\n+    version_tuple = [int(i) for i in version_base.split('.')]\n+    hosts = [HOST1, HOST2]\n+\n+    got_sig_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sigs_path, SIGNATUREFILENAME, args.require_all_hosts)\n+    if got_sig_status != ReturnCode.SUCCESS:\n+        return got_sig_status\n+\n+    # Multi-sig verification is available after 22.0.\n+    MULTISIG_SUPPORTED = version_tuple[0] >= 22\n+\n+    if MULTISIG_SUPPORTED:\n+        min_trusted_sigs = args.min_trusted_sigs\n+        gpg_allowed_codes = [0, 2]  # 2 is returned when untrusted signatures are present.\n+        builder_key_map = get_builder_keys(bitcoin_dir_maybe)\n+\n+        got_sums_status = get_files_from_hosts_and_compare(\n+            hosts, remote_sums_path, SUMS_FILENAME, args.require_all_hosts)\n+        if got_sums_status != ReturnCode.SUCCESS:\n+            return got_sums_status\n+\n+        gpg_retval, gpg_output, good, unknown, bad = check_multisig(\n+            SIGNATUREFILENAME, args, builder_key_map)\n+    else:\n+        # As long as GPG return codes are okay, the sig is valid for pre-22.0.\n+        min_trusted_sigs = 0\n+        gpg_allowed_codes = [0]\n+        builder_key_map = {}\n+\n+        gpg_retval, gpg_output, good, unknown, bad = check_single_sig(\n+            SIGNATUREFILENAME, args)\n+\n+    if gpg_retval not in gpg_allowed_codes:\n+        if gpg_retval == 1:\n+            log.critical(\"Bad signature.\")\n+        if gpg_retval == 2:\n+            log.critical(\n+                \"gpg error. Do you have the Bitcoin Core binary release \"\n+                \"signing key installed?\")\n+        else:\n+            log.critical(\"unexpected GPG exit code\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766033525",
      "id" : 766033525,
      "line" : 535,
      "node_id" : "PRRC_kwDOABII584tqL51",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 535,
      "original_position" : 578,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 578,
      "pull_request_review_id" : 828027865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766033525/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-09T21:16:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766033525",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766076167"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766076167"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Does not seem great if BINVERIFY_REQUIRE_ALL_HOSTS=yes is treated as false. It would be better to raise an error if value is unrecognized.\r\n\r\n```python\r\nif value.lower() in (\"1', \"true\"):\r\n    return True\r\nif value.lower() in (\"0\", \"false\"):\r\n    return False\r\nraise ValueError(f\"Unrecognized environment value {key}={value}\")\r\n```",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-09T19:07:16Z",
      "diff_hunk" : "@@ -2,29 +2,164 @@\n # Copyright (c) 2020 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Script for verifying Bitcoin Core release binaries\n-\n-This script attempts to download the signature file SHA256SUMS.asc from\n-bitcoincore.org and bitcoin.org and compares them.\n-It first checks if the signature passes, and then downloads the files\n-specified in the file, and checks if the hashes of these files match those\n-that are specified in the signature file.\n-The script returns 0 if everything passes the checks. It returns 1 if either\n-the signature check or the hash check doesn't pass. If an error occurs the\n-return value is >= 2.\n+\"\"\"Script for verifying Bitcoin Core release binaries.\n+\n+This script attempts to download the sum file SHA256SUMS and corresponding\n+signature file SHA256SUMS.asc from bitcoincore.org and bitcoin.org and\n+compares them.\n+\n+The sum-signature file is signed by a number of builder keys. This script\n+ensures that there is a minimum threshold of signatures from pubkeys that\n+we trust. This trust is articulated on the basis of configuration options\n+here, but by default is based upon a unionof (i) local GPG trust settings,\n+and (ii) keys which appear in the builder-keys/keys.txt file.\n+\n+If a minimum good, trusted signature threshold is met on the sum file, we then\n+download the files specified in SHA256SUMS, and check if the hashes of these\n+files match those that are specified. The script returns 0 if everything passes\n+the checks. It returns 1 if either the signature check or the hash check\n+doesn't pass. If an error occurs the return value is >= 2.\n+\n+Logging output goes to stderr and final binary verification data goes to stdout.\n+\n+JSON output can by obtained by setting env BINVERIFY_JSON=1.\n \"\"\"\n-from hashlib import sha256\n+import argparse\n+import difflib\n+import json\n+import logging\n import os\n import subprocess\n+import typing as t\n+import re\n import sys\n-from textwrap import indent\n+import shutil\n+import tempfile\n+import textwrap\n+import urllib.request\n+import enum\n+from hashlib import sha256\n+from pathlib import Path\n \n-WORKINGDIR = \"/tmp/bitcoin_verify_binaries\"\n-HASHFILE = \"hashes.tmp\"\n+# The primary host; this will fail if we can't retrieve files from here.\n HOST1 = \"https://bitcoincore.org\"\n HOST2 = \"https://bitcoin.org\"\n VERSIONPREFIX = \"bitcoin-core-\"\n-SIGNATUREFILENAME = \"SHA256SUMS.asc\"\n+SUMS_FILENAME = 'SHA256SUMS'\n+SIGNATUREFILENAME = f\"{SUMS_FILENAME}.asc\"\n+BUILDER_KEYS_GH_URL = (\n+    \"https://raw.githubusercontent.com/bitcoin/bitcoin/master/contrib/builder-keys/keys.txt\"\n+)\n+\n+\n+class ReturnCode(enum.IntEnum):\n+    SUCCESS = 0\n+    INTEGRITY_FAILURE = 1\n+    FILE_GET_FAILED = 4\n+    FILE_MISSING_FROM_ONE_HOST = 5\n+    FILES_NOT_EQUAL = 6\n+    NO_BINARIES_MATCH = 7\n+    NOT_ENOUGH_GOOD_SIGS = 9\n+    BINARY_DOWNLOAD_FAILED = 10\n+\n+\n+def set_up_logger(is_verbose: bool = True) -> logging.Logger:\n+    \"\"\"Set up a logger that writes to stderr.\"\"\"\n+    log = logging.getLogger(__name__)\n+    log.setLevel(logging.INFO if is_verbose else logging.WARNING)\n+    console = logging.StreamHandler(sys.stderr)  # log to stderr\n+    console.setLevel(logging.DEBUG)\n+    formatter = logging.Formatter('[%(levelname)s] %(message)s')\n+    console.setFormatter(formatter)\n+    log.addHandler(console)\n+    return log\n+\n+\n+log = set_up_logger()\n+\n+\n+def indent(output: str) -> str:\n+    return textwrap.indent(output, '  ')\n+\n+\n+def bool_from_env(key, default=False) -> bool:\n+    if key not in os.environ:\n+        return default\n+    raw = os.environ[key]\n+    return raw in ['1', 'True', 'true']",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766076167",
      "id" : 766076167,
      "line" : 89,
      "node_id" : "PRRC_kwDOABII584tqWUH",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 89,
      "original_position" : 103,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 103,
      "pull_request_review_id" : 828027865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766076167/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-09T21:16:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766076167",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766085408"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766085408"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Version is the main required argument so if it isn't parsed correctly it might be good to print a helpful error like \"Version {args.version!r} can't be parsed\" instead of just printing the exception",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-09T19:21:06Z",
      "diff_hunk" : "@@ -59,124 +194,457 @@ def download_with_wget(remote_file, local_file=None):\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError)\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    # Enforce English output since we're relying on output that contains natural language.\n+    # Use string-shell form (vs. args as list) because passing LANGUAGE via `env` doesn't\n+    # seem to work.\n+    args = (\n+        'LANGUAGE=en gpg --yes --decrypt '\n+        + (f' --output {output_filename} ' if output_filename else '')\n+        + signature_filename)\n+\n+    result = subprocess.run(args, shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n+    return result.returncode, result.stdout.decode().rstrip()\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self, key: str, name: str, trusted: bool, status: str):\n+        self.key = key\n+        self.name = name\n+        self.trusted = trusted\n+        self.status = status\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(output: str) -> ([SigData], [SigData], [SigData]):\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs = []\n+    unknown_sigs = []\n+    bad_sigs = []\n+    total_resolved_sigs = 0\n+    curr_key = None\n+\n+    for i, line in enumerate(output):\n+        if 'using RSA key' in line:\n+            if curr_key:\n+                raise RuntimeError(\n+                    f\"WARNING: encountered a new sig without resolving the last ({curr_key}) - \"\n+                    \"this could mean we have encountered a bad signature! check GPG output!\")\n+            curr_key = line.split('key ')[-1].strip()\n+            assert len(curr_key) == 40 or (len(curr_key) == 18 and curr_key.startswith('0x'))\n+\n+        if \"Can't check signature: No public key\" in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            unknown_sigs.append(SigData(curr_key, '', False, ''))\n+            curr_key = None\n+\n+        if 'Good signature from ' in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+\n+            # It's safe to index output[i + 1] because if we saw a good sig, there should\n+            # always be another line\n+            trusted = (\n+                'This key is not certified with a trusted signature' not in output[i + 1])\n+            good_sigs.append(SigData(curr_key, name, trusted, status))\n+            curr_key = None\n+\n+        if 'bad signature from' in line.lower():\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+            bad_sigs.append(SigData(curr_key, name, False, status))\n+            curr_key = None\n+\n+        # Track total signatures included\n+        if ': Signature made ' in line:\n+            total_resolved_sigs += 1\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n+def parse_gpg_from_line(line: str) -> (str, str):\n+    \"\"\"Returns name and expiration status.\"\"\"\n+    assert 'signature from' in line\n+\n+    name_end = line.split(' from ')[-1]\n+    m = re.search(r'(?P<name>\".+\") \\[(?P<status>\\w+)\\]', name_end)\n+    assert m\n+    (name, status) = m.groups()\n+    name = name.strip('\"\\'')\n+\n+    return (name, status)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"[{VERSIONPREFIX}]{VERSION_FORMAT} \"\n+            f\"(example: {VERSIONPREFIX}{VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def get_builder_keys(bitcoin_dir: Path) -> t.Dict[str, str]:\n+    \"\"\"\n+    Return a map of builder key to name from a local or remote source,\n+    in that order of preference.\n+    If we have them locally, compare them to the github repo.\n+    \"\"\"\n+    local_builder_keys = []\n+    local_builder_path = bitcoin_dir / 'contrib' / 'builder-keys' / 'keys.txt'\n+    if local_builder_path.exists():\n+        local_builder_keys = local_builder_path.read_text().splitlines()\n+\n+    success, gh_builder_keys = download_lines_with_urllib(BUILDER_KEYS_GH_URL)\n+    if not success:\n+        log.warning(f\"unable to retrieve builder keys from {BUILDER_KEYS_GH_URL}\")\n+\n+    if not (success or local_builder_keys):\n+        log.error(\"unable to retrieve builder keys locally or remotely\")\n+\n+    # check the local and remote builder keys against each other and report diff\n+    if local_builder_keys and gh_builder_keys:\n+        if local_builder_keys != gh_builder_keys:\n+            diff = indent(\n+                '\\n'.join(difflib.unified_diff(local_builder_keys, gh_builder_keys)))\n+            log.warning(f\"found diff (local vs. GH) in builder keys:\\n{diff}\\n\")\n+\n+    # Prefer local builder keys to those obtained remotely.\n+    builder_keys = local_builder_keys or gh_builder_keys or []\n+\n+    builder_key_map = {}\n+    for i in builder_keys:\n+        key, name = i.split(' ', 1)\n+        builder_key_map[key] = name\n+\n+    return builder_key_map\n+\n+\n+def check_multisig(\n+    sigfilename: str, args: argparse.Namespace, builder_key_map: t.Dict[str, str]\n+):\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    # Retrieve unknown keys that are in the repo builder list and then try GPG again.\n+    if unknown and not args.noninteractive and not args.skip_import_builders:\n+        for unsig in unknown:\n+            name = builder_key_map.get(unsig.key, '<unknown>')\n+            if input(f\" ? Retrieve key {unsig.key} for {name}? (y/N) \").lower() == \"y\":\n+                ran = subprocess.run(\n+                    f\"gpg --keyserver {args.keyserver} --recv-keys {unsig.key}\", shell=True)\n+\n+                if ran.returncode != 0:\n+                    log.warning(f\"failed to retrieve key {unsig.key} for {name}\")\n+\n+    return retval, output, good, unknown, bad\n+\n+\n+def check_single_sig(sigfilename: str, args: argparse.Namespace):\n+    retval, output = verify_with_gpg(sigfilename, SUMS_FILENAME)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    return retval, output, good, unknown, bad\n \n \n def main(args):\n-    # sanity check\n-    if len(args) < 1:\n-        print(\"Error: need to specify a version on the command line\")\n-        return 3\n+    args = parser.parse_args()\n+    if args.quiet:\n+        log.setLevel(logging.WARNING)\n+\n+    WORKINGDIR = Path(tempfile.gettempdir()) / f\"bitcoin_verify_binaries.{args.version}\"\n+\n+    def cleanup():\n+        log.info(\"cleaning up files\")\n+        os.chdir(Path.home())\n+        shutil.rmtree(WORKINGDIR)\n \n     # determine remote dir dependent on provided version string\n-    version_base, version_rc, os_filter = parse_version_string(args[0])\n+    version_base, version_rc, os_filter = parse_version_string(args.version)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766085408",
      "id" : 766085408,
      "line" : 483,
      "node_id" : "PRRC_kwDOABII584tqYkg",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 483,
      "original_position" : 484,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 484,
      "pull_request_review_id" : 828027865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766085408/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-09T21:16:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766085408",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766087843"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766087843"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Another use of shell=True here doesn't handle spaces and special characters and would be easy to eliminate with\r\n\r\n```python\r\n[\"gpg\", \"--keyserver\", args.keyserver, \"--recv-keys\", unsig.key]\r\n```",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-09T19:24:54Z",
      "diff_hunk" : "@@ -59,124 +194,457 @@ def download_with_wget(remote_file, local_file=None):\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError)\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    # Enforce English output since we're relying on output that contains natural language.\n+    # Use string-shell form (vs. args as list) because passing LANGUAGE via `env` doesn't\n+    # seem to work.\n+    args = (\n+        'LANGUAGE=en gpg --yes --decrypt '\n+        + (f' --output {output_filename} ' if output_filename else '')\n+        + signature_filename)\n+\n+    result = subprocess.run(args, shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n+    return result.returncode, result.stdout.decode().rstrip()\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self, key: str, name: str, trusted: bool, status: str):\n+        self.key = key\n+        self.name = name\n+        self.trusted = trusted\n+        self.status = status\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(output: str) -> ([SigData], [SigData], [SigData]):\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs = []\n+    unknown_sigs = []\n+    bad_sigs = []\n+    total_resolved_sigs = 0\n+    curr_key = None\n+\n+    for i, line in enumerate(output):\n+        if 'using RSA key' in line:\n+            if curr_key:\n+                raise RuntimeError(\n+                    f\"WARNING: encountered a new sig without resolving the last ({curr_key}) - \"\n+                    \"this could mean we have encountered a bad signature! check GPG output!\")\n+            curr_key = line.split('key ')[-1].strip()\n+            assert len(curr_key) == 40 or (len(curr_key) == 18 and curr_key.startswith('0x'))\n+\n+        if \"Can't check signature: No public key\" in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            unknown_sigs.append(SigData(curr_key, '', False, ''))\n+            curr_key = None\n+\n+        if 'Good signature from ' in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+\n+            # It's safe to index output[i + 1] because if we saw a good sig, there should\n+            # always be another line\n+            trusted = (\n+                'This key is not certified with a trusted signature' not in output[i + 1])\n+            good_sigs.append(SigData(curr_key, name, trusted, status))\n+            curr_key = None\n+\n+        if 'bad signature from' in line.lower():\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+            bad_sigs.append(SigData(curr_key, name, False, status))\n+            curr_key = None\n+\n+        # Track total signatures included\n+        if ': Signature made ' in line:\n+            total_resolved_sigs += 1\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n+def parse_gpg_from_line(line: str) -> (str, str):\n+    \"\"\"Returns name and expiration status.\"\"\"\n+    assert 'signature from' in line\n+\n+    name_end = line.split(' from ')[-1]\n+    m = re.search(r'(?P<name>\".+\") \\[(?P<status>\\w+)\\]', name_end)\n+    assert m\n+    (name, status) = m.groups()\n+    name = name.strip('\"\\'')\n+\n+    return (name, status)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"[{VERSIONPREFIX}]{VERSION_FORMAT} \"\n+            f\"(example: {VERSIONPREFIX}{VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def get_builder_keys(bitcoin_dir: Path) -> t.Dict[str, str]:\n+    \"\"\"\n+    Return a map of builder key to name from a local or remote source,\n+    in that order of preference.\n+    If we have them locally, compare them to the github repo.\n+    \"\"\"\n+    local_builder_keys = []\n+    local_builder_path = bitcoin_dir / 'contrib' / 'builder-keys' / 'keys.txt'\n+    if local_builder_path.exists():\n+        local_builder_keys = local_builder_path.read_text().splitlines()\n+\n+    success, gh_builder_keys = download_lines_with_urllib(BUILDER_KEYS_GH_URL)\n+    if not success:\n+        log.warning(f\"unable to retrieve builder keys from {BUILDER_KEYS_GH_URL}\")\n+\n+    if not (success or local_builder_keys):\n+        log.error(\"unable to retrieve builder keys locally or remotely\")\n+\n+    # check the local and remote builder keys against each other and report diff\n+    if local_builder_keys and gh_builder_keys:\n+        if local_builder_keys != gh_builder_keys:\n+            diff = indent(\n+                '\\n'.join(difflib.unified_diff(local_builder_keys, gh_builder_keys)))\n+            log.warning(f\"found diff (local vs. GH) in builder keys:\\n{diff}\\n\")\n+\n+    # Prefer local builder keys to those obtained remotely.\n+    builder_keys = local_builder_keys or gh_builder_keys or []\n+\n+    builder_key_map = {}\n+    for i in builder_keys:\n+        key, name = i.split(' ', 1)\n+        builder_key_map[key] = name\n+\n+    return builder_key_map\n+\n+\n+def check_multisig(\n+    sigfilename: str, args: argparse.Namespace, builder_key_map: t.Dict[str, str]\n+):\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    # Retrieve unknown keys that are in the repo builder list and then try GPG again.\n+    if unknown and not args.noninteractive and not args.skip_import_builders:\n+        for unsig in unknown:\n+            name = builder_key_map.get(unsig.key, '<unknown>')\n+            if input(f\" ? Retrieve key {unsig.key} for {name}? (y/N) \").lower() == \"y\":\n+                ran = subprocess.run(\n+                    f\"gpg --keyserver {args.keyserver} --recv-keys {unsig.key}\", shell=True)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766087843",
      "id" : 766087843,
      "line" : 451,
      "node_id" : "PRRC_kwDOABII584tqZKj",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 451,
      "original_position" : 447,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 447,
      "pull_request_review_id" : 828027865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766087843/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-09T21:16:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766087843",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766089203"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766089203"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It would be better if this loop if an unrecognized response was given, instead of assuming a response like \"yes\" means no.",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-09T19:26:46Z",
      "diff_hunk" : "@@ -59,124 +194,457 @@ def download_with_wget(remote_file, local_file=None):\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError)\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    # Enforce English output since we're relying on output that contains natural language.\n+    # Use string-shell form (vs. args as list) because passing LANGUAGE via `env` doesn't\n+    # seem to work.\n+    args = (\n+        'LANGUAGE=en gpg --yes --decrypt '\n+        + (f' --output {output_filename} ' if output_filename else '')\n+        + signature_filename)\n+\n+    result = subprocess.run(args, shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n+    return result.returncode, result.stdout.decode().rstrip()\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self, key: str, name: str, trusted: bool, status: str):\n+        self.key = key\n+        self.name = name\n+        self.trusted = trusted\n+        self.status = status\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(output: str) -> ([SigData], [SigData], [SigData]):\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs = []\n+    unknown_sigs = []\n+    bad_sigs = []\n+    total_resolved_sigs = 0\n+    curr_key = None\n+\n+    for i, line in enumerate(output):\n+        if 'using RSA key' in line:\n+            if curr_key:\n+                raise RuntimeError(\n+                    f\"WARNING: encountered a new sig without resolving the last ({curr_key}) - \"\n+                    \"this could mean we have encountered a bad signature! check GPG output!\")\n+            curr_key = line.split('key ')[-1].strip()\n+            assert len(curr_key) == 40 or (len(curr_key) == 18 and curr_key.startswith('0x'))\n+\n+        if \"Can't check signature: No public key\" in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            unknown_sigs.append(SigData(curr_key, '', False, ''))\n+            curr_key = None\n+\n+        if 'Good signature from ' in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+\n+            # It's safe to index output[i + 1] because if we saw a good sig, there should\n+            # always be another line\n+            trusted = (\n+                'This key is not certified with a trusted signature' not in output[i + 1])\n+            good_sigs.append(SigData(curr_key, name, trusted, status))\n+            curr_key = None\n+\n+        if 'bad signature from' in line.lower():\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+            bad_sigs.append(SigData(curr_key, name, False, status))\n+            curr_key = None\n+\n+        # Track total signatures included\n+        if ': Signature made ' in line:\n+            total_resolved_sigs += 1\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n+def parse_gpg_from_line(line: str) -> (str, str):\n+    \"\"\"Returns name and expiration status.\"\"\"\n+    assert 'signature from' in line\n+\n+    name_end = line.split(' from ')[-1]\n+    m = re.search(r'(?P<name>\".+\") \\[(?P<status>\\w+)\\]', name_end)\n+    assert m\n+    (name, status) = m.groups()\n+    name = name.strip('\"\\'')\n+\n+    return (name, status)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"[{VERSIONPREFIX}]{VERSION_FORMAT} \"\n+            f\"(example: {VERSIONPREFIX}{VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def get_builder_keys(bitcoin_dir: Path) -> t.Dict[str, str]:\n+    \"\"\"\n+    Return a map of builder key to name from a local or remote source,\n+    in that order of preference.\n+    If we have them locally, compare them to the github repo.\n+    \"\"\"\n+    local_builder_keys = []\n+    local_builder_path = bitcoin_dir / 'contrib' / 'builder-keys' / 'keys.txt'\n+    if local_builder_path.exists():\n+        local_builder_keys = local_builder_path.read_text().splitlines()\n+\n+    success, gh_builder_keys = download_lines_with_urllib(BUILDER_KEYS_GH_URL)\n+    if not success:\n+        log.warning(f\"unable to retrieve builder keys from {BUILDER_KEYS_GH_URL}\")\n+\n+    if not (success or local_builder_keys):\n+        log.error(\"unable to retrieve builder keys locally or remotely\")\n+\n+    # check the local and remote builder keys against each other and report diff\n+    if local_builder_keys and gh_builder_keys:\n+        if local_builder_keys != gh_builder_keys:\n+            diff = indent(\n+                '\\n'.join(difflib.unified_diff(local_builder_keys, gh_builder_keys)))\n+            log.warning(f\"found diff (local vs. GH) in builder keys:\\n{diff}\\n\")\n+\n+    # Prefer local builder keys to those obtained remotely.\n+    builder_keys = local_builder_keys or gh_builder_keys or []\n+\n+    builder_key_map = {}\n+    for i in builder_keys:\n+        key, name = i.split(' ', 1)\n+        builder_key_map[key] = name\n+\n+    return builder_key_map\n+\n+\n+def check_multisig(\n+    sigfilename: str, args: argparse.Namespace, builder_key_map: t.Dict[str, str]\n+):\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    # Retrieve unknown keys that are in the repo builder list and then try GPG again.\n+    if unknown and not args.noninteractive and not args.skip_import_builders:\n+        for unsig in unknown:\n+            name = builder_key_map.get(unsig.key, '<unknown>')\n+            if input(f\" ? Retrieve key {unsig.key} for {name}? (y/N) \").lower() == \"y\":",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766089203",
      "id" : 766089203,
      "line" : 449,
      "node_id" : "PRRC_kwDOABII584tqZfz",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 449,
      "original_position" : 445,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 445,
      "pull_request_review_id" : 828027865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766089203/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-09T21:16:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766089203",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766093053"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766093053"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This `main()` function has a lot of verification logic mixed in with a lot of printing code like this. Would be good to move informational parts of `main()` to separate `print_signature_info` or similar functions, so it's easy for someone trying to see how verification works to see what this is doing.",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-09T19:32:06Z",
      "diff_hunk" : "@@ -59,124 +194,457 @@ def download_with_wget(remote_file, local_file=None):\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError)\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    # Enforce English output since we're relying on output that contains natural language.\n+    # Use string-shell form (vs. args as list) because passing LANGUAGE via `env` doesn't\n+    # seem to work.\n+    args = (\n+        'LANGUAGE=en gpg --yes --decrypt '\n+        + (f' --output {output_filename} ' if output_filename else '')\n+        + signature_filename)\n+\n+    result = subprocess.run(args, shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n+    return result.returncode, result.stdout.decode().rstrip()\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self, key: str, name: str, trusted: bool, status: str):\n+        self.key = key\n+        self.name = name\n+        self.trusted = trusted\n+        self.status = status\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(output: str) -> ([SigData], [SigData], [SigData]):\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs = []\n+    unknown_sigs = []\n+    bad_sigs = []\n+    total_resolved_sigs = 0\n+    curr_key = None\n+\n+    for i, line in enumerate(output):\n+        if 'using RSA key' in line:\n+            if curr_key:\n+                raise RuntimeError(\n+                    f\"WARNING: encountered a new sig without resolving the last ({curr_key}) - \"\n+                    \"this could mean we have encountered a bad signature! check GPG output!\")\n+            curr_key = line.split('key ')[-1].strip()\n+            assert len(curr_key) == 40 or (len(curr_key) == 18 and curr_key.startswith('0x'))\n+\n+        if \"Can't check signature: No public key\" in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            unknown_sigs.append(SigData(curr_key, '', False, ''))\n+            curr_key = None\n+\n+        if 'Good signature from ' in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+\n+            # It's safe to index output[i + 1] because if we saw a good sig, there should\n+            # always be another line\n+            trusted = (\n+                'This key is not certified with a trusted signature' not in output[i + 1])\n+            good_sigs.append(SigData(curr_key, name, trusted, status))\n+            curr_key = None\n+\n+        if 'bad signature from' in line.lower():\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+            bad_sigs.append(SigData(curr_key, name, False, status))\n+            curr_key = None\n+\n+        # Track total signatures included\n+        if ': Signature made ' in line:\n+            total_resolved_sigs += 1\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n+def parse_gpg_from_line(line: str) -> (str, str):\n+    \"\"\"Returns name and expiration status.\"\"\"\n+    assert 'signature from' in line\n+\n+    name_end = line.split(' from ')[-1]\n+    m = re.search(r'(?P<name>\".+\") \\[(?P<status>\\w+)\\]', name_end)\n+    assert m\n+    (name, status) = m.groups()\n+    name = name.strip('\"\\'')\n+\n+    return (name, status)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"[{VERSIONPREFIX}]{VERSION_FORMAT} \"\n+            f\"(example: {VERSIONPREFIX}{VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def get_builder_keys(bitcoin_dir: Path) -> t.Dict[str, str]:\n+    \"\"\"\n+    Return a map of builder key to name from a local or remote source,\n+    in that order of preference.\n+    If we have them locally, compare them to the github repo.\n+    \"\"\"\n+    local_builder_keys = []\n+    local_builder_path = bitcoin_dir / 'contrib' / 'builder-keys' / 'keys.txt'\n+    if local_builder_path.exists():\n+        local_builder_keys = local_builder_path.read_text().splitlines()\n+\n+    success, gh_builder_keys = download_lines_with_urllib(BUILDER_KEYS_GH_URL)\n+    if not success:\n+        log.warning(f\"unable to retrieve builder keys from {BUILDER_KEYS_GH_URL}\")\n+\n+    if not (success or local_builder_keys):\n+        log.error(\"unable to retrieve builder keys locally or remotely\")\n+\n+    # check the local and remote builder keys against each other and report diff\n+    if local_builder_keys and gh_builder_keys:\n+        if local_builder_keys != gh_builder_keys:\n+            diff = indent(\n+                '\\n'.join(difflib.unified_diff(local_builder_keys, gh_builder_keys)))\n+            log.warning(f\"found diff (local vs. GH) in builder keys:\\n{diff}\\n\")\n+\n+    # Prefer local builder keys to those obtained remotely.\n+    builder_keys = local_builder_keys or gh_builder_keys or []\n+\n+    builder_key_map = {}\n+    for i in builder_keys:\n+        key, name = i.split(' ', 1)\n+        builder_key_map[key] = name\n+\n+    return builder_key_map\n+\n+\n+def check_multisig(\n+    sigfilename: str, args: argparse.Namespace, builder_key_map: t.Dict[str, str]\n+):\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    # Retrieve unknown keys that are in the repo builder list and then try GPG again.\n+    if unknown and not args.noninteractive and not args.skip_import_builders:\n+        for unsig in unknown:\n+            name = builder_key_map.get(unsig.key, '<unknown>')\n+            if input(f\" ? Retrieve key {unsig.key} for {name}? (y/N) \").lower() == \"y\":\n+                ran = subprocess.run(\n+                    f\"gpg --keyserver {args.keyserver} --recv-keys {unsig.key}\", shell=True)\n+\n+                if ran.returncode != 0:\n+                    log.warning(f\"failed to retrieve key {unsig.key} for {name}\")\n+\n+    return retval, output, good, unknown, bad\n+\n+\n+def check_single_sig(sigfilename: str, args: argparse.Namespace):\n+    retval, output = verify_with_gpg(sigfilename, SUMS_FILENAME)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    return retval, output, good, unknown, bad\n \n \n def main(args):\n-    # sanity check\n-    if len(args) < 1:\n-        print(\"Error: need to specify a version on the command line\")\n-        return 3\n+    args = parser.parse_args()\n+    if args.quiet:\n+        log.setLevel(logging.WARNING)\n+\n+    WORKINGDIR = Path(tempfile.gettempdir()) / f\"bitcoin_verify_binaries.{args.version}\"\n+\n+    def cleanup():\n+        log.info(\"cleaning up files\")\n+        os.chdir(Path.home())\n+        shutil.rmtree(WORKINGDIR)\n \n     # determine remote dir dependent on provided version string\n-    version_base, version_rc, os_filter = parse_version_string(args[0])\n+    version_base, version_rc, os_filter = parse_version_string(args.version)\n     remote_dir = f\"/bin/{VERSIONPREFIX}{version_base}/\"\n     if version_rc:\n         remote_dir += f\"test.{version_rc}/\"\n-    remote_sigfile = remote_dir + SIGNATUREFILENAME\n+    remote_sigs_path = remote_dir + SIGNATUREFILENAME\n+    remote_sums_path = remote_dir + SUMS_FILENAME\n \n+    bitcoin_dir_maybe = Path(args.bitcoin_src_path) if args.bitcoin_src_path else Path.cwd()\n     # create working directory\n     os.makedirs(WORKINGDIR, exist_ok=True)\n     os.chdir(WORKINGDIR)\n \n-    # fetch first signature file\n-    sigfile1 = SIGNATUREFILENAME\n-    success, output = download_with_wget(HOST1 + remote_sigfile, sigfile1)\n-    if not success:\n-        print(\"Error: couldn't fetch signature file. \"\n-              \"Have you specified the version number in the following format?\")\n-        print(f\"[{VERSIONPREFIX}]<version>[-rc[0-9]][-platform] \"\n-              f\"(example: {VERSIONPREFIX}0.21.0-rc3-osx)\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        return 4\n-\n-    # fetch second signature file\n-    sigfile2 = SIGNATUREFILENAME + \".2\"\n-    success, output = download_with_wget(HOST2 + remote_sigfile, sigfile2)\n-    if not success:\n-        print(\"bitcoin.org failed to provide signature file, \"\n-              \"but bitcoincore.org did?\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1])\n-        return 5\n-\n-    # ensure that both signature files are equal\n-    if not files_are_equal(sigfile1, sigfile2):\n-        print(\"bitcoin.org and bitcoincore.org signature files were not equal?\")\n-        print(f\"See files {WORKINGDIR}/{sigfile1} and {WORKINGDIR}/{sigfile2}\")\n-        return 6\n-\n-    # check signature and extract data into file\n-    retval, output = verify_with_gpg(sigfile1, HASHFILE)\n-    if retval != 0:\n-        if retval == 1:\n-            print(\"Bad signature.\")\n-        elif retval == 2:\n-            print(\"gpg error. Do you have the Bitcoin Core binary release \"\n-                  \"signing key installed?\")\n-        print(\"gpg output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1, sigfile2, HASHFILE])\n-        return 1\n+    version_tuple = [int(i) for i in version_base.split('.')]\n+    hosts = [HOST1, HOST2]\n+\n+    got_sig_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sigs_path, SIGNATUREFILENAME, args.require_all_hosts)\n+    if got_sig_status != ReturnCode.SUCCESS:\n+        return got_sig_status\n+\n+    # Multi-sig verification is available after 22.0.\n+    MULTISIG_SUPPORTED = version_tuple[0] >= 22\n+\n+    if MULTISIG_SUPPORTED:\n+        min_trusted_sigs = args.min_trusted_sigs\n+        gpg_allowed_codes = [0, 2]  # 2 is returned when untrusted signatures are present.\n+        builder_key_map = get_builder_keys(bitcoin_dir_maybe)\n+\n+        got_sums_status = get_files_from_hosts_and_compare(\n+            hosts, remote_sums_path, SUMS_FILENAME, args.require_all_hosts)\n+        if got_sums_status != ReturnCode.SUCCESS:\n+            return got_sums_status\n+\n+        gpg_retval, gpg_output, good, unknown, bad = check_multisig(\n+            SIGNATUREFILENAME, args, builder_key_map)\n+    else:\n+        # As long as GPG return codes are okay, the sig is valid for pre-22.0.\n+        min_trusted_sigs = 0\n+        gpg_allowed_codes = [0]\n+        builder_key_map = {}\n+\n+        gpg_retval, gpg_output, good, unknown, bad = check_single_sig(\n+            SIGNATUREFILENAME, args)\n+\n+    if gpg_retval not in gpg_allowed_codes:\n+        if gpg_retval == 1:\n+            log.critical(\"Bad signature.\")\n+        if gpg_retval == 2:\n+            log.critical(\n+                \"gpg error. Do you have the Bitcoin Core binary release \"\n+                \"signing key installed?\")\n+        else:\n+            log.critical(\"unexpected GPG exit code\")\n+\n+        log.error(f\"gpg output:\\n{indent(gpg_output)}\")\n+        cleanup()\n+        return ReturnCode.INTEGRITY_FAILURE\n+\n+    # Decide which keys we trust, though not \"trust\" in the GPG sense, but rather\n+    # which pubkeys convince us that this sums file is legitimate. In other words,\n+    # which pubkeys within the Bitcoin community do we trust for the purposes of\n+    # binary verification?\n+    trusted_keys = set()\n+    if not args.no_builder_keys:\n+        trusted_keys |= set(builder_key_map.keys())\n+    if args.trusted_keys:\n+        trusted_keys |= set(args.trusted_keys.split(','))\n+\n+    # Tally signatures and make sure we have enough good, trusted to fulfill\n+    # our threshold.\n+    good_trusted = {sig for sig in good if sig.trusted or sig.key in trusted_keys}\n+    good_untrusted = [sig for sig in good if sig not in good_trusted]\n+    num_trusted = len(good_trusted)\n+    log.info(f\"got {num_trusted} good, trusted signatures\")\n+\n+    if num_trusted < min_trusted_sigs:\n+        log.error(\n+            \"not enough trusted sigs to meet threshold \"\n+            f\"({num_trusted} vs. {min_trusted_sigs})\")\n+        return ReturnCode.NOT_ENOUGH_GOOD_SIGS\n+\n+    for sig in good_trusted:\n+        log.info(f\"GOOD SIGNATURE: {sig}\")\n+\n+    for sig in good_untrusted:\n+        log.info(f\"GOOD SIGNATURE (untrusted): {sig}\")\n+\n+    for sig in [sig for sig in good if sig.status == 'expired']:\n+        log.warning(f\"key {sig.key} for {sig.name} is expired\")\n+\n+    for sig in bad:\n+        log.warning(f\"BAD SIGNATURE: {sig}\")\n+\n+    for sig in unknown:\n+        log.warning(f\"UNKNOWN SIGNATURE: {sig}\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766093053",
      "id" : 766093053,
      "line" : 577,
      "node_id" : "PRRC_kwDOABII584tqab9",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 577,
      "original_position" : 620,
      "original_start_line" : 564,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 620,
      "pull_request_review_id" : 828027865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766093053/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 564,
      "start_side" : "RIGHT",
      "updated_at" : "2021-12-09T21:16:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766093053",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766105083"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766105083"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Instead of making behavior depend on directory where script was called from, I think it would be more stable to use the script location like:\r\n\r\n```python\r\nlocal_keys = (Path(args.bitcoin_src_path) / 'contrib' if args.bitcoin_src_path else\r\n              Path(__file__).resolve().parent.parent) / 'builder-keys' / 'keys.txt'\r\n```\r\n",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-09T19:49:46Z",
      "diff_hunk" : "@@ -59,124 +194,457 @@ def download_with_wget(remote_file, local_file=None):\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError)\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    # Enforce English output since we're relying on output that contains natural language.\n+    # Use string-shell form (vs. args as list) because passing LANGUAGE via `env` doesn't\n+    # seem to work.\n+    args = (\n+        'LANGUAGE=en gpg --yes --decrypt '\n+        + (f' --output {output_filename} ' if output_filename else '')\n+        + signature_filename)\n+\n+    result = subprocess.run(args, shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n+    return result.returncode, result.stdout.decode().rstrip()\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self, key: str, name: str, trusted: bool, status: str):\n+        self.key = key\n+        self.name = name\n+        self.trusted = trusted\n+        self.status = status\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(output: str) -> ([SigData], [SigData], [SigData]):\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs = []\n+    unknown_sigs = []\n+    bad_sigs = []\n+    total_resolved_sigs = 0\n+    curr_key = None\n+\n+    for i, line in enumerate(output):\n+        if 'using RSA key' in line:\n+            if curr_key:\n+                raise RuntimeError(\n+                    f\"WARNING: encountered a new sig without resolving the last ({curr_key}) - \"\n+                    \"this could mean we have encountered a bad signature! check GPG output!\")\n+            curr_key = line.split('key ')[-1].strip()\n+            assert len(curr_key) == 40 or (len(curr_key) == 18 and curr_key.startswith('0x'))\n+\n+        if \"Can't check signature: No public key\" in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            unknown_sigs.append(SigData(curr_key, '', False, ''))\n+            curr_key = None\n+\n+        if 'Good signature from ' in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+\n+            # It's safe to index output[i + 1] because if we saw a good sig, there should\n+            # always be another line\n+            trusted = (\n+                'This key is not certified with a trusted signature' not in output[i + 1])\n+            good_sigs.append(SigData(curr_key, name, trusted, status))\n+            curr_key = None\n+\n+        if 'bad signature from' in line.lower():\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+            bad_sigs.append(SigData(curr_key, name, False, status))\n+            curr_key = None\n+\n+        # Track total signatures included\n+        if ': Signature made ' in line:\n+            total_resolved_sigs += 1\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n+def parse_gpg_from_line(line: str) -> (str, str):\n+    \"\"\"Returns name and expiration status.\"\"\"\n+    assert 'signature from' in line\n+\n+    name_end = line.split(' from ')[-1]\n+    m = re.search(r'(?P<name>\".+\") \\[(?P<status>\\w+)\\]', name_end)\n+    assert m\n+    (name, status) = m.groups()\n+    name = name.strip('\"\\'')\n+\n+    return (name, status)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"[{VERSIONPREFIX}]{VERSION_FORMAT} \"\n+            f\"(example: {VERSIONPREFIX}{VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def get_builder_keys(bitcoin_dir: Path) -> t.Dict[str, str]:\n+    \"\"\"\n+    Return a map of builder key to name from a local or remote source,\n+    in that order of preference.\n+    If we have them locally, compare them to the github repo.\n+    \"\"\"\n+    local_builder_keys = []\n+    local_builder_path = bitcoin_dir / 'contrib' / 'builder-keys' / 'keys.txt'\n+    if local_builder_path.exists():\n+        local_builder_keys = local_builder_path.read_text().splitlines()\n+\n+    success, gh_builder_keys = download_lines_with_urllib(BUILDER_KEYS_GH_URL)\n+    if not success:\n+        log.warning(f\"unable to retrieve builder keys from {BUILDER_KEYS_GH_URL}\")\n+\n+    if not (success or local_builder_keys):\n+        log.error(\"unable to retrieve builder keys locally or remotely\")\n+\n+    # check the local and remote builder keys against each other and report diff\n+    if local_builder_keys and gh_builder_keys:\n+        if local_builder_keys != gh_builder_keys:\n+            diff = indent(\n+                '\\n'.join(difflib.unified_diff(local_builder_keys, gh_builder_keys)))\n+            log.warning(f\"found diff (local vs. GH) in builder keys:\\n{diff}\\n\")\n+\n+    # Prefer local builder keys to those obtained remotely.\n+    builder_keys = local_builder_keys or gh_builder_keys or []\n+\n+    builder_key_map = {}\n+    for i in builder_keys:\n+        key, name = i.split(' ', 1)\n+        builder_key_map[key] = name\n+\n+    return builder_key_map\n+\n+\n+def check_multisig(\n+    sigfilename: str, args: argparse.Namespace, builder_key_map: t.Dict[str, str]\n+):\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    # Retrieve unknown keys that are in the repo builder list and then try GPG again.\n+    if unknown and not args.noninteractive and not args.skip_import_builders:\n+        for unsig in unknown:\n+            name = builder_key_map.get(unsig.key, '<unknown>')\n+            if input(f\" ? Retrieve key {unsig.key} for {name}? (y/N) \").lower() == \"y\":\n+                ran = subprocess.run(\n+                    f\"gpg --keyserver {args.keyserver} --recv-keys {unsig.key}\", shell=True)\n+\n+                if ran.returncode != 0:\n+                    log.warning(f\"failed to retrieve key {unsig.key} for {name}\")\n+\n+    return retval, output, good, unknown, bad\n+\n+\n+def check_single_sig(sigfilename: str, args: argparse.Namespace):\n+    retval, output = verify_with_gpg(sigfilename, SUMS_FILENAME)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    return retval, output, good, unknown, bad\n \n \n def main(args):\n-    # sanity check\n-    if len(args) < 1:\n-        print(\"Error: need to specify a version on the command line\")\n-        return 3\n+    args = parser.parse_args()\n+    if args.quiet:\n+        log.setLevel(logging.WARNING)\n+\n+    WORKINGDIR = Path(tempfile.gettempdir()) / f\"bitcoin_verify_binaries.{args.version}\"\n+\n+    def cleanup():\n+        log.info(\"cleaning up files\")\n+        os.chdir(Path.home())\n+        shutil.rmtree(WORKINGDIR)\n \n     # determine remote dir dependent on provided version string\n-    version_base, version_rc, os_filter = parse_version_string(args[0])\n+    version_base, version_rc, os_filter = parse_version_string(args.version)\n     remote_dir = f\"/bin/{VERSIONPREFIX}{version_base}/\"\n     if version_rc:\n         remote_dir += f\"test.{version_rc}/\"\n-    remote_sigfile = remote_dir + SIGNATUREFILENAME\n+    remote_sigs_path = remote_dir + SIGNATUREFILENAME\n+    remote_sums_path = remote_dir + SUMS_FILENAME\n \n+    bitcoin_dir_maybe = Path(args.bitcoin_src_path) if args.bitcoin_src_path else Path.cwd()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766105083",
      "id" : 766105083,
      "line" : 490,
      "node_id" : "PRRC_kwDOABII584tqdX7",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 490,
      "original_position" : 492,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 492,
      "pull_request_review_id" : 828027865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766105083/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-09T21:16:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766105083",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766119564"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766119564"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This optiony seems awkard currently and not useful. Would suggest dropping or replacing with a '--import-builder-keys' bool option.\r\n\r\nRight now this option is redundant and does the exact same thing as --noninteractive. It's also indirect, choosing whether or not to prompt about receiving keys, instead of just choosing whether or not to receive keys.\r\n\r\nI think it would be better have a plain `--import-builder-keys` option (defaulting to false) that would provide a way to import keys with `--noninteractive`, and confirm before importing each key without `--noninteractive`",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-09T20:11:20Z",
      "diff_hunk" : "@@ -2,29 +2,164 @@\n # Copyright (c) 2020 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Script for verifying Bitcoin Core release binaries\n-\n-This script attempts to download the signature file SHA256SUMS.asc from\n-bitcoincore.org and bitcoin.org and compares them.\n-It first checks if the signature passes, and then downloads the files\n-specified in the file, and checks if the hashes of these files match those\n-that are specified in the signature file.\n-The script returns 0 if everything passes the checks. It returns 1 if either\n-the signature check or the hash check doesn't pass. If an error occurs the\n-return value is >= 2.\n+\"\"\"Script for verifying Bitcoin Core release binaries.\n+\n+This script attempts to download the sum file SHA256SUMS and corresponding\n+signature file SHA256SUMS.asc from bitcoincore.org and bitcoin.org and\n+compares them.\n+\n+The sum-signature file is signed by a number of builder keys. This script\n+ensures that there is a minimum threshold of signatures from pubkeys that\n+we trust. This trust is articulated on the basis of configuration options\n+here, but by default is based upon a unionof (i) local GPG trust settings,\n+and (ii) keys which appear in the builder-keys/keys.txt file.\n+\n+If a minimum good, trusted signature threshold is met on the sum file, we then\n+download the files specified in SHA256SUMS, and check if the hashes of these\n+files match those that are specified. The script returns 0 if everything passes\n+the checks. It returns 1 if either the signature check or the hash check\n+doesn't pass. If an error occurs the return value is >= 2.\n+\n+Logging output goes to stderr and final binary verification data goes to stdout.\n+\n+JSON output can by obtained by setting env BINVERIFY_JSON=1.\n \"\"\"\n-from hashlib import sha256\n+import argparse\n+import difflib\n+import json\n+import logging\n import os\n import subprocess\n+import typing as t\n+import re\n import sys\n-from textwrap import indent\n+import shutil\n+import tempfile\n+import textwrap\n+import urllib.request\n+import enum\n+from hashlib import sha256\n+from pathlib import Path\n \n-WORKINGDIR = \"/tmp/bitcoin_verify_binaries\"\n-HASHFILE = \"hashes.tmp\"\n+# The primary host; this will fail if we can't retrieve files from here.\n HOST1 = \"https://bitcoincore.org\"\n HOST2 = \"https://bitcoin.org\"\n VERSIONPREFIX = \"bitcoin-core-\"\n-SIGNATUREFILENAME = \"SHA256SUMS.asc\"\n+SUMS_FILENAME = 'SHA256SUMS'\n+SIGNATUREFILENAME = f\"{SUMS_FILENAME}.asc\"\n+BUILDER_KEYS_GH_URL = (\n+    \"https://raw.githubusercontent.com/bitcoin/bitcoin/master/contrib/builder-keys/keys.txt\"\n+)\n+\n+\n+class ReturnCode(enum.IntEnum):\n+    SUCCESS = 0\n+    INTEGRITY_FAILURE = 1\n+    FILE_GET_FAILED = 4\n+    FILE_MISSING_FROM_ONE_HOST = 5\n+    FILES_NOT_EQUAL = 6\n+    NO_BINARIES_MATCH = 7\n+    NOT_ENOUGH_GOOD_SIGS = 9\n+    BINARY_DOWNLOAD_FAILED = 10\n+\n+\n+def set_up_logger(is_verbose: bool = True) -> logging.Logger:\n+    \"\"\"Set up a logger that writes to stderr.\"\"\"\n+    log = logging.getLogger(__name__)\n+    log.setLevel(logging.INFO if is_verbose else logging.WARNING)\n+    console = logging.StreamHandler(sys.stderr)  # log to stderr\n+    console.setLevel(logging.DEBUG)\n+    formatter = logging.Formatter('[%(levelname)s] %(message)s')\n+    console.setFormatter(formatter)\n+    log.addHandler(console)\n+    return log\n+\n+\n+log = set_up_logger()\n+\n+\n+def indent(output: str) -> str:\n+    return textwrap.indent(output, '  ')\n+\n+\n+def bool_from_env(key, default=False) -> bool:\n+    if key not in os.environ:\n+        return default\n+    raw = os.environ[key]\n+    return raw in ['1', 'True', 'true']\n+\n+\n+VERSION_FORMAT = \"<major>.<minor>[.<patch>][-rc[0-9]][-platform]\"\n+VERSION_EXAMPLE = \"22.0-x86_64 or 0.21.0-rc2-osx\"\n+\n+parser = argparse.ArgumentParser(description=__doc__)\n+parser.add_argument(\n+    'version', type=str, help=(\n+        f'version of the bitcoin release to download; of the format '\n+        f'{VERSION_FORMAT}. Example: {VERSION_EXAMPLE}')\n+)\n+parser.add_argument(\n+    '-v', '--verbose', action='store_true',\n+    default=bool_from_env('BINVERIFY_VERBOSE'),\n+)\n+parser.add_argument(\n+    '-q', '--quiet', action='store_true',\n+    default=bool_from_env('BINVERIFY_QUIET'),\n+)\n+parser.add_argument(\n+    '--cleanup', action='store_true',\n+    default=bool_from_env('BINVERIFY_CLEANUP'),\n+    help='if specified, clean up files afterwards'\n+)\n+parser.add_argument(\n+    '--noninteractive', action='store_true',\n+    default=bool_from_env('BINVERIFY_NONINTERACTIVE'),\n+    help='if specified, do not block for user input'\n+)\n+parser.add_argument(\n+    '--require-all-hosts', action='store_true',\n+    default=bool_from_env('BINVERIFY_REQUIRE_ALL_HOSTS'),\n+    help=(\n+        f'If set, require all hosts ({HOST1}, {HOST2}) to provide signatures. '\n+        '(Sometimes bitcoin.org lags behind bitcoincore.org.)')\n+)\n+parser.add_argument(\n+    '--bitcoin-src-path', action='store', nargs='?',\n+    default=os.environ.get('BINVERIFY_BITCOIN_SRC_PATH', ''),\n+    help='specify path to bitcoin repository. Used to find builder keys.',\n+)\n+parser.add_argument(\n+    '--skip-import-builders', action='store_true',\n+    default=bool_from_env('BINVERIFY_SKIP_IMPORT_BUILDERS'),\n+    help='If set, do not prompt to import builder pubkeys',\n+)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766119564",
      "id" : 766119564,
      "line" : 135,
      "node_id" : "PRRC_kwDOABII584tqg6M",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 135,
      "original_position" : 149,
      "original_start_line" : 131,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 149,
      "pull_request_review_id" : 828027865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766119564/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 131,
      "start_side" : "RIGHT",
      "updated_at" : "2021-12-09T21:16:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766119564",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766123661"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766123661"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Would be good to say this option is ignored when verifying older releases with only one signature.",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-09T20:16:57Z",
      "diff_hunk" : "@@ -2,29 +2,164 @@\n # Copyright (c) 2020 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Script for verifying Bitcoin Core release binaries\n-\n-This script attempts to download the signature file SHA256SUMS.asc from\n-bitcoincore.org and bitcoin.org and compares them.\n-It first checks if the signature passes, and then downloads the files\n-specified in the file, and checks if the hashes of these files match those\n-that are specified in the signature file.\n-The script returns 0 if everything passes the checks. It returns 1 if either\n-the signature check or the hash check doesn't pass. If an error occurs the\n-return value is >= 2.\n+\"\"\"Script for verifying Bitcoin Core release binaries.\n+\n+This script attempts to download the sum file SHA256SUMS and corresponding\n+signature file SHA256SUMS.asc from bitcoincore.org and bitcoin.org and\n+compares them.\n+\n+The sum-signature file is signed by a number of builder keys. This script\n+ensures that there is a minimum threshold of signatures from pubkeys that\n+we trust. This trust is articulated on the basis of configuration options\n+here, but by default is based upon a unionof (i) local GPG trust settings,\n+and (ii) keys which appear in the builder-keys/keys.txt file.\n+\n+If a minimum good, trusted signature threshold is met on the sum file, we then\n+download the files specified in SHA256SUMS, and check if the hashes of these\n+files match those that are specified. The script returns 0 if everything passes\n+the checks. It returns 1 if either the signature check or the hash check\n+doesn't pass. If an error occurs the return value is >= 2.\n+\n+Logging output goes to stderr and final binary verification data goes to stdout.\n+\n+JSON output can by obtained by setting env BINVERIFY_JSON=1.\n \"\"\"\n-from hashlib import sha256\n+import argparse\n+import difflib\n+import json\n+import logging\n import os\n import subprocess\n+import typing as t\n+import re\n import sys\n-from textwrap import indent\n+import shutil\n+import tempfile\n+import textwrap\n+import urllib.request\n+import enum\n+from hashlib import sha256\n+from pathlib import Path\n \n-WORKINGDIR = \"/tmp/bitcoin_verify_binaries\"\n-HASHFILE = \"hashes.tmp\"\n+# The primary host; this will fail if we can't retrieve files from here.\n HOST1 = \"https://bitcoincore.org\"\n HOST2 = \"https://bitcoin.org\"\n VERSIONPREFIX = \"bitcoin-core-\"\n-SIGNATUREFILENAME = \"SHA256SUMS.asc\"\n+SUMS_FILENAME = 'SHA256SUMS'\n+SIGNATUREFILENAME = f\"{SUMS_FILENAME}.asc\"\n+BUILDER_KEYS_GH_URL = (\n+    \"https://raw.githubusercontent.com/bitcoin/bitcoin/master/contrib/builder-keys/keys.txt\"\n+)\n+\n+\n+class ReturnCode(enum.IntEnum):\n+    SUCCESS = 0\n+    INTEGRITY_FAILURE = 1\n+    FILE_GET_FAILED = 4\n+    FILE_MISSING_FROM_ONE_HOST = 5\n+    FILES_NOT_EQUAL = 6\n+    NO_BINARIES_MATCH = 7\n+    NOT_ENOUGH_GOOD_SIGS = 9\n+    BINARY_DOWNLOAD_FAILED = 10\n+\n+\n+def set_up_logger(is_verbose: bool = True) -> logging.Logger:\n+    \"\"\"Set up a logger that writes to stderr.\"\"\"\n+    log = logging.getLogger(__name__)\n+    log.setLevel(logging.INFO if is_verbose else logging.WARNING)\n+    console = logging.StreamHandler(sys.stderr)  # log to stderr\n+    console.setLevel(logging.DEBUG)\n+    formatter = logging.Formatter('[%(levelname)s] %(message)s')\n+    console.setFormatter(formatter)\n+    log.addHandler(console)\n+    return log\n+\n+\n+log = set_up_logger()\n+\n+\n+def indent(output: str) -> str:\n+    return textwrap.indent(output, '  ')\n+\n+\n+def bool_from_env(key, default=False) -> bool:\n+    if key not in os.environ:\n+        return default\n+    raw = os.environ[key]\n+    return raw in ['1', 'True', 'true']\n+\n+\n+VERSION_FORMAT = \"<major>.<minor>[.<patch>][-rc[0-9]][-platform]\"\n+VERSION_EXAMPLE = \"22.0-x86_64 or 0.21.0-rc2-osx\"\n+\n+parser = argparse.ArgumentParser(description=__doc__)\n+parser.add_argument(\n+    'version', type=str, help=(\n+        f'version of the bitcoin release to download; of the format '\n+        f'{VERSION_FORMAT}. Example: {VERSION_EXAMPLE}')\n+)\n+parser.add_argument(\n+    '-v', '--verbose', action='store_true',\n+    default=bool_from_env('BINVERIFY_VERBOSE'),\n+)\n+parser.add_argument(\n+    '-q', '--quiet', action='store_true',\n+    default=bool_from_env('BINVERIFY_QUIET'),\n+)\n+parser.add_argument(\n+    '--cleanup', action='store_true',\n+    default=bool_from_env('BINVERIFY_CLEANUP'),\n+    help='if specified, clean up files afterwards'\n+)\n+parser.add_argument(\n+    '--noninteractive', action='store_true',\n+    default=bool_from_env('BINVERIFY_NONINTERACTIVE'),\n+    help='if specified, do not block for user input'\n+)\n+parser.add_argument(\n+    '--require-all-hosts', action='store_true',\n+    default=bool_from_env('BINVERIFY_REQUIRE_ALL_HOSTS'),\n+    help=(\n+        f'If set, require all hosts ({HOST1}, {HOST2}) to provide signatures. '\n+        '(Sometimes bitcoin.org lags behind bitcoincore.org.)')\n+)\n+parser.add_argument(\n+    '--bitcoin-src-path', action='store', nargs='?',\n+    default=os.environ.get('BINVERIFY_BITCOIN_SRC_PATH', ''),\n+    help='specify path to bitcoin repository. Used to find builder keys.',\n+)\n+parser.add_argument(\n+    '--skip-import-builders', action='store_true',\n+    default=bool_from_env('BINVERIFY_SKIP_IMPORT_BUILDERS'),\n+    help='If set, do not prompt to import builder pubkeys',\n+)\n+parser.add_argument(\n+    '--min-trusted-sigs', type=int, action='store', nargs='?',\n+    default=int(os.environ.get('BINVERIFY_MIN_TRUSTED_SIGS', 4)),\n+    help=(\n+        'The minimum number of good signatures from recognized keys to '\n+        'require successful termination.'),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766123661",
      "id" : 766123661,
      "line" : 141,
      "node_id" : "PRRC_kwDOABII584tqh6N",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 141,
      "original_position" : 155,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 155,
      "pull_request_review_id" : 828027865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766123661/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-09T21:16:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766123661",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766126255"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766126255"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Would be good to say this has nothing to with GPG trusted keys\r\n\r\nAlso might be good to say \"separated by commas\" instead of \"specified as CSV\". CSV implies extra complexity around escaping",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-09T20:21:00Z",
      "diff_hunk" : "@@ -2,29 +2,164 @@\n # Copyright (c) 2020 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Script for verifying Bitcoin Core release binaries\n-\n-This script attempts to download the signature file SHA256SUMS.asc from\n-bitcoincore.org and bitcoin.org and compares them.\n-It first checks if the signature passes, and then downloads the files\n-specified in the file, and checks if the hashes of these files match those\n-that are specified in the signature file.\n-The script returns 0 if everything passes the checks. It returns 1 if either\n-the signature check or the hash check doesn't pass. If an error occurs the\n-return value is >= 2.\n+\"\"\"Script for verifying Bitcoin Core release binaries.\n+\n+This script attempts to download the sum file SHA256SUMS and corresponding\n+signature file SHA256SUMS.asc from bitcoincore.org and bitcoin.org and\n+compares them.\n+\n+The sum-signature file is signed by a number of builder keys. This script\n+ensures that there is a minimum threshold of signatures from pubkeys that\n+we trust. This trust is articulated on the basis of configuration options\n+here, but by default is based upon a unionof (i) local GPG trust settings,\n+and (ii) keys which appear in the builder-keys/keys.txt file.\n+\n+If a minimum good, trusted signature threshold is met on the sum file, we then\n+download the files specified in SHA256SUMS, and check if the hashes of these\n+files match those that are specified. The script returns 0 if everything passes\n+the checks. It returns 1 if either the signature check or the hash check\n+doesn't pass. If an error occurs the return value is >= 2.\n+\n+Logging output goes to stderr and final binary verification data goes to stdout.\n+\n+JSON output can by obtained by setting env BINVERIFY_JSON=1.\n \"\"\"\n-from hashlib import sha256\n+import argparse\n+import difflib\n+import json\n+import logging\n import os\n import subprocess\n+import typing as t\n+import re\n import sys\n-from textwrap import indent\n+import shutil\n+import tempfile\n+import textwrap\n+import urllib.request\n+import enum\n+from hashlib import sha256\n+from pathlib import Path\n \n-WORKINGDIR = \"/tmp/bitcoin_verify_binaries\"\n-HASHFILE = \"hashes.tmp\"\n+# The primary host; this will fail if we can't retrieve files from here.\n HOST1 = \"https://bitcoincore.org\"\n HOST2 = \"https://bitcoin.org\"\n VERSIONPREFIX = \"bitcoin-core-\"\n-SIGNATUREFILENAME = \"SHA256SUMS.asc\"\n+SUMS_FILENAME = 'SHA256SUMS'\n+SIGNATUREFILENAME = f\"{SUMS_FILENAME}.asc\"\n+BUILDER_KEYS_GH_URL = (\n+    \"https://raw.githubusercontent.com/bitcoin/bitcoin/master/contrib/builder-keys/keys.txt\"\n+)\n+\n+\n+class ReturnCode(enum.IntEnum):\n+    SUCCESS = 0\n+    INTEGRITY_FAILURE = 1\n+    FILE_GET_FAILED = 4\n+    FILE_MISSING_FROM_ONE_HOST = 5\n+    FILES_NOT_EQUAL = 6\n+    NO_BINARIES_MATCH = 7\n+    NOT_ENOUGH_GOOD_SIGS = 9\n+    BINARY_DOWNLOAD_FAILED = 10\n+\n+\n+def set_up_logger(is_verbose: bool = True) -> logging.Logger:\n+    \"\"\"Set up a logger that writes to stderr.\"\"\"\n+    log = logging.getLogger(__name__)\n+    log.setLevel(logging.INFO if is_verbose else logging.WARNING)\n+    console = logging.StreamHandler(sys.stderr)  # log to stderr\n+    console.setLevel(logging.DEBUG)\n+    formatter = logging.Formatter('[%(levelname)s] %(message)s')\n+    console.setFormatter(formatter)\n+    log.addHandler(console)\n+    return log\n+\n+\n+log = set_up_logger()\n+\n+\n+def indent(output: str) -> str:\n+    return textwrap.indent(output, '  ')\n+\n+\n+def bool_from_env(key, default=False) -> bool:\n+    if key not in os.environ:\n+        return default\n+    raw = os.environ[key]\n+    return raw in ['1', 'True', 'true']\n+\n+\n+VERSION_FORMAT = \"<major>.<minor>[.<patch>][-rc[0-9]][-platform]\"\n+VERSION_EXAMPLE = \"22.0-x86_64 or 0.21.0-rc2-osx\"\n+\n+parser = argparse.ArgumentParser(description=__doc__)\n+parser.add_argument(\n+    'version', type=str, help=(\n+        f'version of the bitcoin release to download; of the format '\n+        f'{VERSION_FORMAT}. Example: {VERSION_EXAMPLE}')\n+)\n+parser.add_argument(\n+    '-v', '--verbose', action='store_true',\n+    default=bool_from_env('BINVERIFY_VERBOSE'),\n+)\n+parser.add_argument(\n+    '-q', '--quiet', action='store_true',\n+    default=bool_from_env('BINVERIFY_QUIET'),\n+)\n+parser.add_argument(\n+    '--cleanup', action='store_true',\n+    default=bool_from_env('BINVERIFY_CLEANUP'),\n+    help='if specified, clean up files afterwards'\n+)\n+parser.add_argument(\n+    '--noninteractive', action='store_true',\n+    default=bool_from_env('BINVERIFY_NONINTERACTIVE'),\n+    help='if specified, do not block for user input'\n+)\n+parser.add_argument(\n+    '--require-all-hosts', action='store_true',\n+    default=bool_from_env('BINVERIFY_REQUIRE_ALL_HOSTS'),\n+    help=(\n+        f'If set, require all hosts ({HOST1}, {HOST2}) to provide signatures. '\n+        '(Sometimes bitcoin.org lags behind bitcoincore.org.)')\n+)\n+parser.add_argument(\n+    '--bitcoin-src-path', action='store', nargs='?',\n+    default=os.environ.get('BINVERIFY_BITCOIN_SRC_PATH', ''),\n+    help='specify path to bitcoin repository. Used to find builder keys.',\n+)\n+parser.add_argument(\n+    '--skip-import-builders', action='store_true',\n+    default=bool_from_env('BINVERIFY_SKIP_IMPORT_BUILDERS'),\n+    help='If set, do not prompt to import builder pubkeys',\n+)\n+parser.add_argument(\n+    '--min-trusted-sigs', type=int, action='store', nargs='?',\n+    default=int(os.environ.get('BINVERIFY_MIN_TRUSTED_SIGS', 4)),\n+    help=(\n+        'The minimum number of good signatures from recognized keys to '\n+        'require successful termination.'),\n+)\n+parser.add_argument(\n+    '--keyserver', action='store', nargs='?',\n+    default=os.environ.get('BINVERIFY_KEYSERVER', 'hkp://keyserver.ubuntu.com'),\n+    help='which keyserver to use',\n+)\n+parser.add_argument(\n+    '--trusted-keys', action='store', nargs='?',\n+    default=os.environ.get('BINVERIFY_TRUSTED_KEYS', ''),\n+    help='A list of trusted builder GPG keys, specified as CSV',",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766126255",
      "id" : 766126255,
      "line" : 151,
      "node_id" : "PRRC_kwDOABII584tqiiv",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 151,
      "original_position" : 165,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 165,
      "pull_request_review_id" : 828027865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766126255/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-09T21:16:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766126255",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766134684"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766134684"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Would call this `--trust-builder-keys` to be consistent with `--trusted-keys` and `--min-trusted-sigs`.\r\n\r\nCurrent double negation and interaction with environment variable also seems awkward and has weird edge cases, like there's no way to set the argument to false if the environment variable sets it to true.\r\n\r\nMaybe this would be better:\r\n\r\n```python\r\nparser.add_argument('--trust-builder-keys', dest='trust_builder_keys', action='store_true', help=\"Treat keys in local builder-keys/keys.txt file as trusted\")\r\nparser.add_argument('--no-trust-builder-keys', dest='trust_builder_keys', action='store_false')\r\nparser.set_defaults(trust_builder_keys=bool_from_env('BINVERIFY_TRUST_BUILDER_KEYS', True))\r\n```",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-09T20:34:44Z",
      "diff_hunk" : "@@ -2,29 +2,164 @@\n # Copyright (c) 2020 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Script for verifying Bitcoin Core release binaries\n-\n-This script attempts to download the signature file SHA256SUMS.asc from\n-bitcoincore.org and bitcoin.org and compares them.\n-It first checks if the signature passes, and then downloads the files\n-specified in the file, and checks if the hashes of these files match those\n-that are specified in the signature file.\n-The script returns 0 if everything passes the checks. It returns 1 if either\n-the signature check or the hash check doesn't pass. If an error occurs the\n-return value is >= 2.\n+\"\"\"Script for verifying Bitcoin Core release binaries.\n+\n+This script attempts to download the sum file SHA256SUMS and corresponding\n+signature file SHA256SUMS.asc from bitcoincore.org and bitcoin.org and\n+compares them.\n+\n+The sum-signature file is signed by a number of builder keys. This script\n+ensures that there is a minimum threshold of signatures from pubkeys that\n+we trust. This trust is articulated on the basis of configuration options\n+here, but by default is based upon a unionof (i) local GPG trust settings,\n+and (ii) keys which appear in the builder-keys/keys.txt file.\n+\n+If a minimum good, trusted signature threshold is met on the sum file, we then\n+download the files specified in SHA256SUMS, and check if the hashes of these\n+files match those that are specified. The script returns 0 if everything passes\n+the checks. It returns 1 if either the signature check or the hash check\n+doesn't pass. If an error occurs the return value is >= 2.\n+\n+Logging output goes to stderr and final binary verification data goes to stdout.\n+\n+JSON output can by obtained by setting env BINVERIFY_JSON=1.\n \"\"\"\n-from hashlib import sha256\n+import argparse\n+import difflib\n+import json\n+import logging\n import os\n import subprocess\n+import typing as t\n+import re\n import sys\n-from textwrap import indent\n+import shutil\n+import tempfile\n+import textwrap\n+import urllib.request\n+import enum\n+from hashlib import sha256\n+from pathlib import Path\n \n-WORKINGDIR = \"/tmp/bitcoin_verify_binaries\"\n-HASHFILE = \"hashes.tmp\"\n+# The primary host; this will fail if we can't retrieve files from here.\n HOST1 = \"https://bitcoincore.org\"\n HOST2 = \"https://bitcoin.org\"\n VERSIONPREFIX = \"bitcoin-core-\"\n-SIGNATUREFILENAME = \"SHA256SUMS.asc\"\n+SUMS_FILENAME = 'SHA256SUMS'\n+SIGNATUREFILENAME = f\"{SUMS_FILENAME}.asc\"\n+BUILDER_KEYS_GH_URL = (\n+    \"https://raw.githubusercontent.com/bitcoin/bitcoin/master/contrib/builder-keys/keys.txt\"\n+)\n+\n+\n+class ReturnCode(enum.IntEnum):\n+    SUCCESS = 0\n+    INTEGRITY_FAILURE = 1\n+    FILE_GET_FAILED = 4\n+    FILE_MISSING_FROM_ONE_HOST = 5\n+    FILES_NOT_EQUAL = 6\n+    NO_BINARIES_MATCH = 7\n+    NOT_ENOUGH_GOOD_SIGS = 9\n+    BINARY_DOWNLOAD_FAILED = 10\n+\n+\n+def set_up_logger(is_verbose: bool = True) -> logging.Logger:\n+    \"\"\"Set up a logger that writes to stderr.\"\"\"\n+    log = logging.getLogger(__name__)\n+    log.setLevel(logging.INFO if is_verbose else logging.WARNING)\n+    console = logging.StreamHandler(sys.stderr)  # log to stderr\n+    console.setLevel(logging.DEBUG)\n+    formatter = logging.Formatter('[%(levelname)s] %(message)s')\n+    console.setFormatter(formatter)\n+    log.addHandler(console)\n+    return log\n+\n+\n+log = set_up_logger()\n+\n+\n+def indent(output: str) -> str:\n+    return textwrap.indent(output, '  ')\n+\n+\n+def bool_from_env(key, default=False) -> bool:\n+    if key not in os.environ:\n+        return default\n+    raw = os.environ[key]\n+    return raw in ['1', 'True', 'true']\n+\n+\n+VERSION_FORMAT = \"<major>.<minor>[.<patch>][-rc[0-9]][-platform]\"\n+VERSION_EXAMPLE = \"22.0-x86_64 or 0.21.0-rc2-osx\"\n+\n+parser = argparse.ArgumentParser(description=__doc__)\n+parser.add_argument(\n+    'version', type=str, help=(\n+        f'version of the bitcoin release to download; of the format '\n+        f'{VERSION_FORMAT}. Example: {VERSION_EXAMPLE}')\n+)\n+parser.add_argument(\n+    '-v', '--verbose', action='store_true',\n+    default=bool_from_env('BINVERIFY_VERBOSE'),\n+)\n+parser.add_argument(\n+    '-q', '--quiet', action='store_true',\n+    default=bool_from_env('BINVERIFY_QUIET'),\n+)\n+parser.add_argument(\n+    '--cleanup', action='store_true',\n+    default=bool_from_env('BINVERIFY_CLEANUP'),\n+    help='if specified, clean up files afterwards'\n+)\n+parser.add_argument(\n+    '--noninteractive', action='store_true',\n+    default=bool_from_env('BINVERIFY_NONINTERACTIVE'),\n+    help='if specified, do not block for user input'\n+)\n+parser.add_argument(\n+    '--require-all-hosts', action='store_true',\n+    default=bool_from_env('BINVERIFY_REQUIRE_ALL_HOSTS'),\n+    help=(\n+        f'If set, require all hosts ({HOST1}, {HOST2}) to provide signatures. '\n+        '(Sometimes bitcoin.org lags behind bitcoincore.org.)')\n+)\n+parser.add_argument(\n+    '--bitcoin-src-path', action='store', nargs='?',\n+    default=os.environ.get('BINVERIFY_BITCOIN_SRC_PATH', ''),\n+    help='specify path to bitcoin repository. Used to find builder keys.',\n+)\n+parser.add_argument(\n+    '--skip-import-builders', action='store_true',\n+    default=bool_from_env('BINVERIFY_SKIP_IMPORT_BUILDERS'),\n+    help='If set, do not prompt to import builder pubkeys',\n+)\n+parser.add_argument(\n+    '--min-trusted-sigs', type=int, action='store', nargs='?',\n+    default=int(os.environ.get('BINVERIFY_MIN_TRUSTED_SIGS', 4)),\n+    help=(\n+        'The minimum number of good signatures from recognized keys to '\n+        'require successful termination.'),\n+)\n+parser.add_argument(\n+    '--keyserver', action='store', nargs='?',\n+    default=os.environ.get('BINVERIFY_KEYSERVER', 'hkp://keyserver.ubuntu.com'),\n+    help='which keyserver to use',\n+)\n+parser.add_argument(\n+    '--trusted-keys', action='store', nargs='?',\n+    default=os.environ.get('BINVERIFY_TRUSTED_KEYS', ''),\n+    help='A list of trusted builder GPG keys, specified as CSV',\n+)\n+parser.add_argument(\n+    '--no-builder-keys', action='store_true',",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766134684",
      "id" : 766134684,
      "line" : 154,
      "node_id" : "PRRC_kwDOABII584tqkmc",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 154,
      "original_position" : 168,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 168,
      "pull_request_review_id" : 828027865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766134684/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-09T21:16:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766134684",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766142230"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766142230"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "There are gaps in numbering here, so maybe would renumber, but I think it would be better to simplify semantics and just return SUCCESS-Verification succeeded, binary is trusted, FAILED-Verification failed, binary is not trusted, or ERROR-Not possible to verify, need to fix errors or retry\r\n\r\nMore detailed errors and status information would seem more appropriate to include in text and json output than condense into a status byte.",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-09T20:47:15Z",
      "diff_hunk" : "@@ -2,29 +2,164 @@\n # Copyright (c) 2020 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Script for verifying Bitcoin Core release binaries\n-\n-This script attempts to download the signature file SHA256SUMS.asc from\n-bitcoincore.org and bitcoin.org and compares them.\n-It first checks if the signature passes, and then downloads the files\n-specified in the file, and checks if the hashes of these files match those\n-that are specified in the signature file.\n-The script returns 0 if everything passes the checks. It returns 1 if either\n-the signature check or the hash check doesn't pass. If an error occurs the\n-return value is >= 2.\n+\"\"\"Script for verifying Bitcoin Core release binaries.\n+\n+This script attempts to download the sum file SHA256SUMS and corresponding\n+signature file SHA256SUMS.asc from bitcoincore.org and bitcoin.org and\n+compares them.\n+\n+The sum-signature file is signed by a number of builder keys. This script\n+ensures that there is a minimum threshold of signatures from pubkeys that\n+we trust. This trust is articulated on the basis of configuration options\n+here, but by default is based upon a unionof (i) local GPG trust settings,\n+and (ii) keys which appear in the builder-keys/keys.txt file.\n+\n+If a minimum good, trusted signature threshold is met on the sum file, we then\n+download the files specified in SHA256SUMS, and check if the hashes of these\n+files match those that are specified. The script returns 0 if everything passes\n+the checks. It returns 1 if either the signature check or the hash check\n+doesn't pass. If an error occurs the return value is >= 2.\n+\n+Logging output goes to stderr and final binary verification data goes to stdout.\n+\n+JSON output can by obtained by setting env BINVERIFY_JSON=1.\n \"\"\"\n-from hashlib import sha256\n+import argparse\n+import difflib\n+import json\n+import logging\n import os\n import subprocess\n+import typing as t\n+import re\n import sys\n-from textwrap import indent\n+import shutil\n+import tempfile\n+import textwrap\n+import urllib.request\n+import enum\n+from hashlib import sha256\n+from pathlib import Path\n \n-WORKINGDIR = \"/tmp/bitcoin_verify_binaries\"\n-HASHFILE = \"hashes.tmp\"\n+# The primary host; this will fail if we can't retrieve files from here.\n HOST1 = \"https://bitcoincore.org\"\n HOST2 = \"https://bitcoin.org\"\n VERSIONPREFIX = \"bitcoin-core-\"\n-SIGNATUREFILENAME = \"SHA256SUMS.asc\"\n+SUMS_FILENAME = 'SHA256SUMS'\n+SIGNATUREFILENAME = f\"{SUMS_FILENAME}.asc\"\n+BUILDER_KEYS_GH_URL = (\n+    \"https://raw.githubusercontent.com/bitcoin/bitcoin/master/contrib/builder-keys/keys.txt\"\n+)\n+\n+\n+class ReturnCode(enum.IntEnum):\n+    SUCCESS = 0\n+    INTEGRITY_FAILURE = 1\n+    FILE_GET_FAILED = 4\n+    FILE_MISSING_FROM_ONE_HOST = 5\n+    FILES_NOT_EQUAL = 6\n+    NO_BINARIES_MATCH = 7\n+    NOT_ENOUGH_GOOD_SIGS = 9\n+    BINARY_DOWNLOAD_FAILED = 10",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766142230",
      "id" : 766142230,
      "line" : 63,
      "node_id" : "PRRC_kwDOABII584tqmcW",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 63,
      "original_position" : 77,
      "original_start_line" : 57,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 77,
      "pull_request_review_id" : 828027865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766142230/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 57,
      "start_side" : "RIGHT",
      "updated_at" : "2021-12-09T21:16:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766142230",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766144667"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766144667"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Why is this being called here instead of in main? Would be more straightforward if log.setLevel was just called once in `set_up_logger` instead of changing later in main()",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-09T20:51:00Z",
      "diff_hunk" : "@@ -2,29 +2,164 @@\n # Copyright (c) 2020 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Script for verifying Bitcoin Core release binaries\n-\n-This script attempts to download the signature file SHA256SUMS.asc from\n-bitcoincore.org and bitcoin.org and compares them.\n-It first checks if the signature passes, and then downloads the files\n-specified in the file, and checks if the hashes of these files match those\n-that are specified in the signature file.\n-The script returns 0 if everything passes the checks. It returns 1 if either\n-the signature check or the hash check doesn't pass. If an error occurs the\n-return value is >= 2.\n+\"\"\"Script for verifying Bitcoin Core release binaries.\n+\n+This script attempts to download the sum file SHA256SUMS and corresponding\n+signature file SHA256SUMS.asc from bitcoincore.org and bitcoin.org and\n+compares them.\n+\n+The sum-signature file is signed by a number of builder keys. This script\n+ensures that there is a minimum threshold of signatures from pubkeys that\n+we trust. This trust is articulated on the basis of configuration options\n+here, but by default is based upon a unionof (i) local GPG trust settings,\n+and (ii) keys which appear in the builder-keys/keys.txt file.\n+\n+If a minimum good, trusted signature threshold is met on the sum file, we then\n+download the files specified in SHA256SUMS, and check if the hashes of these\n+files match those that are specified. The script returns 0 if everything passes\n+the checks. It returns 1 if either the signature check or the hash check\n+doesn't pass. If an error occurs the return value is >= 2.\n+\n+Logging output goes to stderr and final binary verification data goes to stdout.\n+\n+JSON output can by obtained by setting env BINVERIFY_JSON=1.\n \"\"\"\n-from hashlib import sha256\n+import argparse\n+import difflib\n+import json\n+import logging\n import os\n import subprocess\n+import typing as t\n+import re\n import sys\n-from textwrap import indent\n+import shutil\n+import tempfile\n+import textwrap\n+import urllib.request\n+import enum\n+from hashlib import sha256\n+from pathlib import Path\n \n-WORKINGDIR = \"/tmp/bitcoin_verify_binaries\"\n-HASHFILE = \"hashes.tmp\"\n+# The primary host; this will fail if we can't retrieve files from here.\n HOST1 = \"https://bitcoincore.org\"\n HOST2 = \"https://bitcoin.org\"\n VERSIONPREFIX = \"bitcoin-core-\"\n-SIGNATUREFILENAME = \"SHA256SUMS.asc\"\n+SUMS_FILENAME = 'SHA256SUMS'\n+SIGNATUREFILENAME = f\"{SUMS_FILENAME}.asc\"\n+BUILDER_KEYS_GH_URL = (\n+    \"https://raw.githubusercontent.com/bitcoin/bitcoin/master/contrib/builder-keys/keys.txt\"\n+)\n+\n+\n+class ReturnCode(enum.IntEnum):\n+    SUCCESS = 0\n+    INTEGRITY_FAILURE = 1\n+    FILE_GET_FAILED = 4\n+    FILE_MISSING_FROM_ONE_HOST = 5\n+    FILES_NOT_EQUAL = 6\n+    NO_BINARIES_MATCH = 7\n+    NOT_ENOUGH_GOOD_SIGS = 9\n+    BINARY_DOWNLOAD_FAILED = 10\n+\n+\n+def set_up_logger(is_verbose: bool = True) -> logging.Logger:\n+    \"\"\"Set up a logger that writes to stderr.\"\"\"\n+    log = logging.getLogger(__name__)\n+    log.setLevel(logging.INFO if is_verbose else logging.WARNING)\n+    console = logging.StreamHandler(sys.stderr)  # log to stderr\n+    console.setLevel(logging.DEBUG)\n+    formatter = logging.Formatter('[%(levelname)s] %(message)s')\n+    console.setFormatter(formatter)\n+    log.addHandler(console)\n+    return log\n+\n+\n+log = set_up_logger()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766144667",
      "id" : 766144667,
      "line" : 78,
      "node_id" : "PRRC_kwDOABII584tqnCb",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 78,
      "original_position" : 92,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 92,
      "pull_request_review_id" : 828027865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766144667/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-09T21:16:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766144667",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766147623"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766147623"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I guess this is preexisting code but parse_version_string below seems to silently accept len(parts) >= 3 instead of treating it like an error. Would seem more reliable to parse the full string and not silently ignore any parts. Otherwise script might return success while not verifying the thing it was supposed to verify.",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-09T20:55:47Z",
      "diff_hunk" : "@@ -2,29 +2,164 @@\n # Copyright (c) 2020 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Script for verifying Bitcoin Core release binaries\n-\n-This script attempts to download the signature file SHA256SUMS.asc from\n-bitcoincore.org and bitcoin.org and compares them.\n-It first checks if the signature passes, and then downloads the files\n-specified in the file, and checks if the hashes of these files match those\n-that are specified in the signature file.\n-The script returns 0 if everything passes the checks. It returns 1 if either\n-the signature check or the hash check doesn't pass. If an error occurs the\n-return value is >= 2.\n+\"\"\"Script for verifying Bitcoin Core release binaries.\n+\n+This script attempts to download the sum file SHA256SUMS and corresponding\n+signature file SHA256SUMS.asc from bitcoincore.org and bitcoin.org and\n+compares them.\n+\n+The sum-signature file is signed by a number of builder keys. This script\n+ensures that there is a minimum threshold of signatures from pubkeys that\n+we trust. This trust is articulated on the basis of configuration options\n+here, but by default is based upon a unionof (i) local GPG trust settings,\n+and (ii) keys which appear in the builder-keys/keys.txt file.\n+\n+If a minimum good, trusted signature threshold is met on the sum file, we then\n+download the files specified in SHA256SUMS, and check if the hashes of these\n+files match those that are specified. The script returns 0 if everything passes\n+the checks. It returns 1 if either the signature check or the hash check\n+doesn't pass. If an error occurs the return value is >= 2.\n+\n+Logging output goes to stderr and final binary verification data goes to stdout.\n+\n+JSON output can by obtained by setting env BINVERIFY_JSON=1.\n \"\"\"\n-from hashlib import sha256\n+import argparse\n+import difflib\n+import json\n+import logging\n import os\n import subprocess\n+import typing as t\n+import re\n import sys\n-from textwrap import indent\n+import shutil\n+import tempfile\n+import textwrap\n+import urllib.request\n+import enum\n+from hashlib import sha256\n+from pathlib import Path\n \n-WORKINGDIR = \"/tmp/bitcoin_verify_binaries\"\n-HASHFILE = \"hashes.tmp\"\n+# The primary host; this will fail if we can't retrieve files from here.\n HOST1 = \"https://bitcoincore.org\"\n HOST2 = \"https://bitcoin.org\"\n VERSIONPREFIX = \"bitcoin-core-\"\n-SIGNATUREFILENAME = \"SHA256SUMS.asc\"\n+SUMS_FILENAME = 'SHA256SUMS'\n+SIGNATUREFILENAME = f\"{SUMS_FILENAME}.asc\"\n+BUILDER_KEYS_GH_URL = (\n+    \"https://raw.githubusercontent.com/bitcoin/bitcoin/master/contrib/builder-keys/keys.txt\"\n+)\n+\n+\n+class ReturnCode(enum.IntEnum):\n+    SUCCESS = 0\n+    INTEGRITY_FAILURE = 1\n+    FILE_GET_FAILED = 4\n+    FILE_MISSING_FROM_ONE_HOST = 5\n+    FILES_NOT_EQUAL = 6\n+    NO_BINARIES_MATCH = 7\n+    NOT_ENOUGH_GOOD_SIGS = 9\n+    BINARY_DOWNLOAD_FAILED = 10\n+\n+\n+def set_up_logger(is_verbose: bool = True) -> logging.Logger:\n+    \"\"\"Set up a logger that writes to stderr.\"\"\"\n+    log = logging.getLogger(__name__)\n+    log.setLevel(logging.INFO if is_verbose else logging.WARNING)\n+    console = logging.StreamHandler(sys.stderr)  # log to stderr\n+    console.setLevel(logging.DEBUG)\n+    formatter = logging.Formatter('[%(levelname)s] %(message)s')\n+    console.setFormatter(formatter)\n+    log.addHandler(console)\n+    return log\n+\n+\n+log = set_up_logger()\n+\n+\n+def indent(output: str) -> str:\n+    return textwrap.indent(output, '  ')\n+\n+\n+def bool_from_env(key, default=False) -> bool:\n+    if key not in os.environ:\n+        return default\n+    raw = os.environ[key]\n+    return raw in ['1', 'True', 'true']\n+\n+\n+VERSION_FORMAT = \"<major>.<minor>[.<patch>][-rc[0-9]][-platform]\"\n+VERSION_EXAMPLE = \"22.0-x86_64 or 0.21.0-rc2-osx\"\n+\n+parser = argparse.ArgumentParser(description=__doc__)\n+parser.add_argument(\n+    'version', type=str, help=(\n+        f'version of the bitcoin release to download; of the format '\n+        f'{VERSION_FORMAT}. Example: {VERSION_EXAMPLE}')\n+)\n+parser.add_argument(\n+    '-v', '--verbose', action='store_true',\n+    default=bool_from_env('BINVERIFY_VERBOSE'),\n+)\n+parser.add_argument(\n+    '-q', '--quiet', action='store_true',\n+    default=bool_from_env('BINVERIFY_QUIET'),\n+)\n+parser.add_argument(\n+    '--cleanup', action='store_true',\n+    default=bool_from_env('BINVERIFY_CLEANUP'),\n+    help='if specified, clean up files afterwards'\n+)\n+parser.add_argument(\n+    '--noninteractive', action='store_true',\n+    default=bool_from_env('BINVERIFY_NONINTERACTIVE'),\n+    help='if specified, do not block for user input'\n+)\n+parser.add_argument(\n+    '--require-all-hosts', action='store_true',\n+    default=bool_from_env('BINVERIFY_REQUIRE_ALL_HOSTS'),\n+    help=(\n+        f'If set, require all hosts ({HOST1}, {HOST2}) to provide signatures. '\n+        '(Sometimes bitcoin.org lags behind bitcoincore.org.)')\n+)\n+parser.add_argument(\n+    '--bitcoin-src-path', action='store', nargs='?',\n+    default=os.environ.get('BINVERIFY_BITCOIN_SRC_PATH', ''),\n+    help='specify path to bitcoin repository. Used to find builder keys.',\n+)\n+parser.add_argument(\n+    '--skip-import-builders', action='store_true',\n+    default=bool_from_env('BINVERIFY_SKIP_IMPORT_BUILDERS'),\n+    help='If set, do not prompt to import builder pubkeys',\n+)\n+parser.add_argument(\n+    '--min-trusted-sigs', type=int, action='store', nargs='?',\n+    default=int(os.environ.get('BINVERIFY_MIN_TRUSTED_SIGS', 4)),\n+    help=(\n+        'The minimum number of good signatures from recognized keys to '\n+        'require successful termination.'),\n+)\n+parser.add_argument(\n+    '--keyserver', action='store', nargs='?',\n+    default=os.environ.get('BINVERIFY_KEYSERVER', 'hkp://keyserver.ubuntu.com'),\n+    help='which keyserver to use',\n+)\n+parser.add_argument(\n+    '--trusted-keys', action='store', nargs='?',\n+    default=os.environ.get('BINVERIFY_TRUSTED_KEYS', ''),\n+    help='A list of trusted builder GPG keys, specified as CSV',\n+)\n+parser.add_argument(\n+    '--no-builder-keys', action='store_true',\n+    default=bool_from_env('BINVERIFY_NO_BUILDER_KEYS'),\n+    help='If set, do not trust the builder-keys from the bitcoin repo by default',\n+)\n+parser.add_argument(\n+    '--json', action='store_true',\n+    default=bool_from_env('BINVERIFY_JSON'),\n+    help='If set, output the result as JSON',\n+)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766147623",
      "id" : 766147623,
      "line" : 162,
      "node_id" : "PRRC_kwDOABII584tqnwn",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 162,
      "original_position" : 176,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 176,
      "pull_request_review_id" : 828027865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766147623/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-09T21:16:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766147623",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766153692"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766153692"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This is calling wget without `-O` so if wget decides to write a .1, .2 file then then code below will verify the old existing file not the new downloaded file. Would be better to pass `binary_filename` as an explicit second argument to `download_with_wget`",
      "commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "created_at" : "2021-12-09T21:05:43Z",
      "diff_hunk" : "@@ -59,124 +194,457 @@ def download_with_wget(remote_file, local_file=None):\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError)\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    # Enforce English output since we're relying on output that contains natural language.\n+    # Use string-shell form (vs. args as list) because passing LANGUAGE via `env` doesn't\n+    # seem to work.\n+    args = (\n+        'LANGUAGE=en gpg --yes --decrypt '\n+        + (f' --output {output_filename} ' if output_filename else '')\n+        + signature_filename)\n+\n+    result = subprocess.run(args, shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n+    return result.returncode, result.stdout.decode().rstrip()\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self, key: str, name: str, trusted: bool, status: str):\n+        self.key = key\n+        self.name = name\n+        self.trusted = trusted\n+        self.status = status\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(output: str) -> ([SigData], [SigData], [SigData]):\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs = []\n+    unknown_sigs = []\n+    bad_sigs = []\n+    total_resolved_sigs = 0\n+    curr_key = None\n+\n+    for i, line in enumerate(output):\n+        if 'using RSA key' in line:\n+            if curr_key:\n+                raise RuntimeError(\n+                    f\"WARNING: encountered a new sig without resolving the last ({curr_key}) - \"\n+                    \"this could mean we have encountered a bad signature! check GPG output!\")\n+            curr_key = line.split('key ')[-1].strip()\n+            assert len(curr_key) == 40 or (len(curr_key) == 18 and curr_key.startswith('0x'))\n+\n+        if \"Can't check signature: No public key\" in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            unknown_sigs.append(SigData(curr_key, '', False, ''))\n+            curr_key = None\n+\n+        if 'Good signature from ' in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+\n+            # It's safe to index output[i + 1] because if we saw a good sig, there should\n+            # always be another line\n+            trusted = (\n+                'This key is not certified with a trusted signature' not in output[i + 1])\n+            good_sigs.append(SigData(curr_key, name, trusted, status))\n+            curr_key = None\n+\n+        if 'bad signature from' in line.lower():\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+            bad_sigs.append(SigData(curr_key, name, False, status))\n+            curr_key = None\n+\n+        # Track total signatures included\n+        if ': Signature made ' in line:\n+            total_resolved_sigs += 1\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n+def parse_gpg_from_line(line: str) -> (str, str):\n+    \"\"\"Returns name and expiration status.\"\"\"\n+    assert 'signature from' in line\n+\n+    name_end = line.split(' from ')[-1]\n+    m = re.search(r'(?P<name>\".+\") \\[(?P<status>\\w+)\\]', name_end)\n+    assert m\n+    (name, status) = m.groups()\n+    name = name.strip('\"\\'')\n+\n+    return (name, status)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"[{VERSIONPREFIX}]{VERSION_FORMAT} \"\n+            f\"(example: {VERSIONPREFIX}{VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def get_builder_keys(bitcoin_dir: Path) -> t.Dict[str, str]:\n+    \"\"\"\n+    Return a map of builder key to name from a local or remote source,\n+    in that order of preference.\n+    If we have them locally, compare them to the github repo.\n+    \"\"\"\n+    local_builder_keys = []\n+    local_builder_path = bitcoin_dir / 'contrib' / 'builder-keys' / 'keys.txt'\n+    if local_builder_path.exists():\n+        local_builder_keys = local_builder_path.read_text().splitlines()\n+\n+    success, gh_builder_keys = download_lines_with_urllib(BUILDER_KEYS_GH_URL)\n+    if not success:\n+        log.warning(f\"unable to retrieve builder keys from {BUILDER_KEYS_GH_URL}\")\n+\n+    if not (success or local_builder_keys):\n+        log.error(\"unable to retrieve builder keys locally or remotely\")\n+\n+    # check the local and remote builder keys against each other and report diff\n+    if local_builder_keys and gh_builder_keys:\n+        if local_builder_keys != gh_builder_keys:\n+            diff = indent(\n+                '\\n'.join(difflib.unified_diff(local_builder_keys, gh_builder_keys)))\n+            log.warning(f\"found diff (local vs. GH) in builder keys:\\n{diff}\\n\")\n+\n+    # Prefer local builder keys to those obtained remotely.\n+    builder_keys = local_builder_keys or gh_builder_keys or []\n+\n+    builder_key_map = {}\n+    for i in builder_keys:\n+        key, name = i.split(' ', 1)\n+        builder_key_map[key] = name\n+\n+    return builder_key_map\n+\n+\n+def check_multisig(\n+    sigfilename: str, args: argparse.Namespace, builder_key_map: t.Dict[str, str]\n+):\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    # Retrieve unknown keys that are in the repo builder list and then try GPG again.\n+    if unknown and not args.noninteractive and not args.skip_import_builders:\n+        for unsig in unknown:\n+            name = builder_key_map.get(unsig.key, '<unknown>')\n+            if input(f\" ? Retrieve key {unsig.key} for {name}? (y/N) \").lower() == \"y\":\n+                ran = subprocess.run(\n+                    f\"gpg --keyserver {args.keyserver} --recv-keys {unsig.key}\", shell=True)\n+\n+                if ran.returncode != 0:\n+                    log.warning(f\"failed to retrieve key {unsig.key} for {name}\")\n+\n+    return retval, output, good, unknown, bad\n+\n+\n+def check_single_sig(sigfilename: str, args: argparse.Namespace):\n+    retval, output = verify_with_gpg(sigfilename, SUMS_FILENAME)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    return retval, output, good, unknown, bad\n \n \n def main(args):\n-    # sanity check\n-    if len(args) < 1:\n-        print(\"Error: need to specify a version on the command line\")\n-        return 3\n+    args = parser.parse_args()\n+    if args.quiet:\n+        log.setLevel(logging.WARNING)\n+\n+    WORKINGDIR = Path(tempfile.gettempdir()) / f\"bitcoin_verify_binaries.{args.version}\"\n+\n+    def cleanup():\n+        log.info(\"cleaning up files\")\n+        os.chdir(Path.home())\n+        shutil.rmtree(WORKINGDIR)\n \n     # determine remote dir dependent on provided version string\n-    version_base, version_rc, os_filter = parse_version_string(args[0])\n+    version_base, version_rc, os_filter = parse_version_string(args.version)\n     remote_dir = f\"/bin/{VERSIONPREFIX}{version_base}/\"\n     if version_rc:\n         remote_dir += f\"test.{version_rc}/\"\n-    remote_sigfile = remote_dir + SIGNATUREFILENAME\n+    remote_sigs_path = remote_dir + SIGNATUREFILENAME\n+    remote_sums_path = remote_dir + SUMS_FILENAME\n \n+    bitcoin_dir_maybe = Path(args.bitcoin_src_path) if args.bitcoin_src_path else Path.cwd()\n     # create working directory\n     os.makedirs(WORKINGDIR, exist_ok=True)\n     os.chdir(WORKINGDIR)\n \n-    # fetch first signature file\n-    sigfile1 = SIGNATUREFILENAME\n-    success, output = download_with_wget(HOST1 + remote_sigfile, sigfile1)\n-    if not success:\n-        print(\"Error: couldn't fetch signature file. \"\n-              \"Have you specified the version number in the following format?\")\n-        print(f\"[{VERSIONPREFIX}]<version>[-rc[0-9]][-platform] \"\n-              f\"(example: {VERSIONPREFIX}0.21.0-rc3-osx)\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        return 4\n-\n-    # fetch second signature file\n-    sigfile2 = SIGNATUREFILENAME + \".2\"\n-    success, output = download_with_wget(HOST2 + remote_sigfile, sigfile2)\n-    if not success:\n-        print(\"bitcoin.org failed to provide signature file, \"\n-              \"but bitcoincore.org did?\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1])\n-        return 5\n-\n-    # ensure that both signature files are equal\n-    if not files_are_equal(sigfile1, sigfile2):\n-        print(\"bitcoin.org and bitcoincore.org signature files were not equal?\")\n-        print(f\"See files {WORKINGDIR}/{sigfile1} and {WORKINGDIR}/{sigfile2}\")\n-        return 6\n-\n-    # check signature and extract data into file\n-    retval, output = verify_with_gpg(sigfile1, HASHFILE)\n-    if retval != 0:\n-        if retval == 1:\n-            print(\"Bad signature.\")\n-        elif retval == 2:\n-            print(\"gpg error. Do you have the Bitcoin Core binary release \"\n-                  \"signing key installed?\")\n-        print(\"gpg output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1, sigfile2, HASHFILE])\n-        return 1\n+    version_tuple = [int(i) for i in version_base.split('.')]\n+    hosts = [HOST1, HOST2]\n+\n+    got_sig_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sigs_path, SIGNATUREFILENAME, args.require_all_hosts)\n+    if got_sig_status != ReturnCode.SUCCESS:\n+        return got_sig_status\n+\n+    # Multi-sig verification is available after 22.0.\n+    MULTISIG_SUPPORTED = version_tuple[0] >= 22\n+\n+    if MULTISIG_SUPPORTED:\n+        min_trusted_sigs = args.min_trusted_sigs\n+        gpg_allowed_codes = [0, 2]  # 2 is returned when untrusted signatures are present.\n+        builder_key_map = get_builder_keys(bitcoin_dir_maybe)\n+\n+        got_sums_status = get_files_from_hosts_and_compare(\n+            hosts, remote_sums_path, SUMS_FILENAME, args.require_all_hosts)\n+        if got_sums_status != ReturnCode.SUCCESS:\n+            return got_sums_status\n+\n+        gpg_retval, gpg_output, good, unknown, bad = check_multisig(\n+            SIGNATUREFILENAME, args, builder_key_map)\n+    else:\n+        # As long as GPG return codes are okay, the sig is valid for pre-22.0.\n+        min_trusted_sigs = 0\n+        gpg_allowed_codes = [0]\n+        builder_key_map = {}\n+\n+        gpg_retval, gpg_output, good, unknown, bad = check_single_sig(\n+            SIGNATUREFILENAME, args)\n+\n+    if gpg_retval not in gpg_allowed_codes:\n+        if gpg_retval == 1:\n+            log.critical(\"Bad signature.\")\n+        if gpg_retval == 2:\n+            log.critical(\n+                \"gpg error. Do you have the Bitcoin Core binary release \"\n+                \"signing key installed?\")\n+        else:\n+            log.critical(\"unexpected GPG exit code\")\n+\n+        log.error(f\"gpg output:\\n{indent(gpg_output)}\")\n+        cleanup()\n+        return ReturnCode.INTEGRITY_FAILURE\n+\n+    # Decide which keys we trust, though not \"trust\" in the GPG sense, but rather\n+    # which pubkeys convince us that this sums file is legitimate. In other words,\n+    # which pubkeys within the Bitcoin community do we trust for the purposes of\n+    # binary verification?\n+    trusted_keys = set()\n+    if not args.no_builder_keys:\n+        trusted_keys |= set(builder_key_map.keys())\n+    if args.trusted_keys:\n+        trusted_keys |= set(args.trusted_keys.split(','))\n+\n+    # Tally signatures and make sure we have enough good, trusted to fulfill\n+    # our threshold.\n+    good_trusted = {sig for sig in good if sig.trusted or sig.key in trusted_keys}\n+    good_untrusted = [sig for sig in good if sig not in good_trusted]\n+    num_trusted = len(good_trusted)\n+    log.info(f\"got {num_trusted} good, trusted signatures\")\n+\n+    if num_trusted < min_trusted_sigs:\n+        log.error(\n+            \"not enough trusted sigs to meet threshold \"\n+            f\"({num_trusted} vs. {min_trusted_sigs})\")\n+        return ReturnCode.NOT_ENOUGH_GOOD_SIGS\n+\n+    for sig in good_trusted:\n+        log.info(f\"GOOD SIGNATURE: {sig}\")\n+\n+    for sig in good_untrusted:\n+        log.info(f\"GOOD SIGNATURE (untrusted): {sig}\")\n+\n+    for sig in [sig for sig in good if sig.status == 'expired']:\n+        log.warning(f\"key {sig.key} for {sig.name} is expired\")\n+\n+    for sig in bad:\n+        log.warning(f\"BAD SIGNATURE: {sig}\")\n+\n+    for sig in unknown:\n+        log.warning(f\"UNKNOWN SIGNATURE: {sig}\")\n \n     # extract hashes/filenames of binaries to verify from hash file;\n     # each line has the following format: \"<hash> <binary_filename>\"\n-    with open(HASHFILE, 'r', encoding='utf8') as hash_file:\n-        hashes_to_verify = [\n-            line.split()[:2] for line in hash_file if os_filter in line]\n-    remove_files([HASHFILE])\n+    with open(SUMS_FILENAME, 'r', encoding='utf8') as hash_file:\n+        hashes_to_verify = [line.split()[:2] for line in hash_file if os_filter in line]\n+    remove_files([SUMS_FILENAME])\n     if not hashes_to_verify:\n-        print(\"error: no files matched the platform specified\")\n-        return 7\n+        log.error(\"no files matched the platform specified\")\n+        return ReturnCode.NO_BINARIES_MATCH\n+\n+    # remove binaries that are known not to be hosted by bitcoincore.org\n+    fragments_to_remove = ['-unsigned', '-debug', '-codesignatures']\n+    for fragment in fragments_to_remove:\n+        nobinaries = [i for i in hashes_to_verify if fragment in i[1]]\n+        if nobinaries:\n+            remove_str = ', '.join(i[1] for i in nobinaries)\n+            log.info(\n+                f\"removing *{fragment} binaries ({remove_str}) from verification \"\n+                f\"since {HOST1} does not host *{fragment} binaries\")\n+            hashes_to_verify = [i for i in hashes_to_verify if fragment not in i[1]]\n \n     # download binaries\n     for _, binary_filename in hashes_to_verify:\n-        print(f\"Downloading {binary_filename}\")\n-        download_with_wget(HOST1 + remote_dir + binary_filename)\n+        log.info(f\"downloading {binary_filename}\")\n+        success, output = download_with_wget(HOST1 + remote_dir + binary_filename)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r766153692",
      "id" : 766153692,
      "line" : 602,
      "node_id" : "PRRC_kwDOABII584tqpPc",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 602,
      "original_position" : 653,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 653,
      "pull_request_review_id" : 828027865,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766153692/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-09T21:16:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/766153692",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r768960053"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768960053"
         }
      },
      "author_association" : "MEMBER",
      "body" : "While this is good feedback and could be done, I don't have time to do this refactoring - may be a good follow-up for a newer contrib looking for a task.",
      "commit_id" : "ee6517f900ba1638264378e3726dd7237e70957d",
      "created_at" : "2021-12-14T19:00:52Z",
      "diff_hunk" : "@@ -59,124 +194,457 @@ def download_with_wget(remote_file, local_file=None):\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError)\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    # Enforce English output since we're relying on output that contains natural language.\n+    # Use string-shell form (vs. args as list) because passing LANGUAGE via `env` doesn't\n+    # seem to work.\n+    args = (\n+        'LANGUAGE=en gpg --yes --decrypt '\n+        + (f' --output {output_filename} ' if output_filename else '')\n+        + signature_filename)\n+\n+    result = subprocess.run(args, shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n+    return result.returncode, result.stdout.decode().rstrip()\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self, key: str, name: str, trusted: bool, status: str):\n+        self.key = key\n+        self.name = name\n+        self.trusted = trusted\n+        self.status = status\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(output: str) -> ([SigData], [SigData], [SigData]):\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs = []\n+    unknown_sigs = []\n+    bad_sigs = []\n+    total_resolved_sigs = 0\n+    curr_key = None\n+\n+    for i, line in enumerate(output):\n+        if 'using RSA key' in line:\n+            if curr_key:\n+                raise RuntimeError(\n+                    f\"WARNING: encountered a new sig without resolving the last ({curr_key}) - \"\n+                    \"this could mean we have encountered a bad signature! check GPG output!\")\n+            curr_key = line.split('key ')[-1].strip()\n+            assert len(curr_key) == 40 or (len(curr_key) == 18 and curr_key.startswith('0x'))\n+\n+        if \"Can't check signature: No public key\" in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            unknown_sigs.append(SigData(curr_key, '', False, ''))\n+            curr_key = None\n+\n+        if 'Good signature from ' in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+\n+            # It's safe to index output[i + 1] because if we saw a good sig, there should\n+            # always be another line\n+            trusted = (\n+                'This key is not certified with a trusted signature' not in output[i + 1])\n+            good_sigs.append(SigData(curr_key, name, trusted, status))\n+            curr_key = None\n+\n+        if 'bad signature from' in line.lower():\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+            bad_sigs.append(SigData(curr_key, name, False, status))\n+            curr_key = None\n+\n+        # Track total signatures included\n+        if ': Signature made ' in line:\n+            total_resolved_sigs += 1\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n+def parse_gpg_from_line(line: str) -> (str, str):\n+    \"\"\"Returns name and expiration status.\"\"\"\n+    assert 'signature from' in line\n+\n+    name_end = line.split(' from ')[-1]\n+    m = re.search(r'(?P<name>\".+\") \\[(?P<status>\\w+)\\]', name_end)\n+    assert m\n+    (name, status) = m.groups()\n+    name = name.strip('\"\\'')\n+\n+    return (name, status)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"[{VERSIONPREFIX}]{VERSION_FORMAT} \"\n+            f\"(example: {VERSIONPREFIX}{VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def get_builder_keys(bitcoin_dir: Path) -> t.Dict[str, str]:\n+    \"\"\"\n+    Return a map of builder key to name from a local or remote source,\n+    in that order of preference.\n+    If we have them locally, compare them to the github repo.\n+    \"\"\"\n+    local_builder_keys = []\n+    local_builder_path = bitcoin_dir / 'contrib' / 'builder-keys' / 'keys.txt'\n+    if local_builder_path.exists():\n+        local_builder_keys = local_builder_path.read_text().splitlines()\n+\n+    success, gh_builder_keys = download_lines_with_urllib(BUILDER_KEYS_GH_URL)\n+    if not success:\n+        log.warning(f\"unable to retrieve builder keys from {BUILDER_KEYS_GH_URL}\")\n+\n+    if not (success or local_builder_keys):\n+        log.error(\"unable to retrieve builder keys locally or remotely\")\n+\n+    # check the local and remote builder keys against each other and report diff\n+    if local_builder_keys and gh_builder_keys:\n+        if local_builder_keys != gh_builder_keys:\n+            diff = indent(\n+                '\\n'.join(difflib.unified_diff(local_builder_keys, gh_builder_keys)))\n+            log.warning(f\"found diff (local vs. GH) in builder keys:\\n{diff}\\n\")\n+\n+    # Prefer local builder keys to those obtained remotely.\n+    builder_keys = local_builder_keys or gh_builder_keys or []\n+\n+    builder_key_map = {}\n+    for i in builder_keys:\n+        key, name = i.split(' ', 1)\n+        builder_key_map[key] = name\n+\n+    return builder_key_map\n+\n+\n+def check_multisig(\n+    sigfilename: str, args: argparse.Namespace, builder_key_map: t.Dict[str, str]\n+):\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    # Retrieve unknown keys that are in the repo builder list and then try GPG again.\n+    if unknown and not args.noninteractive and not args.skip_import_builders:\n+        for unsig in unknown:\n+            name = builder_key_map.get(unsig.key, '<unknown>')\n+            if input(f\" ? Retrieve key {unsig.key} for {name}? (y/N) \").lower() == \"y\":\n+                ran = subprocess.run(\n+                    f\"gpg --keyserver {args.keyserver} --recv-keys {unsig.key}\", shell=True)\n+\n+                if ran.returncode != 0:\n+                    log.warning(f\"failed to retrieve key {unsig.key} for {name}\")\n+\n+    return retval, output, good, unknown, bad\n+\n+\n+def check_single_sig(sigfilename: str, args: argparse.Namespace):\n+    retval, output = verify_with_gpg(sigfilename, SUMS_FILENAME)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    return retval, output, good, unknown, bad\n \n \n def main(args):\n-    # sanity check\n-    if len(args) < 1:\n-        print(\"Error: need to specify a version on the command line\")\n-        return 3\n+    args = parser.parse_args()\n+    if args.quiet:\n+        log.setLevel(logging.WARNING)\n+\n+    WORKINGDIR = Path(tempfile.gettempdir()) / f\"bitcoin_verify_binaries.{args.version}\"\n+\n+    def cleanup():\n+        log.info(\"cleaning up files\")\n+        os.chdir(Path.home())\n+        shutil.rmtree(WORKINGDIR)\n \n     # determine remote dir dependent on provided version string\n-    version_base, version_rc, os_filter = parse_version_string(args[0])\n+    version_base, version_rc, os_filter = parse_version_string(args.version)\n     remote_dir = f\"/bin/{VERSIONPREFIX}{version_base}/\"\n     if version_rc:\n         remote_dir += f\"test.{version_rc}/\"\n-    remote_sigfile = remote_dir + SIGNATUREFILENAME\n+    remote_sigs_path = remote_dir + SIGNATUREFILENAME\n+    remote_sums_path = remote_dir + SUMS_FILENAME\n \n+    bitcoin_dir_maybe = Path(args.bitcoin_src_path) if args.bitcoin_src_path else Path.cwd()\n     # create working directory\n     os.makedirs(WORKINGDIR, exist_ok=True)\n     os.chdir(WORKINGDIR)\n \n-    # fetch first signature file\n-    sigfile1 = SIGNATUREFILENAME\n-    success, output = download_with_wget(HOST1 + remote_sigfile, sigfile1)\n-    if not success:\n-        print(\"Error: couldn't fetch signature file. \"\n-              \"Have you specified the version number in the following format?\")\n-        print(f\"[{VERSIONPREFIX}]<version>[-rc[0-9]][-platform] \"\n-              f\"(example: {VERSIONPREFIX}0.21.0-rc3-osx)\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        return 4\n-\n-    # fetch second signature file\n-    sigfile2 = SIGNATUREFILENAME + \".2\"\n-    success, output = download_with_wget(HOST2 + remote_sigfile, sigfile2)\n-    if not success:\n-        print(\"bitcoin.org failed to provide signature file, \"\n-              \"but bitcoincore.org did?\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1])\n-        return 5\n-\n-    # ensure that both signature files are equal\n-    if not files_are_equal(sigfile1, sigfile2):\n-        print(\"bitcoin.org and bitcoincore.org signature files were not equal?\")\n-        print(f\"See files {WORKINGDIR}/{sigfile1} and {WORKINGDIR}/{sigfile2}\")\n-        return 6\n-\n-    # check signature and extract data into file\n-    retval, output = verify_with_gpg(sigfile1, HASHFILE)\n-    if retval != 0:\n-        if retval == 1:\n-            print(\"Bad signature.\")\n-        elif retval == 2:\n-            print(\"gpg error. Do you have the Bitcoin Core binary release \"\n-                  \"signing key installed?\")\n-        print(\"gpg output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1, sigfile2, HASHFILE])\n-        return 1\n+    version_tuple = [int(i) for i in version_base.split('.')]\n+    hosts = [HOST1, HOST2]\n+\n+    got_sig_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sigs_path, SIGNATUREFILENAME, args.require_all_hosts)\n+    if got_sig_status != ReturnCode.SUCCESS:\n+        return got_sig_status\n+\n+    # Multi-sig verification is available after 22.0.\n+    MULTISIG_SUPPORTED = version_tuple[0] >= 22\n+\n+    if MULTISIG_SUPPORTED:\n+        min_trusted_sigs = args.min_trusted_sigs\n+        gpg_allowed_codes = [0, 2]  # 2 is returned when untrusted signatures are present.\n+        builder_key_map = get_builder_keys(bitcoin_dir_maybe)\n+\n+        got_sums_status = get_files_from_hosts_and_compare(\n+            hosts, remote_sums_path, SUMS_FILENAME, args.require_all_hosts)\n+        if got_sums_status != ReturnCode.SUCCESS:\n+            return got_sums_status\n+\n+        gpg_retval, gpg_output, good, unknown, bad = check_multisig(\n+            SIGNATUREFILENAME, args, builder_key_map)\n+    else:\n+        # As long as GPG return codes are okay, the sig is valid for pre-22.0.\n+        min_trusted_sigs = 0\n+        gpg_allowed_codes = [0]\n+        builder_key_map = {}\n+\n+        gpg_retval, gpg_output, good, unknown, bad = check_single_sig(\n+            SIGNATUREFILENAME, args)\n+\n+    if gpg_retval not in gpg_allowed_codes:\n+        if gpg_retval == 1:\n+            log.critical(\"Bad signature.\")\n+        if gpg_retval == 2:\n+            log.critical(\n+                \"gpg error. Do you have the Bitcoin Core binary release \"\n+                \"signing key installed?\")\n+        else:\n+            log.critical(\"unexpected GPG exit code\")\n+\n+        log.error(f\"gpg output:\\n{indent(gpg_output)}\")\n+        cleanup()\n+        return ReturnCode.INTEGRITY_FAILURE\n+\n+    # Decide which keys we trust, though not \"trust\" in the GPG sense, but rather\n+    # which pubkeys convince us that this sums file is legitimate. In other words,\n+    # which pubkeys within the Bitcoin community do we trust for the purposes of\n+    # binary verification?\n+    trusted_keys = set()\n+    if not args.no_builder_keys:\n+        trusted_keys |= set(builder_key_map.keys())\n+    if args.trusted_keys:\n+        trusted_keys |= set(args.trusted_keys.split(','))\n+\n+    # Tally signatures and make sure we have enough good, trusted to fulfill\n+    # our threshold.\n+    good_trusted = {sig for sig in good if sig.trusted or sig.key in trusted_keys}\n+    good_untrusted = [sig for sig in good if sig not in good_trusted]\n+    num_trusted = len(good_trusted)\n+    log.info(f\"got {num_trusted} good, trusted signatures\")\n+\n+    if num_trusted < min_trusted_sigs:\n+        log.error(\n+            \"not enough trusted sigs to meet threshold \"\n+            f\"({num_trusted} vs. {min_trusted_sigs})\")\n+        return ReturnCode.NOT_ENOUGH_GOOD_SIGS\n+\n+    for sig in good_trusted:\n+        log.info(f\"GOOD SIGNATURE: {sig}\")\n+\n+    for sig in good_untrusted:\n+        log.info(f\"GOOD SIGNATURE (untrusted): {sig}\")\n+\n+    for sig in [sig for sig in good if sig.status == 'expired']:\n+        log.warning(f\"key {sig.key} for {sig.name} is expired\")\n+\n+    for sig in bad:\n+        log.warning(f\"BAD SIGNATURE: {sig}\")\n+\n+    for sig in unknown:\n+        log.warning(f\"UNKNOWN SIGNATURE: {sig}\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r768960053",
      "id" : 768960053,
      "in_reply_to_id" : 766093053,
      "line" : 612,
      "node_id" : "PRRC_kwDOABII584t1WY1",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 577,
      "original_position" : 620,
      "original_start_line" : 564,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 675,
      "pull_request_review_id" : 831918532,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768960053/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 599,
      "start_side" : "RIGHT",
      "updated_at" : "2021-12-14T19:00:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768960053",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r768966877"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768966877"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'll just remove `--skip-import-builders` for now and we can revisit in a follow-up if desired.",
      "commit_id" : "ee6517f900ba1638264378e3726dd7237e70957d",
      "created_at" : "2021-12-14T19:11:00Z",
      "diff_hunk" : "@@ -2,29 +2,164 @@\n # Copyright (c) 2020 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Script for verifying Bitcoin Core release binaries\n-\n-This script attempts to download the signature file SHA256SUMS.asc from\n-bitcoincore.org and bitcoin.org and compares them.\n-It first checks if the signature passes, and then downloads the files\n-specified in the file, and checks if the hashes of these files match those\n-that are specified in the signature file.\n-The script returns 0 if everything passes the checks. It returns 1 if either\n-the signature check or the hash check doesn't pass. If an error occurs the\n-return value is >= 2.\n+\"\"\"Script for verifying Bitcoin Core release binaries.\n+\n+This script attempts to download the sum file SHA256SUMS and corresponding\n+signature file SHA256SUMS.asc from bitcoincore.org and bitcoin.org and\n+compares them.\n+\n+The sum-signature file is signed by a number of builder keys. This script\n+ensures that there is a minimum threshold of signatures from pubkeys that\n+we trust. This trust is articulated on the basis of configuration options\n+here, but by default is based upon a unionof (i) local GPG trust settings,\n+and (ii) keys which appear in the builder-keys/keys.txt file.\n+\n+If a minimum good, trusted signature threshold is met on the sum file, we then\n+download the files specified in SHA256SUMS, and check if the hashes of these\n+files match those that are specified. The script returns 0 if everything passes\n+the checks. It returns 1 if either the signature check or the hash check\n+doesn't pass. If an error occurs the return value is >= 2.\n+\n+Logging output goes to stderr and final binary verification data goes to stdout.\n+\n+JSON output can by obtained by setting env BINVERIFY_JSON=1.\n \"\"\"\n-from hashlib import sha256\n+import argparse\n+import difflib\n+import json\n+import logging\n import os\n import subprocess\n+import typing as t\n+import re\n import sys\n-from textwrap import indent\n+import shutil\n+import tempfile\n+import textwrap\n+import urllib.request\n+import enum\n+from hashlib import sha256\n+from pathlib import Path\n \n-WORKINGDIR = \"/tmp/bitcoin_verify_binaries\"\n-HASHFILE = \"hashes.tmp\"\n+# The primary host; this will fail if we can't retrieve files from here.\n HOST1 = \"https://bitcoincore.org\"\n HOST2 = \"https://bitcoin.org\"\n VERSIONPREFIX = \"bitcoin-core-\"\n-SIGNATUREFILENAME = \"SHA256SUMS.asc\"\n+SUMS_FILENAME = 'SHA256SUMS'\n+SIGNATUREFILENAME = f\"{SUMS_FILENAME}.asc\"\n+BUILDER_KEYS_GH_URL = (\n+    \"https://raw.githubusercontent.com/bitcoin/bitcoin/master/contrib/builder-keys/keys.txt\"\n+)\n+\n+\n+class ReturnCode(enum.IntEnum):\n+    SUCCESS = 0\n+    INTEGRITY_FAILURE = 1\n+    FILE_GET_FAILED = 4\n+    FILE_MISSING_FROM_ONE_HOST = 5\n+    FILES_NOT_EQUAL = 6\n+    NO_BINARIES_MATCH = 7\n+    NOT_ENOUGH_GOOD_SIGS = 9\n+    BINARY_DOWNLOAD_FAILED = 10\n+\n+\n+def set_up_logger(is_verbose: bool = True) -> logging.Logger:\n+    \"\"\"Set up a logger that writes to stderr.\"\"\"\n+    log = logging.getLogger(__name__)\n+    log.setLevel(logging.INFO if is_verbose else logging.WARNING)\n+    console = logging.StreamHandler(sys.stderr)  # log to stderr\n+    console.setLevel(logging.DEBUG)\n+    formatter = logging.Formatter('[%(levelname)s] %(message)s')\n+    console.setFormatter(formatter)\n+    log.addHandler(console)\n+    return log\n+\n+\n+log = set_up_logger()\n+\n+\n+def indent(output: str) -> str:\n+    return textwrap.indent(output, '  ')\n+\n+\n+def bool_from_env(key, default=False) -> bool:\n+    if key not in os.environ:\n+        return default\n+    raw = os.environ[key]\n+    return raw in ['1', 'True', 'true']\n+\n+\n+VERSION_FORMAT = \"<major>.<minor>[.<patch>][-rc[0-9]][-platform]\"\n+VERSION_EXAMPLE = \"22.0-x86_64 or 0.21.0-rc2-osx\"\n+\n+parser = argparse.ArgumentParser(description=__doc__)\n+parser.add_argument(\n+    'version', type=str, help=(\n+        f'version of the bitcoin release to download; of the format '\n+        f'{VERSION_FORMAT}. Example: {VERSION_EXAMPLE}')\n+)\n+parser.add_argument(\n+    '-v', '--verbose', action='store_true',\n+    default=bool_from_env('BINVERIFY_VERBOSE'),\n+)\n+parser.add_argument(\n+    '-q', '--quiet', action='store_true',\n+    default=bool_from_env('BINVERIFY_QUIET'),\n+)\n+parser.add_argument(\n+    '--cleanup', action='store_true',\n+    default=bool_from_env('BINVERIFY_CLEANUP'),\n+    help='if specified, clean up files afterwards'\n+)\n+parser.add_argument(\n+    '--noninteractive', action='store_true',\n+    default=bool_from_env('BINVERIFY_NONINTERACTIVE'),\n+    help='if specified, do not block for user input'\n+)\n+parser.add_argument(\n+    '--require-all-hosts', action='store_true',\n+    default=bool_from_env('BINVERIFY_REQUIRE_ALL_HOSTS'),\n+    help=(\n+        f'If set, require all hosts ({HOST1}, {HOST2}) to provide signatures. '\n+        '(Sometimes bitcoin.org lags behind bitcoincore.org.)')\n+)\n+parser.add_argument(\n+    '--bitcoin-src-path', action='store', nargs='?',\n+    default=os.environ.get('BINVERIFY_BITCOIN_SRC_PATH', ''),\n+    help='specify path to bitcoin repository. Used to find builder keys.',\n+)\n+parser.add_argument(\n+    '--skip-import-builders', action='store_true',\n+    default=bool_from_env('BINVERIFY_SKIP_IMPORT_BUILDERS'),\n+    help='If set, do not prompt to import builder pubkeys',\n+)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r768966877",
      "id" : 768966877,
      "in_reply_to_id" : 766119564,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584t1YDd",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 135,
      "original_position" : 149,
      "original_start_line" : 131,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : null,
      "pull_request_review_id" : 831928475,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768966877/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-12-14T19:11:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768966877",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r768969941"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768969941"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm going to leave this as-is to marginally aid people migrating from the old script. If we want we can add a generic failure code, but I don't think there's any harm in having specific non-zero error codes.",
      "commit_id" : "ee6517f900ba1638264378e3726dd7237e70957d",
      "created_at" : "2021-12-14T19:15:32Z",
      "diff_hunk" : "@@ -2,29 +2,164 @@\n # Copyright (c) 2020 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Script for verifying Bitcoin Core release binaries\n-\n-This script attempts to download the signature file SHA256SUMS.asc from\n-bitcoincore.org and bitcoin.org and compares them.\n-It first checks if the signature passes, and then downloads the files\n-specified in the file, and checks if the hashes of these files match those\n-that are specified in the signature file.\n-The script returns 0 if everything passes the checks. It returns 1 if either\n-the signature check or the hash check doesn't pass. If an error occurs the\n-return value is >= 2.\n+\"\"\"Script for verifying Bitcoin Core release binaries.\n+\n+This script attempts to download the sum file SHA256SUMS and corresponding\n+signature file SHA256SUMS.asc from bitcoincore.org and bitcoin.org and\n+compares them.\n+\n+The sum-signature file is signed by a number of builder keys. This script\n+ensures that there is a minimum threshold of signatures from pubkeys that\n+we trust. This trust is articulated on the basis of configuration options\n+here, but by default is based upon a unionof (i) local GPG trust settings,\n+and (ii) keys which appear in the builder-keys/keys.txt file.\n+\n+If a minimum good, trusted signature threshold is met on the sum file, we then\n+download the files specified in SHA256SUMS, and check if the hashes of these\n+files match those that are specified. The script returns 0 if everything passes\n+the checks. It returns 1 if either the signature check or the hash check\n+doesn't pass. If an error occurs the return value is >= 2.\n+\n+Logging output goes to stderr and final binary verification data goes to stdout.\n+\n+JSON output can by obtained by setting env BINVERIFY_JSON=1.\n \"\"\"\n-from hashlib import sha256\n+import argparse\n+import difflib\n+import json\n+import logging\n import os\n import subprocess\n+import typing as t\n+import re\n import sys\n-from textwrap import indent\n+import shutil\n+import tempfile\n+import textwrap\n+import urllib.request\n+import enum\n+from hashlib import sha256\n+from pathlib import Path\n \n-WORKINGDIR = \"/tmp/bitcoin_verify_binaries\"\n-HASHFILE = \"hashes.tmp\"\n+# The primary host; this will fail if we can't retrieve files from here.\n HOST1 = \"https://bitcoincore.org\"\n HOST2 = \"https://bitcoin.org\"\n VERSIONPREFIX = \"bitcoin-core-\"\n-SIGNATUREFILENAME = \"SHA256SUMS.asc\"\n+SUMS_FILENAME = 'SHA256SUMS'\n+SIGNATUREFILENAME = f\"{SUMS_FILENAME}.asc\"\n+BUILDER_KEYS_GH_URL = (\n+    \"https://raw.githubusercontent.com/bitcoin/bitcoin/master/contrib/builder-keys/keys.txt\"\n+)\n+\n+\n+class ReturnCode(enum.IntEnum):\n+    SUCCESS = 0\n+    INTEGRITY_FAILURE = 1\n+    FILE_GET_FAILED = 4\n+    FILE_MISSING_FROM_ONE_HOST = 5\n+    FILES_NOT_EQUAL = 6\n+    NO_BINARIES_MATCH = 7\n+    NOT_ENOUGH_GOOD_SIGS = 9\n+    BINARY_DOWNLOAD_FAILED = 10",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r768969941",
      "id" : 768969941,
      "in_reply_to_id" : 766142230,
      "line" : 63,
      "node_id" : "PRRC_kwDOABII584t1YzV",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 63,
      "original_position" : 77,
      "original_start_line" : 57,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 77,
      "pull_request_review_id" : 831932891,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768969941/reactions"
      },
      "side" : "RIGHT",
      "start_line" : 57,
      "start_side" : "RIGHT",
      "updated_at" : "2021-12-14T19:15:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768969941",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r768971420"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768971420"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It's called here so that the `log` reference can be used in functions defined before main.",
      "commit_id" : "ee6517f900ba1638264378e3726dd7237e70957d",
      "created_at" : "2021-12-14T19:17:37Z",
      "diff_hunk" : "@@ -2,29 +2,164 @@\n # Copyright (c) 2020 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Script for verifying Bitcoin Core release binaries\n-\n-This script attempts to download the signature file SHA256SUMS.asc from\n-bitcoincore.org and bitcoin.org and compares them.\n-It first checks if the signature passes, and then downloads the files\n-specified in the file, and checks if the hashes of these files match those\n-that are specified in the signature file.\n-The script returns 0 if everything passes the checks. It returns 1 if either\n-the signature check or the hash check doesn't pass. If an error occurs the\n-return value is >= 2.\n+\"\"\"Script for verifying Bitcoin Core release binaries.\n+\n+This script attempts to download the sum file SHA256SUMS and corresponding\n+signature file SHA256SUMS.asc from bitcoincore.org and bitcoin.org and\n+compares them.\n+\n+The sum-signature file is signed by a number of builder keys. This script\n+ensures that there is a minimum threshold of signatures from pubkeys that\n+we trust. This trust is articulated on the basis of configuration options\n+here, but by default is based upon a unionof (i) local GPG trust settings,\n+and (ii) keys which appear in the builder-keys/keys.txt file.\n+\n+If a minimum good, trusted signature threshold is met on the sum file, we then\n+download the files specified in SHA256SUMS, and check if the hashes of these\n+files match those that are specified. The script returns 0 if everything passes\n+the checks. It returns 1 if either the signature check or the hash check\n+doesn't pass. If an error occurs the return value is >= 2.\n+\n+Logging output goes to stderr and final binary verification data goes to stdout.\n+\n+JSON output can by obtained by setting env BINVERIFY_JSON=1.\n \"\"\"\n-from hashlib import sha256\n+import argparse\n+import difflib\n+import json\n+import logging\n import os\n import subprocess\n+import typing as t\n+import re\n import sys\n-from textwrap import indent\n+import shutil\n+import tempfile\n+import textwrap\n+import urllib.request\n+import enum\n+from hashlib import sha256\n+from pathlib import Path\n \n-WORKINGDIR = \"/tmp/bitcoin_verify_binaries\"\n-HASHFILE = \"hashes.tmp\"\n+# The primary host; this will fail if we can't retrieve files from here.\n HOST1 = \"https://bitcoincore.org\"\n HOST2 = \"https://bitcoin.org\"\n VERSIONPREFIX = \"bitcoin-core-\"\n-SIGNATUREFILENAME = \"SHA256SUMS.asc\"\n+SUMS_FILENAME = 'SHA256SUMS'\n+SIGNATUREFILENAME = f\"{SUMS_FILENAME}.asc\"\n+BUILDER_KEYS_GH_URL = (\n+    \"https://raw.githubusercontent.com/bitcoin/bitcoin/master/contrib/builder-keys/keys.txt\"\n+)\n+\n+\n+class ReturnCode(enum.IntEnum):\n+    SUCCESS = 0\n+    INTEGRITY_FAILURE = 1\n+    FILE_GET_FAILED = 4\n+    FILE_MISSING_FROM_ONE_HOST = 5\n+    FILES_NOT_EQUAL = 6\n+    NO_BINARIES_MATCH = 7\n+    NOT_ENOUGH_GOOD_SIGS = 9\n+    BINARY_DOWNLOAD_FAILED = 10\n+\n+\n+def set_up_logger(is_verbose: bool = True) -> logging.Logger:\n+    \"\"\"Set up a logger that writes to stderr.\"\"\"\n+    log = logging.getLogger(__name__)\n+    log.setLevel(logging.INFO if is_verbose else logging.WARNING)\n+    console = logging.StreamHandler(sys.stderr)  # log to stderr\n+    console.setLevel(logging.DEBUG)\n+    formatter = logging.Formatter('[%(levelname)s] %(message)s')\n+    console.setFormatter(formatter)\n+    log.addHandler(console)\n+    return log\n+\n+\n+log = set_up_logger()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r768971420",
      "id" : 768971420,
      "in_reply_to_id" : 766144667,
      "line" : 80,
      "node_id" : "PRRC_kwDOABII584t1ZKc",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 78,
      "original_position" : 92,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 94,
      "pull_request_review_id" : 831934908,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768971420/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-14T19:17:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768971420",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r768973455"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768973455"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good catch!",
      "commit_id" : "ee6517f900ba1638264378e3726dd7237e70957d",
      "created_at" : "2021-12-14T19:20:27Z",
      "diff_hunk" : "@@ -59,124 +194,457 @@ def download_with_wget(remote_file, local_file=None):\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError)\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    # Enforce English output since we're relying on output that contains natural language.\n+    # Use string-shell form (vs. args as list) because passing LANGUAGE via `env` doesn't\n+    # seem to work.\n+    args = (\n+        'LANGUAGE=en gpg --yes --decrypt '\n+        + (f' --output {output_filename} ' if output_filename else '')\n+        + signature_filename)\n+\n+    result = subprocess.run(args, shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n+    return result.returncode, result.stdout.decode().rstrip()\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self, key: str, name: str, trusted: bool, status: str):\n+        self.key = key\n+        self.name = name\n+        self.trusted = trusted\n+        self.status = status\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(output: str) -> ([SigData], [SigData], [SigData]):\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs = []\n+    unknown_sigs = []\n+    bad_sigs = []\n+    total_resolved_sigs = 0\n+    curr_key = None\n+\n+    for i, line in enumerate(output):\n+        if 'using RSA key' in line:\n+            if curr_key:\n+                raise RuntimeError(\n+                    f\"WARNING: encountered a new sig without resolving the last ({curr_key}) - \"\n+                    \"this could mean we have encountered a bad signature! check GPG output!\")\n+            curr_key = line.split('key ')[-1].strip()\n+            assert len(curr_key) == 40 or (len(curr_key) == 18 and curr_key.startswith('0x'))\n+\n+        if \"Can't check signature: No public key\" in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            unknown_sigs.append(SigData(curr_key, '', False, ''))\n+            curr_key = None\n+\n+        if 'Good signature from ' in line:\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+\n+            # It's safe to index output[i + 1] because if we saw a good sig, there should\n+            # always be another line\n+            trusted = (\n+                'This key is not certified with a trusted signature' not in output[i + 1])\n+            good_sigs.append(SigData(curr_key, name, trusted, status))\n+            curr_key = None\n+\n+        if 'bad signature from' in line.lower():\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+            bad_sigs.append(SigData(curr_key, name, False, status))\n+            curr_key = None\n+\n+        # Track total signatures included\n+        if ': Signature made ' in line:\n+            total_resolved_sigs += 1\n+\n+    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n+    if all_found != total_resolved_sigs:\n+        raise RuntimeError(\n+            f\"failed to evaluate all signatures: found {all_found} \"\n+            f\"but expected {total_resolved_sigs}\")\n+\n+    return (good_sigs, unknown_sigs, bad_sigs)\n+\n+\n+def parse_gpg_from_line(line: str) -> (str, str):\n+    \"\"\"Returns name and expiration status.\"\"\"\n+    assert 'signature from' in line\n+\n+    name_end = line.split(' from ')[-1]\n+    m = re.search(r'(?P<name>\".+\") \\[(?P<status>\\w+)\\]', name_end)\n+    assert m\n+    (name, status) = m.groups()\n+    name = name.strip('\"\\'')\n+\n+    return (name, status)\n+\n+\n def files_are_equal(filename1, filename2):\n     with open(filename1, 'rb') as file1:\n         contents1 = file1.read()\n     with open(filename2, 'rb') as file2:\n         contents2 = file2.read()\n-    return contents1 == contents2\n+    eq = contents1 == contents2\n \n+    if not eq:\n+        with open(filename1, 'r', encoding='utf-8') as f1, \\\n+                open(filename2, 'r', encoding='utf-8') as f2:\n+            f1lines = f1.readlines()\n+            f2lines = f2.readlines()\n \n-def verify_with_gpg(signature_filename, output_filename):\n-    result = subprocess.run(['gpg', '--yes', '--decrypt', '--output',\n-                             output_filename, signature_filename],\n-                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n-    return result.returncode, result.stdout.decode().rstrip()\n+            diff = indent(\n+                ''.join(difflib.unified_diff(f1lines, f2lines)))\n+            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n \n+    return eq\n \n-def remove_files(filenames):\n-    for filename in filenames:\n-        os.remove(filename)\n+\n+def get_files_from_hosts_and_compare(\n+    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n+) -> ReturnCode:\n+    \"\"\"\n+    Retrieve the same file from a number of hosts and ensure they have the same contents.\n+    The first host given will be treated as the \"primary\" host, and is required to succeed.\n+\n+    Args:\n+        filename: for writing the file locally.\n+    \"\"\"\n+    assert len(hosts) > 1\n+    primary_host = hosts[0]\n+    other_hosts = hosts[1:]\n+    got_files = []\n+\n+    def join_url(host: str) -> str:\n+        return host.rstrip('/') + '/' + path.lstrip('/')\n+\n+    url = join_url(primary_host)\n+    success, output = download_with_wget(url, filename)\n+    if not success:\n+        log.error(\n+            f\"couldn't fetch file ({url}). \"\n+            \"Have you specified the version number in the following format?\\n\"\n+            f\"[{VERSIONPREFIX}]{VERSION_FORMAT} \"\n+            f\"(example: {VERSIONPREFIX}{VERSION_EXAMPLE})\\n\"\n+            f\"wget output:\\n{indent(output)}\")\n+        return ReturnCode.FILE_GET_FAILED\n+    else:\n+        log.info(f\"got file {url} as {filename}\")\n+        got_files.append(filename)\n+\n+    for i, host in enumerate(other_hosts):\n+        url = join_url(host)\n+        fname = filename + f'.{i + 2}'\n+        success, output = download_with_wget(url, fname)\n+\n+        if require_all and not success:\n+            log.error(\n+                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n+                f\"wget output:\\n{indent(output)}\")\n+            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n+        elif not success:\n+            log.warning(\n+                f\"{host} failed to provide file ({url}). \"\n+                f\"Continuing based solely upon {primary_host}.\")\n+        else:\n+            log.info(f\"got file {url} as {fname}\")\n+            got_files.append(fname)\n+\n+    for i, got_file in enumerate(got_files):\n+        if got_file == got_files[-1]:\n+            break  # break on last file, nothing after it to compare to\n+\n+        compare_to = got_files[i + 1]\n+        if not files_are_equal(got_file, compare_to):\n+            log.error(f\"files not equal: {got_file} and {compare_to}\")\n+            return ReturnCode.FILES_NOT_EQUAL\n+\n+    return ReturnCode.SUCCESS\n+\n+\n+def get_builder_keys(bitcoin_dir: Path) -> t.Dict[str, str]:\n+    \"\"\"\n+    Return a map of builder key to name from a local or remote source,\n+    in that order of preference.\n+    If we have them locally, compare them to the github repo.\n+    \"\"\"\n+    local_builder_keys = []\n+    local_builder_path = bitcoin_dir / 'contrib' / 'builder-keys' / 'keys.txt'\n+    if local_builder_path.exists():\n+        local_builder_keys = local_builder_path.read_text().splitlines()\n+\n+    success, gh_builder_keys = download_lines_with_urllib(BUILDER_KEYS_GH_URL)\n+    if not success:\n+        log.warning(f\"unable to retrieve builder keys from {BUILDER_KEYS_GH_URL}\")\n+\n+    if not (success or local_builder_keys):\n+        log.error(\"unable to retrieve builder keys locally or remotely\")\n+\n+    # check the local and remote builder keys against each other and report diff\n+    if local_builder_keys and gh_builder_keys:\n+        if local_builder_keys != gh_builder_keys:\n+            diff = indent(\n+                '\\n'.join(difflib.unified_diff(local_builder_keys, gh_builder_keys)))\n+            log.warning(f\"found diff (local vs. GH) in builder keys:\\n{diff}\\n\")\n+\n+    # Prefer local builder keys to those obtained remotely.\n+    builder_keys = local_builder_keys or gh_builder_keys or []\n+\n+    builder_key_map = {}\n+    for i in builder_keys:\n+        key, name = i.split(' ', 1)\n+        builder_key_map[key] = name\n+\n+    return builder_key_map\n+\n+\n+def check_multisig(\n+    sigfilename: str, args: argparse.Namespace, builder_key_map: t.Dict[str, str]\n+):\n+    # check signature\n+    #\n+    # We don't write output to a file because this command will almost certainly\n+    # fail with GPG exit code '2' (and so not writing to --output) because of the\n+    # likely presence of multiple untrusted signatures.\n+    retval, output = verify_with_gpg(sigfilename)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    # Retrieve unknown keys that are in the repo builder list and then try GPG again.\n+    if unknown and not args.noninteractive and not args.skip_import_builders:\n+        for unsig in unknown:\n+            name = builder_key_map.get(unsig.key, '<unknown>')\n+            if input(f\" ? Retrieve key {unsig.key} for {name}? (y/N) \").lower() == \"y\":\n+                ran = subprocess.run(\n+                    f\"gpg --keyserver {args.keyserver} --recv-keys {unsig.key}\", shell=True)\n+\n+                if ran.returncode != 0:\n+                    log.warning(f\"failed to retrieve key {unsig.key} for {name}\")\n+\n+    return retval, output, good, unknown, bad\n+\n+\n+def check_single_sig(sigfilename: str, args: argparse.Namespace):\n+    retval, output = verify_with_gpg(sigfilename, SUMS_FILENAME)\n+\n+    if args.verbose:\n+        log.info(f\"gpg output:\\n{indent(output)}\")\n+\n+    good, unknown, bad = parse_gpg_result(output.splitlines())\n+\n+    return retval, output, good, unknown, bad\n \n \n def main(args):\n-    # sanity check\n-    if len(args) < 1:\n-        print(\"Error: need to specify a version on the command line\")\n-        return 3\n+    args = parser.parse_args()\n+    if args.quiet:\n+        log.setLevel(logging.WARNING)\n+\n+    WORKINGDIR = Path(tempfile.gettempdir()) / f\"bitcoin_verify_binaries.{args.version}\"\n+\n+    def cleanup():\n+        log.info(\"cleaning up files\")\n+        os.chdir(Path.home())\n+        shutil.rmtree(WORKINGDIR)\n \n     # determine remote dir dependent on provided version string\n-    version_base, version_rc, os_filter = parse_version_string(args[0])\n+    version_base, version_rc, os_filter = parse_version_string(args.version)\n     remote_dir = f\"/bin/{VERSIONPREFIX}{version_base}/\"\n     if version_rc:\n         remote_dir += f\"test.{version_rc}/\"\n-    remote_sigfile = remote_dir + SIGNATUREFILENAME\n+    remote_sigs_path = remote_dir + SIGNATUREFILENAME\n+    remote_sums_path = remote_dir + SUMS_FILENAME\n \n+    bitcoin_dir_maybe = Path(args.bitcoin_src_path) if args.bitcoin_src_path else Path.cwd()\n     # create working directory\n     os.makedirs(WORKINGDIR, exist_ok=True)\n     os.chdir(WORKINGDIR)\n \n-    # fetch first signature file\n-    sigfile1 = SIGNATUREFILENAME\n-    success, output = download_with_wget(HOST1 + remote_sigfile, sigfile1)\n-    if not success:\n-        print(\"Error: couldn't fetch signature file. \"\n-              \"Have you specified the version number in the following format?\")\n-        print(f\"[{VERSIONPREFIX}]<version>[-rc[0-9]][-platform] \"\n-              f\"(example: {VERSIONPREFIX}0.21.0-rc3-osx)\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        return 4\n-\n-    # fetch second signature file\n-    sigfile2 = SIGNATUREFILENAME + \".2\"\n-    success, output = download_with_wget(HOST2 + remote_sigfile, sigfile2)\n-    if not success:\n-        print(\"bitcoin.org failed to provide signature file, \"\n-              \"but bitcoincore.org did?\")\n-        print(\"wget output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1])\n-        return 5\n-\n-    # ensure that both signature files are equal\n-    if not files_are_equal(sigfile1, sigfile2):\n-        print(\"bitcoin.org and bitcoincore.org signature files were not equal?\")\n-        print(f\"See files {WORKINGDIR}/{sigfile1} and {WORKINGDIR}/{sigfile2}\")\n-        return 6\n-\n-    # check signature and extract data into file\n-    retval, output = verify_with_gpg(sigfile1, HASHFILE)\n-    if retval != 0:\n-        if retval == 1:\n-            print(\"Bad signature.\")\n-        elif retval == 2:\n-            print(\"gpg error. Do you have the Bitcoin Core binary release \"\n-                  \"signing key installed?\")\n-        print(\"gpg output:\")\n-        print(indent(output, '\\t'))\n-        remove_files([sigfile1, sigfile2, HASHFILE])\n-        return 1\n+    version_tuple = [int(i) for i in version_base.split('.')]\n+    hosts = [HOST1, HOST2]\n+\n+    got_sig_status = get_files_from_hosts_and_compare(\n+        hosts, remote_sigs_path, SIGNATUREFILENAME, args.require_all_hosts)\n+    if got_sig_status != ReturnCode.SUCCESS:\n+        return got_sig_status\n+\n+    # Multi-sig verification is available after 22.0.\n+    MULTISIG_SUPPORTED = version_tuple[0] >= 22\n+\n+    if MULTISIG_SUPPORTED:\n+        min_trusted_sigs = args.min_trusted_sigs\n+        gpg_allowed_codes = [0, 2]  # 2 is returned when untrusted signatures are present.\n+        builder_key_map = get_builder_keys(bitcoin_dir_maybe)\n+\n+        got_sums_status = get_files_from_hosts_and_compare(\n+            hosts, remote_sums_path, SUMS_FILENAME, args.require_all_hosts)\n+        if got_sums_status != ReturnCode.SUCCESS:\n+            return got_sums_status\n+\n+        gpg_retval, gpg_output, good, unknown, bad = check_multisig(\n+            SIGNATUREFILENAME, args, builder_key_map)\n+    else:\n+        # As long as GPG return codes are okay, the sig is valid for pre-22.0.\n+        min_trusted_sigs = 0\n+        gpg_allowed_codes = [0]\n+        builder_key_map = {}\n+\n+        gpg_retval, gpg_output, good, unknown, bad = check_single_sig(\n+            SIGNATUREFILENAME, args)\n+\n+    if gpg_retval not in gpg_allowed_codes:\n+        if gpg_retval == 1:\n+            log.critical(\"Bad signature.\")\n+        if gpg_retval == 2:\n+            log.critical(\n+                \"gpg error. Do you have the Bitcoin Core binary release \"\n+                \"signing key installed?\")\n+        else:\n+            log.critical(\"unexpected GPG exit code\")\n+\n+        log.error(f\"gpg output:\\n{indent(gpg_output)}\")\n+        cleanup()\n+        return ReturnCode.INTEGRITY_FAILURE\n+\n+    # Decide which keys we trust, though not \"trust\" in the GPG sense, but rather\n+    # which pubkeys convince us that this sums file is legitimate. In other words,\n+    # which pubkeys within the Bitcoin community do we trust for the purposes of\n+    # binary verification?\n+    trusted_keys = set()\n+    if not args.no_builder_keys:\n+        trusted_keys |= set(builder_key_map.keys())\n+    if args.trusted_keys:\n+        trusted_keys |= set(args.trusted_keys.split(','))\n+\n+    # Tally signatures and make sure we have enough good, trusted to fulfill\n+    # our threshold.\n+    good_trusted = {sig for sig in good if sig.trusted or sig.key in trusted_keys}\n+    good_untrusted = [sig for sig in good if sig not in good_trusted]\n+    num_trusted = len(good_trusted)\n+    log.info(f\"got {num_trusted} good, trusted signatures\")\n+\n+    if num_trusted < min_trusted_sigs:\n+        log.error(\n+            \"not enough trusted sigs to meet threshold \"\n+            f\"({num_trusted} vs. {min_trusted_sigs})\")\n+        return ReturnCode.NOT_ENOUGH_GOOD_SIGS\n+\n+    for sig in good_trusted:\n+        log.info(f\"GOOD SIGNATURE: {sig}\")\n+\n+    for sig in good_untrusted:\n+        log.info(f\"GOOD SIGNATURE (untrusted): {sig}\")\n+\n+    for sig in [sig for sig in good if sig.status == 'expired']:\n+        log.warning(f\"key {sig.key} for {sig.name} is expired\")\n+\n+    for sig in bad:\n+        log.warning(f\"BAD SIGNATURE: {sig}\")\n+\n+    for sig in unknown:\n+        log.warning(f\"UNKNOWN SIGNATURE: {sig}\")\n \n     # extract hashes/filenames of binaries to verify from hash file;\n     # each line has the following format: \"<hash> <binary_filename>\"\n-    with open(HASHFILE, 'r', encoding='utf8') as hash_file:\n-        hashes_to_verify = [\n-            line.split()[:2] for line in hash_file if os_filter in line]\n-    remove_files([HASHFILE])\n+    with open(SUMS_FILENAME, 'r', encoding='utf8') as hash_file:\n+        hashes_to_verify = [line.split()[:2] for line in hash_file if os_filter in line]\n+    remove_files([SUMS_FILENAME])\n     if not hashes_to_verify:\n-        print(\"error: no files matched the platform specified\")\n-        return 7\n+        log.error(\"no files matched the platform specified\")\n+        return ReturnCode.NO_BINARIES_MATCH\n+\n+    # remove binaries that are known not to be hosted by bitcoincore.org\n+    fragments_to_remove = ['-unsigned', '-debug', '-codesignatures']\n+    for fragment in fragments_to_remove:\n+        nobinaries = [i for i in hashes_to_verify if fragment in i[1]]\n+        if nobinaries:\n+            remove_str = ', '.join(i[1] for i in nobinaries)\n+            log.info(\n+                f\"removing *{fragment} binaries ({remove_str}) from verification \"\n+                f\"since {HOST1} does not host *{fragment} binaries\")\n+            hashes_to_verify = [i for i in hashes_to_verify if fragment not in i[1]]\n \n     # download binaries\n     for _, binary_filename in hashes_to_verify:\n-        print(f\"Downloading {binary_filename}\")\n-        download_with_wget(HOST1 + remote_dir + binary_filename)\n+        log.info(f\"downloading {binary_filename}\")\n+        success, output = download_with_wget(HOST1 + remote_dir + binary_filename)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r768973455",
      "id" : 768973455,
      "in_reply_to_id" : 766153692,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584t1ZqP",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 602,
      "original_position" : 653,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : null,
      "pull_request_review_id" : 831937758,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768973455/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-14T19:20:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768973455",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r768973595"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768973595"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Excellent point, thanks!",
      "commit_id" : "ee6517f900ba1638264378e3726dd7237e70957d",
      "created_at" : "2021-12-14T19:20:42Z",
      "diff_hunk" : "@@ -59,124 +194,457 @@ def download_with_wget(remote_file, local_file=None):\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError)\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    # Enforce English output since we're relying on output that contains natural language.\n+    # Use string-shell form (vs. args as list) because passing LANGUAGE via `env` doesn't\n+    # seem to work.\n+    args = (\n+        'LANGUAGE=en gpg --yes --decrypt '\n+        + (f' --output {output_filename} ' if output_filename else '')\n+        + signature_filename)\n+\n+    result = subprocess.run(args, shell=True, stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n+    return result.returncode, result.stdout.decode().rstrip()\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self, key: str, name: str, trusted: bool, status: str):\n+        self.key = key\n+        self.name = name\n+        self.trusted = trusted\n+        self.status = status\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(output: str) -> ([SigData], [SigData], [SigData]):\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs = []\n+    unknown_sigs = []\n+    bad_sigs = []\n+    total_resolved_sigs = 0\n+    curr_key = None\n+\n+    for i, line in enumerate(output):\n+        if 'using RSA key' in line:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r768973595",
      "id" : 768973595,
      "in_reply_to_id" : 765303913,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584t1Zsb",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 253,
      "original_position" : 240,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : null,
      "pull_request_review_id" : 831937985,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768973595/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-14T19:20:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768973595",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r768985678"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768985678"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Don't have time to think about the best way to handle this, so will leave for a follow-up.",
      "commit_id" : "ee6517f900ba1638264378e3726dd7237e70957d",
      "created_at" : "2021-12-14T19:38:25Z",
      "diff_hunk" : "@@ -2,29 +2,164 @@\n # Copyright (c) 2020 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Script for verifying Bitcoin Core release binaries\n-\n-This script attempts to download the signature file SHA256SUMS.asc from\n-bitcoincore.org and bitcoin.org and compares them.\n-It first checks if the signature passes, and then downloads the files\n-specified in the file, and checks if the hashes of these files match those\n-that are specified in the signature file.\n-The script returns 0 if everything passes the checks. It returns 1 if either\n-the signature check or the hash check doesn't pass. If an error occurs the\n-return value is >= 2.\n+\"\"\"Script for verifying Bitcoin Core release binaries.\n+\n+This script attempts to download the sum file SHA256SUMS and corresponding\n+signature file SHA256SUMS.asc from bitcoincore.org and bitcoin.org and\n+compares them.\n+\n+The sum-signature file is signed by a number of builder keys. This script\n+ensures that there is a minimum threshold of signatures from pubkeys that\n+we trust. This trust is articulated on the basis of configuration options\n+here, but by default is based upon a unionof (i) local GPG trust settings,\n+and (ii) keys which appear in the builder-keys/keys.txt file.\n+\n+If a minimum good, trusted signature threshold is met on the sum file, we then\n+download the files specified in SHA256SUMS, and check if the hashes of these\n+files match those that are specified. The script returns 0 if everything passes\n+the checks. It returns 1 if either the signature check or the hash check\n+doesn't pass. If an error occurs the return value is >= 2.\n+\n+Logging output goes to stderr and final binary verification data goes to stdout.\n+\n+JSON output can by obtained by setting env BINVERIFY_JSON=1.\n \"\"\"\n-from hashlib import sha256\n+import argparse\n+import difflib\n+import json\n+import logging\n import os\n import subprocess\n+import typing as t\n+import re\n import sys\n-from textwrap import indent\n+import shutil\n+import tempfile\n+import textwrap\n+import urllib.request\n+import enum\n+from hashlib import sha256\n+from pathlib import Path\n \n-WORKINGDIR = \"/tmp/bitcoin_verify_binaries\"\n-HASHFILE = \"hashes.tmp\"\n+# The primary host; this will fail if we can't retrieve files from here.\n HOST1 = \"https://bitcoincore.org\"\n HOST2 = \"https://bitcoin.org\"\n VERSIONPREFIX = \"bitcoin-core-\"\n-SIGNATUREFILENAME = \"SHA256SUMS.asc\"\n+SUMS_FILENAME = 'SHA256SUMS'\n+SIGNATUREFILENAME = f\"{SUMS_FILENAME}.asc\"\n+BUILDER_KEYS_GH_URL = (\n+    \"https://raw.githubusercontent.com/bitcoin/bitcoin/master/contrib/builder-keys/keys.txt\"\n+)\n+\n+\n+class ReturnCode(enum.IntEnum):\n+    SUCCESS = 0\n+    INTEGRITY_FAILURE = 1\n+    FILE_GET_FAILED = 4\n+    FILE_MISSING_FROM_ONE_HOST = 5\n+    FILES_NOT_EQUAL = 6\n+    NO_BINARIES_MATCH = 7\n+    NOT_ENOUGH_GOOD_SIGS = 9\n+    BINARY_DOWNLOAD_FAILED = 10\n+\n+\n+def set_up_logger(is_verbose: bool = True) -> logging.Logger:\n+    \"\"\"Set up a logger that writes to stderr.\"\"\"\n+    log = logging.getLogger(__name__)\n+    log.setLevel(logging.INFO if is_verbose else logging.WARNING)\n+    console = logging.StreamHandler(sys.stderr)  # log to stderr\n+    console.setLevel(logging.DEBUG)\n+    formatter = logging.Formatter('[%(levelname)s] %(message)s')\n+    console.setFormatter(formatter)\n+    log.addHandler(console)\n+    return log\n+\n+\n+log = set_up_logger()\n+\n+\n+def indent(output: str) -> str:\n+    return textwrap.indent(output, '  ')\n+\n+\n+def bool_from_env(key, default=False) -> bool:\n+    if key not in os.environ:\n+        return default\n+    raw = os.environ[key]\n+    return raw in ['1', 'True', 'true']\n+\n+\n+VERSION_FORMAT = \"<major>.<minor>[.<patch>][-rc[0-9]][-platform]\"\n+VERSION_EXAMPLE = \"22.0-x86_64 or 0.21.0-rc2-osx\"\n+\n+parser = argparse.ArgumentParser(description=__doc__)\n+parser.add_argument(\n+    'version', type=str, help=(\n+        f'version of the bitcoin release to download; of the format '\n+        f'{VERSION_FORMAT}. Example: {VERSION_EXAMPLE}')\n+)\n+parser.add_argument(\n+    '-v', '--verbose', action='store_true',\n+    default=bool_from_env('BINVERIFY_VERBOSE'),\n+)\n+parser.add_argument(\n+    '-q', '--quiet', action='store_true',\n+    default=bool_from_env('BINVERIFY_QUIET'),\n+)\n+parser.add_argument(\n+    '--cleanup', action='store_true',\n+    default=bool_from_env('BINVERIFY_CLEANUP'),\n+    help='if specified, clean up files afterwards'\n+)\n+parser.add_argument(\n+    '--noninteractive', action='store_true',\n+    default=bool_from_env('BINVERIFY_NONINTERACTIVE'),\n+    help='if specified, do not block for user input'\n+)\n+parser.add_argument(\n+    '--require-all-hosts', action='store_true',\n+    default=bool_from_env('BINVERIFY_REQUIRE_ALL_HOSTS'),\n+    help=(\n+        f'If set, require all hosts ({HOST1}, {HOST2}) to provide signatures. '\n+        '(Sometimes bitcoin.org lags behind bitcoincore.org.)')\n+)\n+parser.add_argument(\n+    '--bitcoin-src-path', action='store', nargs='?',\n+    default=os.environ.get('BINVERIFY_BITCOIN_SRC_PATH', ''),\n+    help='specify path to bitcoin repository. Used to find builder keys.',\n+)\n+parser.add_argument(\n+    '--skip-import-builders', action='store_true',\n+    default=bool_from_env('BINVERIFY_SKIP_IMPORT_BUILDERS'),\n+    help='If set, do not prompt to import builder pubkeys',\n+)\n+parser.add_argument(\n+    '--min-trusted-sigs', type=int, action='store', nargs='?',\n+    default=int(os.environ.get('BINVERIFY_MIN_TRUSTED_SIGS', 4)),\n+    help=(\n+        'The minimum number of good signatures from recognized keys to '\n+        'require successful termination.'),\n+)\n+parser.add_argument(\n+    '--keyserver', action='store', nargs='?',\n+    default=os.environ.get('BINVERIFY_KEYSERVER', 'hkp://keyserver.ubuntu.com'),\n+    help='which keyserver to use',\n+)\n+parser.add_argument(\n+    '--trusted-keys', action='store', nargs='?',\n+    default=os.environ.get('BINVERIFY_TRUSTED_KEYS', ''),\n+    help='A list of trusted builder GPG keys, specified as CSV',\n+)\n+parser.add_argument(\n+    '--no-builder-keys', action='store_true',\n+    default=bool_from_env('BINVERIFY_NO_BUILDER_KEYS'),\n+    help='If set, do not trust the builder-keys from the bitcoin repo by default',\n+)\n+parser.add_argument(\n+    '--json', action='store_true',\n+    default=bool_from_env('BINVERIFY_JSON'),\n+    help='If set, output the result as JSON',\n+)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r768985678",
      "id" : 768985678,
      "in_reply_to_id" : 766147623,
      "line" : 169,
      "node_id" : "PRRC_kwDOABII584t1cpO",
      "original_commit_id" : "a92ec88cbc6e153eabf5e809d8960454488cc391",
      "original_line" : 162,
      "original_position" : 176,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 183,
      "pull_request_review_id" : 831955649,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768985678/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-12-14T19:38:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/768985678",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Thanks (as always) for the great review and feedback @ryanofsky. To avoid painful review invalidation (and an even more painful rebase process), I've addressed the majority of your feedback in an additional commit. ",
      "created_at" : "2021-12-14T19:38:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-993917253",
      "id" : 993917253,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5847PflF",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/993917253/reactions"
      },
      "updated_at" : "2021-12-14T19:38:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/993917253",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Pushed a rebase that ports the functional tests from .sh to .py - immediately to fix the shellcheck failures, but I'd been meaning to do this anyway because the tests are easier to write and maintain in Python.",
      "created_at" : "2021-12-15T16:15:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-994943488",
      "id" : 994943488,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5847TaIA",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/994943488/reactions"
      },
      "updated_at" : "2021-12-15T16:15:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/994943488",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Pushed a rebase that ports the functional tests from .sh to .py \r\n\r\nThank you!",
      "created_at" : "2021-12-18T14:06:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-997207479",
      "id" : 997207479,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5847cC23",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/997207479/reactions"
      },
      "updated_at" : "2021-12-18T14:06:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/997207479",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "tACK 396cb35a2205a625ce3ba1a86d97754fbb983e85. I really like this and IMO should be very simple to explain to end users.",
      "created_at" : "2021-12-21T18:01:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-998984273",
      "id" : 998984273,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII5847i0pR",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/998984273/reactions"
      },
      "updated_at" : "2021-12-21T18:01:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/998984273",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/24482484?v=4",
         "events_url" : "https://api.github.com/users/Rspigler/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Rspigler/followers",
         "following_url" : "https://api.github.com/users/Rspigler/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Rspigler/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Rspigler",
         "id" : 24482484,
         "login" : "Rspigler",
         "node_id" : "MDQ6VXNlcjI0NDgyNDg0",
         "organizations_url" : "https://api.github.com/users/Rspigler/orgs",
         "received_events_url" : "https://api.github.com/users/Rspigler/received_events",
         "repos_url" : "https://api.github.com/users/Rspigler/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Rspigler/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Rspigler/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Rspigler"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Should I just close this?",
      "created_at" : "2022-07-22T15:33:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-1192694320",
      "id" : 1192694320,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII585HFxIw",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1192694320/reactions"
      },
      "updated_at" : "2022-07-22T15:33:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1192694320",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "I would prefer not, I really like this solution",
      "created_at" : "2022-07-22T15:37:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-1192700096",
      "id" : 1192700096,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII585HFyjA",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1192700096/reactions"
      },
      "updated_at" : "2022-07-22T15:37:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1192700096",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/24482484?v=4",
         "events_url" : "https://api.github.com/users/Rspigler/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Rspigler/followers",
         "following_url" : "https://api.github.com/users/Rspigler/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Rspigler/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Rspigler",
         "id" : 24482484,
         "login" : "Rspigler",
         "node_id" : "MDQ6VXNlcjI0NDgyNDg0",
         "organizations_url" : "https://api.github.com/users/Rspigler/orgs",
         "received_events_url" : "https://api.github.com/users/Rspigler/received_events",
         "repos_url" : "https://api.github.com/users/Rspigler/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Rspigler/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Rspigler/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Rspigler"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r963698985"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/963698985"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Pico-nit in case you re-touch: fn returns an unparenthesized tuple on L77 and parenthesized here. There's no behavioural difference in Python, but could be nice to have them the same (as \"the comma makes the tuple\", perhaps both unparenthesized?)",
      "commit_id" : "396cb35a2205a625ce3ba1a86d97754fbb983e85",
      "created_at" : "2022-09-06T13:19:20Z",
      "diff_hunk" : "@@ -63,6 +71,17 @@ def download_with_wget(remote_file, local_file=None):\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [l.strip().decode() for l in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError:\n+        print_warn(f\"HTTP request to {url} failed (HTTPError)\")\n+    except Exception as e:\n+        print_warn(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r963698985",
      "id" : 963698985,
      "line" : 207,
      "node_id" : "PRRC_kwDOABII5845cOEp",
      "original_commit_id" : "0bd3220200f9b87a2bb7b1644cb67b55cce4f3d0",
      "original_line" : 82,
      "original_position" : 47,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 47,
      "pull_request_review_id" : 1097576225,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/963698985/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-06T13:19:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/963698985",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6606587?v=4",
         "events_url" : "https://api.github.com/users/willcl-ark/events{/privacy}",
         "followers_url" : "https://api.github.com/users/willcl-ark/followers",
         "following_url" : "https://api.github.com/users/willcl-ark/following{/other_user}",
         "gists_url" : "https://api.github.com/users/willcl-ark/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/willcl-ark",
         "id" : 6606587,
         "login" : "willcl-ark",
         "node_id" : "MDQ6VXNlcjY2MDY1ODc=",
         "organizations_url" : "https://api.github.com/users/willcl-ark/orgs",
         "received_events_url" : "https://api.github.com/users/willcl-ark/received_events",
         "repos_url" : "https://api.github.com/users/willcl-ark/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/willcl-ark/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/willcl-ark/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/willcl-ark"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r964163444"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964163444"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "There may well be another line in the good case, however my output looks like this for many keys:\r\n\r\n```\r\n  gpg: Good signature from \"Antoine Poinsot <darosior@protonmail.com>\" [unknown]\r\n  gpg:                 aka \"darosior <darosior@protonmail.com>\" [unknown]\r\n  gpg:                 aka \"Antoine Poinsot <antoine@revault.dev>\" [unknown]\r\n  gpg:                 aka \"darosior <darosior@ln.dev>\" [unknown]\r\n  gpg: WARNING: This key is not certified with a trusted signature!\r\n```\r\n\r\nSo it shows up as `trusted = True`, when in fact it should not be",
      "commit_id" : "dff50dc68a54799df4415be6fea52a1e6fc88fc1",
      "created_at" : "2022-09-06T21:02:08Z",
      "diff_hunk" : "@@ -47,136 +189,498 @@ def parse_version_string(version_str):\n     return version_base, version_rc, version_os\n \n \n-def download_with_wget(remote_file, local_file=None):\n-    if local_file:\n-        wget_args = ['wget', '-O', local_file, remote_file]\n-    else:\n-        # use timestamping mechanism if local filename is not explicitly set\n-        wget_args = ['wget', '-N', remote_file]\n-\n-    result = subprocess.run(wget_args,\n+def download_with_wget(remote_file, local_file):\n+    result = subprocess.run(['wget', '-O', local_file, remote_file],\n                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError as e:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError): {e}\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    args = [\n+        'gpg', '--yes', '--decrypt',\n+        '--output', output_filename if output_filename else '', signature_filename]\n+\n+    env = dict(os.environ, LANGUAGE='en')\n+    result = subprocess.run(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=env)\n+    log.debug(f'Result from GPG ({result.returncode}): {result.stdout}')\n+    return result.returncode, result.stdout.decode().rstrip()\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self, key: str, name: str, trusted: bool, status: str):\n+        self.key = key\n+        self.name = name\n+        self.trusted = trusted\n+        self.status = status\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(output: str) -> ([SigData], [SigData], [SigData]):\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs = []\n+    unknown_sigs = []\n+    bad_sigs = []\n+    total_resolved_sigs = 0\n+    curr_key = None\n+\n+    # Ensure that all lines we match on include a prefix that prevents malicious input\n+    # from fooling the parser.\n+    def line_begins_with(patt: str, line: str) -> bool:\n+        return re.match(r'^\\s*(gpg:)?(\\s+)' + patt, line)\n+\n+    for i, line in enumerate(output):\n+        if line_begins_with(r\"using RSA key (0x[0-9a-fA-F]{16}|[0-9a-fA-F]{40})$\", line):\n+            if curr_key:\n+                raise RuntimeError(\n+                    f\"WARNING: encountered a new sig without resolving the last ({curr_key}) - \"\n+                    \"this could mean we have encountered a bad signature! check GPG output!\")\n+            curr_key = line.split('key ')[-1].strip()\n+            assert len(curr_key) == 40 or (len(curr_key) == 18 and curr_key.startswith('0x'))\n+\n+        if line_begins_with(r\"Can't check signature: No public key$\", line):\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            unknown_sigs.append(SigData(curr_key, '', False, ''))\n+            curr_key = None\n+\n+        if line_begins_with(r'Good signature from (\".+\")(\\s+)(\\[.+\\])$', line):\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+\n+            # It's safe to index output[i + 1] because if we saw a good sig, there should",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r964163444",
      "id" : 964163444,
      "line" : 276,
      "node_id" : "PRRC_kwDOABII5845d_d0",
      "original_commit_id" : "396cb35a2205a625ce3ba1a86d97754fbb983e85",
      "original_line" : 276,
      "original_position" : 283,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 283,
      "pull_request_review_id" : 1098240546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964163444/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-06T21:02:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964163444",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6606587?v=4",
         "events_url" : "https://api.github.com/users/willcl-ark/events{/privacy}",
         "followers_url" : "https://api.github.com/users/willcl-ark/followers",
         "following_url" : "https://api.github.com/users/willcl-ark/following{/other_user}",
         "gists_url" : "https://api.github.com/users/willcl-ark/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/willcl-ark",
         "id" : 6606587,
         "login" : "willcl-ark",
         "node_id" : "MDQ6VXNlcjY2MDY1ODc=",
         "organizations_url" : "https://api.github.com/users/willcl-ark/orgs",
         "received_events_url" : "https://api.github.com/users/willcl-ark/received_events",
         "repos_url" : "https://api.github.com/users/willcl-ark/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/willcl-ark/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/willcl-ark/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/willcl-ark"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r964165977"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964165977"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "~Perhaps keep indexing until we reach a line which does not start with `aka`, and then check that? This does feel quite brittle though.~\r\n\r\nActually it seems like we might be able to use `gpg --verify-options show-primary-uid-only` to hide the `aka` lines, according to https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html",
      "commit_id" : "dff50dc68a54799df4415be6fea52a1e6fc88fc1",
      "created_at" : "2022-09-06T21:05:01Z",
      "diff_hunk" : "@@ -47,136 +189,498 @@ def parse_version_string(version_str):\n     return version_base, version_rc, version_os\n \n \n-def download_with_wget(remote_file, local_file=None):\n-    if local_file:\n-        wget_args = ['wget', '-O', local_file, remote_file]\n-    else:\n-        # use timestamping mechanism if local filename is not explicitly set\n-        wget_args = ['wget', '-N', remote_file]\n-\n-    result = subprocess.run(wget_args,\n+def download_with_wget(remote_file, local_file):\n+    result = subprocess.run(['wget', '-O', local_file, remote_file],\n                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError as e:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError): {e}\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    args = [\n+        'gpg', '--yes', '--decrypt',\n+        '--output', output_filename if output_filename else '', signature_filename]\n+\n+    env = dict(os.environ, LANGUAGE='en')\n+    result = subprocess.run(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=env)\n+    log.debug(f'Result from GPG ({result.returncode}): {result.stdout}')\n+    return result.returncode, result.stdout.decode().rstrip()\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self, key: str, name: str, trusted: bool, status: str):\n+        self.key = key\n+        self.name = name\n+        self.trusted = trusted\n+        self.status = status\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(output: str) -> ([SigData], [SigData], [SigData]):\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs = []\n+    unknown_sigs = []\n+    bad_sigs = []\n+    total_resolved_sigs = 0\n+    curr_key = None\n+\n+    # Ensure that all lines we match on include a prefix that prevents malicious input\n+    # from fooling the parser.\n+    def line_begins_with(patt: str, line: str) -> bool:\n+        return re.match(r'^\\s*(gpg:)?(\\s+)' + patt, line)\n+\n+    for i, line in enumerate(output):\n+        if line_begins_with(r\"using RSA key (0x[0-9a-fA-F]{16}|[0-9a-fA-F]{40})$\", line):\n+            if curr_key:\n+                raise RuntimeError(\n+                    f\"WARNING: encountered a new sig without resolving the last ({curr_key}) - \"\n+                    \"this could mean we have encountered a bad signature! check GPG output!\")\n+            curr_key = line.split('key ')[-1].strip()\n+            assert len(curr_key) == 40 or (len(curr_key) == 18 and curr_key.startswith('0x'))\n+\n+        if line_begins_with(r\"Can't check signature: No public key$\", line):\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            unknown_sigs.append(SigData(curr_key, '', False, ''))\n+            curr_key = None\n+\n+        if line_begins_with(r'Good signature from (\".+\")(\\s+)(\\[.+\\])$', line):\n+            if not curr_key:\n+                raise RuntimeError(\"failed to detect signature being resolved\")\n+            name, status = parse_gpg_from_line(line)\n+\n+            # It's safe to index output[i + 1] because if we saw a good sig, there should",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r964165977",
      "id" : 964165977,
      "in_reply_to_id" : 964163444,
      "line" : 276,
      "node_id" : "PRRC_kwDOABII5845eAFZ",
      "original_commit_id" : "396cb35a2205a625ce3ba1a86d97754fbb983e85",
      "original_line" : 276,
      "original_position" : 283,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : 283,
      "pull_request_review_id" : 1098243681,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964165977/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-06T21:07:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964165977",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6606587?v=4",
         "events_url" : "https://api.github.com/users/willcl-ark/events{/privacy}",
         "followers_url" : "https://api.github.com/users/willcl-ark/followers",
         "following_url" : "https://api.github.com/users/willcl-ark/following{/other_user}",
         "gists_url" : "https://api.github.com/users/willcl-ark/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/willcl-ark",
         "id" : 6606587,
         "login" : "willcl-ark",
         "node_id" : "MDQ6VXNlcjY2MDY1ODc=",
         "organizations_url" : "https://api.github.com/users/willcl-ark/orgs",
         "received_events_url" : "https://api.github.com/users/willcl-ark/received_events",
         "repos_url" : "https://api.github.com/users/willcl-ark/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/willcl-ark/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/willcl-ark/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/willcl-ark"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r964177784"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964177784"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n        'gpg', '--yes', '--decrypt', '--verify-options', 'show-primary-uid-only',\r\n```",
      "commit_id" : "dff50dc68a54799df4415be6fea52a1e6fc88fc1",
      "created_at" : "2022-09-06T21:16:11Z",
      "diff_hunk" : "@@ -47,136 +189,498 @@ def parse_version_string(version_str):\n     return version_base, version_rc, version_os\n \n \n-def download_with_wget(remote_file, local_file=None):\n-    if local_file:\n-        wget_args = ['wget', '-O', local_file, remote_file]\n-    else:\n-        # use timestamping mechanism if local filename is not explicitly set\n-        wget_args = ['wget', '-N', remote_file]\n-\n-    result = subprocess.run(wget_args,\n+def download_with_wget(remote_file, local_file):\n+    result = subprocess.run(['wget', '-O', local_file, remote_file],\n                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError as e:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError): {e}\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    args = [\n+        'gpg', '--yes', '--decrypt',",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r964177784",
      "id" : 964177784,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5845eC94",
      "original_commit_id" : "396cb35a2205a625ce3ba1a86d97754fbb983e85",
      "original_line" : 215,
      "original_position" : 222,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : null,
      "pull_request_review_id" : 1098255438,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964177784/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-06T21:16:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964177784",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6606587?v=4",
         "events_url" : "https://api.github.com/users/willcl-ark/events{/privacy}",
         "followers_url" : "https://api.github.com/users/willcl-ark/followers",
         "following_url" : "https://api.github.com/users/willcl-ark/following{/other_user}",
         "gists_url" : "https://api.github.com/users/willcl-ark/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/willcl-ark",
         "id" : 6606587,
         "login" : "willcl-ark",
         "node_id" : "MDQ6VXNlcjY2MDY1ODc=",
         "organizations_url" : "https://api.github.com/users/willcl-ark/orgs",
         "received_events_url" : "https://api.github.com/users/willcl-ark/received_events",
         "repos_url" : "https://api.github.com/users/willcl-ark/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/willcl-ark/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/willcl-ark/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/willcl-ark"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r964178396"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964178396"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This fixes my comment about not strictly checking trusted for keys displaying akas (https://github.com/bitcoin/bitcoin/pull/23020/files#r964163444)",
      "commit_id" : "dff50dc68a54799df4415be6fea52a1e6fc88fc1",
      "created_at" : "2022-09-06T21:17:04Z",
      "diff_hunk" : "@@ -47,136 +189,498 @@ def parse_version_string(version_str):\n     return version_base, version_rc, version_os\n \n \n-def download_with_wget(remote_file, local_file=None):\n-    if local_file:\n-        wget_args = ['wget', '-O', local_file, remote_file]\n-    else:\n-        # use timestamping mechanism if local filename is not explicitly set\n-        wget_args = ['wget', '-N', remote_file]\n-\n-    result = subprocess.run(wget_args,\n+def download_with_wget(remote_file, local_file):\n+    result = subprocess.run(['wget', '-O', local_file, remote_file],\n                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError as e:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError): {e}\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    args = [\n+        'gpg', '--yes', '--decrypt',",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r964178396",
      "id" : 964178396,
      "in_reply_to_id" : 964177784,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5845eDHc",
      "original_commit_id" : "396cb35a2205a625ce3ba1a86d97754fbb983e85",
      "original_line" : 215,
      "original_position" : 222,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : null,
      "pull_request_review_id" : 1098256241,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964178396/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-06T21:17:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964178396",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6606587?v=4",
         "events_url" : "https://api.github.com/users/willcl-ark/events{/privacy}",
         "followers_url" : "https://api.github.com/users/willcl-ark/followers",
         "following_url" : "https://api.github.com/users/willcl-ark/following{/other_user}",
         "gists_url" : "https://api.github.com/users/willcl-ark/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/willcl-ark",
         "id" : 6606587,
         "login" : "willcl-ark",
         "node_id" : "MDQ6VXNlcjY2MDY1ODc=",
         "organizations_url" : "https://api.github.com/users/willcl-ark/orgs",
         "received_events_url" : "https://api.github.com/users/willcl-ark/received_events",
         "repos_url" : "https://api.github.com/users/willcl-ark/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/willcl-ark/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/willcl-ark/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/willcl-ark"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r964201756"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964201756"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "  For v23.0 one user now has an ECDSA key which seems to break this script (`output[70:80]`)\r\n  ```\r\n  gpg: Signature made Sat 23 Apr 2022 13:39:56 BST\r\n  gpg:                using ECDSA key C388F6961FB972A95678E327F62711DBDCA8AE56\r\n  gpg:                issuer \"kvaciral@protonmail.com\"\r\n  gpg: key 0x2F9867672542AC32: \"kvaciral@protonmail.com <kvaciral@protonmail.com>\" not changed\r\n  gpg: Total number processed: 1\r\n  gpg:              unchanged: 1\r\n  gpg: requesting key 0xF62711DBDCA8AE56 from hkps server keys.openpgp.org\r\n  gpg: key 0xF62711DBDCA8AE56: new key but contains no user ID - skipped\r\n  gpg: Total number processed: 1\r\n  gpg:           w/o user IDs: 1\r\n  gpg: Can't check signature: No public key\r\n  ```\r\n  \r\n  After this block is skipped `curr_key` is not set, which then causes the `RuntimeError` on L269 to hit",
      "commit_id" : "dff50dc68a54799df4415be6fea52a1e6fc88fc1",
      "created_at" : "2022-09-06T21:40:36Z",
      "diff_hunk" : "@@ -47,136 +189,498 @@ def parse_version_string(version_str):\n     return version_base, version_rc, version_os\n \n \n-def download_with_wget(remote_file, local_file=None):\n-    if local_file:\n-        wget_args = ['wget', '-O', local_file, remote_file]\n-    else:\n-        # use timestamping mechanism if local filename is not explicitly set\n-        wget_args = ['wget', '-N', remote_file]\n-\n-    result = subprocess.run(wget_args,\n+def download_with_wget(remote_file, local_file):\n+    result = subprocess.run(['wget', '-O', local_file, remote_file],\n                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError as e:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError): {e}\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    args = [\n+        'gpg', '--yes', '--decrypt',\n+        '--output', output_filename if output_filename else '', signature_filename]\n+\n+    env = dict(os.environ, LANGUAGE='en')\n+    result = subprocess.run(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=env)\n+    log.debug(f'Result from GPG ({result.returncode}): {result.stdout}')\n+    return result.returncode, result.stdout.decode().rstrip()\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self, key: str, name: str, trusted: bool, status: str):\n+        self.key = key\n+        self.name = name\n+        self.trusted = trusted\n+        self.status = status\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(output: str) -> ([SigData], [SigData], [SigData]):\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs = []\n+    unknown_sigs = []\n+    bad_sigs = []\n+    total_resolved_sigs = 0\n+    curr_key = None\n+\n+    # Ensure that all lines we match on include a prefix that prevents malicious input\n+    # from fooling the parser.\n+    def line_begins_with(patt: str, line: str) -> bool:\n+        return re.match(r'^\\s*(gpg:)?(\\s+)' + patt, line)\n+\n+    for i, line in enumerate(output):\n+        if line_begins_with(r\"using RSA key (0x[0-9a-fA-F]{16}|[0-9a-fA-F]{40})$\", line):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r964201756",
      "id" : 964201756,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5845eI0c",
      "original_commit_id" : "396cb35a2205a625ce3ba1a86d97754fbb983e85",
      "original_line" : 257,
      "original_position" : 264,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : null,
      "pull_request_review_id" : 1098286686,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964201756/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-06T21:40:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964201756",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6606587?v=4",
         "events_url" : "https://api.github.com/users/willcl-ark/events{/privacy}",
         "followers_url" : "https://api.github.com/users/willcl-ark/followers",
         "following_url" : "https://api.github.com/users/willcl-ark/following{/other_user}",
         "gists_url" : "https://api.github.com/users/willcl-ark/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/willcl-ark",
         "id" : 6606587,
         "login" : "willcl-ark",
         "node_id" : "MDQ6VXNlcjY2MDY1ODc=",
         "organizations_url" : "https://api.github.com/users/willcl-ark/orgs",
         "received_events_url" : "https://api.github.com/users/willcl-ark/received_events",
         "repos_url" : "https://api.github.com/users/willcl-ark/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/willcl-ark/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/willcl-ark/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/willcl-ark"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r964203244"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964203244"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "```suggestion\r\n        if line_begins_with(r\"using (ECDSA|RSA) key (0x[0-9a-fA-F]{16}|[0-9a-fA-F]{40})$\", line):\r\n```",
      "commit_id" : "dff50dc68a54799df4415be6fea52a1e6fc88fc1",
      "created_at" : "2022-09-06T21:41:47Z",
      "diff_hunk" : "@@ -47,136 +189,498 @@ def parse_version_string(version_str):\n     return version_base, version_rc, version_os\n \n \n-def download_with_wget(remote_file, local_file=None):\n-    if local_file:\n-        wget_args = ['wget', '-O', local_file, remote_file]\n-    else:\n-        # use timestamping mechanism if local filename is not explicitly set\n-        wget_args = ['wget', '-N', remote_file]\n-\n-    result = subprocess.run(wget_args,\n+def download_with_wget(remote_file, local_file):\n+    result = subprocess.run(['wget', '-O', local_file, remote_file],\n                             stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n     return result.returncode == 0, result.stdout.decode().rstrip()\n \n \n+def download_lines_with_urllib(url) -> (bool, [str]):\n+    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n+    try:\n+        return True, [\n+            line.strip().decode() for line in urllib.request.urlopen(url).readlines()]\n+    except urllib.request.HTTPError as e:\n+        log.warning(f\"HTTP request to {url} failed (HTTPError): {e}\")\n+    except Exception as e:\n+        log.warning(f\"HTTP request to {url} failed ({e})\")\n+    return (False, [])\n+\n+\n+def verify_with_gpg(\n+    signature_filename,\n+    output_filename: t.Optional[str] = None\n+) -> t.Tuple[int, str]:\n+    args = [\n+        'gpg', '--yes', '--decrypt',\n+        '--output', output_filename if output_filename else '', signature_filename]\n+\n+    env = dict(os.environ, LANGUAGE='en')\n+    result = subprocess.run(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=env)\n+    log.debug(f'Result from GPG ({result.returncode}): {result.stdout}')\n+    return result.returncode, result.stdout.decode().rstrip()\n+\n+\n+def remove_files(filenames):\n+    for filename in filenames:\n+        os.remove(filename)\n+\n+\n+class SigData:\n+    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n+    def __init__(self, key: str, name: str, trusted: bool, status: str):\n+        self.key = key\n+        self.name = name\n+        self.trusted = trusted\n+        self.status = status\n+\n+    def __repr__(self):\n+        return (\n+            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n+            (self.key, self.name, self.trusted, self.status))\n+\n+\n+def parse_gpg_result(output: str) -> ([SigData], [SigData], [SigData]):\n+    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n+    good_sigs = []\n+    unknown_sigs = []\n+    bad_sigs = []\n+    total_resolved_sigs = 0\n+    curr_key = None\n+\n+    # Ensure that all lines we match on include a prefix that prevents malicious input\n+    # from fooling the parser.\n+    def line_begins_with(patt: str, line: str) -> bool:\n+        return re.match(r'^\\s*(gpg:)?(\\s+)' + patt, line)\n+\n+    for i, line in enumerate(output):\n+        if line_begins_with(r\"using RSA key (0x[0-9a-fA-F]{16}|[0-9a-fA-F]{40})$\", line):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r964203244",
      "id" : 964203244,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5845eJLs",
      "original_commit_id" : "396cb35a2205a625ce3ba1a86d97754fbb983e85",
      "original_line" : 257,
      "original_position" : 264,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/verify.py",
      "position" : null,
      "pull_request_review_id" : 1098288835,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964203244/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-06T21:41:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964203244",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6606587?v=4",
         "events_url" : "https://api.github.com/users/willcl-ark/events{/privacy}",
         "followers_url" : "https://api.github.com/users/willcl-ark/followers",
         "following_url" : "https://api.github.com/users/willcl-ark/following{/other_user}",
         "gists_url" : "https://api.github.com/users/willcl-ark/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/willcl-ark",
         "id" : 6606587,
         "login" : "willcl-ark",
         "node_id" : "MDQ6VXNlcjY2MDY1ODc=",
         "organizations_url" : "https://api.github.com/users/willcl-ark/orgs",
         "received_events_url" : "https://api.github.com/users/willcl-ark/received_events",
         "repos_url" : "https://api.github.com/users/willcl-ark/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/willcl-ark/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/willcl-ark/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/willcl-ark"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r964210645"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964210645"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Perhaps this option name was changed?\r\n\r\n```suggestion\r\n    --no-trust-builder-keys \\\r\n```",
      "commit_id" : "dff50dc68a54799df4415be6fea52a1e6fc88fc1",
      "created_at" : "2022-09-06T21:54:14Z",
      "diff_hunk" : "@@ -1,41 +1,93 @@\n ### Verify Binaries\n \n-#### Preparation:\n+#### Preparation\n \n-Make sure you obtain the proper release signing key and verify the fingerprint with several independent sources.\n+As of Bitcoin Core v22.0, releases are signed by a number of public keys on the basis\n+of the [guix.sigs repository](https://github.com/bitcoin-core/guix.sigs/). When\n+verifying binary downloads, you (the end user) decide which of these public keys you\n+trust and then use that trust model to evaluate the signature on a file that contains\n+hashes of the release binaries. The downloaded binaries are then hashed and compared to\n+the signed checksum file.\n \n-```sh\n-$ gpg --fingerprint \"Bitcoin Core binary release signing key\"\n-pub   4096R/36C2E964 2015-06-24 [expires: YYYY-MM-DD]\n-      Key fingerprint = 01EA 5486 DE18 A882 D4C2  6845 90C8 019E 36C2 E964\n-uid                  Wladimir J. van der Laan (Bitcoin Core binary release signing key) <laanwj@gmail.com>\n-```\n+First, you have to figure out which public keys to recognize. Browse the [list of frequent\n+builder-keys](https://github.com/bitcoin/bitcoin/tree/master/contrib/builder-keys) and\n+decide which of these keys you would like to trust. For each key you want to trust, you\n+must obtain that key for your local GPG installation (you can use this script to do\n+this automatically, or you can do it yourself).\n+\n+You can obtain these keys by\n+  - (most laborious) through a browser using a key server (e.g. https://keyserver.ubuntu.com/),\n+  - manually using the `gpg --keyserver <url> --recv-keys <key>` command, or\n+  - (easiest) you can run the packaged `verifybinaries.py` script to have it automatically\n+    retrieve unrecognized keys.\n+\n+#### Legacy verification\n+\n+Historically, the lead maintainer Wladimir J. van der Laan has provided the sole signing\n+key for releases, but since 22.0 Bitcoin release sum files are signed as described\n+above using a plurality of keys.\n+\n+Legacy verification is preserved for releases before v22.0; namely, GPG verification for\n+a checksum file based solely on a valid signature by the old release key\n+(`0x90C8019E36C2E964`).\n+\n+#### Usage\n+\n+This script attempts to download the checksum file (`SHA256SUMS`) and corresponding\n+signature file `SHA256SUMS.asc` from https://bitcoincore.org and https://bitcoin.org.\n \n-#### Usage:\n+It first checks if the checksum file is valid based upon a plurality of signatures, and\n+then downloads the release files specified in the checksum file, and checks if the\n+hashes of the release files are as expected.\n \n-This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n+If we encounter pubkeys in the signature file that we do not recognize, the script\n+will prompt the user as to whether they'd like to download the pubkeys (unless the\n+`BINVERIFY_NONINTERACTIVE=1` option is set).\n \n-It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n+If the script is run from the root of the bitcoin/bitcoin repository, it will by\n+default use the `builder-keys/keys.txt` file to establish trusted pubkeys.\n \n-The script returns 0 if everything passes the checks. It returns 1 if either the signature check or the hash check doesn't pass. If an error occurs the return value is 2.\n+The script returns 0 if everything passes the checks. It returns 1 if either the\n+signature check or the hash check doesn't pass. An exit code of >2 indicates an error.\n \n+See the `Config` object for various options.\n+\n+#### Examples\n+\n+Validate releases with default settings:\n+```sh\n+./contrib/verifybinaries/verify.py 22.0\n+./contrib/verifybinaries/verify.py 22.0-rc2\n+./contrib/verifybinaries/verify.py 0.11.2\n+./contrib/verifybinaries/verify.py bitcoin-core-0.12.0\n+./contrib/verifybinaries/verify.py bitcoin-core-0.13.0-rc3\n+```\n+\n+Get JSON output and don't prompt for user input (no auto key import):\n+\n+```sh\n+./contrib/verifybinaries/verify.py 22.0-x86 --json --noninteractive\n+```\n \n+Don't trust builder-keys by default, and rely only on local GPG state and manually\n+specified keys, while requiring a threshold of at least 10 trusted signatures:\n ```sh\n-./verify.py bitcoin-core-0.11.2\n-./verify.py bitcoin-core-0.12.0\n-./verify.py bitcoin-core-0.13.0-rc3\n+./contrib/verifybinaries/verify.py 22.0-x86 \\\n+    --no-builder-keys \\",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r964210645",
      "id" : 964210645,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5845eK_V",
      "original_commit_id" : "396cb35a2205a625ce3ba1a86d97754fbb983e85",
      "original_line" : 76,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/README.md",
      "position" : null,
      "pull_request_review_id" : 1098299195,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964210645/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-06T21:54:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964210645",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6606587?v=4",
         "events_url" : "https://api.github.com/users/willcl-ark/events{/privacy}",
         "followers_url" : "https://api.github.com/users/willcl-ark/followers",
         "following_url" : "https://api.github.com/users/willcl-ark/following{/other_user}",
         "gists_url" : "https://api.github.com/users/willcl-ark/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/willcl-ark",
         "id" : 6606587,
         "login" : "willcl-ark",
         "node_id" : "MDQ6VXNlcjY2MDY1ODc=",
         "organizations_url" : "https://api.github.com/users/willcl-ark/orgs",
         "received_events_url" : "https://api.github.com/users/willcl-ark/received_events",
         "repos_url" : "https://api.github.com/users/willcl-ark/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/willcl-ark/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/willcl-ark/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/willcl-ark"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r964213335"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964213335"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Capture_output is python 3.7. Can just capture both with `subprocess.PIPE` though:\r\n\r\n```suggestion\r\n        f\"{path} --noninteractive --cleanup {extra}\", stdout=subprocess.PIPE, stderr=subprocess.PIPE, shell=True)\r\n```",
      "commit_id" : "dff50dc68a54799df4415be6fea52a1e6fc88fc1",
      "created_at" : "2022-09-06T22:02:33Z",
      "diff_hunk" : "@@ -0,0 +1,57 @@\n+#!/usr/bin/env python3\n+\n+import json\n+import sys\n+import subprocess\n+from pathlib import Path\n+\n+\n+def main():\n+    \"\"\"Tests ordered roughly from faster to slower.\"\"\"\n+\n+    expect_code(run_verify('0.32'), 4, \"Nonexistent version should fail\")\n+    expect_code(run_verify('0.32.awefa.12f9h'), 11, \"Malformed version should fail\")\n+    expect_code(run_verify('22.0 --min-trusted-sigs 20'), 9, \"--min-trusted-sigs 20 should fail\")\n+\n+    _220 = run_verify('22.0 --json')\n+    result = json.loads(_220.stdout.decode())\n+\n+    print(\"- testing multisig verification (22.0)\", flush=True)\n+    expect_code(_220, 0, \"22.0 should succeed\")\n+    v = result['verified_binaries']\n+    assert result['good_trusted_sigs']\n+    assert v['bitcoin-22.0-aarch64-linux-gnu.tar.gz'] == 'ac718fed08570a81b3587587872ad85a25173afa5f9fbbd0c03ba4d1714cfa3e'\n+    assert v['bitcoin-22.0-osx64.tar.gz'] == '2744d199c3343b2d94faffdfb2c94d75a630ba27301a70e47b0ad30a7e0155e9'\n+    assert v['bitcoin-22.0-x86_64-linux-gnu.tar.gz'] == '59ebd25dd82a51638b7a6bb914586201e67db67b919b2a1ff08925a7936d1b16'\n+\n+    print(\"- testing single-sig verification (0.20.0)\", flush=True)\n+    _20 = run_verify('0.20.0 --json')\n+    result = json.loads(_20.stdout.decode())\n+    v = result['verified_binaries']\n+\n+    expect_code(_20, 0, \"0.20.0 should succeed\")\n+    assert v['bitcoin-0.20.0-aarch64-linux-gnu.tar.gz'] == '081b30b0f1af95656242c83eef30bbf7216b1a30fa8e8f29b3b160fe520d28f6'\n+    assert v['bitcoin-0.20.0-arm-linux-gnueabihf.tar.gz'] == '05014c7ff00f4496b1f389f0961d807e04505d8721d5c6f69567f2a0ec1985cc'\n+    assert v['bitcoin-0.20.0-osx64.tar.gz'] == '34f377fee2c7adf59981dde7e41215765d47b466f773cf2673137d30495b2675'\n+\n+\n+def run_verify(extra: str) -> subprocess.CompletedProcess:\n+    maybe_here = Path.cwd() / 'verify.py'\n+    path = maybe_here if maybe_here.exists() else Path.cwd() / 'contrib' / 'verifybinaries' / 'verify.py'\n+\n+    return subprocess.run(\n+        f\"{path} --noninteractive --cleanup {extra}\", capture_output=True, shell=True)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#discussion_r964213335",
      "id" : 964213335,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5845eLpX",
      "original_commit_id" : "396cb35a2205a625ce3ba1a86d97754fbb983e85",
      "original_line" : 43,
      "original_position" : 43,
      "original_start_line" : null,
      "path" : "contrib/verifybinaries/test.py",
      "position" : null,
      "pull_request_review_id" : 1098302418,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/23020",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964213335/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-09-06T22:04:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/964213335",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6606587?v=4",
         "events_url" : "https://api.github.com/users/willcl-ark/events{/privacy}",
         "followers_url" : "https://api.github.com/users/willcl-ark/followers",
         "following_url" : "https://api.github.com/users/willcl-ark/following{/other_user}",
         "gists_url" : "https://api.github.com/users/willcl-ark/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/willcl-ark",
         "id" : 6606587,
         "login" : "willcl-ark",
         "node_id" : "MDQ6VXNlcjY2MDY1ODc=",
         "organizations_url" : "https://api.github.com/users/willcl-ark/orgs",
         "received_events_url" : "https://api.github.com/users/willcl-ark/received_events",
         "repos_url" : "https://api.github.com/users/willcl-ark/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/willcl-ark/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/willcl-ark/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/willcl-ark"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@willcl-ark thanks very much for the review; pushed your feedback.",
      "created_at" : "2022-09-06T22:32:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/23020#issuecomment-1238718049",
      "id" : 1238718049,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/23020",
      "node_id" : "IC_kwDOABII585J1VZh",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1238718049/reactions"
      },
      "updated_at" : "2022-09-06T22:32:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1238718049",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   }
]
