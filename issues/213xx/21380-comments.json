[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "~Because of the refactoring this will conflict heavily with other changes to versionbits. I've rebased #21377 on top of this and there's a height based variant at #21392.~ I think it should be possible to adapt to cover the rest of #19573, but haven't tried. It would require some refactoring of the bip8 code in order to be able to catch bugs in the MUST_SIGNAL handling, but maybe that's worthwhile anyway.\r\n\r\nParticularly interested in additional checks that could be added, or better ways of converting fuzz data into interesting chains to test. I've just hardcoded the intervals at 10 minutes, ~and currently the BIP9 timeouts will precisely match some block's time, which could be missing edge cases?~ So far it seems pretty reasonable though.",
      "created_at" : "2021-03-07T12:46:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-792273605",
      "id" : 792273605,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MjI3MzYwNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-16T11:30:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/792273605",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #21401 (Refactor versionbits deployments to avoid potential uninitialized variables by achow101)\n* #21393 (BIP 341: Add Speedy Trial activation parameters by achow101)\n* #21392 (Implement BIP 8 based Speedy Trial activation by achow101)\n* #21391 ([Bundle 5/n] Prune g_chainman usage in RPC modules by dongcarl)\n* #21378 (Convert taproot to flag day activation by ajtowns)\n* #19438 (Introduce deploymentstatus by ajtowns)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2021-03-07T17:25:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-792316498",
      "id" : 792316498,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MjMxNjQ5OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-16T11:45:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/792316498",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Particularly interested in additional checks that could be added\r\n\r\nMaybe some simple reorg testing, e.g. just invalidateblock around various thresholds to ensure we return to the previous state, then add a new block with a different timestamp to ensure we either advance or don't advance to the next state as is appropriate?",
      "created_at" : "2021-03-07T17:42:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-792321707",
      "id" : 792321707,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MjMyMTcwNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-07T17:42:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/792321707",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/61096?v=4",
         "events_url" : "https://api.github.com/users/harding/events{/privacy}",
         "followers_url" : "https://api.github.com/users/harding/followers",
         "following_url" : "https://api.github.com/users/harding/following{/other_user}",
         "gists_url" : "https://api.github.com/users/harding/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/harding",
         "id" : 61096,
         "login" : "harding",
         "node_id" : "MDQ6VXNlcjYxMDk2",
         "organizations_url" : "https://api.github.com/users/harding/orgs",
         "received_events_url" : "https://api.github.com/users/harding/received_events",
         "repos_url" : "https://api.github.com/users/harding/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/harding/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/harding/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/harding"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Strong Concept ACK\r\n\r\nVery excited to see the versionbits implementation more thoroughly fuzzed :)\r\n\r\nThanks!",
      "created_at" : "2021-03-07T18:34:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-792330157",
      "id" : 792330157,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MjMzMDE1Nw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-07T18:34:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/792330157",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Maybe some simple reorg testing, e.g. just invalidateblock around various thresholds to ensure we return to the previous state, then add a new block with a different timestamp to ensure we either advance or don't advance to the next state as is appropriate?\r\n\r\nThat would make sense if versionbits knew about tips or cached blocks based on height, but it caches based on block hash and just relies on being able to query ancestors of whatever `CBlockIndex*` is passed in. Neither the fuzz tester nor the existing unit test set up the scenario sufficiently for invalidateblock to work.",
      "created_at" : "2021-03-07T23:26:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-792373952",
      "id" : 792373952,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MjM3Mzk1Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-07T23:26:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/792373952",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Code Review ACK 9c08af24e77980673efa30b5101451c3c8b20b1b\r\n\r\nThe cleanups to versionbits handling are nice. Skimmed over the fuzzer part, but did run it. It did catch a possible corner case in #21392.",
      "created_at" : "2021-03-09T04:23:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-793365701",
      "id" : 793365701,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MzM2NTcwMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-09T04:23:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/793365701",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK 9c08af24e77980673efa30b5101451c3c8b20b1b\r\n\r\nI managed to run the fuzzer (on linux), but haven't studied it in much detail. We should probably improve it in followups, so the PR's that build on top of the refactoring commits here can continue without rebase headaches.",
      "created_at" : "2021-03-09T12:21:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-793807435",
      "id" : 793807435,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5MzgwNzQzNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-09T12:21:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/793807435",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I am not sure if it is good to hide validation code refactoring in a \"Add fuzzing harness\" pull",
      "created_at" : "2021-03-12T09:29:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-797361955",
      "id" : 797361955,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5NzM2MTk1NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-12T09:29:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/797361955",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I am not sure if it is good to hide validation code refactoring in a \"Add fuzzing harness\" pull\r\n\r\nIt's not mean to be hidden; the commits aren't subtle, it's called out in the description, and the labels are all there... The reason it's a single PR is that (I don't think) the fuzzer works without the refactoring, and without the fuzzer, there's not a lot of other tests to ensure the refactoring is correct...",
      "created_at" : "2021-03-12T21:40:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-797771240",
      "id" : 797771240,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5Nzc3MTI0MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-12T21:40:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/797771240",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Maybe the title could be changed to \"Refactor versionbits to add fuzzing harness\" or so?",
      "created_at" : "2021-03-13T07:44:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-797884708",
      "id" : 797884708,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5Nzg4NDcwOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-13T07:44:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/797884708",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK.\r\n\r\nCan we remove `nRuleChangeActivationThreshold` from `Params` now that it's only used in the `WarningBitsConditionChecker`?",
      "created_at" : "2021-03-15T12:43:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-799388832",
      "id" : 799388832,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5OTM4ODgzMg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-15T12:43:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/799388832",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--4a62be1de6b64f3ed646cdc7932c8cf5-->\nðµï¸ @sipa has been requested to review this pull request as specified in the REVIEWERS file.",
      "created_at" : "2021-03-15T16:49:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-799573869",
      "id" : 799573869,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5OTU3Mzg2OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-15T16:49:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/799573869",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-03-15T18:54:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-799670259",
      "id" : 799670259,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5OTY3MDI1OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-15T18:54:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/799670259",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Can we remove `nRuleChangeActivationThreshold` from `Params` now that it's only used in the `WarningBitsConditionChecker`?\r\n\r\nIt's still chain specific, so it could be moved from Consensus::Params to ChainParams (and renamed), but not removed entirely I think.",
      "created_at" : "2021-03-16T03:31:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-799917074",
      "id" : 799917074,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5OTkxNzA3NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-16T03:31:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/799917074",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> The reason it's a single PR is that (I don't think) the fuzzer works without the refactoring, [...]\r\n\r\nThis turns out not to be the case. I'm having a go at changing the approach to fuzzing approach, and if that works out will probably split the refactoring out of this PR.\r\n",
      "created_at" : "2021-03-16T05:23:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-799959690",
      "id" : 799959690,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc5OTk1OTY5MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-16T05:23:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/799959690",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Rebased and updated to only add the fuzzing harness and not do any refactoring.\r\n\r\nThis also changes the approach used for fuzzing to only sanity check one period's worth of blocks, rather than every period -- relying instead on different fuzz inputs to check different periods. Seems to be no less thorough, and much faster for fuzzing. Also might be a bit easier to understand.",
      "created_at" : "2021-03-16T11:31:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-800181058",
      "id" : 800181058,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwMDE4MTA1OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-16T11:32:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/800181058",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595099275"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595099275"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Would you consider adding a few line breaks to these function declarations?",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T11:55:40Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595099275",
      "id" : 595099275,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA5OTI3NQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 34,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595099275",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595102829"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595102829"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n} // namespace\r\n\r\nFUZZ_TARGET(versionbits)\r\n```",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T12:00:15Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595102829",
      "id" : 595102829,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwMjgyOQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 114,
      "original_position" : 110,
      "original_start_line" : 103,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595102829",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595103941"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595103941"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    constexpr int period{32};\r\n    constexpr int threshold{29};\r\n\r\n    static_assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\r\n```",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T12:01:55Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595103941",
      "id" : 595103941,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwMzk0MQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : 114,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595103941",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595104935"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595104935"
         }
      },
      "author_association" : "MEMBER",
      "body" : "style-nit: (add new line and clang-format to avoid excessive long lines)\r\n\r\n```suggestion\r\n    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit)\r\n    : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\r\n```",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T12:03:30Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595104935",
      "id" : 595104935,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwNDkzNQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 34,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613159162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595104935",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595105060"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595105060"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Also consider s/period/PERIOD/ and s/threshold/THRESHOLD/",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T12:03:43Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595105060",
      "id" : 595105060,
      "in_reply_to_id" : 595103941,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwNTA2MA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : 114,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595105060",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595106496"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595106496"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Any reason not to make `blocks` a `std::vector<std::unique_ptr<CBlockIndex>>`, and let the default destructor take care of this for you?",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T12:06:11Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595106496",
      "id" : 595106496,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwNjQ5Ng==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 76,
      "original_position" : 76,
      "original_start_line" : 71,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595106496",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595106608"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595106608"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    std::vector<CBlockIndex*> m_blocks;\r\n```",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T12:06:23Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595106608",
      "id" : 595106608,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwNjYwOA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 63,
      "original_position" : 63,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595106608",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595106617"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595106617"
         }
      },
      "author_association" : "MEMBER",
      "body" : "style-nit: Can be shorter\r\n\r\n```suggestion\r\nFUZZ_TARGET(versionbits)\r\n```\r\n",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T12:06:24Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595106617",
      "id" : 595106617,
      "line" : 114,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwNjYxNw==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 114,
      "original_position" : 110,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 114,
      "pull_request_review_id" : 613159162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595106617",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595108166"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595108166"
         }
      },
      "author_association" : "MEMBER",
      "body" : "shouldn't this be a static assert? (With the constexpr symbols all uppercase)\r\n\r\nOr is the goal to have the fuzz engine pick the period length?",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T12:08:46Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595108166",
      "id" : 595108166,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwODE2Ng==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613159162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595108166",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595109347"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595109347"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Maybe move this up next to the `n_blocks` declaration, make those constants `constexpr` and make this a static_assert.",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T12:10:39Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595109347",
      "id" : 595109347,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwOTM0Nw==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 132,
      "original_position" : 132,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595109347",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595109600"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595109600"
         }
      },
      "author_association" : "MEMBER",
      "body" : "would it be possible to use params.genesis.nTime instead of the copied value?",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T12:11:03Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595109600",
      "id" : 595109600,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTEwOTYwMA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 128,
      "original_position" : 128,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613159162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595109600",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595110128"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595110128"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Mind doing a clang-format, so that all files in `src/test/fuzz` are \"clean\"?",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T12:11:53Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595110128",
      "id" : 595110128,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTExMDEyOA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 125,
      "original_position" : 125,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613159162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595110128",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595110558"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595110558"
         }
      },
      "author_association" : "MEMBER",
      "body" : "static_assert (with same comment from above)",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T12:12:34Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595110558",
      "id" : 595110558,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTExMDU1OA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 132,
      "original_position" : 132,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613159162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595110558",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595111407"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595111407"
         }
      },
      "author_association" : "MEMBER",
      "body" : "would it be possible to use params.consensus.nPowTargetSpacing instead of the hardcoded value?",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T12:13:42Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595111407",
      "id" : 595111407,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTExMTQwNw==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 146,
      "original_position" : 146,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613159162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595111407",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595114366"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595114366"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could replace with \r\n```suggestion\r\n    while (fuzzed_data_provider.ConsumeBool()) {\r\n```\r\n\r\nor mention that the provider is used up after this call and should not be accessed again?",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T12:17:43Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595114366",
      "id" : 595114366,
      "line" : 207,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTExNDM2Ng==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 207,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 207,
      "pull_request_review_id" : 613159162,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595114366",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595146970"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595146970"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n        if (blocks.size() > 2 * n_blocks) break;\r\n```",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T13:02:36Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {\n+        // all blocks in these periods either do or don't signal\n+        bool signal = fuzzed_data_provider.ConsumeBool();\n+        for (int b = 0; b < period; ++b) {\n+            blocks.mine_block(signal);\n+        }\n+\n+        // don't go too crazy with how many blocks we mine\n+        if (blocks.size() > 2*n_blocks) break;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595146970",
      "id" : 595146970,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE0Njk3MA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 206,
      "original_position" : 206,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595146970",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595147323"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595147323"
         }
      },
      "author_association" : "MEMBER",
      "body" : "s/n_blocks/max_blocks/",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T13:03:09Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595147323",
      "id" : 595147323,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE0NzMyMw==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 120,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595147323",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595148151"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595148151"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Wanted to leave it open for the threshold could be picked by the fuzzer at least. Changing the period makes the test take longer, so not sure how much sense it makes to fuzz that.",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T13:04:19Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595148151",
      "id" : 595148151,
      "in_reply_to_id" : 595108166,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE0ODE1MQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 117,
      "original_position" : 117,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613215547,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595148151",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595151368"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595151368"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Move this declaration down to where it's used first.",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T13:08:28Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595151368",
      "id" : 595151368,
      "line" : 204,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE1MTM2OA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 204,
      "original_position" : 195,
      "original_start_line" : 194,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 204,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : 203,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595151368",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595160435"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595160435"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Neither of these are used.",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T13:19:55Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595160435",
      "id" : 595160435,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE2MDQzNQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 17,
      "original_position" : 17,
      "original_start_line" : 16,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613152496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595160435",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595161446"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595161446"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Couldn't the subsequent `ConsumeBool()` fail if this is the last byte in the data provider?",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T13:21:12Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595161446",
      "id" : 595161446,
      "in_reply_to_id" : 595114366,
      "line" : 207,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE2MTQ0Ng==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 207,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 207,
      "pull_request_review_id" : 613233132,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595161446",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595172488"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595172488"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Seemed easier to do it this way than to have to manually extract the raw pointers everywhere",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T13:34:11Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595172488",
      "id" : 595172488,
      "in_reply_to_id" : 595106496,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE3MjQ4OA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 76,
      "original_position" : 76,
      "original_start_line" : 71,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613247624,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595172488",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595173844"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595173844"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm deliberately getting the mask beforehand so that adding bytes at the end of the fuzz data just adds blocks and doesn't change what gets interpreted as a mask and what gets interpreted as a bool",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T13:35:46Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595173844",
      "id" : 595173844,
      "in_reply_to_id" : 595151368,
      "line" : 204,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE3Mzg0NA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 204,
      "original_position" : 195,
      "original_start_line" : 194,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 204,
      "pull_request_review_id" : 613249467,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : 203,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595173844",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595197898"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595197898"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think you'd only need to change the `tip()` and `mine_block()` member functions:\r\n\r\n```diff\r\ndiff --git a/src/test/fuzz/versionbits.cpp b/src/test/fuzz/versionbits.cpp\r\nindex ded18d8602..1613f65586 100644\r\n--- a/src/test/fuzz/versionbits.cpp\r\n+++ b/src/test/fuzz/versionbits.cpp\r\n@@ -13,6 +13,7 @@\r\n #include <test/fuzz/util.h>\r\n \r\n #include <cstdint>\r\n+#include <memory>\r\n #include <optional>\r\n #include <string>\r\n #include <vector>\r\n@@ -60,7 +61,7 @@ public:\r\n class Blocks\r\n {\r\n private:\r\n-    std::vector<CBlockIndex*> blocks;\r\n+    std::vector<std::unique_ptr<CBlockIndex>> blocks;\r\n     const uint32_t m_start_time;\r\n     const int32_t m_signal;\r\n     const int32_t m_no_signal;\r\n@@ -68,19 +69,11 @@ private:\r\n public:\r\n     Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\r\n \r\n-    ~Blocks()\r\n-    {\r\n-        for (auto& v : blocks) {\r\n-            delete v;\r\n-        }\r\n-        blocks.clear();\r\n-    }\r\n-\r\n     size_t size() const { return blocks.size(); }\r\n \r\n     CBlockIndex* tip() const\r\n     {\r\n-        return blocks.empty() ? nullptr : blocks.back();\r\n+        return blocks.empty() ? nullptr : blocks.back().get();\r\n     }\r\n \r\n     CBlockIndex* mine_block(bool signal)\r\n@@ -90,14 +83,14 @@ public:\r\n         header.nTime = m_start_time + blocks.size() * 600;\r\n         header.nBits = 0x1d00ffff;\r\n \r\n-        CBlockIndex* current_block = new CBlockIndex{header};\r\n+        auto current_block = std::make_unique<CBlockIndex>(header);\r\n         current_block->pprev = tip();\r\n         current_block->nHeight = blocks.size();\r\n         current_block->BuildSkip();\r\n \r\n-        blocks.push_back(current_block);\r\n+        blocks.push_back(std::move(current_block));\r\n \r\n-        return current_block;\r\n+        return tip();\r\n     }\r\n };\r\n```",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T14:02:17Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595197898",
      "id" : 595197898,
      "in_reply_to_id" : 595106496,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTE5Nzg5OA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 76,
      "original_position" : 76,
      "original_start_line" : 71,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : null,
      "pull_request_review_id" : 613281570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-16T14:17:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595197898",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595213695"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595213695"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Added the comment",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T14:19:27Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595213695",
      "id" : 595213695,
      "in_reply_to_id" : 595114366,
      "line" : 207,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTIxMzY5NQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 207,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 207,
      "pull_request_review_id" : 613302546,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T14:19:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595213695",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Bunches of nits addressed.\r\n\r\n> This fuzz test is based on times, so I presume it will change again once activation is changed to be based on block heights?\r\n\r\nMy theory is having a fuzz test should make it easier to be confident a switch to heights isn't introducing new edge cases with bogus behaviour.",
      "created_at" : "2021-03-16T14:23:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-800302418",
      "id" : 800302418,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwMDMwMjQxOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-16T14:23:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/800302418",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595279670"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595279670"
         }
      },
      "author_association" : "MEMBER",
      "body" : "ah! Makes sense. Thanks.",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T15:26:20Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595279670",
      "id" : 595279670,
      "in_reply_to_id" : 595151368,
      "line" : 204,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTI3OTY3MA==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 204,
      "original_position" : 195,
      "original_start_line" : 194,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 204,
      "pull_request_review_id" : 613391060,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : 203,
      "start_side" : "RIGHT",
      "updated_at" : "2021-03-16T15:26:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595279670",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595376481"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595376481"
         }
      },
      "author_association" : "MEMBER",
      "body" : "FuzzedDataProvider itself doesn't fail if the last byte was consumed. It will simply return constant values. In the case of bool, `false`. So using `ConsumeBool()` would be identical to `remaining_bytes`, with the difference that the fuzz input is one more byte large (to encode the consumed bool) per iteration. Also, `ConsumeBool` would leave open the possibility to use the data provider afterwards without invalidating the inputs.",
      "commit_id" : "56f16a0aee95d89ca8d6318cd6a282568fe3b953",
      "created_at" : "2021-03-16T17:11:32Z",
      "diff_hunk" : "@@ -0,0 +1,343 @@\n+// Copyright (c) 2020-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chain.h>\n+#include <chainparams.h>\n+#include <consensus/params.h>\n+#include <primitives/block.h>\n+#include <versionbits.h>\n+\n+#include <test/fuzz/FuzzedDataProvider.h>\n+#include <test/fuzz/fuzz.h>\n+#include <test/fuzz/util.h>\n+\n+#include <cstdint>\n+#include <optional>\n+#include <string>\n+#include <vector>\n+\n+namespace {\n+class TestConditionChecker : public AbstractThresholdConditionChecker\n+{\n+private:\n+    mutable ThresholdConditionCache m_cache;\n+    const Consensus::Params dummy_params{};\n+\n+public:\n+    const int64_t m_begin = 0;\n+    const int64_t m_end = 0;\n+    const int m_period = 0;\n+    const int m_threshold = 0;\n+    const int m_bit = 0;\n+\n+    TestConditionChecker(int64_t begin, int64_t end, int period, int threshold, int bit) : m_begin{begin}, m_end{end}, m_period{period}, m_threshold{threshold}, m_bit{bit}\n+    {\n+        assert(m_period > 0);\n+        assert(0 <= m_threshold && m_threshold <= m_period);\n+        assert(0 <= m_bit && m_bit <= 32 && m_bit < VERSIONBITS_NUM_BITS);\n+    }\n+\n+    virtual bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return Condition(pindex->nVersion); }\n+    virtual int64_t BeginTime(const Consensus::Params& params) const override { return m_begin; }\n+    virtual int64_t EndTime(const Consensus::Params& params) const override { return m_end; }\n+    virtual int Period(const Consensus::Params& params) const override { return m_period; }\n+    virtual int Threshold(const Consensus::Params& params) const override { return m_threshold; }\n+\n+    ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, dummy_params, m_cache); }\n+    int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, dummy_params, m_cache); }\n+    BIP9Stats GetStateStatisticsFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateStatisticsFor(pindexPrev, dummy_params); }\n+\n+    bool Condition(int64_t version) const\n+    {\n+        return ((version >> m_bit) & 1) != 0 && (version & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS;\n+    }\n+\n+    bool Condition(const CBlockIndex* pindex) const { return Condition(pindex->nVersion); }\n+};\n+\n+/** Track blocks mined for test */\n+class Blocks\n+{\n+private:\n+    std::vector<CBlockIndex*> blocks;\n+    const uint32_t m_start_time;\n+    const int32_t m_signal;\n+    const int32_t m_no_signal;\n+\n+public:\n+    Blocks(uint32_t start_time, int32_t signal, int32_t no_signal) : m_start_time{start_time}, m_signal{signal}, m_no_signal{no_signal} { }\n+\n+    ~Blocks()\n+    {\n+        for (auto& v : blocks) {\n+            delete v;\n+        }\n+        blocks.clear();\n+    }\n+\n+    size_t size() const { return blocks.size(); }\n+\n+    CBlockIndex* tip() const\n+    {\n+        return blocks.empty() ? nullptr : blocks.back();\n+    }\n+\n+    CBlockIndex* mine_block(bool signal)\n+    {\n+        CBlockHeader header;\n+        header.nVersion = signal ? m_signal : m_no_signal;\n+        header.nTime = m_start_time + blocks.size() * 600;\n+        header.nBits = 0x1d00ffff;\n+\n+        CBlockIndex* current_block = new CBlockIndex{header};\n+        current_block->pprev = tip();\n+        current_block->nHeight = blocks.size();\n+        current_block->BuildSkip();\n+\n+        blocks.push_back(current_block);\n+\n+        return current_block;\n+    }\n+};\n+\n+void initialize()\n+{\n+    return;\n+}\n+} // namespace\n+\n+FUZZ_TARGET_INIT(versionbits, initialize)\n+{\n+    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n+\n+    const int period = 32;\n+    const int threshold = 29;\n+\n+    assert(0 < threshold && threshold <= period - 2);  // must be able to not signal!\n+\n+    const size_t max_periods = 16;\n+    const size_t n_blocks = period * max_periods;\n+\n+    // pick the timestamp to switch based on a block\n+    // note states will change *after* these blocks because mediantime lags\n+    int start_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, period * (max_periods-3));\n+    int end_block = fuzzed_data_provider.ConsumeIntegralInRange<int>(start_block, period * (max_periods-3));\n+\n+    // between genesis and 2100-01-01\n+    const int64_t block_start_time = fuzzed_data_provider.ConsumeIntegralInRange<uint32_t>(1231006505, 4102444800);\n+\n+    // too many blocks at 10min each might cause uint32_t time to overflow if\n+    // block_start_time is at the end of the range above\n+    assert(n_blocks < 320000);\n+\n+    // what values for version will we use to signal / not signal?\n+    int32_t ver_signal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+    int32_t ver_nosignal = fuzzed_data_provider.ConsumeIntegral<int32_t>();\n+\n+    // select deployment parameters: bit, start time, timeout\n+    int bit = fuzzed_data_provider.ConsumeIntegralInRange<int>(0, VERSIONBITS_NUM_BITS-1);\n+\n+    bool always_active_test = false;\n+    bool never_active_test = false;\n+    int64_t start_time;\n+    int64_t timeout;\n+    if (fuzzed_data_provider.ConsumeBool()) {\n+        start_time = block_start_time + start_block*600;\n+        timeout = block_start_time + end_block*600;\n+\n+        assert(start_time <= timeout);\n+\n+        // allow for times to not exactly match a block\n+        if (fuzzed_data_provider.ConsumeBool()) start_time += 300;\n+        if (fuzzed_data_provider.ConsumeBool()) timeout += 300;\n+\n+        // this may make timeout too early; if so, don't run the test\n+        if (start_time > timeout) return;\n+    } else {\n+        if (fuzzed_data_provider.ConsumeBool()) {\n+            start_time = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n+            timeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n+            always_active_test = true;\n+        } else {\n+            start_time = 1199145601; // January 1, 2008\n+            timeout = 1230767999; // December 31, 2008\n+            never_active_test = true;\n+        }\n+    }\n+\n+    TestConditionChecker checker(start_time, timeout, period, threshold, bit);\n+\n+    // Early exit if the versions don't signal sensibly for the deployment\n+    if (!checker.Condition(ver_signal)) return;\n+    if (checker.Condition(ver_nosignal)) return;\n+    if (ver_nosignal < 0) return;\n+\n+    // TOP_BITS should ensure version will be positive\n+    assert(ver_signal > 0);\n+\n+    // Now that we have chosen time and versions, setup to mine blocks\n+    Blocks blocks(block_start_time, ver_signal, ver_nosignal);\n+\n+    /* Strategy:\n+     *  * we will mine a final period worth of blocks, with\n+     *    randomised signalling according to a mask\n+     *  * but before we mine those blocks, we will mine some\n+     *    randomised number of prior periods; with either all\n+     *    or no blocks in the period signalling\n+     *\n+     * We establish the mask first, then consume \"bools\" until\n+     * we run out of fuzz data to work out how many prior periods\n+     * there are and which ones will signal.\n+     */\n+\n+    // establish the mask\n+    uint32_t signalling_mask = fuzzed_data_provider.ConsumeIntegral<uint32_t>();\n+\n+    // mine prior periods\n+    while (fuzzed_data_provider.remaining_bytes() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#discussion_r595376481",
      "id" : 595376481,
      "in_reply_to_id" : 595114366,
      "line" : 207,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTM3NjQ4MQ==",
      "original_commit_id" : "e333affe3475ab3fd88daf514be72f06ede42a15",
      "original_line" : 207,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/test/fuzz/versionbits.cpp",
      "position" : 207,
      "pull_request_review_id" : 613515128,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21380",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-03-16T17:11:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/595376481",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "concept ACK ",
      "created_at" : "2021-03-16T20:25:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21380#issuecomment-800579714",
      "id" : 800579714,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/21380",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDgwMDU3OTcxNA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-03-16T20:25:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/800579714",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   }
]
