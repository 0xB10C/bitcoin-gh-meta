[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212404219"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212404219"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Should this be Ã¢ÂÂenvelopeÃ¢ÂÂ instead of Ã¢ÂÂenvelopÃ¢ÂÂ? If so, change applies throughout this PR and also the BIP.",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-08-23T18:03:45Z",
      "diff_hunk" : "@@ -746,43 +764,70 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes, bool& complete\n     nLastRecv = nTimeMicros / 1000000;\n     nRecvBytes += nBytes;\n     while (nBytes > 0) {\n-\n         // get current incomplete message, or create a new one\n-        if (vRecvMsg.empty() ||\n-            vRecvMsg.back().complete())\n-            vRecvMsg.push_back(CNetMessage(Params().MessageStart(), SER_NETWORK, INIT_PROTO_VERSION));\n-\n-        CNetMessage& msg = vRecvMsg.back();\n+        if (vRecvMsg.empty() || vRecvMsg.back()->complete()) {\n+            if (m_encryption_handler && m_encryption_handler->shouldCryptMsg()) {\n+                vRecvMsg.emplace_back(std::make_shared<NetCryptedMessageEnvelop>(m_encryption_handler, Params().MessageStart(), SER_NETWORK, INIT_PROTO_VERSION));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212404219",
      "id" : 212404219,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjQwNDIxOQ==",
      "original_commit_id" : "e654fd60d8955f74124f700a5d73baacf67301b6",
      "original_position" : 51,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 149030580,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-18T07:54:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212404219",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212405404"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212405404"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If IÃ¢ÂÂm reading the logic correct then this should be Ã¢ÂÂevery 10 seconds _or_ after 10kb of dataÃ¢ÂÂ?",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-08-23T18:07:22Z",
      "diff_hunk" : "@@ -477,6 +478,7 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-maxtipage=<n>\", strprintf(\"Maximum tip age in seconds to consider node in initial block download (default: %u)\", DEFAULT_MAX_TIP_AGE), true, OptionsCategory::DEBUG_TEST);\n     gArgs.AddArg(\"-maxtxfee=<amt>\", strprintf(\"Maximum total fees (in %s) to use in a single wallet transaction or raw transaction; setting this too low may abort large transactions (default: %s)\",\n         CURRENCY_UNIT, FormatMoney(DEFAULT_TRANSACTION_MAXFEE)), false, OptionsCategory::DEBUG_TEST);\n+    gArgs.AddArg(\"-netencryptionfastrekey\", \"Rekeys every 10 seconds and after 10kb of data\", true, OptionsCategory::DEBUG_TEST);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212405404",
      "id" : 212405404,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjQwNTQwNA==",
      "original_commit_id" : "e654fd60d8955f74124f700a5d73baacf67301b6",
      "original_position" : 12,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_review_id" : 149032015,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-18T07:54:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212405404",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212405909"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212405909"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Ã¢ÂÂtreatÃ¢ÂÂ",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-08-23T18:08:57Z",
      "diff_hunk" : "@@ -746,43 +764,70 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes, bool& complete\n     nLastRecv = nTimeMicros / 1000000;\n     nRecvBytes += nBytes;\n     while (nBytes > 0) {\n-\n         // get current incomplete message, or create a new one\n-        if (vRecvMsg.empty() ||\n-            vRecvMsg.back().complete())\n-            vRecvMsg.push_back(CNetMessage(Params().MessageStart(), SER_NETWORK, INIT_PROTO_VERSION));\n-\n-        CNetMessage& msg = vRecvMsg.back();\n+        if (vRecvMsg.empty() || vRecvMsg.back()->complete()) {\n+            if (m_encryption_handler && m_encryption_handler->shouldCryptMsg()) {\n+                vRecvMsg.emplace_back(std::make_shared<NetCryptedMessageEnvelop>(m_encryption_handler, Params().MessageStart(), SER_NETWORK, INIT_PROTO_VERSION));\n+            } else if (gArgs.GetBoolArg(\"-netencryption\", DEFAULT_ALLOW_NET_ENCRYPTION) && nRecvBytes == nBytes /* first message */) {\n+                // first bytes can be a network encryption handshake\n+                // use a NetMessageEncryptionHandshake with option to fallback to a standard NetMessage (if valid version message is detected)\n+                vRecvMsg.emplace_back(std::make_shared<NetMessageEncryptionHandshake>(Params().MessageStart(), SER_NETWORK, INIT_PROTO_VERSION));\n+            } else {\n+                vRecvMsg.emplace_back(std::make_shared<NetMessage>(Params().MessageStart(), SER_NETWORK, INIT_PROTO_VERSION));\n+            }\n+        }\n+        NetMessageBaseRef msg = vRecvMsg.back();\n \n         // absorb network data\n-        int handled;\n-        if (!msg.in_data)\n-            handled = msg.readHeader(pch, nBytes);\n-        else\n-            handled = msg.readData(pch, nBytes);\n+        int handled = msg->read(pch, nBytes);\n \n         if (handled < 0)\n             return false;\n \n-        if (msg.in_data && msg.hdr.nMessageSize > MAX_PROTOCOL_MESSAGE_LENGTH) {\n+        if (msg->getMessageSize() > MAX_PROTOCOL_MESSAGE_LENGTH) {\n             LogPrint(BCLog::NET, \"Oversized message from peer=%i, disconnecting\\n\", GetId());\n             return false;\n         }\n \n         pch += handled;\n         nBytes -= handled;\n \n-        if (msg.complete()) {\n+        if (msg->complete()) {\n+            msg->nTime = nTimeMicros;\n+            if (msg->m_type == NetMessageType::PLAINTEXT_ENCRYPTION_HANDSHAKE && !msg->verifyHeader()) {\n+                // message contains expected network magic and \"version\" message command\n+                // threat as version message",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212405909",
      "id" : 212405909,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjQwNTkwOQ==",
      "original_commit_id" : "e654fd60d8955f74124f700a5d73baacf67301b6",
      "original_position" : 87,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 149032670,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-18T07:54:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212405909",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212406669"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212406669"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Ã¢ÂÂthereforeÃ¢ÂÂ?",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-08-23T18:11:13Z",
      "diff_hunk" : "@@ -0,0 +1,375 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+int NetCryptedMessageEnvelop::read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->getAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->getAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->getLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 31));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 31);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->getAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->getTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->authenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+            if (m_rekey_flag) {\n+                // post decrypt rekey if rekey was requested\n+                m_encryption_handler->rekey(false);\n+            }\n+        }\n+        return copy_bytes;\n+    }\n+}\n+\n+int NetMessageEncryptionHandshake::read(const char* pch, unsigned int bytes)\n+{\n+    // copy data to temporary parsing buffer\n+    unsigned int remaining = 32 - m_data_pos;\n+    unsigned int copy_bytes = std::min(remaining, bytes);\n+    if (vRecv.size() < 32) {\n+        vRecv.resize(32);\n+    }\n+    memcpy(&vRecv[m_data_pos], pch, copy_bytes);\n+    m_data_pos += copy_bytes;\n+\n+    return copy_bytes;\n+}\n+\n+bool NetMessageEncryptionHandshake::verifyHeader() const\n+{\n+    CMessageHeader hdr(Params().MessageStart());\n+    CDataStream str = vRecv; //copy stream to keep function const\n+    try {\n+        str >> hdr;\n+    } catch (const std::exception&) {\n+        return false;\n+    }\n+    if (memcmp(hdr.pchMessageStart, Params().MessageStart(), CMessageHeader::MESSAGE_START_SIZE) == 0 || hdr.GetCommand() == NetMsgType::VERSION) {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+int NetCryptedMessage::read(const char* pch, unsigned int nBytes)\n+{\n+    // not supported\n+    return -1;\n+}\n+\n+bool NetCryptedMessage::decompose_from_stream(CDataStream& stream)\n+{\n+    // decompose a single massage from a multimessage envelop\n+    try {\n+        stream >> m_command_name;\n+        stream >> m_message_size;\n+    } catch (const std::exception&) {\n+        return false;\n+    }\n+    if (m_message_size > MAX_PROTOCOL_MESSAGE_LENGTH || m_message_size > stream.size()) {\n+        return false;\n+    }\n+\n+    // copy the extracted message to the internal message buffer\n+    if (m_message_size > 0) {\n+        assert(vRecv.size() == 0);\n+        vRecv.write(&stream.begin()[0], m_message_size);\n+\n+        // skip the message payload\n+        stream.ignore(m_message_size);\n+    }\n+    return true;\n+}\n+\n+bool BIP151Encryption::authenticatedAndDecrypt(CDataStream& data_in_out)\n+{\n+    // create a buffer for the decrypted payload\n+    std::vector<unsigned char> buf_dec;\n+    buf_dec.resize(data_in_out.size());\n+\n+    // keep the original payload size\n+    size_t vsize = data_in_out.size();\n+\n+    LOCK(cs);\n+    if (m_bytes_decrypted + vsize > ABORT_LIMIT_BYTES || GetTime() - m_time_last_rekey_send > ABORT_LIMIT_TIME ||\n+        (gArgs.GetBoolArg(\"-netencryptionfastrekey\", false) && m_bytes_decrypted + vsize > 12 * 1024)) {\n+        // don't further decrypt and therefor abort connection when counterparty failed to respect rekey limits",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212406669",
      "id" : 212406669,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjQwNjY2OQ==",
      "original_commit_id" : "e654fd60d8955f74124f700a5d73baacf67301b6",
      "original_position" : 156,
      "path" : "src/net_encryption.cpp",
      "position" : null,
      "pull_request_review_id" : 149033591,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-18T07:54:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212406669",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212407341"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212407341"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: Ã¢ÂÂhasÃ¢ÂÂ?",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-08-23T18:13:18Z",
      "diff_hunk" : "@@ -0,0 +1,124 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NET_MESSAGE_H\n+#define BITCOIN_NET_MESSAGE_H\n+\n+#include <hash.h>\n+#include <protocol.h>\n+#include <streams.h>\n+#include <uint256.h>\n+\n+/** Maximum length of incoming protocol messages (no message over 4 MB is currently acceptable). */\n+static const unsigned int MAX_PROTOCOL_MESSAGE_LENGTH = 4 * 1000 * 1000;\n+\n+enum class NetMessageType {\n+    PLAINTEXT,\n+    PLAINTEXT_ENCRYPTION_HANDSHAKE,\n+    BIP151_ENVELOP,\n+    BIP151_MSG\n+};\n+\n+// base class for format agnostic network messages\n+class NetMessageBase\n+{\n+public:\n+    CDataStream vRecv; // received message data\n+    int64_t nTime;     // time (in microseconds) of message receipt.\n+    NetMessageType m_type;\n+\n+    NetMessageBase(const CMessageHeader::MessageStartChars& pchMessageStartIn, int nTypeIn, int nVersionIn) : vRecv(nTypeIn, nVersionIn)\n+    {\n+        nTime = 0;\n+    }\n+\n+    virtual bool complete() const = 0;\n+    virtual uint32_t getMessageSize() const = 0;           //returns 0 when message hat not yet been parsed",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r212407341",
      "id" : 212407341,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxMjQwNzM0MQ==",
      "original_commit_id" : "e654fd60d8955f74124f700a5d73baacf67301b6",
      "original_position" : 37,
      "path" : "src/net_message.h",
      "position" : null,
      "pull_request_review_id" : 149034437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-18T07:54:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/212407341",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->Note to reviewers: This pull request conflicts with the following ones:\n\n* #14221 (wip: net: Implement poll by pstratem)\n* #14147 (net: Refactor ThreadSocketHandler by pstratem)\n* #14050 (Add chacha20/poly1305 and chacha20poly1305_AEAD from openssh by jonasschnelli)\n* #14047 (Add HKDF_HMAC256_L32 and method to negate a private key by jonasschnelli)\n* #14046 (net: Refactor message parsing (CNetMessage), adds flexibility by jonasschnelli)\n* #13766 (Prefer initialization to assignment in constructors. Prefer in-class initializers to member initializers in constructors for constant initializers. by practicalswift)\n* #13123 (net: Add Clang thread safety annotations for guarded variables in the networking code by practicalswift)\n* #12288 ([WIP][NET] Add NATPMP support. by annanay25)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-08-23T18:28:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-415521431",
      "id" : 415521431,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNTUyMTQzMQ==",
      "updated_at" : "2018-09-18T10:45:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/415521431",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Fixed @practicalswift points.",
      "created_at" : "2018-08-23T19:50:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-415549299",
      "id" : 415549299,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNTU0OTI5OQ==",
      "updated_at" : "2018-08-23T19:50:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/415549299",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Great work!\r\n\r\nAlthough optimized crypto is certainly out of scope, we do want to be mindful of making any protocol decisions that would preclude using them. :)",
      "created_at" : "2018-08-23T20:26:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-415559982",
      "id" : 415559982,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNTU1OTk4Mg==",
      "updated_at" : "2018-08-23T20:26:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/415559982",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Note to reviewers: please review...\r\n* #14046 Refactor message parsing (CNetMessage), adds flexibility \r\n* #14047 Add HKDF_HMAC256_L32 and method to negate a private key\r\n* #14049 Enable libsecp256k1 ecdh module, add ECDH function to CKey\r\n* #14050 Add chacha20/poly1305 and chacha20poly1305_AEAD from openssh\r\n... first (extracted commits from this PR)",
      "created_at" : "2018-08-24T09:22:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-415704147",
      "id" : 415704147,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNTcwNDE0Nw==",
      "updated_at" : "2018-08-24T15:13:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/415704147",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "What is the point of `NODE_ENCRYPTED`? Service bits shouldn't be used for mere protocol negotiation...",
      "created_at" : "2018-08-29T18:20:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-417054311",
      "id" : 417054311,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNzA1NDMxMQ==",
      "updated_at" : "2018-08-29T18:20:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/417054311",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> What is the point of NODE_ENCRYPTED? Service bits shouldn't be used for mere protocol negotiation...\r\n\r\nThis has now been discussed on IRC:\r\nhttps://botbot.me/freenode/bitcoin-core-dev/2018-08-29/?msg=103889728&page=3",
      "created_at" : "2018-08-29T19:11:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-417070832",
      "id" : 417070832,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNzA3MDgzMg==",
      "updated_at" : "2018-08-29T19:11:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/417070832",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214523047"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214523047"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Should be Ã¢ÂÂresetÃ¢ÂÂ?",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-01T21:07:03Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size exluding the MAC\n+\n+            // initially check the message\n+            try {\n+                vRecv >> m_command_name;\n+            } catch (const std::exception&) {\n+                return false;\n+            }\n+            // vRecv points now to the plaintext message payload (MAC is removed)\n+\n+            if (m_rekey_flag) {\n+                // post decrypt rekey if rekey was requested\n+                m_encryption_handler->Rekey(false);\n+            }\n+        }\n+        return copy_bytes;\n+    }\n+}\n+\n+int NetMessageEncryptionHandshake::Read(const char* pch, unsigned int bytes)\n+{\n+    // copy data to temporary parsing buffer\n+    unsigned int remaining = 32 - m_data_pos;\n+    unsigned int copy_bytes = std::min(remaining, bytes);\n+    if (vRecv.size() < 32) {\n+        vRecv.resize(32);\n+    }\n+    memcpy(&vRecv[m_data_pos], pch, copy_bytes);\n+    m_data_pos += copy_bytes;\n+\n+    return copy_bytes;\n+}\n+\n+bool NetMessageEncryptionHandshake::VerifyHeader() const\n+{\n+    CMessageHeader hdr(Params().MessageStart());\n+    CDataStream str = vRecv; //copy stream to keep function const\n+    try {\n+        str >> hdr;\n+    } catch (const std::exception&) {\n+        return false;\n+    }\n+    if (memcmp(hdr.pchMessageStart, Params().MessageStart(), CMessageHeader::MESSAGE_START_SIZE) == 0 || hdr.GetCommand() == NetMsgType::VERSION) {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool BIP151Encryption::AuthenticatedAndDecrypt(CDataStream& data_in_out)\n+{\n+    // create a buffer for the decrypted payload\n+    std::vector<unsigned char> buf_dec;\n+    buf_dec.resize(data_in_out.size());\n+\n+    // keep the original payload size\n+    size_t vsize = data_in_out.size();\n+\n+    LOCK(cs);\n+    if (m_bytes_decrypted + vsize > ABORT_LIMIT_BYTES || GetTime() - m_time_last_rekey_send > ABORT_LIMIT_TIME ||\n+        (gArgs.GetBoolArg(\"-netencryptionfastrekey\", false) && m_bytes_decrypted + vsize > 12 * 1024)) {\n+        // don't further decrypt and therefore abort connection when counterparty failed to respect rekey limits\n+        return false;\n+    }\n+    // authenticate and decrypt the message\n+    if (chacha20poly1305_crypt(&m_recv_aead_ctx, m_recv_seq_nr++, &buf_dec[0], (const uint8_t*)&data_in_out.data()[0],\n+            data_in_out.size() - TAG_LEN - AAD_LEN, AAD_LEN, 0) == -1) {\n+        memory_cleanse(data_in_out.data(), data_in_out.size());\n+        return false;\n+    }\n+\n+    // append chacha20 main payload size\n+    m_bytes_decrypted += data_in_out.size() - TAG_LEN - AAD_LEN;\n+\n+    data_in_out.clear();\n+    data_in_out.write((const char*)&buf_dec.begin()[AAD_LEN], vsize - TAG_LEN - AAD_LEN);\n+    return true;\n+}\n+\n+bool BIP151Encryption::EncryptAppendMAC(std::vector<unsigned char>& data_in_out)\n+{\n+    // first 3 bytes are the LE uint32 message length the most significant bit\n+    // indicates to the counterparty that the next message will be using the next\n+    // key (rekey) with resetted nonce",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214523047",
      "id" : 214523047,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDUyMzA0Nw==",
      "original_commit_id" : "93f64ad566b014f69f797e8911c5ff75bb257758",
      "original_position" : 163,
      "path" : "src/net_encryption.cpp",
      "position" : null,
      "pull_request_review_id" : 151603394,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-18T07:54:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214523047",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214523056"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214523056"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here: Ã¢ÂÂresetÃ¢ÂÂ?",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-01T21:07:17Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size exluding the MAC\n+\n+            // initially check the message\n+            try {\n+                vRecv >> m_command_name;\n+            } catch (const std::exception&) {\n+                return false;\n+            }\n+            // vRecv points now to the plaintext message payload (MAC is removed)\n+\n+            if (m_rekey_flag) {\n+                // post decrypt rekey if rekey was requested\n+                m_encryption_handler->Rekey(false);\n+            }\n+        }\n+        return copy_bytes;\n+    }\n+}\n+\n+int NetMessageEncryptionHandshake::Read(const char* pch, unsigned int bytes)\n+{\n+    // copy data to temporary parsing buffer\n+    unsigned int remaining = 32 - m_data_pos;\n+    unsigned int copy_bytes = std::min(remaining, bytes);\n+    if (vRecv.size() < 32) {\n+        vRecv.resize(32);\n+    }\n+    memcpy(&vRecv[m_data_pos], pch, copy_bytes);\n+    m_data_pos += copy_bytes;\n+\n+    return copy_bytes;\n+}\n+\n+bool NetMessageEncryptionHandshake::VerifyHeader() const\n+{\n+    CMessageHeader hdr(Params().MessageStart());\n+    CDataStream str = vRecv; //copy stream to keep function const\n+    try {\n+        str >> hdr;\n+    } catch (const std::exception&) {\n+        return false;\n+    }\n+    if (memcmp(hdr.pchMessageStart, Params().MessageStart(), CMessageHeader::MESSAGE_START_SIZE) == 0 || hdr.GetCommand() == NetMsgType::VERSION) {\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool BIP151Encryption::AuthenticatedAndDecrypt(CDataStream& data_in_out)\n+{\n+    // create a buffer for the decrypted payload\n+    std::vector<unsigned char> buf_dec;\n+    buf_dec.resize(data_in_out.size());\n+\n+    // keep the original payload size\n+    size_t vsize = data_in_out.size();\n+\n+    LOCK(cs);\n+    if (m_bytes_decrypted + vsize > ABORT_LIMIT_BYTES || GetTime() - m_time_last_rekey_send > ABORT_LIMIT_TIME ||\n+        (gArgs.GetBoolArg(\"-netencryptionfastrekey\", false) && m_bytes_decrypted + vsize > 12 * 1024)) {\n+        // don't further decrypt and therefore abort connection when counterparty failed to respect rekey limits\n+        return false;\n+    }\n+    // authenticate and decrypt the message\n+    if (chacha20poly1305_crypt(&m_recv_aead_ctx, m_recv_seq_nr++, &buf_dec[0], (const uint8_t*)&data_in_out.data()[0],\n+            data_in_out.size() - TAG_LEN - AAD_LEN, AAD_LEN, 0) == -1) {\n+        memory_cleanse(data_in_out.data(), data_in_out.size());\n+        return false;\n+    }\n+\n+    // append chacha20 main payload size\n+    m_bytes_decrypted += data_in_out.size() - TAG_LEN - AAD_LEN;\n+\n+    data_in_out.clear();\n+    data_in_out.write((const char*)&buf_dec.begin()[AAD_LEN], vsize - TAG_LEN - AAD_LEN);\n+    return true;\n+}\n+\n+bool BIP151Encryption::EncryptAppendMAC(std::vector<unsigned char>& data_in_out)\n+{\n+    // first 3 bytes are the LE uint32 message length the most significant bit\n+    // indicates to the counterparty that the next message will be using the next\n+    // key (rekey) with resetted nonce\n+    if (data_in_out[2] & (1u << 7)) {\n+        // length is only allowed up to 2^23\n+        return false;\n+    }\n+    bool should_rekey = ShouldRekeySend();\n+    if (should_rekey) {\n+        // set the rekey flag and signal that the next message will be encrypted\n+        // with the next key (and resetted sequence)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214523056",
      "id" : 214523056,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDUyMzA1Ng==",
      "original_commit_id" : "93f64ad566b014f69f797e8911c5ff75bb257758",
      "original_position" : 171,
      "path" : "src/net_encryption.cpp",
      "position" : null,
      "pull_request_review_id" : 151603405,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-18T07:54:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214523056",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214532174"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214532174"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Typo found by `codespell`: exluding",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-02T08:00:35Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size exluding the MAC",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214532174",
      "id" : 214532174,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDUzMjE3NA==",
      "original_commit_id" : "9c2fd588ebd29478c72b3add6acd549d5742e870",
      "original_position" : 81,
      "path" : "src/net_encryption.cpp",
      "position" : null,
      "pull_request_review_id" : 151612586,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-18T07:54:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214532174",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Lightly tested on macOS. I was able to establish an encrypted connection and sync headers to afresh node. It didn't (immediately) sync blocks though, but maybe that's normal behavior when you only have 1 peer?\r\n\r\nQT Peers Window doesn't show the new service flag next to Services, and it also doesn't show the encryption info, but that can be done in another PR. \r\n\r\nI would move the TODO `add option to -connect=` to a different PR. I'd also like a way to only accept inbound encrypted peers, and only connect to outbound encrypted peers.\r\n\r\nCan you add more functional tests, e.g. to check that it rotates the key after N bytes? \r\n\r\nI would be nice to have a fork of @sipa's [DNS seeder](https://github.com/sipa/bitcoin-seeder) that finds these nodes on testnet. I'd be happy to switch mine over.",
      "created_at" : "2018-09-02T08:40:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-417914339",
      "id" : 417914339,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNzkxNDMzOQ==",
      "updated_at" : "2018-09-02T10:12:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/417914339",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214533260"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214533260"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed those spelling issues.",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-02T08:48:09Z",
      "diff_hunk" : "@@ -0,0 +1,358 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include <config/bitcoin-config.h>\n+#endif\n+\n+#include <net_encryption.h>\n+\n+#include <chainparams.h>\n+#include <crypto/hkdf_sha256_32.h>\n+#include <net_message.h>\n+#include <util.h>\n+\n+#include <util.h>\n+\n+int NetCryptedMessage::Read(const char* pch, unsigned bytes)\n+{\n+    if (!m_in_data) {\n+        // copy data to temporary parsing buffer\n+        unsigned int remaining = m_encryption_handler->GetAADLen() - m_hdr_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        memcpy(&vRecv[m_hdr_pos], pch, copy_bytes);\n+        m_hdr_pos += copy_bytes;\n+\n+        // if AAD incomplete, exit\n+        if (m_hdr_pos < m_encryption_handler->GetAADLen()) {\n+            return copy_bytes;\n+        }\n+\n+        // decrypt the length from the AAD\n+        if (!m_encryption_handler->GetLength(vRecv, m_message_size)) {\n+            return -1;\n+        }\n+\n+        // check and unset rekey bit\n+        // the counterparty can signal a post-this-message rekey by setting the\n+        // most significant bit in the (unencrypted) length\n+        m_rekey_flag = (m_message_size & (1U << 23));\n+        if (m_rekey_flag) {\n+            LogPrint(BCLog::NET, \"Rekey flag detected %ld\\n\", m_message_size);\n+            m_message_size &= ~(1U << 23);\n+        }\n+\n+        // reject messages larger than MAX_SIZE\n+        if (m_message_size > MAX_SIZE) {\n+            LogPrint(BCLog::NET, \"Max message size exceeded %ld\\n\", m_message_size);\n+            return -1;\n+        }\n+\n+        // switch state to reading message data\n+        m_in_data = true;\n+\n+        return copy_bytes;\n+    } else {\n+        // copy the message payload plus the MAC tag\n+        const unsigned int AAD_LEN = m_encryption_handler->GetAADLen();\n+        const unsigned int TAG_LEN = m_encryption_handler->GetTagLen();\n+        unsigned int remaining = m_message_size + TAG_LEN - m_data_pos;\n+        unsigned int copy_bytes = std::min(remaining, bytes);\n+\n+        // extend buffer, respect previous copied AAD part\n+        if (vRecv.size() < AAD_LEN + m_data_pos + copy_bytes) {\n+            // Allocate up to 256 KiB ahead, but never more than the total message size (incl. AAD & TAG).\n+            vRecv.resize(std::min(AAD_LEN + m_message_size + TAG_LEN, AAD_LEN + m_data_pos + copy_bytes + 256 * 1024 + TAG_LEN));\n+        }\n+\n+        memcpy(&vRecv[AAD_LEN + m_data_pos], pch, copy_bytes);\n+        m_data_pos += copy_bytes;\n+\n+        if (Complete()) {\n+            // authenticate and decrypt if the message is complete\n+            if (!m_encryption_handler->AuthenticatedAndDecrypt(vRecv)) {\n+                LogPrint(BCLog::NET, \"Authentication or decryption failed\\n\");\n+                return false;\n+            }\n+\n+            // vRecv holds now the plaintext message excluding the AAD and MAC\n+            // m_message_size holds the packet size exluding the MAC",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214533260",
      "id" : 214533260,
      "in_reply_to_id" : 214532174,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDUzMzI2MA==",
      "original_commit_id" : "9c2fd588ebd29478c72b3add6acd549d5742e870",
      "original_position" : 81,
      "path" : "src/net_encryption.cpp",
      "position" : null,
      "pull_request_review_id" : 151613701,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-18T07:54:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214533260",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214536556"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214536556"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You're using the term \"stealth encryption\" in various places, but this term isn't used in the BIP.",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-02T11:03:40Z",
      "diff_hunk" : "@@ -2820,40 +2788,124 @@ bool CConnman::NodeFullyConnected(const CNode* pnode)\n void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n     size_t nMessageSize = msg.data.size();\n-    size_t nTotalSize = nMessageSize + CMessageHeader::HEADER_SIZE;\n-    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n+    size_t nTotalSize = nMessageSize;\n+    size_t serialized_command_size = ::GetSerializeSize(msg.command, SER_NETWORK, PROTOCOL_VERSION);\n+    uint8_t cmd_short_id = 0;\n+    bool should_crypt = pnode->m_encryption_handler && pnode->m_encryption_handler->ShouldCryptMsg();\n+    if (should_crypt) {\n+        // the crypted protocol supports short command IDs\n+        cmd_short_id = GetShortCommandIDFromCommand(msg.command);\n+        if (cmd_short_id != 0) {\n+            // if no short ID is available, use a size between 1-12 (always one byte)\n+            assert(msg.command.size() <= 12);\n+            serialized_command_size = 1;\n+        }\n+\n+        // add encrypted header size (AAD + MAC TAG + Varlen-Command + inner-message-size)\n+        nTotalSize += pnode->m_encryption_handler->GetAADLen() + pnode->m_encryption_handler->GetTagLen() + serialized_command_size;\n+    } else {\n+        nTotalSize += CMessageHeader::HEADER_SIZE;\n+    }\n+    LogPrint(BCLog::NET, \"sending%s %s (%d bytes) peer=%d\\n\", should_crypt ? \" encrypted\" : \"\", SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n \n-    std::vector<unsigned char> serializedHeader;\n-    serializedHeader.reserve(CMessageHeader::HEADER_SIZE);\n-    uint256 hash = Hash(msg.data.data(), msg.data.data() + nMessageSize);\n-    CMessageHeader hdr(Params().MessageStart(), msg.command.c_str(), nMessageSize);\n-    memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n+    size_t nBytesSent = 0;\n \n-    CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, serializedHeader, 0, hdr};\n+    if (should_crypt) {\n+        std::vector<unsigned char> serialized_envelope;\n+        uint32_t envelope_payload_length = serialized_command_size + nMessageSize;\n+        serialized_envelope.reserve(3 /* <- packet length */ + serialized_command_size + nMessageSize + pnode->m_encryption_handler->GetTagLen());\n \n-    size_t nBytesSent = 0;\n-    {\n-        LOCK(pnode->cs_vSend);\n-        bool optimisticSend(pnode->vSendMsg.empty());\n+        // convert the host 32 bit size into a LE 24bit\n+        envelope_payload_length = htole32(envelope_payload_length);\n+        uint8_t int24[3];\n+        memcpy(int24, &envelope_payload_length, 3);\n \n-        //log total amount of bytes per command\n-        pnode->mapSendBytesPerMsgCmd[msg.command] += nTotalSize;\n-        pnode->nSendSize += nTotalSize;\n+        CVectorWriter vector_writer(SER_NETWORK, INIT_PROTO_VERSION, serialized_envelope, 0, int24[0], int24[1], int24[2]);\n+        if (cmd_short_id) {\n+            // append the single byte short ID...\n+            vector_writer << cmd_short_id;\n+        } else {\n+            // or the ASCII command string\n+            vector_writer << msg.command;\n+        }\n+        //append the message itself (if there is a message)\n+        if (nMessageSize) serialized_envelope.insert(serialized_envelope.end(), msg.data.begin(), msg.data.end());\n \n-        if (pnode->nSendSize > nSendBufferMaxSize)\n-            pnode->fPauseSend = true;\n-        pnode->vSendMsg.push_back(std::move(serializedHeader));\n-        if (nMessageSize)\n-            pnode->vSendMsg.push_back(std::move(msg.data));\n+        //form the AAED (encipher and append tag)\n+        if (!pnode->m_encryption_handler->EncryptAppendMAC(serialized_envelope)) {\n+            LogPrintf(\"Encryption failed, peer=%d\\n\", pnode->GetId());\n+            pnode->fDisconnect = true;\n+            return;\n+        }\n+        {\n+            LOCK(pnode->cs_vSend);\n+            bool optimisticSend(pnode->vSendMsg.empty());\n \n-        // If write queue empty, attempt \"optimistic write\"\n-        if (optimisticSend == true)\n-            nBytesSent = SocketSendData(pnode);\n+            //log total amount of bytes per command\n+            pnode->mapSendBytesPerMsgCmd[msg.command] += nTotalSize;\n+            pnode->nSendSize += nTotalSize;\n+\n+            if (pnode->nSendSize > nSendBufferMaxSize)\n+                pnode->fPauseSend = true;\n+            pnode->vSendMsg.push_back(std::move(serialized_envelope));\n+\n+            // If write queue empty, attempt \"optimistic write\"\n+            if (optimisticSend == true)\n+                nBytesSent = SocketSendData(pnode);\n+        }\n+    } else {\n+        std::vector<unsigned char> serializedHeader;\n+        serializedHeader.reserve(CMessageHeader::HEADER_SIZE);\n+        uint256 hash = Hash(msg.data.data(), msg.data.data() + nMessageSize);\n+        CMessageHeader hdr(Params().MessageStart(), msg.command.c_str(), nMessageSize);\n+        memcpy(hdr.pchChecksum, hash.begin(), CMessageHeader::CHECKSUM_SIZE);\n+\n+        CVectorWriter{SER_NETWORK, INIT_PROTO_VERSION, serializedHeader, 0, hdr};\n+        {\n+            LOCK(pnode->cs_vSend);\n+            bool optimisticSend(pnode->vSendMsg.empty());\n+\n+            //log total amount of bytes per command\n+            pnode->mapSendBytesPerMsgCmd[msg.command] += nTotalSize;\n+            pnode->nSendSize += nTotalSize;\n+\n+            if (pnode->nSendSize > nSendBufferMaxSize)\n+                pnode->fPauseSend = true;\n+            pnode->vSendMsg.push_back(std::move(serializedHeader));\n+            if (nMessageSize)\n+                pnode->vSendMsg.push_back(std::move(msg.data));\n+\n+            // If write queue empty, attempt \"optimistic write\"\n+            if (optimisticSend == true)\n+                nBytesSent = SocketSendData(pnode);\n+        }\n     }\n     if (nBytesSent)\n         RecordBytesSent(nBytesSent);\n }\n \n+void CConnman::SendStealthEncryptionHandshakeData(CNode* pnode)\n+{\n+    // initialize encryption, generate ephemeral key\n+    assert(pnode->m_encryption_handler == nullptr);\n+    pnode->m_encryption_handler = std::make_shared<BIP151Encryption>();\n+\n+    // get encryption handshake data\n+    std::vector<unsigned char> handshake_data;\n+    pnode->m_encryption_handler->GetHandshakeRequestData(handshake_data);\n+\n+    // push handshake data\n+    LogPrint(BCLog::NET, \"Send stealth encryption handshake payload of %d bytes, peer=%d\\n\", handshake_data.size(), pnode->GetId());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214536556",
      "id" : 214536556,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDUzNjU1Ng==",
      "original_commit_id" : "d98eedb3f8765e1909c58da637e187eb872c708d",
      "original_position" : 360,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 151616903,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-18T07:54:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214536556",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214536621"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214536621"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\"does accept\"? Maybe change to \"NODE_ENCRYPTED: node accepts encrypted communication, see BIP151\"?",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-02T11:06:35Z",
      "diff_hunk" : "@@ -268,6 +268,9 @@ enum ServiceFlags : uint64_t {\n     // serving the last 288 (2 day) blocks\n     // See BIP159 for details on how this is implemented.\n     NODE_NETWORK_LIMITED = (1 << 10),\n+    // NODE_ENCRYPTED means that the node does accept encrypted communication after BIP151",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r214536621",
      "id" : 214536621,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDUzNjYyMQ==",
      "original_commit_id" : "0971380cca98d80724c0fd6707e3ee571362d8cb",
      "original_position" : 4,
      "path" : "src/protocol.h",
      "position" : null,
      "pull_request_review_id" : 151616979,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-18T07:54:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214536621",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I removed the term \"stealth encryption\" from the source code (plus code comments). Also fixed the protocol.h `NODE_ENCRYPTED` comment.",
      "created_at" : "2018-09-03T11:23:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-418086026",
      "id" : 418086026,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxODA4NjAyNg==",
      "updated_at" : "2018-09-03T11:23:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/418086026",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r215158004"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215158004"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`m_inbound` is not initialized in the constructor?",
      "commit_id" : "6e6f8bc3db39d3510f8e73ddd8dd5a42a1260977",
      "created_at" : "2018-09-05T07:14:46Z",
      "diff_hunk" : "@@ -0,0 +1,206 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NET_ENCRYPTION_H\n+#define BITCOIN_NET_ENCRYPTION_H\n+\n+#include <atomic>\n+#include <memory>\n+\n+#include <crypto/chachapoly_aead.h>\n+#include <key.h>\n+#include <net_message.h>\n+#include <streams.h>\n+#include <sync.h>\n+#include <uint256.h>\n+\n+\n+class EncryptionHandlerInterface\n+{\n+public:\n+    virtual ~EncryptionHandlerInterface() {}\n+\n+    virtual bool GetHandshakeRequestData(std::vector<unsigned char>& handshake_data) = 0;\n+    virtual bool ProcessHandshakeRequestData(const std::vector<unsigned char>& handshake_data) = 0;\n+\n+    virtual bool GetLength(CDataStream& data_in, uint32_t& len_out) = 0;\n+    virtual bool EncryptAppendMAC(std::vector<unsigned char>& data_in_out) = 0;\n+    virtual bool AuthenticatedAndDecrypt(CDataStream& data_in_out) = 0;\n+    virtual bool ShouldCryptMsg() = 0;\n+\n+    virtual unsigned int GetTagLen() const = 0;\n+    virtual unsigned int GetAADLen() const = 0;\n+    virtual void EnableEncryption(bool inbound) = 0;\n+    virtual uint256 GetSessionID() = 0;\n+    virtual bool Rekey(bool send_channel) = 0;\n+};\n+\n+class BIP151Encryption : public EncryptionHandlerInterface\n+{\n+private:\n+    static constexpr unsigned int TAG_LEN = 16; /* poly1305 128bit MAC tag */\n+    static constexpr unsigned int AAD_LEN = 3;  /* 24 bit payload length */\n+\n+    // ChaCha20 must never reuse a {key, nonce} for encryption nor may it be\n+    // used to encrypt more than 2^70 bytes under the same {key, nonce}\n+    // Re-key after 1GB (RFC4253 / SSH recommendation) or after 1h\n+    static constexpr unsigned int REKEY_LIMIT_BYTES = (1024 * 1024 * 1024);\n+    static constexpr unsigned int REKEY_LIMIT_TIME = 3600;                     /* rekey after 1h */\n+    static constexpr unsigned int ABORT_LIMIT_BYTES = REKEY_LIMIT_BYTES * 1.1; // abort after ~10% tolerance buffer\n+    static constexpr unsigned int ABORT_LIMIT_TIME = REKEY_LIMIT_BYTES * 1.1;  // abort after ~10% tolerance buffer\n+    static constexpr unsigned int MIN_REKEY_TIME = 10;                         // minimal rekey time to avoid DOS\n+\n+    CKey m_ecdh_key;\n+    CPrivKey m_raw_ecdh_secret;\n+    CPrivKey m_k1_encryption_keypack; // key1A & key1B (AAD & payload key)\n+    CPrivKey m_k2_encryption_keypack; // key2A & key2B (AAD & payload key)\n+    uint256 m_session_id;\n+    bool m_inbound;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#discussion_r215158004",
      "id" : 215158004,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTE1ODAwNA==",
      "original_commit_id" : "d98eedb3f8765e1909c58da637e187eb872c708d",
      "original_position" : 59,
      "path" : "src/net_encryption.h",
      "position" : 59,
      "pull_request_review_id" : 152360948,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14032",
      "updated_at" : "2018-09-18T07:54:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215158004",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-09-05T20:13:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-418865816",
      "id" : 418865816,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxODg2NTgxNg==",
      "updated_at" : "2018-09-05T20:13:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/418865816",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased.",
      "created_at" : "2018-09-18T07:54:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14032#issuecomment-422293012",
      "id" : 422293012,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14032",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyMjI5MzAxMg==",
      "updated_at" : "2018-09-18T07:54:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/422293012",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   }
]
