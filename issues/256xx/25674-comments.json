[
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK and code looks good on first read.\r\n\r\n```\r\ntest/rbf_tests.cpp:47:14: error: calling function 'addUnchecked' requires holding mutex 'pool.cs' exclusively [-Werror,-Wthread-safety-analysis]\r\n        pool.addUnchecked(entry.FromTx(next_tx));\r\n             ^\r\ntest/rbf_tests.cpp:47:14: error: calling function 'addUnchecked' requires holding mutex 'cs_main' exclusively [-Werror,-Wthread-safety-analysis]\r\n```\r\n ",
      "created_at" : "2022-07-22T11:40:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#issuecomment-1192485046",
      "id" : 1192485046,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25674",
      "node_id" : "IC_kwDOABII585HE-C2",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1192485046/reactions"
      },
      "updated_at" : "2022-07-22T11:40:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1192485046",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927846036"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927846036"
         }
      },
      "author_association" : "MEMBER",
      "body" : "should note what this is doing ahead of time, or do it JIT before usage",
      "commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "created_at" : "2022-07-22T17:08:38Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927846036",
      "id" : 927846036,
      "line" : 88,
      "node_id" : "PRRC_kwDOABII5843Tc6U",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 88,
      "pull_request_review_id" : 1048185967,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927846036/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-22T18:42:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927846036",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927887590"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927887590"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\r\n    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\r\n```\r\nrules out the case where tx2 has no witness data(same wtxid) but some other bug.,.",
      "commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "created_at" : "2022-07-22T18:10:34Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927887590",
      "id" : 927887590,
      "line" : 135,
      "node_id" : "PRRC_kwDOABII5843TnDm",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 135,
      "original_position" : 135,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 135,
      "pull_request_review_id" : 1048185967,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927887590/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-22T18:42:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927887590",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927890596"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927890596"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n    const auto higher_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE * 2};\r\n```\r\nin case the incremental rate ever changes out from underneath the test",
      "commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "created_at" : "2022-07-22T18:15:13Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2, 1)};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927890596",
      "id" : 927890596,
      "line" : 144,
      "node_id" : "PRRC_kwDOABII5843Tnyk",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 144,
      "original_position" : 144,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 144,
      "pull_request_review_id" : 1048185967,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927890596/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-22T18:42:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927890596",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927895019"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927895019"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not really a part of this test, but I find the name `relay_fee` and the header description very misleading.\r\n\r\n```\r\n* @param[in]   relay_fee           The node's minimum feerate for transaction relay.\r\n```\r\n\r\nThis is whatever ::incrementalRelayFee is during runtime, which is explicitly not that? i.e. mempool minfee could be much higher, yes?",
      "commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "created_at" : "2022-07-22T18:22:26Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2, 1)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927895019",
      "id" : 927895019,
      "line" : 149,
      "node_id" : "PRRC_kwDOABII5843To3r",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 149,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 149,
      "pull_request_review_id" : 1048185967,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927895019/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-22T18:42:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927895019",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927900263"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927900263"
         }
      },
      "author_association" : "MEMBER",
      "body" : "QoL improvement for future readers/editors would be accumulating these constants",
      "commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "created_at" : "2022-07-22T18:30:34Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2, 1)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r927900263",
      "id" : 927900263,
      "line" : 175,
      "node_id" : "PRRC_kwDOABII5843TqJn",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 175,
      "original_position" : 175,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 175,
      "pull_request_review_id" : 1048185967,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927900263/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-22T18:42:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/927900263",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#25038](https://github.com/bitcoin/bitcoin/pull/25038) (policy: nVersion=3 and Package RBF by glozow)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2022-07-23T01:14:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#issuecomment-1193029730",
      "id" : 1193029730,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25674",
      "node_id" : "IC_kwDOABII585HHDBi",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1193029730/reactions"
      },
      "updated_at" : "2022-07-23T01:14:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1193029730",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928564065"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928564065"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah looking back I should have named it `incremental_relay_feerate`.\r\n\r\nThis should always be called with the incremental relay feerate. The reason it's parameterizable instead of having the function use `::incrementalRelayFee` is to avoid using globals within this module (see https://github.com/bitcoin/bitcoin/pull/22675#discussion_r702737511).",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T07:44:15Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2, 1)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928564065",
      "id" : 928564065,
      "in_reply_to_id" : 927895019,
      "line" : 152,
      "node_id" : "PRRC_kwDOABII5843WMNh",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 152,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 152,
      "pull_request_review_id" : 1048999401,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928564065/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T07:50:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928564065",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928568171"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568171"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T07:49:02Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928568171",
      "id" : 928568171,
      "in_reply_to_id" : 927887590,
      "line" : 137,
      "node_id" : "PRRC_kwDOABII5843WNNr",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 137,
      "original_position" : 135,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 137,
      "pull_request_review_id" : 1049005234,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568171/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T07:49:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568171",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928568272"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568272"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T07:49:09Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2, 1)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928568272",
      "id" : 928568272,
      "in_reply_to_id" : 927900263,
      "line" : 179,
      "node_id" : "PRRC_kwDOABII5843WNPQ",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 179,
      "original_position" : 175,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 179,
      "pull_request_review_id" : 1049005234,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568272/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T07:49:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568272",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928568622"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568622"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Added comment, hopefully clearer now",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T07:49:32Z",
      "diff_hunk" : "@@ -0,0 +1,211 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928568622",
      "id" : 928568622,
      "in_reply_to_id" : 927846036,
      "line" : null,
      "node_id" : "PRRC_kwDOABII5843WNUu",
      "original_commit_id" : "645c593a6027e7939c00d70f185ccbd0f381b7b5",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 1049005234,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568622/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T07:49:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928568622",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928865773"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928865773"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think you can test the boundary value just under `CFeeRate(entry1->GetModifiedFee() - 1, entry1->GetTxSize())`. In case of accidental refactoring of `PaysMoreThanConflitcts` and the `<=` is dropped to `=` it should catch it.  ",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T13:09:53Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928865773",
      "id" : 928865773,
      "line" : 124,
      "node_id" : "PRRC_kwDOABII5843XV3t",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 124,
      "original_position" : 124,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 124,
      "pull_request_review_id" : 1049441415,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928865773/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T15:10:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928865773",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928905282"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928905282"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm wondering what you're aiming to demonstrate with this test ? If you would like to show that a replacement candidate with a higher ancestor feerate won't replace conflicts with higher individual feerate, I believe the replacement topology should have a parent with a higher feerate, namely here with `entry8` ?",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T13:47:16Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928905282",
      "id" : 928905282,
      "line" : 131,
      "node_id" : "PRRC_kwDOABII5843XfhC",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 131,
      "original_position" : 131,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 131,
      "pull_request_review_id" : 1049441415,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928905282/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T15:10:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928905282",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "reACK https://github.com/bitcoin/bitcoin/pull/25674/commits/433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T14:19:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#issuecomment-1194112240",
      "id" : 1194112240,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25674",
      "node_id" : "IC_kwDOABII585HLLTw",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1194112240/reactions"
      },
      "updated_at" : "2022-07-25T14:19:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1194112240",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928954333"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928954333"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think in practice `entry1` should be part of the replacement transaction's ancestors so this topology should fail in a normal evaluation in `PreChecks` ? I'm correct can be nice to document.",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T14:30:38Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928954333",
      "id" : 928954333,
      "line" : 143,
      "node_id" : "PRRC_kwDOABII5843Xrfd",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 143,
      "original_position" : 143,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 143,
      "pull_request_review_id" : 1049441415,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928954333/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T15:10:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928954333",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928973898"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928973898"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think here you can the variant where the `additional_fees` are so high, even with a big transaction that it can succeed `PaysForRBF`, to verify that huge size in itself isn't a source of error ?",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T14:47:57Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928973898",
      "id" : 928973898,
      "line" : 162,
      "node_id" : "PRRC_kwDOABII5843XwRK",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 162,
      "original_position" : 162,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 162,
      "pull_request_review_id" : 1049441415,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928973898/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T15:10:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928973898",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928995580"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928995580"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Bikeshedding of the day. This function name could actually reflect the fact that BIP125 is enforced here for codebase clarity, something like `FetchConflictingEntriesAndCheckMaxReplacement` ? (can be in other commit/PR).",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T15:07:31Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    auto conflicts_size = all_conflicts.size();\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx4, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx6, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx7, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), 100);\n+    all_conflicts.clear();\n+\n+    // Exceeds maximum number of conflicts.\n+    add_descendants(tx8, pool, 1);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928995580",
      "id" : 928995580,
      "line" : 206,
      "node_id" : "PRRC_kwDOABII5843X1j8",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 206,
      "original_position" : 206,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 206,
      "pull_request_review_id" : 1049441415,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928995580/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T15:10:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928995580",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928996334"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928996334"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If you're bored, I think there is `IsRBFOptIn` remaining in `rbf.cpp` deserving unit test coverage.",
      "commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "created_at" : "2022-07-25T15:08:08Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    auto conflicts_size = all_conflicts.size();\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx4, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx6, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx7, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), 100);\n+    all_conflicts.clear();\n+\n+    // Exceeds maximum number of conflicts.\n+    add_descendants(tx8, pool, 1);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts).has_value());\n+\n+    // Tests for HasNoNewUnconfirmed\n+    CTransactionRef spends_unconfirmed = make_tx({36 * CENT}, {tx1});\n+    for (const auto& input : spends_unconfirmed->vin) {\n+        // Spends unconfirmed inputs.\n+        BOOST_CHECK(pool.exists(GenTxid::Txid(input.prevout.hash)));\n+    }\n+    BOOST_CHECK(HasNoNewUnconfirmed(/*tx=*/ *spends_unconfirmed.get(),\n+                                    /*pool=*/ pool,\n+                                    /*iters_conflicting=*/ all_entries) == std::nullopt);\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_unconfirmed.get(), pool, {entry2}) == std::nullopt);\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_unconfirmed.get(), pool, empty_set).has_value());\n+\n+    CTransactionRef spends_new_unconfirmed = make_tx({36 * CENT}, {tx1, tx8});\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_new_unconfirmed.get(), pool, {entry2}).has_value());\n+    BOOST_CHECK(HasNoNewUnconfirmed(*spends_new_unconfirmed.get(), pool, all_entries).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r928996334",
      "id" : 928996334,
      "line" : 222,
      "node_id" : "PRRC_kwDOABII5843X1vu",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 222,
      "original_position" : 222,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 222,
      "pull_request_review_id" : 1049441415,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928996334/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-25T15:10:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/928996334",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929750073"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929750073"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Tests pass even if the check for mempool existence in `HasNoNewUnconfirmed`Â removed:\r\n```diff\r\ndiff --git a/src/policy/rbf.cpp b/src/policy/rbf.cpp\r\nindex e25f5c7c5b..f1d8301ab6 100644\r\n--- a/src/policy/rbf.cpp\r\n+++ b/src/policy/rbf.cpp\r\n@@ -106,10 +106,10 @@ std::optional<std::string> HasNoNewUnconfirmed(const CTransaction& tx,\r\n         if (!parents_of_conflicts.count(tx.vin[j].prevout.hash)) {\r\n             // Rather than check the UTXO set - potentially expensive - it's cheaper to just check\r\n             // if the new input refers to a tx that's in the mempool.\r\n-            if (pool.exists(GenTxid::Txid(tx.vin[j].prevout.hash))) {\r\n+            //if (pool.exists(GenTxid::Txid(tx.vin[j].prevout.hash))) {\r\n                 return strprintf(\"replacement %s adds unconfirmed input, idx %d\",\r\n                                  tx.GetHash().ToString(), j);\r\n-            }\r\n+            //}\r\n         }\r\n     }\r\n     return std::nullopt;\r\n```",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T09:40:22Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    auto conflicts_size = all_conflicts.size();\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx4, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx6, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx7, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), 100);\n+    all_conflicts.clear();\n+\n+    // Exceeds maximum number of conflicts.\n+    add_descendants(tx8, pool, 1);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts).has_value());\n+\n+    // Tests for HasNoNewUnconfirmed",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929750073",
      "id" : 929750073,
      "line" : 211,
      "node_id" : "PRRC_kwDOABII5843atw5",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 211,
      "original_position" : 208,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 211,
      "pull_request_review_id" : 1050677147,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929750073/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:10:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929750073",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929770835"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929770835"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The opposite, actually. We're showing that, if individual feerate is the same, the original is preferred even though it has a lower ancestor feerate. I don't think a high-feerate parent is particularly interesting, since they'd be mined without the child (which is why we usually use min(ancestor, individual) feerate).\r\n\r\nAlso note that entry8 doesn't have any parents.",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:01:24Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929770835",
      "id" : 929770835,
      "in_reply_to_id" : 928905282,
      "line" : 133,
      "node_id" : "PRRC_kwDOABII5843ay1T",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 133,
      "original_position" : 131,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 133,
      "pull_request_review_id" : 1050705894,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929770835/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:01:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929770835",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929772631"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929772631"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Changing the check in `PaysMoreThanConflict` to anything else than `<=` (ie `<`, `>`, `>=`, `==`) would fail the test already.\r\n\r\nChanging to `=` would not compile.",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:03:18Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929772631",
      "id" : 929772631,
      "in_reply_to_id" : 928865773,
      "line" : 124,
      "node_id" : "PRRC_kwDOABII5843azRX",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 124,
      "original_position" : 124,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 124,
      "pull_request_review_id" : 1050677147,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929772631/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:10:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929772631",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929776616"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929776616"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Antoine: It's precisely what's being tested the 2 lines just above?",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:07:41Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929776616",
      "id" : 929776616,
      "in_reply_to_id" : 928954333,
      "line" : 145,
      "node_id" : "PRRC_kwDOABII5843a0Po",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 145,
      "original_position" : 143,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 145,
      "pull_request_review_id" : 1050677147,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929776616/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:10:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929776616",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/22457751?v=4",
         "events_url" : "https://api.github.com/users/darosior/events{/privacy}",
         "followers_url" : "https://api.github.com/users/darosior/followers",
         "following_url" : "https://api.github.com/users/darosior/following{/other_user}",
         "gists_url" : "https://api.github.com/users/darosior/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/darosior",
         "id" : 22457751,
         "login" : "darosior",
         "node_id" : "MDQ6VXNlcjIyNDU3NzUx",
         "organizations_url" : "https://api.github.com/users/darosior/orgs",
         "received_events_url" : "https://api.github.com/users/darosior/received_events",
         "repos_url" : "https://api.github.com/users/darosior/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/darosior/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/darosior/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/darosior"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929795471"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929795471"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, I think the off-by-one error is accounted for on these lines. i.e. same fee fails, same fee + 1 succeeds.",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:27:02Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929795471",
      "id" : 929795471,
      "in_reply_to_id" : 928865773,
      "line" : 124,
      "node_id" : "PRRC_kwDOABII5843a42P",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 124,
      "original_position" : 124,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 124,
      "pull_request_review_id" : 1050739785,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929795471/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:27:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929795471",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929796137"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796137"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've added a comment to clarify. Hopefully resolves this, but feel free to unresolve if not!",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:27:45Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929796137",
      "id" : 929796137,
      "in_reply_to_id" : 928905282,
      "line" : 133,
      "node_id" : "PRRC_kwDOABII5843a5Ap",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 133,
      "original_position" : 131,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 133,
      "pull_request_review_id" : 1050740666,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796137/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:27:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796137",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929796517"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796517"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, that's the idea for the comment \"EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\" I've edited the comment and moved it down 2 lines to make it more clear what's being tested.",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:28:12Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929796517",
      "id" : 929796517,
      "in_reply_to_id" : 928954333,
      "line" : 145,
      "node_id" : "PRRC_kwDOABII5843a5Gl",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 145,
      "original_position" : 143,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 145,
      "pull_request_review_id" : 1050741255,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796517/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:28:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796517",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929796635"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796635"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good idea, done.",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:28:20Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929796635",
      "id" : 929796635,
      "in_reply_to_id" : 928973898,
      "line" : 164,
      "node_id" : "PRRC_kwDOABII5843a5Ib",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 164,
      "original_position" : 162,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 164,
      "pull_request_review_id" : 1050741413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796635/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:28:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796635",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929796910"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796910"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Good point! Added a test for conflicting confirmed inputs.",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:28:40Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    auto conflicts_size = all_conflicts.size();\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx4, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx6, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx7, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), 100);\n+    all_conflicts.clear();\n+\n+    // Exceeds maximum number of conflicts.\n+    add_descendants(tx8, pool, 1);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts).has_value());\n+\n+    // Tests for HasNoNewUnconfirmed",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929796910",
      "id" : 929796910,
      "in_reply_to_id" : 929750073,
      "line" : 211,
      "node_id" : "PRRC_kwDOABII5843a5Mu",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 211,
      "original_position" : 208,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 211,
      "pull_request_review_id" : 1050741823,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796910/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:28:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929796910",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929798212"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929798212"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree the naming could be changed to reflect that the function checks max replacements. But maybe for another PR :sweat_smile:",
      "commit_id" : "520657a5620a11bd0426b14d6bb8053667a4f20d",
      "created_at" : "2022-07-26T10:30:11Z",
      "diff_hunk" : "@@ -0,0 +1,225 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#include <policy/policy.h>\n+#include <policy/rbf.h>\n+#include <random.h>\n+#include <txmempool.h>\n+#include <util/system.h>\n+#include <util/time.h>\n+\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+#include <optional>\n+#include <vector>\n+\n+BOOST_FIXTURE_TEST_SUITE(rbf_tests, TestingSetup)\n+\n+inline CTransactionRef make_tx(const std::vector<CAmount>& output_values,\n+                               const std::vector<CTransactionRef>& inputs)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(inputs.size());\n+    tx.vout.resize(output_values.size());\n+    for (size_t i = 0; i < inputs.size(); ++i) {\n+        tx.vin[i].prevout.hash = inputs[i]->GetHash();\n+        tx.vin[i].prevout.n = 0;\n+        // Add a witness so wtxid != txid\n+        CScriptWitness witness;\n+        witness.stack.push_back(std::vector<unsigned char>(i + 10));\n+        tx.vin[i].scriptWitness = witness;\n+    }\n+    for (size_t i = 0; i < output_values.size(); ++i) {\n+        tx.vout[i].scriptPubKey = CScript() << OP_11 << OP_EQUAL;\n+        tx.vout[i].nValue = output_values[i];\n+    }\n+    return MakeTransactionRef(tx);\n+}\n+\n+void add_descendants(const CTransactionRef& tx, CTxMemPool& pool, int32_t num_descendants)\n+    EXCLUSIVE_LOCKS_REQUIRED(cs_main, pool.cs)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(pool.cs);\n+    TestMemPoolEntryHelper entry;\n+    // Assumes this isn't already spent in mempool\n+    auto tx_to_spend = tx;\n+    for (int32_t i{0}; i < num_descendants; ++i) {\n+        auto next_tx = make_tx(/*output_values=*/ {(50 - i) * CENT}, /*inputs=*/ {tx_to_spend});\n+        pool.addUnchecked(entry.FromTx(next_tx));\n+        tx_to_spend = next_tx;\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(rbf_helper_functions, TestChain100Setup)\n+{\n+    CTxMemPool& pool = *Assert(m_node.mempool);\n+    LOCK2(cs_main, pool.cs);\n+    TestMemPoolEntryHelper entry;\n+\n+    const CAmount low_fee{100};\n+    const CAmount normal_fee{10000};\n+    const CAmount high_fee{1 * COIN};\n+\n+    // Create a parent tx1 and child tx2 with normal fees:\n+    CTransactionRef tx1 = make_tx(/*output_values=*/ {10 * COIN}, /*inputs=*/ {m_coinbase_txns[0]});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx1));\n+    CTransactionRef tx2 = make_tx(/*output_values=*/ {995 * CENT}, /*inputs=*/ {tx1});\n+    pool.addUnchecked(entry.Fee(normal_fee).FromTx(tx2));\n+\n+    // Create a low-feerate parent tx3 and high-feerate child tx4 (cpfp)\n+    CTransactionRef tx3 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[1]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx3));\n+    CTransactionRef tx4 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx4));\n+\n+    // Create a parent tx5 and child tx6 where both have very low fees\n+    CTransactionRef tx5 = make_tx(/*output_values=*/ {1099 * CENT}, /*inputs=*/ {m_coinbase_txns[2]});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx5));\n+    CTransactionRef tx6 = make_tx(/*output_values=*/ {1098 * CENT}, /*inputs=*/ {tx3});\n+    pool.addUnchecked(entry.Fee(low_fee).FromTx(tx6));\n+    // Make tx6's modified fee much higher than its base fee. This should cause it to pass\n+    // the fee-related checks despite being low-feerate.\n+    pool.PrioritiseTransaction(tx6->GetHash(), 1 * COIN);\n+\n+    // Two independent high-feerate transactions, tx7 and tx8\n+    CTransactionRef tx7 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[3]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx7));\n+    CTransactionRef tx8 = make_tx(/*output_values=*/ {999 * CENT}, /*inputs=*/ {m_coinbase_txns[4]});\n+    pool.addUnchecked(entry.Fee(high_fee).FromTx(tx8));\n+\n+    const auto entry1 = pool.GetIter(tx1->GetHash()).value();\n+    const auto entry2 = pool.GetIter(tx2->GetHash()).value();\n+    const auto entry3 = pool.GetIter(tx3->GetHash()).value();\n+    const auto entry4 = pool.GetIter(tx4->GetHash()).value();\n+    const auto entry5 = pool.GetIter(tx5->GetHash()).value();\n+    const auto entry6 = pool.GetIter(tx6->GetHash()).value();\n+    const auto entry7 = pool.GetIter(tx7->GetHash()).value();\n+    const auto entry8 = pool.GetIter(tx8->GetHash()).value();\n+\n+    BOOST_CHECK_EQUAL(entry1->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry2->GetFee(), normal_fee);\n+    BOOST_CHECK_EQUAL(entry3->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry4->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry5->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry6->GetFee(), low_fee);\n+    BOOST_CHECK_EQUAL(entry7->GetFee(), high_fee);\n+    BOOST_CHECK_EQUAL(entry8->GetFee(), high_fee);\n+\n+    CTxMemPool::setEntries set_12_normal{entry1, entry2};\n+    CTxMemPool::setEntries set_34_cpfp{entry3, entry4};\n+    CTxMemPool::setEntries set_56_low{entry5, entry6};\n+    CTxMemPool::setEntries all_entries{entry1, entry2, entry3, entry4, entry5, entry6, entry7, entry8};\n+    CTxMemPool::setEntries empty_set;\n+\n+    const auto unused_txid{GetRandHash()};\n+\n+    // Tests for PaysMoreThanConflicts\n+    // These tests use feerate, not absolute fee.\n+    BOOST_CHECK(PaysMoreThanConflicts(/*iters_conflicting=*/set_12_normal,\n+                                      /*replacement_feerate=*/CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize() + 2),\n+                                      /*txid=*/unused_txid).has_value());\n+    // Replacement must be strictly greater than the originals.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee(), entry1->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts(set_12_normal, CFeeRate(entry1->GetModifiedFee() + 1, entry1->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests use modified fees (including prioritisation), not base fees.\n+    BOOST_CHECK(PaysMoreThanConflicts({entry5}, CFeeRate(entry5->GetModifiedFee() + 1, entry5->GetTxSize()), unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetFee() + 1, entry6->GetTxSize()), unused_txid).has_value());\n+    BOOST_CHECK(PaysMoreThanConflicts({entry6}, CFeeRate(entry6->GetModifiedFee() + 1, entry6->GetTxSize()), unused_txid) == std::nullopt);\n+    // These tests only check individual feerate. Ancestor feerate does not matter.\n+    BOOST_CHECK(PaysMoreThanConflicts(set_34_cpfp, CFeeRate(entry4->GetModifiedFee(), entry4->GetTxSize()), unused_txid).has_value());\n+\n+    // Tests for EntriesAndTxidsDisjoint\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(empty_set, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx3->GetHash()}, unused_txid) == std::nullopt);\n+    // EntriesAndTxidsDisjoint uses txids, not wtxids.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetWitnessHash()}, unused_txid) == std::nullopt);\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx2->GetHash()}, unused_txid).has_value());\n+    // If entry2 is an ancestor of a tx, that tx cannot replace entry1.  However,\n+    // EntriesAndTxidsDisjoint uses the ancestors directly. It does not calculate descendants.\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx1->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint(set_12_normal, {tx2->GetHash()}, unused_txid).has_value());\n+    BOOST_CHECK(EntriesAndTxidsDisjoint({entry2}, {tx1->GetHash()}, unused_txid) == std::nullopt);\n+\n+    // Tests for PaysForRBF\n+    const auto incremental_relay_feerate{CFeeRate(DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    const auto higher_relay_feerate{CFeeRate(2 * DEFAULT_INCREMENTAL_RELAY_FEE)};\n+    // Must pay at least as much as the original.\n+    BOOST_CHECK(PaysForRBF(/*original_fees=*/high_fee,\n+                           /*replacement_fees=*/high_fee,\n+                           /*replacement_vsize=*/1,\n+                           /*relay_fee=*/CFeeRate(0),\n+                           /*txid=*/unused_txid)\n+                           == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee - 1, 1, CFeeRate(0), unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee + 1, high_fee, 1, CFeeRate(0), unused_txid).has_value());\n+    // Additional fees must cover the replacement's vsize at incremental relay fee\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 1, 2, incremental_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, incremental_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 2, 2, higher_relay_feerate, unused_txid).has_value());\n+    BOOST_CHECK(PaysForRBF(high_fee, high_fee + 4, 2, higher_relay_feerate, unused_txid) == std::nullopt);\n+    BOOST_CHECK(PaysForRBF(low_fee, high_fee, 99999999, incremental_relay_feerate, unused_txid).has_value());\n+\n+    // Tests for GetEntriesForConflicts\n+    CTxMemPool::setEntries all_parents{entry1, entry3, entry5, entry7, entry8};\n+    CTxMemPool::setEntries all_children{entry2, entry4, entry6};\n+    std::vector<CTransactionRef> parent_inputs({m_coinbase_txns[0], m_coinbase_txns[1], m_coinbase_txns[2],\n+                                                m_coinbase_txns[3], m_coinbase_txns[4]});\n+    CTransactionRef conflicts_with_parents = make_tx({50 * CENT}, parent_inputs);\n+    CTxMemPool::setEntries all_conflicts;\n+    BOOST_CHECK(GetEntriesForConflicts(/*tx=*/ *conflicts_with_parents.get(),\n+                                       /*pool=*/ pool,\n+                                       /*iters_conflicting=*/ all_parents,\n+                                       /*all_conflicts=*/ all_conflicts) == std::nullopt);\n+    BOOST_CHECK(all_conflicts == all_entries);\n+    auto conflicts_size = all_conflicts.size();\n+    all_conflicts.clear();\n+\n+    add_descendants(tx2, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx4, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx6, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    all_conflicts.clear();\n+\n+    add_descendants(tx7, pool, 23);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts) == std::nullopt);\n+    conflicts_size += 23;\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), conflicts_size);\n+    BOOST_CHECK_EQUAL(all_conflicts.size(), 100);\n+    all_conflicts.clear();\n+\n+    // Exceeds maximum number of conflicts.\n+    add_descendants(tx8, pool, 1);\n+    BOOST_CHECK(GetEntriesForConflicts(*conflicts_with_parents.get(), pool, all_parents, all_conflicts).has_value());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#discussion_r929798212",
      "id" : 929798212,
      "in_reply_to_id" : 928995580,
      "line" : 209,
      "node_id" : "PRRC_kwDOABII5843a5hE",
      "original_commit_id" : "433411ac98c0e6ea08defe27913ed9d06482f64c",
      "original_line" : 209,
      "original_position" : 206,
      "original_start_line" : null,
      "path" : "src/test/rbf_tests.cpp",
      "position" : 209,
      "pull_request_review_id" : 1050743710,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/25674",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929798212/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2022-07-26T10:30:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/929798212",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, will review soon",
      "created_at" : "2022-07-26T11:47:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/25674#issuecomment-1195378564",
      "id" : 1195378564,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/25674",
      "node_id" : "IC_kwDOABII585HQAeE",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1195378564/reactions"
      },
      "updated_at" : "2022-07-26T11:47:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/1195378564",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   }
]
