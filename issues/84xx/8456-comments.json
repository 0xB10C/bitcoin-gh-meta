[
   {
      "body" : "Thanks! Looks good.\r\nConcept ACK will review and test soon.",
      "created_at" : "2016-08-05T10:56:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-237822346",
      "id" : 237822346,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-08-05T10:56:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/237822346",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73769322"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73769322"
         }
      },
      "body" : "nit: Double negation makes it hards to read. I suggest to replace by\r\n\r\n```\r\n CAmount nOldFee = wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0;\r\n```",
      "commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "created_at" : "2016-08-05T22:39:53Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73769322",
      "id" : 73769322,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 113,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-08-05T22:39:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73769322",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73769911"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73769911"
         }
      },
      "body" : "I'm not sure about this. The problem is that such case will rarely happen so applications risk to break during sudden peak usage, amplifying bad news. \r\n\r\nI suggest to silently bump fees to the minMempoolFeeRate.",
      "commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "created_at" : "2016-08-05T22:47:25Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73769911",
      "id" : 73769911,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 153,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 153,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-08-05T22:47:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73769911",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770122"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770122"
         }
      },
      "body" : "nit: \r\n```\r\n nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)\r\n```\r\nIs repeated. Suggest using variable.",
      "commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "created_at" : "2016-08-05T22:50:32Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770122",
      "id" : 73770122,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 176,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 176,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-08-05T22:50:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770122",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770489"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770489"
         }
      },
      "body" : "additional check should be done:\r\n\r\n```\r\nnDelta >= poutput->GetDustThreshold(::minRelayTxFee);\r\n```\r\nOr it won't get propagated.",
      "commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "created_at" : "2016-08-05T22:55:41Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770489",
      "id" : 73770489,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 204,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 204,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-08-05T22:55:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770489",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770556"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770556"
         }
      },
      "body" : "can you use C++11 loop style ?",
      "commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "created_at" : "2016-08-05T22:56:20Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto it(tx.vin.begin()); it != tx.vin.end(); ++it, nIn++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770556",
      "id" : 73770556,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 214,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 214,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-08-05T22:56:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770556",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770774"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770774"
         }
      },
      "body" : "You should use the same SIGHASH than the previous one. (might be done separate PR ?)",
      "commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "created_at" : "2016-08-05T22:58:48Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto it(tx.vin.begin()); it != tx.vin.end(); ++it, nIn++) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find((*it).prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && (nIn < (int)(*mi).second.vout.size())) {\n+            const CScript& scriptPubKey = (*mi).second.vout[(*it).prevout.n].scriptPubKey;\n+            SignatureData sigdata;\n+            if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, sigdata))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770774",
      "id" : 73770774,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 219,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 219,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-08-05T23:07:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770774",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73771062"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73771062"
         }
      },
      "body" : ">  (nIn < (int)(*mi).second.vout.size())\r\n\r\nI think this is a bug, why does the index of the input to sign should be below the number of vout of the parent ? Does not make sense.",
      "commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "created_at" : "2016-08-05T23:02:03Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto it(tx.vin.begin()); it != tx.vin.end(); ++it, nIn++) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find((*it).prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && (nIn < (int)(*mi).second.vout.size())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73771062",
      "id" : 73771062,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 216,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 216,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-08-05T23:02:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73771062",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   }
]
