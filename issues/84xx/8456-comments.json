[
   {
      "body" : "Thanks! Looks good.\r\nConcept ACK will review and test soon.",
      "created_at" : "2016-08-05T10:56:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-237822346",
      "id" : 237822346,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-08-05T10:56:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/237822346",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73769322"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73769322"
         }
      },
      "body" : "nit: Double negation makes it hards to read. I suggest to replace by\r\n\r\n```\r\n CAmount nOldFee = wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0;\r\n```",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-08-05T22:39:53Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73769322",
      "id" : 73769322,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 113,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73769322",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73769911"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73769911"
         }
      },
      "body" : "I'm not sure about this. The problem is that such case will rarely happen so applications risk to break during sudden peak usage, amplifying bad news. \r\n\r\nI suggest to silently bump fees to the minMempoolFeeRate.",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-08-05T22:47:25Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73769911",
      "id" : 73769911,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 153,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73769911",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770122"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770122"
         }
      },
      "body" : "nit: \r\n```\r\n nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)\r\n```\r\nIs repeated. Suggest using variable.",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-08-05T22:50:32Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770122",
      "id" : 73770122,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 176,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770122",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770489"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770489"
         }
      },
      "body" : "additional check should be done:\r\n\r\n```\r\nnDelta >= poutput->GetDustThreshold(::minRelayTxFee);\r\n```\r\nOr it won't get propagated.",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-08-05T22:55:41Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770489",
      "id" : 73770489,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 204,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 234,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770489",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770556"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770556"
         }
      },
      "body" : "can you use C++11 loop style ?",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-08-05T22:56:20Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto it(tx.vin.begin()); it != tx.vin.end(); ++it, nIn++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770556",
      "id" : 73770556,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 214,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770556",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770774"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770774"
         }
      },
      "body" : "You should use the same SIGHASH than the previous one. (might be done separate PR ?)",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-08-05T22:58:48Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto it(tx.vin.begin()); it != tx.vin.end(); ++it, nIn++) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find((*it).prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && (nIn < (int)(*mi).second.vout.size())) {\n+            const CScript& scriptPubKey = (*mi).second.vout[(*it).prevout.n].scriptPubKey;\n+            SignatureData sigdata;\n+            if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, sigdata))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73770774",
      "id" : 73770774,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 219,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73770774",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73771062"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73771062"
         }
      },
      "body" : ">  (nIn < (int)(*mi).second.vout.size())\r\n\r\nI think this is a bug, why does the index of the input to sign should be below the number of vout of the parent ? Does not make sense.",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-08-05T23:02:03Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto it(tx.vin.begin()); it != tx.vin.end(); ++it, nIn++) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find((*it).prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && (nIn < (int)(*mi).second.vout.size())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r73771062",
      "id" : 73771062,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 216,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/73771062",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/3020646?v=3",
         "events_url" : "https://api.github.com/users/NicolasDorier/events{/privacy}",
         "followers_url" : "https://api.github.com/users/NicolasDorier/followers",
         "following_url" : "https://api.github.com/users/NicolasDorier/following{/other_user}",
         "gists_url" : "https://api.github.com/users/NicolasDorier/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/NicolasDorier",
         "id" : 3020646,
         "login" : "NicolasDorier",
         "organizations_url" : "https://api.github.com/users/NicolasDorier/orgs",
         "received_events_url" : "https://api.github.com/users/NicolasDorier/received_events",
         "repos_url" : "https://api.github.com/users/NicolasDorier/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/NicolasDorier/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/NicolasDorier/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/NicolasDorier"
      }
   },
   {
      "body" : "Needs rebase and reviewers... setting 0.14 milestone.",
      "created_at" : "2016-08-19T16:50:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-241071499",
      "id" : 241071499,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-08-19T16:50:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/241071499",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Rebased and addressed feedback.\r\n",
      "created_at" : "2016-10-18T18:07:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-254590532",
      "id" : 254590532,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-10-18T18:07:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/254590532",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83915487"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83915487"
         }
      },
      "body" : "Good idea, fixed.\r\n",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-10-18T18:07:33Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto it(tx.vin.begin()); it != tx.vin.end(); ++it, nIn++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83915487",
      "id" : 83915487,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 214,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 4727308,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83915487",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83915534"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83915534"
         }
      },
      "body" : "Let's punt to separate PR. ",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-10-18T18:07:47Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto it(tx.vin.begin()); it != tx.vin.end(); ++it, nIn++) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find((*it).prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && (nIn < (int)(*mi).second.vout.size())) {\n+            const CScript& scriptPubKey = (*mi).second.vout[(*it).prevout.n].scriptPubKey;\n+            SignatureData sigdata;\n+            if (!ProduceSignature(TransactionSignatureCreator(pwalletMain, &txNewConst, nIn, SIGHASH_ALL), scriptPubKey, sigdata))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83915534",
      "id" : 83915534,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 219,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 4727354,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83915534",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83915788"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83915788"
         }
      },
      "body" : "Good catch, edited to bounds-check the prevout.",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-10-18T18:09:04Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {\n+        poutput->nValue = poutput->nValue - nDelta;\n+    }\n+    else {\n+        throw JSONRPCError(RPC_MISC_ERROR, \"Output does not have enough money to bump the fee\");\n+    }\n+\n+    // sign the new tx\n+    CTransaction txNewConst(tx);\n+    int nIn = 0;\n+    for (auto it(tx.vin.begin()); it != tx.vin.end(); ++it, nIn++) {\n+        std::map<uint256, CWalletTx>::const_iterator mi = pwalletMain->mapWallet.find((*it).prevout.hash);\n+        if (mi != pwalletMain->mapWallet.end() && (nIn < (int)(*mi).second.vout.size())) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83915788",
      "id" : 83915788,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 216,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 4727614,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83915788",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83916251"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83916251"
         }
      },
      "body" : "I checked earlier that the bumped fee pays for the new relay fee;  I'm not following as to the relationship between nDelta and dust. ",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-10-18T18:11:13Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {\n+                std::string strError = strprintf(\"Insufficent fee due to child transactions, the bumped fee must be at least: %s\", FormatMoney(nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)));\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+            }\n+        }\n+        else\n+        {\n+            // Tx not in mempool\n+            // -----------------\n+            // If the tx is in the wallet but not the mempool, we cannot check its descendants' fees.\n+            //\n+            // Not being in the mempool likely means that it was evicted for having a low fee.\n+            // In this situation, we may not need RBF for this node (if the tx is not in the mempool,\n+            // then it doesn't need to be replaced), but it may still be in the mempol of peers\n+            // (perhaps a peer has allocated more space for the mempool).\n+            //\n+            // Our approach is to go ahead and bump/commit/relay the transaction.  In the event that\n+            // the tx does have children and the fee is insufficient to cover, the peer(s) will reject\n+            // the tx on that basis, so we warn the user of this possibility.\n+            //\n+            LogPrint(\"rpc\", \"Warning: bumping fee on tx that is not in the mempool; if it has child transactions, it may be rejected by peers\\n\");\n+        }\n+    }\n+\n+    // Now modify the output to increase the fee.\n+    // Output must be able to pay the increased fee, without being reduced to dust\n+    CMutableTransaction tx(wtx);\n+    CTxOut* poutput = &(tx.vout[nOutput]);\n+    if (poutput->nValue >= nDelta + poutput->GetDustThreshold(::minRelayTxFee)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83916251",
      "id" : 83916251,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 204,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 234,
      "pull_request_review_id" : 4728048,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83916251",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83916320"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83916320"
         }
      },
      "body" : "Fixed.",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-10-18T18:11:32Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendants = it->GetModFeesWithDescendants();\n+            if (nNewFee < nFeesWithDescendants + ::minRelayTxFee.GetFee(txSize)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83916320",
      "id" : 83916320,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 176,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 4728114,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83916320",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83916647"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83916647"
         }
      },
      "body" : "I edited the comment to explain why I'm reporting an error.  Especially if the user set totalFee (or had in the recent past used paytxfee to set an explicit fee rate) I think silently bumping could surprise the user. ",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-10-18T18:13:02Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83916647",
      "id" : 83916647,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 153,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 4728436,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83916647",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83916680"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83916680"
         }
      },
      "body" : "Fixed.",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-10-18T18:13:12Z",
      "diff_hunk" : "@@ -2554,6 +2556,230 @@ UniValue fundrawtransaction(const UniValue& params, bool fHelp)\n     return result;\n }\n \n+UniValue bumpfee(const UniValue& params, bool fHelp)\n+{\n+    if (!EnsureWalletIsAvailable(fHelp))\n+        return NullUniValue;\n+\n+    if (fHelp || params.size() < 2 || params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (params.size() > 2) {\n+        RPCTypeCheck(params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = -(wtx.IsFromMe(ISMINE_SPENDABLE) ? wtx.GetValueOut() - nDebit : 0);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r83916680",
      "id" : 83916680,
      "original_commit_id" : "41572b183d33080602b8522ff7085f472ef3e4a7",
      "original_position" : 113,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 4728467,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/83916680",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "body" : "Needs rebase again...",
      "created_at" : "2016-10-20T19:55:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-255210711",
      "id" : 255210711,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-10-20T19:55:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/255210711",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Rebased and edited to use JSONRPCRequest, consistent with #8788.",
      "created_at" : "2016-10-21T15:44:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-255412618",
      "id" : 255412618,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-10-21T15:44:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/255412618",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r84578211"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84578211"
         }
      },
      "body" : "This line is outdated",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-10-22T14:35:52Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r84578211",
      "id" : 84578211,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 22,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 5350229,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/84578211",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "body" : "I think it's very important for this command to actual figure out the change output on its own.  I understand that it's a bit messier and more fragile doing it here -- but it actually has enough information to do this, and by avoiding it, it just pushes that mess into the caller which comes at a very significant usability issue.\r\n\r\n\r\nCompare:\r\nTransaction stuck? Use `bumpfee $txid`\r\n\r\nvs\r\n\r\nTransaction stuck? First use `gettransaction $txid`, and now get the data from the \"hex\" field to feed into `decoderawtransaction $hex`  now go through the \"vout\" fields until you find \"addresses\" nested in the \"scriptPubKey\". Now try figure out which is a change address. (I can't even see this exposed over rpc at all?). So maybe go `validateaddress $address` and check the `ismine` field. If one of them is yours, but the other one isn't -- then the one that is yours is a change address, so now go back through the results of `decoderawtransaction` to figure out which index that is. And finally `bumpfee $txid $index`.  Oh yeah, becareful to handle all the edge cases, like the transaction only having 1 output, some of the outputs not having address, both having the same address etc.\r\n\r\n\r\nI think you'll find the usability problem of needing to know the index will prevent the majority of use by users and services for this =)",
      "created_at" : "2016-10-26T00:30:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-256217731",
      "id" : 256217731,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-10-26T00:37:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/256217731",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/9326759?v=3",
         "events_url" : "https://api.github.com/users/RHavar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/RHavar/followers",
         "following_url" : "https://api.github.com/users/RHavar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/RHavar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/RHavar",
         "id" : 9326759,
         "login" : "RHavar",
         "organizations_url" : "https://api.github.com/users/RHavar/orgs",
         "received_events_url" : "https://api.github.com/users/RHavar/received_events",
         "repos_url" : "https://api.github.com/users/RHavar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/RHavar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/RHavar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/RHavar"
      }
   },
   {
      "body" : "Also ideally, I think the `txid` argument should be an array of transaction ids to bump. And then it creates a single transaction that bumps the fees on all of those transactions (stripping out extraneous change outputs as it goes). However, I imagine this can be done separately and later as the `txid` argument could be overloaded to either accept a string or array of strings?",
      "created_at" : "2016-10-26T00:34:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-256218209",
      "id" : 256218209,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-10-26T00:35:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/256218209",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/9326759?v=3",
         "events_url" : "https://api.github.com/users/RHavar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/RHavar/followers",
         "following_url" : "https://api.github.com/users/RHavar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/RHavar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/RHavar",
         "id" : 9326759,
         "login" : "RHavar",
         "organizations_url" : "https://api.github.com/users/RHavar/orgs",
         "received_events_url" : "https://api.github.com/users/RHavar/received_events",
         "repos_url" : "https://api.github.com/users/RHavar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/RHavar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/RHavar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/RHavar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85203030"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85203030"
         }
      },
      "body" : "Perhaps make this fail if there are any options other than confTarget or totalFee passed in to guard against the case where a user has a typo or something.",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-10-26T19:38:20Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85203030",
      "id" : 85203030,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 87,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 5931993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85203030",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85204987"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85204987"
         }
      },
      "body" : "Maybe add a tighter limit to your bumpfee code, bumpfeeMaxTxFee. Set this to be an optional default parameter in options. maxTxFee is huge, so might be safer to have something smaller and not much added code. This parameter can be overridden if need be, but not to more the maxTxFee.",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-10-26T19:48:41Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85204987",
      "id" : 85204987,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 106,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 5931993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85204987",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85209694"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85209694"
         }
      },
      "body" : "There is kind of a weird deal here where nDelta can be <= 0 if totalFee is set, and will be accepted on a race condition with mempool, I would explicitly guard against this case by restricting nDelta > 0.",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-10-26T20:12:09Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85209694",
      "id" : 85209694,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 159,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 178,
      "pull_request_review_id" : 5931993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85209694",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85209934"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85209934"
         }
      },
      "body" : "Using a nNewFee = 0 is fine here, it just slightly bothers me to use this as a null value when indeed 0 is a valid fee amount.\r\n\r\n-1 would be an invalid fee amount (creates coins) so I have a slight preference to use this.\r\n",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-10-26T20:13:26Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85209934",
      "id" : 85209934,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 118,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 137,
      "pull_request_review_id" : 5931993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85209934",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85211353"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85211353"
         }
      },
      "body" : "I would suggest that this should also return in the error message the txid of the furthest child, and suggest bumping the fee on that one if possible to take advantage of ancestor fee based mining and keep txs valid?",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-10-26T20:21:00Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendantsPlusRelay = it->GetModFeesWithDescendants() + ::minRelayTxFee.GetFee(txSize);\n+            if (nNewFee < nFeesWithDescendantsPlusRelay) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85211353",
      "id" : 85211353,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 179,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 200,
      "pull_request_review_id" : 5931993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85211353",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85216916"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85216916"
         }
      },
      "body" : "There is something kinda funky when a user is running in say blocksonlymode and doesn't know about any child transactions that may exist and therefore has trouble setting the fee correctly for those that they will invalidate.\r\n\r\nThis is probably a hard problem to solve; so I'm just pointing it out.",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-10-26T20:48:30Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendantsPlusRelay = it->GetModFeesWithDescendants() + ::minRelayTxFee.GetFee(txSize);\n+            if (nNewFee < nFeesWithDescendantsPlusRelay) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85216916",
      "id" : 85216916,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 179,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 200,
      "pull_request_review_id" : 5931993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85216916",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=3",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85427104"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85427104"
         }
      },
      "body" : "Done.\r\n",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-10-27T21:03:03Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85427104",
      "id" : 85427104,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 159,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 178,
      "pull_request_review_id" : 6145468,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85427104",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85427448"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85427448"
         }
      },
      "body" : "As far as I can tell it's a little tricky to track down the furthest child (and there could be numerous furthest children at the same level) but I edited the error message to give the user more info (number of children and size of those transactions) and explaining the situation a bit better.\r\n ",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-10-27T21:05:03Z",
      "diff_hunk" : "@@ -2575,6 +2577,234 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\"\\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"\\nThis command requires that the txid is in the wallet.\\n\"\n+                            \"\\nUser specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"\\nThis command will NOT add new inputs.\\n\"\n+                            \"\\nFee must be high enough to pay a new relay fee.\\n\"\n+                            \"\\nIf tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"\\nThis command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"\\nUser can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transactions txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (higher than maxTxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendantsPlusRelay = it->GetModFeesWithDescendants() + ::minRelayTxFee.GetFee(txSize);\n+            if (nNewFee < nFeesWithDescendantsPlusRelay) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r85427448",
      "id" : 85427448,
      "original_commit_id" : "8e969e3fc4d16f77882fe2a858c47de990161a91",
      "original_position" : 179,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 200,
      "pull_request_review_id" : 6145807,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/85427448",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "body" : "Addressed JeremyRubin feedback, edited the python test, and made a few other small changes I noticed with further testing. \r\n\r\nRHavar:  I understand your point but I still think it's better for this command to be low-level and not fragile.  A more user-friendly RPC (e.g., \"bumpfeeauto\" or something) could be layered on top, identifying the change output and then using this code.  Then if the change-output-identifying code breaks, it might break the user-friendly version but it wouldn't dismantle RBF entirely. \r\n",
      "created_at" : "2016-10-27T21:10:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-256770931",
      "id" : 256770931,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-10-27T21:10:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/256770931",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "body" : "ACK f3833f4\r\nTested on Windows x64\r\n```\r\nbumpfee 8c56b13830405a55ec4bc58b26b531f1b187d2349ee19bd0dd01aa835972929a 1\r\n\r\n{\r\n  \"txid\": \"67d6af1a3e29e246eaef0b7ce272f745e2ae6178050ccb78fca515b13c0f9e92\",\r\n  \"oldfee\": 0.00000260,\r\n  \"fee\": 0.00000520\r\n}\r\n```",
      "created_at" : "2016-11-11T13:13:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-259954550",
      "id" : 259954550,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-11-11T13:16:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/259954550",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/11365204?v=3",
         "events_url" : "https://api.github.com/users/Victorsueca/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Victorsueca/followers",
         "following_url" : "https://api.github.com/users/Victorsueca/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Victorsueca/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Victorsueca",
         "id" : 11365204,
         "login" : "Victorsueca",
         "organizations_url" : "https://api.github.com/users/Victorsueca/orgs",
         "received_events_url" : "https://api.github.com/users/Victorsueca/received_events",
         "repos_url" : "https://api.github.com/users/Victorsueca/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Victorsueca/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Victorsueca/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Victorsueca"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87586451"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87586451"
         }
      },
      "body" : "nit: Maybe use txid to correspond with the call header at L2587 or use `transactionid` there?",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-11-11T13:18:38Z",
      "diff_hunk" : "@@ -2575,6 +2577,267 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" \\\"output\\\" \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87586451",
      "id" : 87586451,
      "original_commit_id" : "f3833f42d05209768c3360b4404b8b57f884bb79",
      "original_position" : 32,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 8194636,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87586451",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87586523"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87586523"
         }
      },
      "body" : "add third parameter `(\"options\")`?",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-11-11T13:19:22Z",
      "diff_hunk" : "@@ -2575,6 +2577,267 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" \\\"output\\\" \\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87586523",
      "id" : 87586523,
      "original_commit_id" : "f3833f42d05209768c3360b4404b8b57f884bb79",
      "original_position" : 22,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 8194716,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87586523",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87586825"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87586825"
         }
      },
      "body" : "I'm not sure if we want absolute fee values here.\r\nThe user can't be sure how many inputs are getting added when setting this value, probably resulting in an uncontrollable feerate.\r\n\r\nWhat about switching this to a feerate?",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-11-11T13:22:38Z",
      "diff_hunk" : "@@ -2575,6 +2577,267 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" \\\"output\\\" \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87586825",
      "id" : 87586825,
      "original_commit_id" : "f3833f42d05209768c3360b4404b8b57f884bb79",
      "original_position" : 37,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 8195025,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87586825",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87587175"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87587175"
         }
      },
      "body" : "This check looks really expensive for large wallets. Why not calling `mapWallet.find(hash)` and check `nDepth` (and maybe call `GetConflicts()` to ensure its not conflicted with a already mined tx)?",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-11-11T13:25:49Z",
      "diff_hunk" : "@@ -2575,6 +2577,267 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" \\\"output\\\" \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\"          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    vector<COutput> vecOutputs;\n+    pwalletMain->AvailableCoins(vecOutputs, false, NULL, true);\n+    BOOST_FOREACH(const COutput& out, vecOutputs) {\n+        if (out.tx->GetHash().GetHex() == hash.GetHex() && out.nDepth > 0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87587175",
      "id" : 87587175,
      "original_commit_id" : "f3833f42d05209768c3360b4404b8b57f884bb79",
      "original_position" : 67,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 8195411,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87587175",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87587201"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87587201"
         }
      },
      "body" : "Another possibility is to leave the RPC with an absolute value and use Fee/KB on the GUI.\r\nSome software may want to use it's own relative fee rate.",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-11-11T13:26:03Z",
      "diff_hunk" : "@@ -2575,6 +2577,267 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" \\\"output\\\" \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"transactionid\\\"     (string, required) The txid to be bumped\\n\"\n+                            \"2. \\\"output\\\"            (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87587201",
      "id" : 87587201,
      "original_commit_id" : "f3833f42d05209768c3360b4404b8b57f884bb79",
      "original_position" : 37,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : null,
      "pull_request_review_id" : 8195437,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T16:33:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87587201",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/11365204?v=3",
         "events_url" : "https://api.github.com/users/Victorsueca/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Victorsueca/followers",
         "following_url" : "https://api.github.com/users/Victorsueca/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Victorsueca/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Victorsueca",
         "id" : 11365204,
         "login" : "Victorsueca",
         "organizations_url" : "https://api.github.com/users/Victorsueca/orgs",
         "received_events_url" : "https://api.github.com/users/Victorsueca/received_events",
         "repos_url" : "https://api.github.com/users/Victorsueca/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Victorsueca/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Victorsueca/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Victorsueca"
      }
   },
   {
      "body" : "Oh. I just realized that this PR does not add new inputs (it requires an output index to identify the change-output which then can be reduced).\r\n\r\nIMO we should...\r\n\r\n1.) not let the user identify which output is change\r\n2.) allow bumping fees including adding new inputs (some transactions do not have a change output, some will not allow a reasonable bumping without adding a new input).\r\n\r\nBut 1.) & 2.) can also be solved later.",
      "created_at" : "2016-11-11T13:31:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-259957619",
      "id" : 259957619,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-11-11T13:31:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/259957619",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=3",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "body" : "Feedback addressed.  Good catch on checking whether the tx had already been mined - that code was able to be shortened to a single line.\r\nYes, the approach of this PR is to solve 1) and 2) later.\r\nIf this looks good I'll squash the commits. ",
      "created_at" : "2016-11-14T16:38:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#issuecomment-260387468",
      "id" : 260387468,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8456",
      "updated_at" : "2016-11-14T16:38:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/260387468",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7504522?v=3",
         "events_url" : "https://api.github.com/users/mrbandrews/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mrbandrews/followers",
         "following_url" : "https://api.github.com/users/mrbandrews/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mrbandrews/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mrbandrews",
         "id" : 7504522,
         "login" : "mrbandrews",
         "organizations_url" : "https://api.github.com/users/mrbandrews/orgs",
         "received_events_url" : "https://api.github.com/users/mrbandrews/received_events",
         "repos_url" : "https://api.github.com/users/mrbandrews/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mrbandrews/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mrbandrews/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mrbandrews"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87878468"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87878468"
         }
      },
      "body" : "I don't think this section makes sense.  Transactions which are in newer in the wallet are not a good indication of the most \"up to date\" spend of the outputs.  If anything, conflicts in the mempool would be a good proxy, because at least for those you'd be able to calculate any descendants fees.  But it may make the most sense to make this more of a utility function and just assume the user is trying to bump the right txid.  I would just eliminate this set of checks entirely.",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-11-14T19:49:02Z",
      "diff_hunk" : "@@ -2575,6 +2577,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output                (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\"          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87878468",
      "id" : 87878468,
      "original_commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "original_position" : 76,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 76,
      "pull_request_review_id" : 8471777,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-14T19:49:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87878468",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87879296"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87879296"
         }
      },
      "body" : "Would be helpful to refer to this as the output index throughout...  (comments, help, and error messages)",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-11-14T19:53:20Z",
      "diff_hunk" : "@@ -2575,6 +2577,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output                (int, required) The output to be decremented\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r87879296",
      "id" : 87879296,
      "original_commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "original_position" : 33,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 33,
      "pull_request_review_id" : 8472577,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-15T21:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/87879296",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88117668"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88117668"
         }
      },
      "body" : "We need to be sure we are calculating the correct fee here.  Either using new `IsAllFromMe` or getting the fee from the mempool.",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-11-15T21:29:51Z",
      "diff_hunk" : "@@ -2575,6 +2577,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output                (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\"          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88117668",
      "id" : 88117668,
      "original_commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "original_position" : 131,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 131,
      "pull_request_review_id" : 8472577,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-15T21:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88117668",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88120736"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88120736"
         }
      },
      "body" : "you don't need this, you can just leave it out as an argument",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-11-15T21:44:39Z",
      "diff_hunk" : "@@ -2575,6 +2577,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output                (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\"          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88120736",
      "id" : 88120736,
      "original_commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "original_position" : 143,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 143,
      "pull_request_review_id" : 8472577,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-15T21:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88120736",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88122200"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88122200"
         }
      },
      "body" : "I think this reduces bumpfee to a two step process in the common case (whenever there are children) and makes it so the second step is going to require setting totalfee.  It seems more user friendly to just pay what it takes?\r\n\r\nOn a separate note, I think it might be nice to check all of the children transactions and make sure their ancestor fee rate isn't higher than the new feerate you are bumping to.  If one of them has a higher ancestor fee rate you are actually make your situation worse.",
      "commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "created_at" : "2016-11-15T21:52:42Z",
      "diff_hunk" : "@@ -2575,6 +2577,261 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue bumpfee(const JSONRPCRequest& request)\n+{\n+    if (!EnsureWalletIsAvailable(request.fHelp))\n+        return NullUniValue;\n+\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+        throw runtime_error(\n+                            \"bumpfee \\\"txid\\\" output ( options ) \\n\"\n+                            \"\\nBumps the fee of a opt-in-RBF transaction.\\n\"\n+                            \"This command requires that the transaction with the given txid is in the wallet.\\n\"\n+                            \"User specifies which output (e.g., a change output) will be used to bump the fee.\\n\"\n+                            \"This command will NOT add new inputs.\\n\"\n+                            \"Fee must be high enough to pay a new relay fee.\\n\"\n+                            \"If tx has child transactions in mempool, the new fee must pay for them as well.\\n\"\n+                            \"This command will fail if fee is not high enough or output is not large enough.\\n\"\n+                            \"User can specify totalFee, or use RPC setpaytxfee to set a higher fee rate.\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"txid\\\"              (string, required) The txid to be bumped\\n\"\n+                            \"2. output                (int, required) The output to be decremented\\n\"\n+                            \"3. options               (object, optional)\\n\"\n+                            \"   {\\n\"\n+                            \"     \\\"confTarget\\\"      (int, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"totalFee\\\"        (numeric, optional) Total fee to pay, in satoshis (not btc)\\n\"\n+                            \"     \\\"maxFee\\\"          (numeric, optional) Allows user to override bumpfee's max fee\\n\"\n+                            \"   }\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"{\\n\"\n+                            \"  \\\"txid\\\":    \\\"value\\\", (string)  The id of the new transaction\\n\"\n+                            \"  \\\"oldfee\\\":    n,         (numeric) Fee of the replaced transaction\\n\"\n+                            \"  \\\"fee\\\":       n,         (numeric) Fee of the new transaction\\n\"\n+                            \"}\\n\"\n+                            \"\\nExamples:\\n\"\n+                            \"\\nBump the fee, get the new transaction\\'s txid\\n\"\n+                            + HelpExampleCli(\"bumpfee\", \"<txid> <output>\")\n+                            );\n+\n+    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM));\n+    uint256 hash;\n+    hash.SetHex(request.params[0].get_str());\n+    std::string strError;\n+\n+    // retrieve the original tx from the wallet\n+    assert(pwalletMain != NULL);\n+    LOCK2(cs_main, pwalletMain->cs_wallet);\n+    if (!pwalletMain->mapWallet.count(hash))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n+    const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n+\n+    // check that we are not trying to bump a tx that has already been mined\n+    if (wtx.GetDepthInMainChain() > 0)\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"This transaction has already been mined!\");\n+\n+    // check that original tx signals opt-in-RBF\n+    if (!SignalsOptInRBF(wtx))\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction is not bip-125 replaceable\");\n+\n+    // Check that if the original tx has wallet conflicts (meaning there is at least one other tx\n+    // in the wallet that spends at least one of the same outputs) that it is the most recent one.\n+    // This prevents us from trying to bump fee on a tx that has already been bumped.  So if the\n+    // user created txid1, bumped the fee which resulted in txid2, and now wishes to bump the fee\n+    // again, the user must call bumpfee on txid2.\n+    const CWalletTx *conflictTx;\n+    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts()) {\n+        conflictTx = pwalletMain->GetWalletTx(conflict);\n+        LogPrint(\"rpc\", \"bumpfee wallet conflict, conflicted tx has time: %d\\n\", conflictTx->GetTxTime());\n+        if (conflictTx->GetTxTime() > wtx.GetTxTime()) {\n+            strError = strprintf(\"Transaction conflicts with later wallet tx: %s\", conflict.GetHex());\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+    }\n+\n+    // bounds-check the output to decrement\n+    int nOutput = request.params[1].get_int();\n+    if (nOutput < 0 || (unsigned int) nOutput > wtx.vout.size())\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Output out of bounds\");\n+\n+    // optional parameters\n+    int newConfirmTarget = nTxConfirmTarget;\n+    CAmount totalFee = 0;\n+    CAmount bumpfeeMaxTxFee = 0.01 * COIN;\n+    if (request.params.size() > 2) {\n+        RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VNUM)(UniValue::VOBJ));\n+        UniValue options = request.params[2];\n+        if (options.size() > 3)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Too many optional parameters\");\n+        RPCTypeCheckObj(options,\n+            {\n+                {\"confTarget\", UniValueType(UniValue::VNUM)},\n+                {\"totalFee\", UniValueType(UniValue::VNUM)},\n+                {\"maxFee\", UniValueType(UniValue::VNUM)},\n+            },\n+            true, true);\n+\n+        if (options.exists(\"confTarget\")) {\n+            newConfirmTarget = options[\"confTarget\"].get_int();\n+            if (newConfirmTarget <= 0) // upper-bound will be checked by estimatefee/smartfee\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n+        }\n+        if (options.exists(\"maxFee\")) {\n+            CAmount proposedMaxFee = options[\"maxFee\"].get_int();\n+            if (proposedMaxFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be <= 0)\");\n+            else if (proposedMaxFee > maxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid maxFee (cannot be higher than the global maxTxFee)\");\n+            bumpfeeMaxTxFee = proposedMaxFee;\n+        }\n+        if (options.exists(\"totalFee\")) {\n+            totalFee = options[\"totalFee\"].get_int();\n+            if (totalFee <= 0)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be <= 0)\");\n+            else if (totalFee > bumpfeeMaxTxFee)\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid totalFee (cannot be higher than bumpfee's maxFee)\");\n+        }\n+    }\n+\n+    // calculate the old fee and fee-rate\n+    CAmount nDebit = wtx.GetDebit(ISMINE_SPENDABLE);\n+    CAmount nOldFee = (wtx.IsFromMe(ISMINE_SPENDABLE) ? nDebit - wtx.GetValueOut() : 0);\n+    int txSize = (int)GetVirtualTransactionSize((CTransaction)wtx);\n+    CFeeRate nOldFeeRate(nOldFee, txSize);\n+\n+    // use the user-defined payTxFee if possible, otherwise use smartfee / fallbackfee\n+    CAmount nNewFee = 0;\n+    CFeeRate nNewFeeRate;\n+    if (payTxFee.GetFeePerK() > 0) {\n+        nNewFeeRate = CFeeRate(payTxFee.GetFeePerK());\n+    }\n+    else {\n+        int estimateFoundTarget = newConfirmTarget;\n+        nNewFeeRate = mempool.estimateSmartFee(newConfirmTarget, &estimateFoundTarget);\n+        if (nNewFeeRate.GetFeePerK() == 0) nNewFeeRate = CWallet::fallbackFee;\n+    }\n+\n+    // new fee rate must be at least old rate + minimum relay rate\n+    if (nNewFeeRate.GetFeePerK() < nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK()) {\n+        nNewFeeRate = CFeeRate(nOldFeeRate.GetFeePerK() + ::minRelayTxFee.GetFeePerK());\n+    }\n+\n+    // signature sizes can vary by a byte, so add 1 for each input when calculating the new fee\n+    nNewFee = nNewFeeRate.GetFee(txSize + wtx.vin.size());\n+\n+    // if user set totalFee, use that instead\n+    if (totalFee > 0) {\n+        CAmount minTotalFee = nOldFeeRate.GetFee(txSize) + minRelayTxFee.GetFee(txSize);\n+        if (totalFee < minTotalFee) {\n+            strError = strprintf(\"Invalid totalFee, must be at least oldFee + relayFee: %s\", FormatMoney(minTotalFee));\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, strError);\n+        }\n+        nNewFee = totalFee;\n+        nNewFeeRate = CFeeRate(totalFee, txSize);\n+    }\n+\n+    // check that fee rate is higher than mempool's mininum fee\n+    // (no point in bumping fee if we know that the new tx won't be accepted to the mempool)\n+    // This may occur if the user set TotalFee or paytxfee too low, if fallbackfee is too low, or, perhaps,\n+    // in a rare situation where the mempool minimum fee increased significantly since the fee estimation just a\n+    // moment earlier. In this case, we report an error to the user, who may use totalFee to make an adjustment.\n+    CFeeRate minMempoolFeeRate = mempool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000);\n+    if (nNewFeeRate.GetFeePerK() < minMempoolFeeRate.GetFeePerK()) {\n+        strError = strprintf(\"New fee rate (%s) is too low to get into the mempool (min rate: %s)\", FormatMoney(nNewFeeRate.GetFeePerK()), FormatMoney(minMempoolFeeRate.GetFeePerK()));\n+        throw JSONRPCError(RPC_MISC_ERROR, strError);\n+    }\n+\n+    CAmount nDelta = nNewFee - nOldFee;\n+    if (nDelta <= 0) // it should not be possible to have a negative delta at this point (an attempt to reduce the fee)\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"New fee must be higher than old fee\");\n+\n+    {\n+        LOCK(mempool.cs);\n+        auto it = mempool.mapTx.find(hash);\n+        if (it != mempool.mapTx.end()) {\n+\n+            // Tx with descendants\n+            // --------------------\n+            // Idea:  When a tx is bumped, its descendants (if any) are evicted from the mempool.\n+            // Policy is that when you replace a tx, the total fees in the mempool cannot go down.\n+            // So when you bump a tx that has children, you have to bump your fee by the sum of all of the\n+            // descendants, plus the new bumped tx's relay fee.\n+            //\n+            // If the bumped fee is less than what's required because of children, we fail.  This is a different\n+            // situation than bumping the fee to pay the minimum relay fee. Here, we can't be sure whether the user\n+            // really wants to pay full price for all of the child transactions.  If so, the user can set payTxFee\n+            // and run the command again.\n+            //\n+            CAmount nFeesWithDescendantsPlusRelay = it->GetModFeesWithDescendants() + ::minRelayTxFee.GetFee(txSize);\n+            if (nNewFee < nFeesWithDescendantsPlusRelay) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8456#discussion_r88122200",
      "id" : 88122200,
      "original_commit_id" : "82062cd27dac300319bdd41af5a0820e1c0ccbfd",
      "original_position" : 200,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 200,
      "pull_request_review_id" : 8472577,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8456",
      "updated_at" : "2016-11-15T21:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/88122200",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/4360349?v=3",
         "events_url" : "https://api.github.com/users/morcos/events{/privacy}",
         "followers_url" : "https://api.github.com/users/morcos/followers",
         "following_url" : "https://api.github.com/users/morcos/following{/other_user}",
         "gists_url" : "https://api.github.com/users/morcos/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/morcos",
         "id" : 4360349,
         "login" : "morcos",
         "organizations_url" : "https://api.github.com/users/morcos/orgs",
         "received_events_url" : "https://api.github.com/users/morcos/received_events",
         "repos_url" : "https://api.github.com/users/morcos/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/morcos/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/morcos/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/morcos"
      }
   }
]
