[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->Note to reviewers: This pull request conflicts with the following ones:\n\n* #14172 (Refactor and add tests for BlockFilter construction by jimpo)\n* #14085 (index: Fix for indexers skipping genesis block. by jimpo)\n* #14074 (Use std::unordered_set instead of set in blockfilter interface by jimpo)\n* #14053 (Add address-based index (attempt 4?) by marcinja)\n* #14035 (Utxoscriptindex by mgrychow)\n* #13864 (validation: Document where we are intentionally ignoring bool return values from validation related functions by practicalswift)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-08-31T22:47:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#issuecomment-417807823",
      "id" : 417807823,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14121",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNzgwNzgyMw==",
      "updated_at" : "2018-09-24T21:05:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/417807823",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r214494925"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214494925"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Out of scope for this PR, but is there a reason we can't write a batch of entries for more than a single block? Could we write 100 - 1000 blocks worth of entries in each batch write to speed up the migrations? This introduces some complexity, but perhaps it's worth it?",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-08-31T23:31:07Z",
      "diff_hunk" : "@@ -0,0 +1,289 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <map>\n+\n+#include <dbwrapper.h>\n+#include <index/blockfilter.h>\n+#include <util.h>\n+#include <validation.h>\n+\n+/* The index database stores three items for each block: the encoded filter, its D256 hash, and the\n+ * header. Those belonging to blocks on the active chain are indexed by height, and those belonging\n+ * to blocks that have been reorganized out of the active chain are indexed by block hash. This\n+ * ensures that filter data for any block that becomes part of the active chain can always be\n+ * retrieved, alleviating timing concerns.\n+ *\n+ * Keys for the height index have the type pair<char, pair<DB_BLOCK_HEIGHT, int>>.\n+ * Keys for the hash index have the type pair<char, pair<DB_BLOCK_HASH, int>>.\n+ */\n+constexpr char DB_FILTER = 'f';\n+constexpr char DB_FILTER_HASH = 'h';\n+constexpr char DB_FILTER_HEADER = 'r';\n+\n+constexpr char DB_BLOCK_HASH = 's';\n+constexpr char DB_BLOCK_HEIGHT = 't';\n+\n+static std::map<BlockFilterType, BlockFilterIndex> g_filter_indexes;\n+\n+BlockFilterIndex::BlockFilterIndex(BlockFilterType filter_type,\n+                                   size_t n_cache_size, bool f_memory, bool f_wipe)\n+    : m_filter_type(filter_type)\n+{\n+    const std::string& filter_name = BlockFilterTypeName(filter_type);\n+    if (filter_name == \"\") throw std::invalid_argument(\"unknown filter_type\");\n+\n+    m_name = filter_name + \" block filter index\";\n+    m_db = MakeUnique<BaseIndex::DB>(GetDataDir() / \"indexes\" / \"blockfilter\" / filter_name,\n+                                     n_cache_size, f_memory, f_wipe);\n+}\n+\n+bool BlockFilterIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n+{\n+    CBlockUndo block_undo;\n+    uint256 prev_header;\n+\n+    if (pindex->nHeight > 0) {\n+        if (!UndoReadFromDisk(block_undo, pindex)) {\n+            return false;\n+        }\n+\n+        std::pair<uint256, uint256> read_out;\n+        std::pair<char, int> prev_height_key(DB_BLOCK_HEIGHT, pindex->nHeight - 1);\n+        if (!m_db->Read(std::make_pair(DB_FILTER_HEADER, prev_height_key), read_out)) {\n+            return false;\n+        }\n+\n+        uint256 expected_block_hash = pindex->pprev->GetBlockHash();\n+        if (read_out.first != expected_block_hash) {\n+            return error(\"%s: previous block header belongs to unexpected block %s; expected %s\",\n+                         __func__, read_out.first.ToString(), expected_block_hash.ToString());\n+        }\n+\n+        prev_header = read_out.second;\n+    }\n+\n+    BlockFilter filter(m_filter_type, block, block_undo);\n+    std::pair<char, int> height_key(DB_BLOCK_HEIGHT, pindex->nHeight);\n+\n+    CDBBatch batch(*m_db);\n+    batch.Write(std::make_pair(DB_FILTER, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.GetEncodedFilter()));\n+    batch.Write(std::make_pair(DB_FILTER_HASH, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.GetHash()));\n+    batch.Write(std::make_pair(DB_FILTER_HEADER, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.ComputeHeader(prev_header)));\n+    return m_db->WriteBatch(batch);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r214494925",
      "id" : 214494925,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDQ5NDkyNQ==",
      "original_commit_id" : "1c2079125a394197e577be272dd5caa899278672",
      "original_position" : 77,
      "path" : "src/index/blockfilter.cpp",
      "position" : null,
      "pull_request_review_id" : 151572564,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214494925",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3648618?v=4",
         "events_url" : "https://api.github.com/users/leishman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/leishman/followers",
         "following_url" : "https://api.github.com/users/leishman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/leishman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/leishman",
         "id" : 3648618,
         "login" : "leishman",
         "node_id" : "MDQ6VXNlcjM2NDg2MTg=",
         "organizations_url" : "https://api.github.com/users/leishman/orgs",
         "received_events_url" : "https://api.github.com/users/leishman/received_events",
         "repos_url" : "https://api.github.com/users/leishman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/leishman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/leishman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/leishman"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r214495167"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214495167"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "typo `differente`",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-08-31T23:33:47Z",
      "diff_hunk" : "@@ -0,0 +1,83 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INDEX_BLOCKFILTER_H\n+#define BITCOIN_INDEX_BLOCKFILTER_H\n+\n+#include <blockfilter.h>\n+#include <chain.h>\n+#include <index/base.h>\n+\n+/**\n+ * BlockFilterIndex is used to store and retrieve block filters, hashes, and headers for a range of\n+ * blocks by height. An index is constructed for each supported filter type with its own database\n+ * (ie. filter data for different types are stored in differente databases).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r214495167",
      "id" : 214495167,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDQ5NTE2Nw==",
      "original_commit_id" : "1c2079125a394197e577be272dd5caa899278672",
      "original_position" : 15,
      "path" : "src/index/blockfilter.h",
      "position" : null,
      "pull_request_review_id" : 151572855,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214495167",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3648618?v=4",
         "events_url" : "https://api.github.com/users/leishman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/leishman/followers",
         "following_url" : "https://api.github.com/users/leishman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/leishman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/leishman",
         "id" : 3648618,
         "login" : "leishman",
         "node_id" : "MDQ6VXNlcjM2NDg2MTg=",
         "organizations_url" : "https://api.github.com/users/leishman/orgs",
         "received_events_url" : "https://api.github.com/users/leishman/received_events",
         "repos_url" : "https://api.github.com/users/leishman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/leishman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/leishman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/leishman"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r214496437"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214496437"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is assigning to the dereferenced pointer here instead of using a vector function an optimization? I can't see an obvious reason there is anything wrong with this, but just double checking.",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-08-31T23:50:20Z",
      "diff_hunk" : "@@ -0,0 +1,289 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <map>\n+\n+#include <dbwrapper.h>\n+#include <index/blockfilter.h>\n+#include <util.h>\n+#include <validation.h>\n+\n+/* The index database stores three items for each block: the encoded filter, its D256 hash, and the\n+ * header. Those belonging to blocks on the active chain are indexed by height, and those belonging\n+ * to blocks that have been reorganized out of the active chain are indexed by block hash. This\n+ * ensures that filter data for any block that becomes part of the active chain can always be\n+ * retrieved, alleviating timing concerns.\n+ *\n+ * Keys for the height index have the type pair<char, pair<DB_BLOCK_HEIGHT, int>>.\n+ * Keys for the hash index have the type pair<char, pair<DB_BLOCK_HASH, int>>.\n+ */\n+constexpr char DB_FILTER = 'f';\n+constexpr char DB_FILTER_HASH = 'h';\n+constexpr char DB_FILTER_HEADER = 'r';\n+\n+constexpr char DB_BLOCK_HASH = 's';\n+constexpr char DB_BLOCK_HEIGHT = 't';\n+\n+static std::map<BlockFilterType, BlockFilterIndex> g_filter_indexes;\n+\n+BlockFilterIndex::BlockFilterIndex(BlockFilterType filter_type,\n+                                   size_t n_cache_size, bool f_memory, bool f_wipe)\n+    : m_filter_type(filter_type)\n+{\n+    const std::string& filter_name = BlockFilterTypeName(filter_type);\n+    if (filter_name == \"\") throw std::invalid_argument(\"unknown filter_type\");\n+\n+    m_name = filter_name + \" block filter index\";\n+    m_db = MakeUnique<BaseIndex::DB>(GetDataDir() / \"indexes\" / \"blockfilter\" / filter_name,\n+                                     n_cache_size, f_memory, f_wipe);\n+}\n+\n+bool BlockFilterIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n+{\n+    CBlockUndo block_undo;\n+    uint256 prev_header;\n+\n+    if (pindex->nHeight > 0) {\n+        if (!UndoReadFromDisk(block_undo, pindex)) {\n+            return false;\n+        }\n+\n+        std::pair<uint256, uint256> read_out;\n+        std::pair<char, int> prev_height_key(DB_BLOCK_HEIGHT, pindex->nHeight - 1);\n+        if (!m_db->Read(std::make_pair(DB_FILTER_HEADER, prev_height_key), read_out)) {\n+            return false;\n+        }\n+\n+        uint256 expected_block_hash = pindex->pprev->GetBlockHash();\n+        if (read_out.first != expected_block_hash) {\n+            return error(\"%s: previous block header belongs to unexpected block %s; expected %s\",\n+                         __func__, read_out.first.ToString(), expected_block_hash.ToString());\n+        }\n+\n+        prev_header = read_out.second;\n+    }\n+\n+    BlockFilter filter(m_filter_type, block, block_undo);\n+    std::pair<char, int> height_key(DB_BLOCK_HEIGHT, pindex->nHeight);\n+\n+    CDBBatch batch(*m_db);\n+    batch.Write(std::make_pair(DB_FILTER, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.GetEncodedFilter()));\n+    batch.Write(std::make_pair(DB_FILTER_HASH, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.GetHash()));\n+    batch.Write(std::make_pair(DB_FILTER_HEADER, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.ComputeHeader(prev_header)));\n+    return m_db->WriteBatch(batch);\n+}\n+\n+template <typename T>\n+static bool CopyHeightIndexToHashIndex(CDBIterator& db_it, CDBBatch& batch,\n+                                       const std::string& index_name, char key_prefix,\n+                                       int start_height, const CBlockIndex* stop_index)\n+{\n+    db_it.Seek(std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, start_height)));\n+\n+    for (int height = start_height; height <= stop_index->nHeight; ++height) {\n+        std::pair<char, std::pair<char, int>> key, expected_key;\n+        expected_key = std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, height));\n+\n+        if (!db_it.GetKey(key) || key != expected_key) {\n+            return error(\"%s: unexpected key in %s: expected (%c, (%c, %d))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HEIGHT, height);\n+        }\n+\n+        std::pair<uint256, T> value;\n+        if (!db_it.GetValue(value)) {\n+            return error(\"%s: unable to read value in %s at key (%c, (%c, %d))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HEIGHT, height);\n+        }\n+\n+        auto hash_key = std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HASH, value.first));\n+        batch.Write(hash_key, std::move(value.second));\n+\n+        db_it.Next();\n+    }\n+    return true;\n+}\n+\n+bool BlockFilterIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip)\n+{\n+    assert(current_tip->GetAncestor(new_tip->nHeight) == new_tip);\n+\n+    CDBBatch batch(*m_db);\n+    std::unique_ptr<CDBIterator> db_it(m_db->NewIterator());\n+\n+    if (!CopyHeightIndexToHashIndex<std::vector<unsigned char>>(*db_it, batch, m_name, DB_FILTER,\n+                                                                new_tip->nHeight, current_tip)) {\n+        return false;\n+    }\n+    if (!CopyHeightIndexToHashIndex<uint256>(*db_it, batch, m_name, DB_FILTER_HASH,\n+                                             new_tip->nHeight, current_tip)) {\n+        return false;\n+    }\n+    if (!CopyHeightIndexToHashIndex<uint256>(*db_it, batch, m_name, DB_FILTER_HEADER,\n+                                             new_tip->nHeight, current_tip)) {\n+        return false;\n+    }\n+\n+    if (!m_db->WriteBatch(batch)) return false;\n+\n+    return BaseIndex::Rewind(current_tip, new_tip);\n+}\n+\n+template <typename T>\n+static bool LookupOne(const CDBWrapper& db, char key_prefix,\n+                      const CBlockIndex* block_index, T& result)\n+{\n+    // First check if the result is stored under the height index and the value there matches the\n+    // block hash. This should be the case if the block is on the active chain.\n+    std::pair<char, int> height_key(DB_BLOCK_HEIGHT, block_index->nHeight);\n+    std::pair<uint256, T> read_out;\n+    if (!db.Read(std::make_pair(key_prefix, height_key), read_out)) {\n+        return false;\n+    }\n+    if (read_out.first == block_index->GetBlockHash()) {\n+        result = std::move(read_out.second);\n+        return true;\n+    }\n+\n+    // If value at the height index corresponds to an different block, the result will be stored in\n+    // the hash index.\n+    std::pair<char, uint256> hash_key(DB_BLOCK_HASH, block_index->GetBlockHash());\n+    return db.Read(std::make_pair(key_prefix, hash_key), result);\n+}\n+\n+template <typename T>\n+static bool LookupRange(CDBWrapper& db, const std::string& index_name,\n+                        char key_prefix, int start_height, const CBlockIndex* stop_index,\n+                        std::vector<T>& results)\n+{\n+    if (start_height < 0) {\n+        return error(\"%s: start height (%d) is negative\", __func__, start_height);\n+    }\n+    if (start_height > stop_index->nHeight) {\n+        return error(\"%s: start height (%d) is greater than stop height (%d)\",\n+                     __func__, start_height, stop_index->nHeight);\n+    }\n+\n+    std::vector<std::pair<uint256, T>> values(stop_index->nHeight - start_height + 1);\n+\n+    std::unique_ptr<CDBIterator> db_it(db.NewIterator());\n+    db_it->Seek(std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, start_height)));\n+    for (int height = start_height; height <= stop_index->nHeight; ++height) {\n+        std::pair<char, std::pair<char, int>> key, expected_key;\n+        expected_key = std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, height));\n+\n+        if (!db_it->Valid() || !db_it->GetKey(key) || key != expected_key) {\n+            return false;\n+        }\n+\n+        size_t i = height - start_height;\n+        if (!db_it->GetValue(values[i])) {\n+            return error(\"%s: unable to read value in %s at key (%c, (%c, %d))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HEIGHT, height);\n+        }\n+\n+        db_it->Next();\n+    }\n+\n+    results.resize(stop_index->nHeight - start_height + 1);\n+    for (const CBlockIndex* block_index = stop_index;\n+         block_index && block_index->nHeight >= start_height;\n+         block_index = block_index->pprev) {\n+        uint256 block_hash = block_index->GetBlockHash();\n+\n+        size_t i = block_index->nHeight - start_height;\n+        if (block_hash == values[i].first) {\n+            results[i] = std::move(values[i].second);\n+            continue;\n+        }\n+\n+        std::pair<char, uint256> hash_key(DB_BLOCK_HASH, block_hash);\n+        if (!db.Read(std::make_pair(key_prefix, hash_key), results[i])) {\n+            return error(\"%s: unable to read value in %s at key (%c, (%c, %s))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HASH, block_hash.ToString());\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+bool BlockFilterIndex::LookupFilter(const CBlockIndex* block_index, BlockFilter& filter_out) const\n+{\n+    std::vector<unsigned char> encoded_filter;\n+    if (!LookupOne(*m_db, DB_FILTER, block_index, encoded_filter)) {\n+        return false;\n+    }\n+\n+    filter_out = BlockFilter(m_filter_type, block_index->GetBlockHash(), std::move(encoded_filter));\n+    return true;\n+}\n+\n+bool BlockFilterIndex::LookupFilterHeader(const CBlockIndex* block_index, uint256& header_out) const\n+{\n+    return LookupOne(*m_db, DB_FILTER_HEADER, block_index, header_out);\n+}\n+\n+bool BlockFilterIndex::LookupFilterRange(int start_height, const CBlockIndex* stop_index,\n+                                         std::vector<BlockFilter>& filters_out) const\n+{\n+    std::vector<std::vector<unsigned char>> encoded_filters;\n+    if (!LookupRange(*m_db, m_name, DB_FILTER, start_height, stop_index, encoded_filters)) {\n+        return false;\n+    }\n+\n+    filters_out.resize(stop_index->nHeight - start_height + 1);\n+\n+    auto it = filters_out.rbegin();\n+    auto encoded_filter_it = encoded_filters.rbegin();\n+    const CBlockIndex* pindex = stop_index;\n+\n+    while (it != filters_out.rend()) {\n+        *it = BlockFilter(m_filter_type, pindex->GetBlockHash(), std::move(*encoded_filter_it));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r214496437",
      "id" : 214496437,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDQ5NjQzNw==",
      "original_commit_id" : "1c2079125a394197e577be272dd5caa899278672",
      "original_position" : 244,
      "path" : "src/index/blockfilter.cpp",
      "position" : null,
      "pull_request_review_id" : 151574447,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214496437",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3648618?v=4",
         "events_url" : "https://api.github.com/users/leishman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/leishman/followers",
         "following_url" : "https://api.github.com/users/leishman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/leishman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/leishman",
         "id" : 3648618,
         "login" : "leishman",
         "node_id" : "MDQ6VXNlcjM2NDg2MTg=",
         "organizations_url" : "https://api.github.com/users/leishman/orgs",
         "received_events_url" : "https://api.github.com/users/leishman/received_events",
         "repos_url" : "https://api.github.com/users/leishman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/leishman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/leishman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/leishman"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r214497299"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214497299"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "s/D256/DSHA256/",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-09-01T00:02:53Z",
      "diff_hunk" : "@@ -0,0 +1,289 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <map>\n+\n+#include <dbwrapper.h>\n+#include <index/blockfilter.h>\n+#include <util.h>\n+#include <validation.h>\n+\n+/* The index database stores three items for each block: the encoded filter, its D256 hash, and the",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r214497299",
      "id" : 214497299,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDQ5NzI5OQ==",
      "original_commit_id" : "b384c3e86c018c6e7cb701dd40dfa2a3f601e2a5",
      "original_position" : 12,
      "path" : "src/index/blockfilter.cpp",
      "position" : null,
      "pull_request_review_id" : 151575502,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214497299",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Storing large records in leveldb is generally a bad idea. Is there a particular reason this doesn't work like the undo data?",
      "created_at" : "2018-09-01T00:17:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#issuecomment-417818486",
      "id" : 417818486,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14121",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNzgxODQ4Ng==",
      "updated_at" : "2018-09-01T00:17:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/417818486",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@gmaxwell If by that you mean writing the filters sequentially in flat files then indexing the disk positions in LevelDB, I hadn't considered that, but it may be worthwhile. The downside of course is additional complexity. What are you mostly concerned about, read or write performance? I'd want to benchmark reads and writes to determine if the DB value sizes are problematic before making the change. With filters on average being 2% of block size and a LevelDB file size limit of 2 MiB, each file could still store ~200 filters (ignoring keys and overhead and such).",
      "created_at" : "2018-09-01T00:47:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#issuecomment-417820776",
      "id" : 417820776,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14121",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNzgyMDc3Ng==",
      "updated_at" : "2018-09-01T00:47:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/417820776",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r214548666"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214548666"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Could be worth looking into during ThreadSync. As you note though, it's a fairly independent change.",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-09-02T18:10:30Z",
      "diff_hunk" : "@@ -0,0 +1,289 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <map>\n+\n+#include <dbwrapper.h>\n+#include <index/blockfilter.h>\n+#include <util.h>\n+#include <validation.h>\n+\n+/* The index database stores three items for each block: the encoded filter, its D256 hash, and the\n+ * header. Those belonging to blocks on the active chain are indexed by height, and those belonging\n+ * to blocks that have been reorganized out of the active chain are indexed by block hash. This\n+ * ensures that filter data for any block that becomes part of the active chain can always be\n+ * retrieved, alleviating timing concerns.\n+ *\n+ * Keys for the height index have the type pair<char, pair<DB_BLOCK_HEIGHT, int>>.\n+ * Keys for the hash index have the type pair<char, pair<DB_BLOCK_HASH, int>>.\n+ */\n+constexpr char DB_FILTER = 'f';\n+constexpr char DB_FILTER_HASH = 'h';\n+constexpr char DB_FILTER_HEADER = 'r';\n+\n+constexpr char DB_BLOCK_HASH = 's';\n+constexpr char DB_BLOCK_HEIGHT = 't';\n+\n+static std::map<BlockFilterType, BlockFilterIndex> g_filter_indexes;\n+\n+BlockFilterIndex::BlockFilterIndex(BlockFilterType filter_type,\n+                                   size_t n_cache_size, bool f_memory, bool f_wipe)\n+    : m_filter_type(filter_type)\n+{\n+    const std::string& filter_name = BlockFilterTypeName(filter_type);\n+    if (filter_name == \"\") throw std::invalid_argument(\"unknown filter_type\");\n+\n+    m_name = filter_name + \" block filter index\";\n+    m_db = MakeUnique<BaseIndex::DB>(GetDataDir() / \"indexes\" / \"blockfilter\" / filter_name,\n+                                     n_cache_size, f_memory, f_wipe);\n+}\n+\n+bool BlockFilterIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n+{\n+    CBlockUndo block_undo;\n+    uint256 prev_header;\n+\n+    if (pindex->nHeight > 0) {\n+        if (!UndoReadFromDisk(block_undo, pindex)) {\n+            return false;\n+        }\n+\n+        std::pair<uint256, uint256> read_out;\n+        std::pair<char, int> prev_height_key(DB_BLOCK_HEIGHT, pindex->nHeight - 1);\n+        if (!m_db->Read(std::make_pair(DB_FILTER_HEADER, prev_height_key), read_out)) {\n+            return false;\n+        }\n+\n+        uint256 expected_block_hash = pindex->pprev->GetBlockHash();\n+        if (read_out.first != expected_block_hash) {\n+            return error(\"%s: previous block header belongs to unexpected block %s; expected %s\",\n+                         __func__, read_out.first.ToString(), expected_block_hash.ToString());\n+        }\n+\n+        prev_header = read_out.second;\n+    }\n+\n+    BlockFilter filter(m_filter_type, block, block_undo);\n+    std::pair<char, int> height_key(DB_BLOCK_HEIGHT, pindex->nHeight);\n+\n+    CDBBatch batch(*m_db);\n+    batch.Write(std::make_pair(DB_FILTER, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.GetEncodedFilter()));\n+    batch.Write(std::make_pair(DB_FILTER_HASH, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.GetHash()));\n+    batch.Write(std::make_pair(DB_FILTER_HEADER, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.ComputeHeader(prev_header)));\n+    return m_db->WriteBatch(batch);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r214548666",
      "id" : 214548666,
      "in_reply_to_id" : 214494925,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDU0ODY2Ng==",
      "original_commit_id" : "1c2079125a394197e577be272dd5caa899278672",
      "original_position" : 77,
      "path" : "src/index/blockfilter.cpp",
      "position" : null,
      "pull_request_review_id" : 151628758,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214548666",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r214548691"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214548691"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "What do you mean by a vector function? This just seemed to be the most immediate way to do the assignment to me.",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-09-02T18:11:23Z",
      "diff_hunk" : "@@ -0,0 +1,289 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <map>\n+\n+#include <dbwrapper.h>\n+#include <index/blockfilter.h>\n+#include <util.h>\n+#include <validation.h>\n+\n+/* The index database stores three items for each block: the encoded filter, its D256 hash, and the\n+ * header. Those belonging to blocks on the active chain are indexed by height, and those belonging\n+ * to blocks that have been reorganized out of the active chain are indexed by block hash. This\n+ * ensures that filter data for any block that becomes part of the active chain can always be\n+ * retrieved, alleviating timing concerns.\n+ *\n+ * Keys for the height index have the type pair<char, pair<DB_BLOCK_HEIGHT, int>>.\n+ * Keys for the hash index have the type pair<char, pair<DB_BLOCK_HASH, int>>.\n+ */\n+constexpr char DB_FILTER = 'f';\n+constexpr char DB_FILTER_HASH = 'h';\n+constexpr char DB_FILTER_HEADER = 'r';\n+\n+constexpr char DB_BLOCK_HASH = 's';\n+constexpr char DB_BLOCK_HEIGHT = 't';\n+\n+static std::map<BlockFilterType, BlockFilterIndex> g_filter_indexes;\n+\n+BlockFilterIndex::BlockFilterIndex(BlockFilterType filter_type,\n+                                   size_t n_cache_size, bool f_memory, bool f_wipe)\n+    : m_filter_type(filter_type)\n+{\n+    const std::string& filter_name = BlockFilterTypeName(filter_type);\n+    if (filter_name == \"\") throw std::invalid_argument(\"unknown filter_type\");\n+\n+    m_name = filter_name + \" block filter index\";\n+    m_db = MakeUnique<BaseIndex::DB>(GetDataDir() / \"indexes\" / \"blockfilter\" / filter_name,\n+                                     n_cache_size, f_memory, f_wipe);\n+}\n+\n+bool BlockFilterIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n+{\n+    CBlockUndo block_undo;\n+    uint256 prev_header;\n+\n+    if (pindex->nHeight > 0) {\n+        if (!UndoReadFromDisk(block_undo, pindex)) {\n+            return false;\n+        }\n+\n+        std::pair<uint256, uint256> read_out;\n+        std::pair<char, int> prev_height_key(DB_BLOCK_HEIGHT, pindex->nHeight - 1);\n+        if (!m_db->Read(std::make_pair(DB_FILTER_HEADER, prev_height_key), read_out)) {\n+            return false;\n+        }\n+\n+        uint256 expected_block_hash = pindex->pprev->GetBlockHash();\n+        if (read_out.first != expected_block_hash) {\n+            return error(\"%s: previous block header belongs to unexpected block %s; expected %s\",\n+                         __func__, read_out.first.ToString(), expected_block_hash.ToString());\n+        }\n+\n+        prev_header = read_out.second;\n+    }\n+\n+    BlockFilter filter(m_filter_type, block, block_undo);\n+    std::pair<char, int> height_key(DB_BLOCK_HEIGHT, pindex->nHeight);\n+\n+    CDBBatch batch(*m_db);\n+    batch.Write(std::make_pair(DB_FILTER, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.GetEncodedFilter()));\n+    batch.Write(std::make_pair(DB_FILTER_HASH, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.GetHash()));\n+    batch.Write(std::make_pair(DB_FILTER_HEADER, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.ComputeHeader(prev_header)));\n+    return m_db->WriteBatch(batch);\n+}\n+\n+template <typename T>\n+static bool CopyHeightIndexToHashIndex(CDBIterator& db_it, CDBBatch& batch,\n+                                       const std::string& index_name, char key_prefix,\n+                                       int start_height, const CBlockIndex* stop_index)\n+{\n+    db_it.Seek(std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, start_height)));\n+\n+    for (int height = start_height; height <= stop_index->nHeight; ++height) {\n+        std::pair<char, std::pair<char, int>> key, expected_key;\n+        expected_key = std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, height));\n+\n+        if (!db_it.GetKey(key) || key != expected_key) {\n+            return error(\"%s: unexpected key in %s: expected (%c, (%c, %d))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HEIGHT, height);\n+        }\n+\n+        std::pair<uint256, T> value;\n+        if (!db_it.GetValue(value)) {\n+            return error(\"%s: unable to read value in %s at key (%c, (%c, %d))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HEIGHT, height);\n+        }\n+\n+        auto hash_key = std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HASH, value.first));\n+        batch.Write(hash_key, std::move(value.second));\n+\n+        db_it.Next();\n+    }\n+    return true;\n+}\n+\n+bool BlockFilterIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip)\n+{\n+    assert(current_tip->GetAncestor(new_tip->nHeight) == new_tip);\n+\n+    CDBBatch batch(*m_db);\n+    std::unique_ptr<CDBIterator> db_it(m_db->NewIterator());\n+\n+    if (!CopyHeightIndexToHashIndex<std::vector<unsigned char>>(*db_it, batch, m_name, DB_FILTER,\n+                                                                new_tip->nHeight, current_tip)) {\n+        return false;\n+    }\n+    if (!CopyHeightIndexToHashIndex<uint256>(*db_it, batch, m_name, DB_FILTER_HASH,\n+                                             new_tip->nHeight, current_tip)) {\n+        return false;\n+    }\n+    if (!CopyHeightIndexToHashIndex<uint256>(*db_it, batch, m_name, DB_FILTER_HEADER,\n+                                             new_tip->nHeight, current_tip)) {\n+        return false;\n+    }\n+\n+    if (!m_db->WriteBatch(batch)) return false;\n+\n+    return BaseIndex::Rewind(current_tip, new_tip);\n+}\n+\n+template <typename T>\n+static bool LookupOne(const CDBWrapper& db, char key_prefix,\n+                      const CBlockIndex* block_index, T& result)\n+{\n+    // First check if the result is stored under the height index and the value there matches the\n+    // block hash. This should be the case if the block is on the active chain.\n+    std::pair<char, int> height_key(DB_BLOCK_HEIGHT, block_index->nHeight);\n+    std::pair<uint256, T> read_out;\n+    if (!db.Read(std::make_pair(key_prefix, height_key), read_out)) {\n+        return false;\n+    }\n+    if (read_out.first == block_index->GetBlockHash()) {\n+        result = std::move(read_out.second);\n+        return true;\n+    }\n+\n+    // If value at the height index corresponds to an different block, the result will be stored in\n+    // the hash index.\n+    std::pair<char, uint256> hash_key(DB_BLOCK_HASH, block_index->GetBlockHash());\n+    return db.Read(std::make_pair(key_prefix, hash_key), result);\n+}\n+\n+template <typename T>\n+static bool LookupRange(CDBWrapper& db, const std::string& index_name,\n+                        char key_prefix, int start_height, const CBlockIndex* stop_index,\n+                        std::vector<T>& results)\n+{\n+    if (start_height < 0) {\n+        return error(\"%s: start height (%d) is negative\", __func__, start_height);\n+    }\n+    if (start_height > stop_index->nHeight) {\n+        return error(\"%s: start height (%d) is greater than stop height (%d)\",\n+                     __func__, start_height, stop_index->nHeight);\n+    }\n+\n+    std::vector<std::pair<uint256, T>> values(stop_index->nHeight - start_height + 1);\n+\n+    std::unique_ptr<CDBIterator> db_it(db.NewIterator());\n+    db_it->Seek(std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, start_height)));\n+    for (int height = start_height; height <= stop_index->nHeight; ++height) {\n+        std::pair<char, std::pair<char, int>> key, expected_key;\n+        expected_key = std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, height));\n+\n+        if (!db_it->Valid() || !db_it->GetKey(key) || key != expected_key) {\n+            return false;\n+        }\n+\n+        size_t i = height - start_height;\n+        if (!db_it->GetValue(values[i])) {\n+            return error(\"%s: unable to read value in %s at key (%c, (%c, %d))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HEIGHT, height);\n+        }\n+\n+        db_it->Next();\n+    }\n+\n+    results.resize(stop_index->nHeight - start_height + 1);\n+    for (const CBlockIndex* block_index = stop_index;\n+         block_index && block_index->nHeight >= start_height;\n+         block_index = block_index->pprev) {\n+        uint256 block_hash = block_index->GetBlockHash();\n+\n+        size_t i = block_index->nHeight - start_height;\n+        if (block_hash == values[i].first) {\n+            results[i] = std::move(values[i].second);\n+            continue;\n+        }\n+\n+        std::pair<char, uint256> hash_key(DB_BLOCK_HASH, block_hash);\n+        if (!db.Read(std::make_pair(key_prefix, hash_key), results[i])) {\n+            return error(\"%s: unable to read value in %s at key (%c, (%c, %s))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HASH, block_hash.ToString());\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+bool BlockFilterIndex::LookupFilter(const CBlockIndex* block_index, BlockFilter& filter_out) const\n+{\n+    std::vector<unsigned char> encoded_filter;\n+    if (!LookupOne(*m_db, DB_FILTER, block_index, encoded_filter)) {\n+        return false;\n+    }\n+\n+    filter_out = BlockFilter(m_filter_type, block_index->GetBlockHash(), std::move(encoded_filter));\n+    return true;\n+}\n+\n+bool BlockFilterIndex::LookupFilterHeader(const CBlockIndex* block_index, uint256& header_out) const\n+{\n+    return LookupOne(*m_db, DB_FILTER_HEADER, block_index, header_out);\n+}\n+\n+bool BlockFilterIndex::LookupFilterRange(int start_height, const CBlockIndex* stop_index,\n+                                         std::vector<BlockFilter>& filters_out) const\n+{\n+    std::vector<std::vector<unsigned char>> encoded_filters;\n+    if (!LookupRange(*m_db, m_name, DB_FILTER, start_height, stop_index, encoded_filters)) {\n+        return false;\n+    }\n+\n+    filters_out.resize(stop_index->nHeight - start_height + 1);\n+\n+    auto it = filters_out.rbegin();\n+    auto encoded_filter_it = encoded_filters.rbegin();\n+    const CBlockIndex* pindex = stop_index;\n+\n+    while (it != filters_out.rend()) {\n+        *it = BlockFilter(m_filter_type, pindex->GetBlockHash(), std::move(*encoded_filter_it));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r214548691",
      "id" : 214548691,
      "in_reply_to_id" : 214496437,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDU0ODY5MQ==",
      "original_commit_id" : "1c2079125a394197e577be272dd5caa899278672",
      "original_position" : 244,
      "path" : "src/index/blockfilter.cpp",
      "position" : null,
      "pull_request_review_id" : 151628780,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214548691",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r214550876"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214550876"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I meant using something like `insert` instead of direct assignment. It's been a while since I've written a lot of c++. ",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-09-02T19:40:14Z",
      "diff_hunk" : "@@ -0,0 +1,289 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <map>\n+\n+#include <dbwrapper.h>\n+#include <index/blockfilter.h>\n+#include <util.h>\n+#include <validation.h>\n+\n+/* The index database stores three items for each block: the encoded filter, its D256 hash, and the\n+ * header. Those belonging to blocks on the active chain are indexed by height, and those belonging\n+ * to blocks that have been reorganized out of the active chain are indexed by block hash. This\n+ * ensures that filter data for any block that becomes part of the active chain can always be\n+ * retrieved, alleviating timing concerns.\n+ *\n+ * Keys for the height index have the type pair<char, pair<DB_BLOCK_HEIGHT, int>>.\n+ * Keys for the hash index have the type pair<char, pair<DB_BLOCK_HASH, int>>.\n+ */\n+constexpr char DB_FILTER = 'f';\n+constexpr char DB_FILTER_HASH = 'h';\n+constexpr char DB_FILTER_HEADER = 'r';\n+\n+constexpr char DB_BLOCK_HASH = 's';\n+constexpr char DB_BLOCK_HEIGHT = 't';\n+\n+static std::map<BlockFilterType, BlockFilterIndex> g_filter_indexes;\n+\n+BlockFilterIndex::BlockFilterIndex(BlockFilterType filter_type,\n+                                   size_t n_cache_size, bool f_memory, bool f_wipe)\n+    : m_filter_type(filter_type)\n+{\n+    const std::string& filter_name = BlockFilterTypeName(filter_type);\n+    if (filter_name == \"\") throw std::invalid_argument(\"unknown filter_type\");\n+\n+    m_name = filter_name + \" block filter index\";\n+    m_db = MakeUnique<BaseIndex::DB>(GetDataDir() / \"indexes\" / \"blockfilter\" / filter_name,\n+                                     n_cache_size, f_memory, f_wipe);\n+}\n+\n+bool BlockFilterIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n+{\n+    CBlockUndo block_undo;\n+    uint256 prev_header;\n+\n+    if (pindex->nHeight > 0) {\n+        if (!UndoReadFromDisk(block_undo, pindex)) {\n+            return false;\n+        }\n+\n+        std::pair<uint256, uint256> read_out;\n+        std::pair<char, int> prev_height_key(DB_BLOCK_HEIGHT, pindex->nHeight - 1);\n+        if (!m_db->Read(std::make_pair(DB_FILTER_HEADER, prev_height_key), read_out)) {\n+            return false;\n+        }\n+\n+        uint256 expected_block_hash = pindex->pprev->GetBlockHash();\n+        if (read_out.first != expected_block_hash) {\n+            return error(\"%s: previous block header belongs to unexpected block %s; expected %s\",\n+                         __func__, read_out.first.ToString(), expected_block_hash.ToString());\n+        }\n+\n+        prev_header = read_out.second;\n+    }\n+\n+    BlockFilter filter(m_filter_type, block, block_undo);\n+    std::pair<char, int> height_key(DB_BLOCK_HEIGHT, pindex->nHeight);\n+\n+    CDBBatch batch(*m_db);\n+    batch.Write(std::make_pair(DB_FILTER, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.GetEncodedFilter()));\n+    batch.Write(std::make_pair(DB_FILTER_HASH, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.GetHash()));\n+    batch.Write(std::make_pair(DB_FILTER_HEADER, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.ComputeHeader(prev_header)));\n+    return m_db->WriteBatch(batch);\n+}\n+\n+template <typename T>\n+static bool CopyHeightIndexToHashIndex(CDBIterator& db_it, CDBBatch& batch,\n+                                       const std::string& index_name, char key_prefix,\n+                                       int start_height, const CBlockIndex* stop_index)\n+{\n+    db_it.Seek(std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, start_height)));\n+\n+    for (int height = start_height; height <= stop_index->nHeight; ++height) {\n+        std::pair<char, std::pair<char, int>> key, expected_key;\n+        expected_key = std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, height));\n+\n+        if (!db_it.GetKey(key) || key != expected_key) {\n+            return error(\"%s: unexpected key in %s: expected (%c, (%c, %d))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HEIGHT, height);\n+        }\n+\n+        std::pair<uint256, T> value;\n+        if (!db_it.GetValue(value)) {\n+            return error(\"%s: unable to read value in %s at key (%c, (%c, %d))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HEIGHT, height);\n+        }\n+\n+        auto hash_key = std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HASH, value.first));\n+        batch.Write(hash_key, std::move(value.second));\n+\n+        db_it.Next();\n+    }\n+    return true;\n+}\n+\n+bool BlockFilterIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip)\n+{\n+    assert(current_tip->GetAncestor(new_tip->nHeight) == new_tip);\n+\n+    CDBBatch batch(*m_db);\n+    std::unique_ptr<CDBIterator> db_it(m_db->NewIterator());\n+\n+    if (!CopyHeightIndexToHashIndex<std::vector<unsigned char>>(*db_it, batch, m_name, DB_FILTER,\n+                                                                new_tip->nHeight, current_tip)) {\n+        return false;\n+    }\n+    if (!CopyHeightIndexToHashIndex<uint256>(*db_it, batch, m_name, DB_FILTER_HASH,\n+                                             new_tip->nHeight, current_tip)) {\n+        return false;\n+    }\n+    if (!CopyHeightIndexToHashIndex<uint256>(*db_it, batch, m_name, DB_FILTER_HEADER,\n+                                             new_tip->nHeight, current_tip)) {\n+        return false;\n+    }\n+\n+    if (!m_db->WriteBatch(batch)) return false;\n+\n+    return BaseIndex::Rewind(current_tip, new_tip);\n+}\n+\n+template <typename T>\n+static bool LookupOne(const CDBWrapper& db, char key_prefix,\n+                      const CBlockIndex* block_index, T& result)\n+{\n+    // First check if the result is stored under the height index and the value there matches the\n+    // block hash. This should be the case if the block is on the active chain.\n+    std::pair<char, int> height_key(DB_BLOCK_HEIGHT, block_index->nHeight);\n+    std::pair<uint256, T> read_out;\n+    if (!db.Read(std::make_pair(key_prefix, height_key), read_out)) {\n+        return false;\n+    }\n+    if (read_out.first == block_index->GetBlockHash()) {\n+        result = std::move(read_out.second);\n+        return true;\n+    }\n+\n+    // If value at the height index corresponds to an different block, the result will be stored in\n+    // the hash index.\n+    std::pair<char, uint256> hash_key(DB_BLOCK_HASH, block_index->GetBlockHash());\n+    return db.Read(std::make_pair(key_prefix, hash_key), result);\n+}\n+\n+template <typename T>\n+static bool LookupRange(CDBWrapper& db, const std::string& index_name,\n+                        char key_prefix, int start_height, const CBlockIndex* stop_index,\n+                        std::vector<T>& results)\n+{\n+    if (start_height < 0) {\n+        return error(\"%s: start height (%d) is negative\", __func__, start_height);\n+    }\n+    if (start_height > stop_index->nHeight) {\n+        return error(\"%s: start height (%d) is greater than stop height (%d)\",\n+                     __func__, start_height, stop_index->nHeight);\n+    }\n+\n+    std::vector<std::pair<uint256, T>> values(stop_index->nHeight - start_height + 1);\n+\n+    std::unique_ptr<CDBIterator> db_it(db.NewIterator());\n+    db_it->Seek(std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, start_height)));\n+    for (int height = start_height; height <= stop_index->nHeight; ++height) {\n+        std::pair<char, std::pair<char, int>> key, expected_key;\n+        expected_key = std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, height));\n+\n+        if (!db_it->Valid() || !db_it->GetKey(key) || key != expected_key) {\n+            return false;\n+        }\n+\n+        size_t i = height - start_height;\n+        if (!db_it->GetValue(values[i])) {\n+            return error(\"%s: unable to read value in %s at key (%c, (%c, %d))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HEIGHT, height);\n+        }\n+\n+        db_it->Next();\n+    }\n+\n+    results.resize(stop_index->nHeight - start_height + 1);\n+    for (const CBlockIndex* block_index = stop_index;\n+         block_index && block_index->nHeight >= start_height;\n+         block_index = block_index->pprev) {\n+        uint256 block_hash = block_index->GetBlockHash();\n+\n+        size_t i = block_index->nHeight - start_height;\n+        if (block_hash == values[i].first) {\n+            results[i] = std::move(values[i].second);\n+            continue;\n+        }\n+\n+        std::pair<char, uint256> hash_key(DB_BLOCK_HASH, block_hash);\n+        if (!db.Read(std::make_pair(key_prefix, hash_key), results[i])) {\n+            return error(\"%s: unable to read value in %s at key (%c, (%c, %s))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HASH, block_hash.ToString());\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+bool BlockFilterIndex::LookupFilter(const CBlockIndex* block_index, BlockFilter& filter_out) const\n+{\n+    std::vector<unsigned char> encoded_filter;\n+    if (!LookupOne(*m_db, DB_FILTER, block_index, encoded_filter)) {\n+        return false;\n+    }\n+\n+    filter_out = BlockFilter(m_filter_type, block_index->GetBlockHash(), std::move(encoded_filter));\n+    return true;\n+}\n+\n+bool BlockFilterIndex::LookupFilterHeader(const CBlockIndex* block_index, uint256& header_out) const\n+{\n+    return LookupOne(*m_db, DB_FILTER_HEADER, block_index, header_out);\n+}\n+\n+bool BlockFilterIndex::LookupFilterRange(int start_height, const CBlockIndex* stop_index,\n+                                         std::vector<BlockFilter>& filters_out) const\n+{\n+    std::vector<std::vector<unsigned char>> encoded_filters;\n+    if (!LookupRange(*m_db, m_name, DB_FILTER, start_height, stop_index, encoded_filters)) {\n+        return false;\n+    }\n+\n+    filters_out.resize(stop_index->nHeight - start_height + 1);\n+\n+    auto it = filters_out.rbegin();\n+    auto encoded_filter_it = encoded_filters.rbegin();\n+    const CBlockIndex* pindex = stop_index;\n+\n+    while (it != filters_out.rend()) {\n+        *it = BlockFilter(m_filter_type, pindex->GetBlockHash(), std::move(*encoded_filter_it));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r214550876",
      "id" : 214550876,
      "in_reply_to_id" : 214496437,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNDU1MDg3Ng==",
      "original_commit_id" : "1c2079125a394197e577be272dd5caa899278672",
      "original_position" : 244,
      "path" : "src/index/blockfilter.cpp",
      "position" : null,
      "pull_request_review_id" : 151630949,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/214550876",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3648618?v=4",
         "events_url" : "https://api.github.com/users/leishman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/leishman/followers",
         "following_url" : "https://api.github.com/users/leishman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/leishman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/leishman",
         "id" : 3648618,
         "login" : "leishman",
         "node_id" : "MDQ6VXNlcjM2NDg2MTg=",
         "organizations_url" : "https://api.github.com/users/leishman/orgs",
         "received_events_url" : "https://api.github.com/users/leishman/received_events",
         "repos_url" : "https://api.github.com/users/leishman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/leishman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/leishman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/leishman"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@gmaxwell I put together a (not-production-ready) [branch](https://github.com/jimpo/bitcoin/tree/bip157-index-ff) to test your suggestion of writing filters to flat files. In sample size n=1 experiments, I measured that the time to write the entire block index was <1% faster using flat files, and reading 5,000 sequential filters (starting at height 500,000) was 11% slower. The total storage space consumed is nearly the same (3.4 GiB total). Happy to provide the log files/iPython notebooks I used if you'd like.\r\n\r\nGiven the additional complexity and absence of significantly improved performance, I think writing filters directly into LevelDB is the way to go.",
      "created_at" : "2018-09-03T01:45:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#issuecomment-417978694",
      "id" : 417978694,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14121",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQxNzk3ODY5NA==",
      "updated_at" : "2018-09-03T01:47:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/417978694",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r215163302"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215163302"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Please make `explicit` :-)",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-09-05T07:35:45Z",
      "diff_hunk" : "@@ -44,19 +54,16 @@ class GCSFilter\n public:\n \n     /** Constructs an empty filter. */\n-    GCSFilter(uint64_t siphash_k0 = 0, uint64_t siphash_k1 = 0, uint8_t P = 0, uint32_t M = 0);\n+    GCSFilter(const Params& params = Params());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r215163302",
      "id" : 215163302,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTE2MzMwMg==",
      "original_commit_id" : "9b1e7a6cf213590e016bc26f2a094f2b6d59eb93",
      "original_position" : 38,
      "path" : "src/blockfilter.h",
      "position" : null,
      "pull_request_review_id" : 152367186,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215163302",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r215163648"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215163648"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Assertions should not have side effects. Please move `GetAncestor` outside of assertion :-)",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-09-05T07:37:09Z",
      "diff_hunk" : "@@ -0,0 +1,289 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <map>\n+\n+#include <dbwrapper.h>\n+#include <index/blockfilter.h>\n+#include <util.h>\n+#include <validation.h>\n+\n+/* The index database stores three items for each block: the encoded filter, its dSHA256 hash, and\n+ * the header. Those belonging to blocks on the active chain are indexed by height, and those\n+ * belonging to blocks that have been reorganized out of the active chain are indexed by block hash.\n+ * This ensures that filter data for any block that becomes part of the active chain can always be\n+ * retrieved, alleviating timing concerns.\n+ *\n+ * Keys for the height index have the type pair<char, pair<DB_BLOCK_HEIGHT, int>>.\n+ * Keys for the hash index have the type pair<char, pair<DB_BLOCK_HASH, int>>.\n+ */\n+constexpr char DB_FILTER = 'f';\n+constexpr char DB_FILTER_HASH = 'h';\n+constexpr char DB_FILTER_HEADER = 'r';\n+\n+constexpr char DB_BLOCK_HASH = 's';\n+constexpr char DB_BLOCK_HEIGHT = 't';\n+\n+static std::map<BlockFilterType, BlockFilterIndex> g_filter_indexes;\n+\n+BlockFilterIndex::BlockFilterIndex(BlockFilterType filter_type,\n+                                   size_t n_cache_size, bool f_memory, bool f_wipe)\n+    : m_filter_type(filter_type)\n+{\n+    const std::string& filter_name = BlockFilterTypeName(filter_type);\n+    if (filter_name == \"\") throw std::invalid_argument(\"unknown filter_type\");\n+\n+    m_name = filter_name + \" block filter index\";\n+    m_db = MakeUnique<BaseIndex::DB>(GetDataDir() / \"indexes\" / \"blockfilter\" / filter_name,\n+                                     n_cache_size, f_memory, f_wipe);\n+}\n+\n+bool BlockFilterIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n+{\n+    CBlockUndo block_undo;\n+    uint256 prev_header;\n+\n+    if (pindex->nHeight > 0) {\n+        if (!UndoReadFromDisk(block_undo, pindex)) {\n+            return false;\n+        }\n+\n+        std::pair<uint256, uint256> read_out;\n+        std::pair<char, int> prev_height_key(DB_BLOCK_HEIGHT, pindex->nHeight - 1);\n+        if (!m_db->Read(std::make_pair(DB_FILTER_HEADER, prev_height_key), read_out)) {\n+            return false;\n+        }\n+\n+        uint256 expected_block_hash = pindex->pprev->GetBlockHash();\n+        if (read_out.first != expected_block_hash) {\n+            return error(\"%s: previous block header belongs to unexpected block %s; expected %s\",\n+                         __func__, read_out.first.ToString(), expected_block_hash.ToString());\n+        }\n+\n+        prev_header = read_out.second;\n+    }\n+\n+    BlockFilter filter(m_filter_type, block, block_undo);\n+    std::pair<char, int> height_key(DB_BLOCK_HEIGHT, pindex->nHeight);\n+\n+    CDBBatch batch(*m_db);\n+    batch.Write(std::make_pair(DB_FILTER, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.GetEncodedFilter()));\n+    batch.Write(std::make_pair(DB_FILTER_HASH, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.GetHash()));\n+    batch.Write(std::make_pair(DB_FILTER_HEADER, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.ComputeHeader(prev_header)));\n+    return m_db->WriteBatch(batch);\n+}\n+\n+template <typename T>\n+static bool CopyHeightIndexToHashIndex(CDBIterator& db_it, CDBBatch& batch,\n+                                       const std::string& index_name, char key_prefix,\n+                                       int start_height, const CBlockIndex* stop_index)\n+{\n+    db_it.Seek(std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, start_height)));\n+\n+    for (int height = start_height; height <= stop_index->nHeight; ++height) {\n+        std::pair<char, std::pair<char, int>> key, expected_key;\n+        expected_key = std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, height));\n+\n+        if (!db_it.GetKey(key) || key != expected_key) {\n+            return error(\"%s: unexpected key in %s: expected (%c, (%c, %d))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HEIGHT, height);\n+        }\n+\n+        std::pair<uint256, T> value;\n+        if (!db_it.GetValue(value)) {\n+            return error(\"%s: unable to read value in %s at key (%c, (%c, %d))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HEIGHT, height);\n+        }\n+\n+        auto hash_key = std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HASH, value.first));\n+        batch.Write(hash_key, std::move(value.second));\n+\n+        db_it.Next();\n+    }\n+    return true;\n+}\n+\n+bool BlockFilterIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip)\n+{\n+    assert(current_tip->GetAncestor(new_tip->nHeight) == new_tip);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r215163648",
      "id" : 215163648,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTE2MzY0OA==",
      "original_commit_id" : "9b1e7a6cf213590e016bc26f2a094f2b6d59eb93",
      "original_position" : 112,
      "path" : "src/index/blockfilter.cpp",
      "position" : null,
      "pull_request_review_id" : 152367624,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215163648",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r215163868"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215163868"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Remove `GetParams()`? Not used?",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-09-05T07:38:03Z",
      "diff_hunk" : "@@ -44,19 +54,16 @@ class GCSFilter\n public:\n \n     /** Constructs an empty filter. */\n-    GCSFilter(uint64_t siphash_k0 = 0, uint64_t siphash_k1 = 0, uint8_t P = 0, uint32_t M = 0);\n+    GCSFilter(const Params& params = Params());\n \n     /** Reconstructs an already-created filter from an encoding. */\n-    GCSFilter(uint64_t siphash_k0, uint64_t siphash_k1, uint8_t P, uint32_t M,\n-              std::vector<unsigned char> encoded_filter);\n+    GCSFilter(const Params& params, std::vector<unsigned char> encoded_filter);\n \n     /** Builds a new filter from the params and set of elements. */\n-    GCSFilter(uint64_t siphash_k0, uint64_t siphash_k1, uint8_t P, uint32_t M,\n-              const ElementSet& elements);\n+    GCSFilter(const Params& params, const ElementSet& elements);\n \n-    uint8_t GetP() const { return m_P; }\n     uint32_t GetN() const { return m_N; }\n-    uint32_t GetM() const { return m_M; }\n+    const Params& GetParams() const { return m_params; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r215163868",
      "id" : 215163868,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTE2Mzg2OA==",
      "original_commit_id" : "9b1e7a6cf213590e016bc26f2a094f2b6d59eb93",
      "original_position" : 53,
      "path" : "src/blockfilter.h",
      "position" : 53,
      "pull_request_review_id" : 152367896,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215163868",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r215449867"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215449867"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "What is the side effect? `GetAncestor` is a `const` method.",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-09-05T22:53:02Z",
      "diff_hunk" : "@@ -0,0 +1,289 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <map>\n+\n+#include <dbwrapper.h>\n+#include <index/blockfilter.h>\n+#include <util.h>\n+#include <validation.h>\n+\n+/* The index database stores three items for each block: the encoded filter, its dSHA256 hash, and\n+ * the header. Those belonging to blocks on the active chain are indexed by height, and those\n+ * belonging to blocks that have been reorganized out of the active chain are indexed by block hash.\n+ * This ensures that filter data for any block that becomes part of the active chain can always be\n+ * retrieved, alleviating timing concerns.\n+ *\n+ * Keys for the height index have the type pair<char, pair<DB_BLOCK_HEIGHT, int>>.\n+ * Keys for the hash index have the type pair<char, pair<DB_BLOCK_HASH, int>>.\n+ */\n+constexpr char DB_FILTER = 'f';\n+constexpr char DB_FILTER_HASH = 'h';\n+constexpr char DB_FILTER_HEADER = 'r';\n+\n+constexpr char DB_BLOCK_HASH = 's';\n+constexpr char DB_BLOCK_HEIGHT = 't';\n+\n+static std::map<BlockFilterType, BlockFilterIndex> g_filter_indexes;\n+\n+BlockFilterIndex::BlockFilterIndex(BlockFilterType filter_type,\n+                                   size_t n_cache_size, bool f_memory, bool f_wipe)\n+    : m_filter_type(filter_type)\n+{\n+    const std::string& filter_name = BlockFilterTypeName(filter_type);\n+    if (filter_name == \"\") throw std::invalid_argument(\"unknown filter_type\");\n+\n+    m_name = filter_name + \" block filter index\";\n+    m_db = MakeUnique<BaseIndex::DB>(GetDataDir() / \"indexes\" / \"blockfilter\" / filter_name,\n+                                     n_cache_size, f_memory, f_wipe);\n+}\n+\n+bool BlockFilterIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n+{\n+    CBlockUndo block_undo;\n+    uint256 prev_header;\n+\n+    if (pindex->nHeight > 0) {\n+        if (!UndoReadFromDisk(block_undo, pindex)) {\n+            return false;\n+        }\n+\n+        std::pair<uint256, uint256> read_out;\n+        std::pair<char, int> prev_height_key(DB_BLOCK_HEIGHT, pindex->nHeight - 1);\n+        if (!m_db->Read(std::make_pair(DB_FILTER_HEADER, prev_height_key), read_out)) {\n+            return false;\n+        }\n+\n+        uint256 expected_block_hash = pindex->pprev->GetBlockHash();\n+        if (read_out.first != expected_block_hash) {\n+            return error(\"%s: previous block header belongs to unexpected block %s; expected %s\",\n+                         __func__, read_out.first.ToString(), expected_block_hash.ToString());\n+        }\n+\n+        prev_header = read_out.second;\n+    }\n+\n+    BlockFilter filter(m_filter_type, block, block_undo);\n+    std::pair<char, int> height_key(DB_BLOCK_HEIGHT, pindex->nHeight);\n+\n+    CDBBatch batch(*m_db);\n+    batch.Write(std::make_pair(DB_FILTER, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.GetEncodedFilter()));\n+    batch.Write(std::make_pair(DB_FILTER_HASH, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.GetHash()));\n+    batch.Write(std::make_pair(DB_FILTER_HEADER, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.ComputeHeader(prev_header)));\n+    return m_db->WriteBatch(batch);\n+}\n+\n+template <typename T>\n+static bool CopyHeightIndexToHashIndex(CDBIterator& db_it, CDBBatch& batch,\n+                                       const std::string& index_name, char key_prefix,\n+                                       int start_height, const CBlockIndex* stop_index)\n+{\n+    db_it.Seek(std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, start_height)));\n+\n+    for (int height = start_height; height <= stop_index->nHeight; ++height) {\n+        std::pair<char, std::pair<char, int>> key, expected_key;\n+        expected_key = std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, height));\n+\n+        if (!db_it.GetKey(key) || key != expected_key) {\n+            return error(\"%s: unexpected key in %s: expected (%c, (%c, %d))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HEIGHT, height);\n+        }\n+\n+        std::pair<uint256, T> value;\n+        if (!db_it.GetValue(value)) {\n+            return error(\"%s: unable to read value in %s at key (%c, (%c, %d))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HEIGHT, height);\n+        }\n+\n+        auto hash_key = std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HASH, value.first));\n+        batch.Write(hash_key, std::move(value.second));\n+\n+        db_it.Next();\n+    }\n+    return true;\n+}\n+\n+bool BlockFilterIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip)\n+{\n+    assert(current_tip->GetAncestor(new_tip->nHeight) == new_tip);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r215449867",
      "id" : 215449867,
      "in_reply_to_id" : 215163648,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTQ0OTg2Nw==",
      "original_commit_id" : "9b1e7a6cf213590e016bc26f2a094f2b6d59eb93",
      "original_position" : 112,
      "path" : "src/index/blockfilter.cpp",
      "position" : null,
      "pull_request_review_id" : 152718402,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215449867",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r215449989"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215449989"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "No, it's not used, but it feels like there should be a getter.",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-09-05T22:53:37Z",
      "diff_hunk" : "@@ -44,19 +54,16 @@ class GCSFilter\n public:\n \n     /** Constructs an empty filter. */\n-    GCSFilter(uint64_t siphash_k0 = 0, uint64_t siphash_k1 = 0, uint8_t P = 0, uint32_t M = 0);\n+    GCSFilter(const Params& params = Params());\n \n     /** Reconstructs an already-created filter from an encoding. */\n-    GCSFilter(uint64_t siphash_k0, uint64_t siphash_k1, uint8_t P, uint32_t M,\n-              std::vector<unsigned char> encoded_filter);\n+    GCSFilter(const Params& params, std::vector<unsigned char> encoded_filter);\n \n     /** Builds a new filter from the params and set of elements. */\n-    GCSFilter(uint64_t siphash_k0, uint64_t siphash_k1, uint8_t P, uint32_t M,\n-              const ElementSet& elements);\n+    GCSFilter(const Params& params, const ElementSet& elements);\n \n-    uint8_t GetP() const { return m_P; }\n     uint32_t GetN() const { return m_N; }\n-    uint32_t GetM() const { return m_M; }\n+    const Params& GetParams() const { return m_params; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r215449989",
      "id" : 215449989,
      "in_reply_to_id" : 215163868,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTQ0OTk4OQ==",
      "original_commit_id" : "9b1e7a6cf213590e016bc26f2a094f2b6d59eb93",
      "original_position" : 53,
      "path" : "src/blockfilter.h",
      "position" : 53,
      "pull_request_review_id" : 152718528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215449989",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r215523962"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215523962"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Unused code is untested code, so I suggest removing it or adding a test for it :-)",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-09-06T07:40:13Z",
      "diff_hunk" : "@@ -44,19 +54,16 @@ class GCSFilter\n public:\n \n     /** Constructs an empty filter. */\n-    GCSFilter(uint64_t siphash_k0 = 0, uint64_t siphash_k1 = 0, uint8_t P = 0, uint32_t M = 0);\n+    GCSFilter(const Params& params = Params());\n \n     /** Reconstructs an already-created filter from an encoding. */\n-    GCSFilter(uint64_t siphash_k0, uint64_t siphash_k1, uint8_t P, uint32_t M,\n-              std::vector<unsigned char> encoded_filter);\n+    GCSFilter(const Params& params, std::vector<unsigned char> encoded_filter);\n \n     /** Builds a new filter from the params and set of elements. */\n-    GCSFilter(uint64_t siphash_k0, uint64_t siphash_k1, uint8_t P, uint32_t M,\n-              const ElementSet& elements);\n+    GCSFilter(const Params& params, const ElementSet& elements);\n \n-    uint8_t GetP() const { return m_P; }\n     uint32_t GetN() const { return m_N; }\n-    uint32_t GetM() const { return m_M; }\n+    const Params& GetParams() const { return m_params; }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r215523962",
      "id" : 215523962,
      "in_reply_to_id" : 215163868,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTUyMzk2Mg==",
      "original_commit_id" : "9b1e7a6cf213590e016bc26f2a094f2b6d59eb93",
      "original_position" : 53,
      "path" : "src/blockfilter.h",
      "position" : 53,
      "pull_request_review_id" : 152805690,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215523962",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r215872796"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215872796"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n./test/functional/rpc_getblockfilter.py:21:17: E211 whitespace before '('\r\n```",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-09-07T07:43:57Z",
      "diff_hunk" : "@@ -0,0 +1,59 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2018 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test the getblockfilter RPC.\"\"\"\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import (\n+    assert_equal, assert_is_hex_string, assert_raises_rpc_error,\n+    connect_nodes, disconnect_nodes, sync_blocks\n+    )\n+\n+FILTER_TYPES = [\"basic\"]\n+\n+class GetBlockFilterTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.setup_clean_chain = True\n+        self.num_nodes = 2\n+        self.extra_args = [[\"-blockfilterindex\"], []]\n+\n+    def run_test (self):",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r215872796",
      "id" : 215872796,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNTg3Mjc5Ng==",
      "original_commit_id" : "9b1e7a6cf213590e016bc26f2a094f2b6d59eb93",
      "original_position" : 21,
      "path" : "test/functional/rpc_getblockfilter.py",
      "position" : null,
      "pull_request_review_id" : 153234072,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/215872796",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r216003484"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/216003484"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can you explain this? What would be wrong with always indexing by block hash? Especially given that `getblockfilter` takes a block hash argument. ",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-09-07T15:45:12Z",
      "diff_hunk" : "@@ -0,0 +1,289 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <map>\n+\n+#include <dbwrapper.h>\n+#include <index/blockfilter.h>\n+#include <util.h>\n+#include <validation.h>\n+\n+/* The index database stores three items for each block: the encoded filter, its dSHA256 hash, and\n+ * the header. Those belonging to blocks on the active chain are indexed by height, and those\n+ * belonging to blocks that have been reorganized out of the active chain are indexed by block hash.\n+ * This ensures that filter data for any block that becomes part of the active chain can always be\n+ * retrieved, alleviating timing concerns.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r216003484",
      "id" : 216003484,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNjAwMzQ4NA==",
      "original_commit_id" : "9b1e7a6cf213590e016bc26f2a094f2b6d59eb93",
      "original_position" : 16,
      "path" : "src/index/blockfilter.cpp",
      "position" : null,
      "pull_request_review_id" : 153399005,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/216003484",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r216138058"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/216138058"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Indexing by hash is less efficient when fetching a range of filters or filter hashes by height, which is a common access pattern in BIP 157.",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-09-08T18:51:56Z",
      "diff_hunk" : "@@ -0,0 +1,289 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <map>\n+\n+#include <dbwrapper.h>\n+#include <index/blockfilter.h>\n+#include <util.h>\n+#include <validation.h>\n+\n+/* The index database stores three items for each block: the encoded filter, its dSHA256 hash, and\n+ * the header. Those belonging to blocks on the active chain are indexed by height, and those\n+ * belonging to blocks that have been reorganized out of the active chain are indexed by block hash.\n+ * This ensures that filter data for any block that becomes part of the active chain can always be\n+ * retrieved, alleviating timing concerns.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r216138058",
      "id" : 216138058,
      "in_reply_to_id" : 216003484,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNjEzODA1OA==",
      "original_commit_id" : "9b1e7a6cf213590e016bc26f2a094f2b6d59eb93",
      "original_position" : 16,
      "path" : "src/index/blockfilter.cpp",
      "position" : null,
      "pull_request_review_id" : 153562071,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/216138058",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r216412270"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/216412270"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@jimpo You're right! Forget my comment :-)",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-09-10T17:42:35Z",
      "diff_hunk" : "@@ -0,0 +1,289 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <map>\n+\n+#include <dbwrapper.h>\n+#include <index/blockfilter.h>\n+#include <util.h>\n+#include <validation.h>\n+\n+/* The index database stores three items for each block: the encoded filter, its dSHA256 hash, and\n+ * the header. Those belonging to blocks on the active chain are indexed by height, and those\n+ * belonging to blocks that have been reorganized out of the active chain are indexed by block hash.\n+ * This ensures that filter data for any block that becomes part of the active chain can always be\n+ * retrieved, alleviating timing concerns.\n+ *\n+ * Keys for the height index have the type pair<char, pair<DB_BLOCK_HEIGHT, int>>.\n+ * Keys for the hash index have the type pair<char, pair<DB_BLOCK_HASH, int>>.\n+ */\n+constexpr char DB_FILTER = 'f';\n+constexpr char DB_FILTER_HASH = 'h';\n+constexpr char DB_FILTER_HEADER = 'r';\n+\n+constexpr char DB_BLOCK_HASH = 's';\n+constexpr char DB_BLOCK_HEIGHT = 't';\n+\n+static std::map<BlockFilterType, BlockFilterIndex> g_filter_indexes;\n+\n+BlockFilterIndex::BlockFilterIndex(BlockFilterType filter_type,\n+                                   size_t n_cache_size, bool f_memory, bool f_wipe)\n+    : m_filter_type(filter_type)\n+{\n+    const std::string& filter_name = BlockFilterTypeName(filter_type);\n+    if (filter_name == \"\") throw std::invalid_argument(\"unknown filter_type\");\n+\n+    m_name = filter_name + \" block filter index\";\n+    m_db = MakeUnique<BaseIndex::DB>(GetDataDir() / \"indexes\" / \"blockfilter\" / filter_name,\n+                                     n_cache_size, f_memory, f_wipe);\n+}\n+\n+bool BlockFilterIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n+{\n+    CBlockUndo block_undo;\n+    uint256 prev_header;\n+\n+    if (pindex->nHeight > 0) {\n+        if (!UndoReadFromDisk(block_undo, pindex)) {\n+            return false;\n+        }\n+\n+        std::pair<uint256, uint256> read_out;\n+        std::pair<char, int> prev_height_key(DB_BLOCK_HEIGHT, pindex->nHeight - 1);\n+        if (!m_db->Read(std::make_pair(DB_FILTER_HEADER, prev_height_key), read_out)) {\n+            return false;\n+        }\n+\n+        uint256 expected_block_hash = pindex->pprev->GetBlockHash();\n+        if (read_out.first != expected_block_hash) {\n+            return error(\"%s: previous block header belongs to unexpected block %s; expected %s\",\n+                         __func__, read_out.first.ToString(), expected_block_hash.ToString());\n+        }\n+\n+        prev_header = read_out.second;\n+    }\n+\n+    BlockFilter filter(m_filter_type, block, block_undo);\n+    std::pair<char, int> height_key(DB_BLOCK_HEIGHT, pindex->nHeight);\n+\n+    CDBBatch batch(*m_db);\n+    batch.Write(std::make_pair(DB_FILTER, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.GetEncodedFilter()));\n+    batch.Write(std::make_pair(DB_FILTER_HASH, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.GetHash()));\n+    batch.Write(std::make_pair(DB_FILTER_HEADER, height_key),\n+                std::make_pair(pindex->GetBlockHash(), filter.ComputeHeader(prev_header)));\n+    return m_db->WriteBatch(batch);\n+}\n+\n+template <typename T>\n+static bool CopyHeightIndexToHashIndex(CDBIterator& db_it, CDBBatch& batch,\n+                                       const std::string& index_name, char key_prefix,\n+                                       int start_height, const CBlockIndex* stop_index)\n+{\n+    db_it.Seek(std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, start_height)));\n+\n+    for (int height = start_height; height <= stop_index->nHeight; ++height) {\n+        std::pair<char, std::pair<char, int>> key, expected_key;\n+        expected_key = std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HEIGHT, height));\n+\n+        if (!db_it.GetKey(key) || key != expected_key) {\n+            return error(\"%s: unexpected key in %s: expected (%c, (%c, %d))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HEIGHT, height);\n+        }\n+\n+        std::pair<uint256, T> value;\n+        if (!db_it.GetValue(value)) {\n+            return error(\"%s: unable to read value in %s at key (%c, (%c, %d))\",\n+                         __func__, index_name, key_prefix, DB_BLOCK_HEIGHT, height);\n+        }\n+\n+        auto hash_key = std::make_pair(key_prefix, std::make_pair(DB_BLOCK_HASH, value.first));\n+        batch.Write(hash_key, std::move(value.second));\n+\n+        db_it.Next();\n+    }\n+    return true;\n+}\n+\n+bool BlockFilterIndex::Rewind(const CBlockIndex* current_tip, const CBlockIndex* new_tip)\n+{\n+    assert(current_tip->GetAncestor(new_tip->nHeight) == new_tip);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r216412270",
      "id" : 216412270,
      "in_reply_to_id" : 215163648,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNjQxMjI3MA==",
      "original_commit_id" : "9b1e7a6cf213590e016bc26f2a094f2b6d59eb93",
      "original_position" : 112,
      "path" : "src/index/blockfilter.cpp",
      "position" : null,
      "pull_request_review_id" : 153886694,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-11T17:44:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/216412270",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@Sjors Thanks for testing and finding that incompatibility! It has been fixed with 775c160ee266bc61d1dcb6f35265354e3f9f5dbc, and roasbeef or I will update the BIP to clarify this point.",
      "created_at" : "2018-09-10T19:36:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#issuecomment-420033880",
      "id" : 420033880,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14121",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyMDAzMzg4MA==",
      "updated_at" : "2018-09-10T19:36:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/420033880",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@jimpo ok, those three examples now match. Is there an up to date Btcd branch that can be used to compare other blocks? cc @Roasbeef ",
      "created_at" : "2018-09-11T13:37:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#issuecomment-420277474",
      "id" : 420277474,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14121",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyMDI3NzQ3NA==",
      "updated_at" : "2018-09-11T13:37:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/420277474",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@Sjors There is nothing that checks block by block, but the filter headers commit to all previous filters in the chain, so comparing the headers at the chain tip on both change is equivalent to comparing blocks individually. btcd also has an RPC for fetching filter headers `getcfheader`.",
      "created_at" : "2018-09-11T16:22:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#issuecomment-420333183",
      "id" : 420333183,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14121",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyMDMzMzE4Mw==",
      "updated_at" : "2018-09-11T16:22:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/420333183",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/881253?v=4",
         "events_url" : "https://api.github.com/users/jimpo/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jimpo/followers",
         "following_url" : "https://api.github.com/users/jimpo/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jimpo/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jimpo",
         "id" : 881253,
         "login" : "jimpo",
         "node_id" : "MDQ6VXNlcjg4MTI1Mw==",
         "organizations_url" : "https://api.github.com/users/jimpo/orgs",
         "received_events_url" : "https://api.github.com/users/jimpo/received_events",
         "repos_url" : "https://api.github.com/users/jimpo/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jimpo/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jimpo"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r219691258"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691258"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-22 21:14:22 cpplint(pr=14121): src/test/blockfilter_index_tests.cpp:130:  Redundant blank line at the start of a code block should be deleted.  [whitespace/blank_line] [2]\r\n```",
      "commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "created_at" : "2018-09-23T07:58:51Z",
      "diff_hunk" : "@@ -0,0 +1,307 @@\n+// Copyright (c) 2017-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <blockfilter.h>\n+#include <chainparams.h>\n+#include <consensus/validation.h>\n+#include <index/blockfilterindex.h>\n+#include <miner.h>\n+#include <pow.h>\n+#include <test/test_bitcoin.h>\n+#include <script/standard.h>\n+#include <validation.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(blockfilter_index_tests)\n+\n+static bool ComputeFilter(BlockFilterType filter_type, const CBlockIndex* block_index,\n+                          BlockFilter& filter)\n+{\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, block_index->GetBlockPos(), Params().GetConsensus())) {\n+        return false;\n+    }\n+\n+    CBlockUndo block_undo;\n+    if (block_index->nHeight > 0 && !UndoReadFromDisk(block_undo, block_index)) {\n+        return false;\n+    }\n+\n+    filter = BlockFilter(filter_type, block, block_undo);\n+    return true;\n+}\n+\n+static bool CheckFilterLookups(BlockFilterIndex& filter_index, const CBlockIndex* block_index,\n+                               uint256& last_header)\n+{\n+    BlockFilter expected_filter;\n+    if (!ComputeFilter(filter_index.GetFilterType(), block_index, expected_filter)) {\n+        BOOST_ERROR(\"ComputeFilter failed on block \" << block_index->nHeight);\n+        return false;\n+    }\n+\n+    BlockFilter filter;\n+    uint256 filter_header;\n+    std::vector<BlockFilter> filters;\n+    std::vector<uint256> filter_hashes;\n+\n+    BOOST_CHECK(filter_index.LookupFilter(block_index, filter));\n+    BOOST_CHECK(filter_index.LookupFilterHeader(block_index, filter_header));\n+    BOOST_CHECK(filter_index.LookupFilterRange(block_index->nHeight, block_index, filters));\n+    BOOST_CHECK(filter_index.LookupFilterHashRange(block_index->nHeight, block_index,\n+                                                   filter_hashes));\n+\n+    BOOST_CHECK_EQUAL(filters.size(), 1);\n+    BOOST_CHECK_EQUAL(filter_hashes.size(), 1);\n+\n+    BOOST_CHECK_EQUAL(filter.GetHash(), expected_filter.GetHash());\n+    BOOST_CHECK_EQUAL(filter_header, expected_filter.ComputeHeader(last_header));\n+    BOOST_CHECK_EQUAL(filters[0].GetHash(), expected_filter.GetHash());\n+    BOOST_CHECK_EQUAL(filter_hashes[0], expected_filter.GetHash());\n+\n+    filters.clear();\n+    filter_hashes.clear();\n+    last_header = filter_header;\n+    return true;\n+}\n+\n+static CBlock CreateBlock(const CBlockIndex* prev,\n+                          const std::vector<CMutableTransaction>& txns,\n+                          const CScript& scriptPubKey)\n+{\n+    const CChainParams& chainparams = Params();\n+    std::unique_ptr<CBlockTemplate> pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey);\n+    CBlock& block = pblocktemplate->block;\n+    block.hashPrevBlock = prev->GetBlockHash();\n+    block.nTime = prev->nTime + 1;\n+\n+    // Replace mempool-selected txns with just coinbase plus passed-in txns:\n+    block.vtx.resize(1);\n+    for (const CMutableTransaction& tx : txns)\n+        block.vtx.push_back(MakeTransactionRef(tx));\n+    // IncrementExtraNonce creates a valid coinbase and merkleRoot\n+    unsigned int extraNonce = 0;\n+    IncrementExtraNonce(&block, prev, extraNonce);\n+\n+    while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus())) ++block.nNonce;\n+\n+    return block;\n+}\n+\n+static bool BuildChain(const CBlockIndex* pindex, const CScript& coinbase_script_pub_key,\n+                       size_t length, std::vector<std::shared_ptr<CBlock>>& chain)\n+{\n+    std::vector<CMutableTransaction> no_txns;\n+\n+    chain.resize(length);\n+    for (auto& block : chain) {\n+        block = std::make_shared<CBlock>(CreateBlock(pindex, no_txns, coinbase_script_pub_key));\n+        CBlockHeader header = block->GetBlockHeader();\n+\n+        CValidationState state;\n+        if (!ProcessNewBlockHeaders({header}, state, Params(), &pindex, nullptr)) {\n+            return false;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(blockfilter_index_initial_sync, TestChain100Setup)\n+{\n+    BlockFilterIndex filter_index(BlockFilterType::BASIC, 1 << 20, true);\n+\n+    uint256 last_header;\n+\n+    // Filter should not be found in the index before it is started.\n+    {\n+        LOCK(cs_main);\n+\n+        BlockFilter filter;\n+        uint256 filter_header;\n+        std::vector<BlockFilter> filters;\n+        std::vector<uint256> filter_hashes;\n+\n+        for (const CBlockIndex* block_index = chainActive.Genesis();\n+             block_index != nullptr;\n+             block_index = chainActive.Next(block_index)) {\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14121#discussion_r219691258",
      "id" : 219691258,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTY5MTI1OA==",
      "original_commit_id" : "d4d3ba7ceb6121b56e2fa38151e88f95993881ea",
      "original_position" : 130,
      "path" : "src/test/blockfilter_index_tests.cpp",
      "position" : 130,
      "pull_request_review_id" : 157931825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14121",
      "updated_at" : "2018-09-23T07:58:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691258",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   }
]
