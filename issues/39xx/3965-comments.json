[
   {
      "body" : "ping @sipa . I'm hoping this resembles what you had in mind.",
      "created_at" : "2014-03-27T00:37:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-38757622",
      "id" : 38757622,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-03-27T00:37:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/38757622",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "Hum.  Wish you had pinged me.  Had this half-done already.  Oh well -- fully done is better than that.\r\n\r\nUntested, quick-review ACK.  This is the direction I was headed -- ScriptNum replaces BigNum.  Looks good to me.\r\n",
      "created_at" : "2014-03-27T00:55:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-38758577",
      "id" : 38758577,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-03-27T00:55:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/38758577",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/494411?v=3",
         "events_url" : "https://api.github.com/users/jgarzik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jgarzik/followers",
         "following_url" : "https://api.github.com/users/jgarzik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jgarzik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jgarzik",
         "id" : 494411,
         "login" : "jgarzik",
         "organizations_url" : "https://api.github.com/users/jgarzik/orgs",
         "received_events_url" : "https://api.github.com/users/jgarzik/received_events",
         "repos_url" : "https://api.github.com/users/jgarzik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jgarzik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jgarzik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jgarzik"
      }
   },
   {
      "body" : "@jgarzik Ah, I didn't realize you were working on it. I've seen a few discussions lately about outside-access to script verification, and this seemed the logical place to start hacking toward that end.\r\n\r\nDo you have anything in the works regarding such libification? If so, I'd definitely prefer not to duplicate the work. Otherwise, I'll keep at it after a short detour for some build-system stuff.",
      "created_at" : "2014-03-27T02:24:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-38763014",
      "id" : 38763014,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-03-27T02:24:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/38763014",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "Oh, I (and others) have been talking about the idea of separating script evaluation (and later perhaps the whole of validation) into separate low-dependency libraries. I didn't expect such immediate progress towards that... sorry if that caused some duplicate work.\r\n\r\nApproach looks good to me, but this will require very careful inspection and testing.",
      "created_at" : "2014-03-27T05:21:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-38770077",
      "id" : 38770077,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-03-27T05:21:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/38770077",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Agree on the direction and code changes look good on first glace (though as @sipa says, as this affects consensus it will have to be thoroughly scrutinized).",
      "created_at" : "2014-03-27T09:45:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-38783747",
      "id" : 38783747,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-03-27T09:45:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/38783747",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "I think we want unit tests for CScriptNum, to ensure their compatibility with CBigNum.\r\n\r\nShouldn't be too hard I think; construct some random and non-random numbers (0, max, min, ...), do some operations on combinations of them, and compare the result with doing the same operation on CBigNum (and serialize/deserialize to vectors).",
      "created_at" : "2014-03-29T16:33:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-39000747",
      "id" : 39000747,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-03-29T16:33:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/39000747",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "@sipa Can't believe I didn't think of that, that's very obviously the correct way forward with this.\r\n\r\nGreat idea, will do.",
      "created_at" : "2014-03-29T17:10:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-39001915",
      "id" : 39001915,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-03-29T17:10:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/39001915",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "I threw in a few quick tests as @sipa suggested over the weekend, and there are some significant problems. I'll push up a fixed tomorrow.",
      "created_at" : "2014-03-31T02:28:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-39049310",
      "id" : 39049310,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-03-31T02:28:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/39049310",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "Updated, and pretty much rewritten. Lots of tests added, it now conforms to the previous usage of CBigNum as much as possible. See the note in 8ca9e9b about the usage differences.",
      "created_at" : "2014-04-01T05:25:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-39171967",
      "id" : 39171967,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-01T05:25:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/39171967",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "Code review ACK.\r\n\r\nI also tested to make sure the unit tests can fail (ran tests against a script.h with intentionally introduced bugs).\r\n",
      "created_at" : "2014-04-03T14:51:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-39460384",
      "id" : 39460384,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-03T14:51:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/39460384",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/331997?v=3",
         "events_url" : "https://api.github.com/users/gavinandresen/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gavinandresen/followers",
         "following_url" : "https://api.github.com/users/gavinandresen/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gavinandresen/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gavinandresen",
         "id" : 331997,
         "login" : "gavinandresen",
         "organizations_url" : "https://api.github.com/users/gavinandresen/orgs",
         "received_events_url" : "https://api.github.com/users/gavinandresen/received_events",
         "repos_url" : "https://api.github.com/users/gavinandresen/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gavinandresen/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gavinandresen/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gavinandresen"
      }
   },
   {
      "body" : "@gavinandresen thanks for the review. Your description above finally helped me put a finger on the overflow subtleties that had been bothering me, so I made a few more changes.\r\nThe nMaxNumValue/nMinNumValue were not enough to handle all overflow scenarios, so I split them into OperandValue/TotalValue. Also, the current (possibly overflown) value was not tested on subsequent math operations, so I fixed that and added the tests in script_invalid to check for them.\r\n\r\nA quick sanity review of those changes would definitely be appreciated.",
      "created_at" : "2014-04-03T20:52:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-39503334",
      "id" : 39503334,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-03T20:52:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/39503334",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "Mmm, there are still several details that aren't quite right here. Several tests need to be added for hitting the corner cases. Will keep at it.",
      "created_at" : "2014-04-03T23:06:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-39515885",
      "id" : 39515885,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-03T23:06:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/39515885",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "Ok, I really think that's everything now, sorry for all the wavering. Thanks to @gmaxwell for gently answering some dumb questions after the tunnel-vision set in.\r\n\r\n@gavinandresen I left some uglies in rather than force-pushing. No history before your comment has been rewritten.",
      "created_at" : "2014-04-04T03:50:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-39529517",
      "id" : 39529517,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-04T03:50:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/39529517",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "Testnet reindexed from scratch to height=208945 after the last set of changes, without issue.",
      "created_at" : "2014-04-04T07:01:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-39536970",
      "id" : 39536970,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-04T07:01:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/39536970",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "@maaku I have no idea where your comment went.. Github seems to have swallowed it somehow.\r\n```\r\nIn src/script.h:\r\nWhat about zero-padded bignums? These can be more than 4 bytes in length but still pass CastToBigNum()\r\n```\r\nWe no longer have a CBigNum cast, so there's no way to get a BigNum into a script directly.\r\nBut more importantly, see the previous behavior: https://github.com/bitcoin/bitcoin/pull/3965/files#diff-dedcc88d0e66b86a19981e7c175658c2L36\r\n\r\nAs I see it, CScriptNum does the same thing as before. Am I missing something?",
      "created_at" : "2014-04-04T22:20:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-39617353",
      "id" : 39617353,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-04T22:20:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/39617353",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "Yeah, right after making that comment I figured I should double-check,\nand sure enough it matches the previous behavior. So I deleted the\ncomment, but I guess you got the notification email. Sorry to waste your\ntime with it.\n\n\nOn 04/04/2014 03:20 PM, Cory Fields wrote:\n> @maaku <https://github.com/maaku> I have no idea where your comment\n> went.. Github seems to have swallowed it somehow.\n> \n> |In src/script.h:\n> What about zero-padded bignums? These can be more than 4 bytes in length but still pass CastToBigNum()\n> |\n> \n> We no longer have a CBigNum cast, so there's no way to get a BigNum into\n> a script directly.\n> But more importantly, see the previous behavior:\n> https://github.com/bitcoin/bitcoin/pull/3965/files#diff-dedcc88d0e66b86a19981e7c175658c2L36\n> \n> As I see it, CScriptNum does the same thing as before. Am I missing\n> something?\n> \n> Ã¢ÂÂ\n> Reply to this email directly or view it on GitHub\n> <https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-39617353>.\n>",
      "created_at" : "2014-04-04T23:23:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-39620916",
      "id" : 39620916,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-04T23:23:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/39620916",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69154?v=3",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "body" : "No worries, thanks for the review. Please point out anything you're unsure of, it's worth the few min it takes me to double-check. :)",
      "created_at" : "2014-04-04T23:29:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-39621193",
      "id" : 39621193,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-04T23:29:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/39621193",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "ACK.\r\n\r\nDuring the review the only part that had me worried was the `setvch()` and `serialize()` implementations, since that's a lot of new consensus-critical code. It looked correct but rather than trust my judgement I performed an exhaustive test of all possible (non-overflow) values. It only took 661m 35.921s to run:\r\n\r\n    BOOST_AUTO_TEST_CASE(scriptnum_i64_2)\r\n    {\r\n        for (int64_t i  = CScriptNum::nMinOperandValue;\r\n                     i <= CScriptNum::nMaxOperandValue; ++i)\r\n        {\r\n            CheckCreateVch(i);\r\n            CheckCreateInt(i);\r\n        }\r\n    }\r\n    \r\n    BOOST_AUTO_TEST_CASE(scriptnum_vch)\r\n    {\r\n        for (int a = 0; a <= 255; ++a)\r\n        for (int b = 0; b <= 255; ++b)\r\n        for (int c = 0; c <= 255; ++c)\r\n        for (int d = 0; d <= 255; ++d)\r\n        {\r\n            std::vector<unsigned char> vch;\r\n            vch.push_back((unsigned char)a);\r\n            vch.push_back((unsigned char)b);\r\n            vch.push_back((unsigned char)c);\r\n            vch.push_back((unsigned char)d);\r\n            BOOST_CHECK(CBigNum(vch).getint() == CScriptNum(vch).getint());\r\n        }\r\n    }\r\n\r\nPassed with flying colors. Overflow values were not tested as that would have extended the run time into weeks, the overflow-related parts of the code are uncomplicated, and there is adequate coverage of those edge cases in the tests already.\r\n\r\nThis eliminates a huge dependency in the script code. Great work Cory.",
      "created_at" : "2014-04-05T22:19:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-39652469",
      "id" : 39652469,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-05T22:19:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/39652469",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69154?v=3",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11334851"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11334851"
         }
      },
      "body" : "Just to check: this minimum is correct?\r\nIt would be easy to make mistakes here, as in principle `-0x80000000` is the lowest representable value in a 32-bit int. The old `CastToBigNum` just checks the size of the vector so it doesn't tell me much.",
      "commit_id" : "b1fdd5475d9040445d7655730f262f214ea87c5f",
      "created_at" : "2014-04-07T08:37:24Z",
      "diff_hunk" : "@@ -25,6 +24,172 @@\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31...2^31],\n+// but results may overflow (and are valid as long as they are not used in a subsequent\n+// numeric operation). CScriptNum enforces those semantics by storing results as\n+// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n+// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n+\n+public:\n+\n+  explicit CScriptNum(const int64_t& n)\n+  {\n+    if( n > nMaxTotalValue || n < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum(int64_t) : overflow\");\n+    m_value = n;\n+  }\n+\n+  explicit CScriptNum(const std::vector<unsigned char>& vch)\n+  {\n+    if (vch.size() > nMaxNumSize)\n+      throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n+    m_value = set_vch(vch);\n+  }\n+\n+  inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+  inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+  inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+  inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+  inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+  inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+  inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n+  inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n+  inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n+  inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n+  inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n+  inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n+\n+  inline CScriptNum operator-()                         const { return CScriptNum(-m_value);     }\n+  inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n+  inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n+  inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n+  inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n+\n+  inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n+  inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n+\n+  inline CScriptNum& operator=( const int64_t& rhs)\n+  {\n+    if( rhs > nMaxTotalValue || rhs < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum=(int64_t) : overflow\");\n+    m_value = rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator+=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    if (m_value + rhs > nMaxTotalValue || m_value + rhs <  nMinTotalValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    m_value += rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator-=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    if (m_value - rhs < nMinTotalValue || m_value - rhs >  nMaxTotalValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    m_value -= rhs;\n+    return *this;\n+  }\n+\n+  int getint() const\n+  {\n+    if (m_value > std::numeric_limits<int>::max())\n+      return std::numeric_limits<int>::max();\n+    else if (m_value < std::numeric_limits<int>::min())\n+      return std::numeric_limits<int>::min();\n+    return m_value;\n+  }\n+\n+  std::vector<unsigned char> getvch() const\n+  {\n+    return serialize(m_value);\n+  }\n+\n+  static std::vector<unsigned char> serialize(const int64_t& value)\n+  {\n+    //  The input here is not range-checked. This is useful for serializing\n+    //  non-arithmetic data that is not bound by CScriptNum's limits.\n+\n+    if(value == 0)\n+        return std::vector<unsigned char>();\n+\n+    std::vector<unsigned char> result;\n+    const bool neg = value < 0;\n+    uint64_t absvalue = neg ? -value : value;\n+\n+    while(absvalue)\n+    {\n+      result.push_back(absvalue & 0xff);\n+      absvalue >>= 8;\n+    }\n+\n+/*\n+    - If the most significant byte is >= 0x80 and the value is positive, push a\n+    new zero-byte to make the significant byte < 0x80 again.\n+\n+    - If the most significant byte is >= 0x80 and the value is negative, push a\n+    new 0x80 byte that will be popped off when converting to an integral.\n+\n+    - If the most significant byte is < 0x80 and the value is negative, add\n+    0x80 to it, since it will be subtracted and interpreted as a negative when\n+    converting to an integral.\n+*/\n+    if (result.back() & 0x80)\n+        result.push_back(neg ? 0x80 : 0);\n+    else if (neg)\n+        result.back() |= 0x80;\n+\n+    return result;\n+  }\n+\n+  static const size_t nMaxNumSize = 4;\n+  static const int64_t nMaxOperandValue = 0x7FFFFFFF;\n+  static const int64_t nMinOperandValue = -nMaxOperandValue;\n+  static const int64_t nMaxTotalValue = 0x7FFFFFFFFFLL;\n+  static const int64_t nMinTotalValue = -nMaxTotalValue;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11334851",
      "id" : 11334851,
      "original_commit_id" : "2ee6bf163b328f60e389e71c4e2d245ba2fe4420",
      "original_position" : 155,
      "path" : "src/script.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965",
      "updated_at" : "2014-04-22T04:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11334851",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11347763"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11347763"
         }
      },
      "body" : "Bignums have explicit sign bits, so `-0x80000000` requires five bytes to represent: `0000008080`.",
      "commit_id" : "b1fdd5475d9040445d7655730f262f214ea87c5f",
      "created_at" : "2014-04-07T15:09:14Z",
      "diff_hunk" : "@@ -25,6 +24,172 @@\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31...2^31],\n+// but results may overflow (and are valid as long as they are not used in a subsequent\n+// numeric operation). CScriptNum enforces those semantics by storing results as\n+// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n+// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n+\n+public:\n+\n+  explicit CScriptNum(const int64_t& n)\n+  {\n+    if( n > nMaxTotalValue || n < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum(int64_t) : overflow\");\n+    m_value = n;\n+  }\n+\n+  explicit CScriptNum(const std::vector<unsigned char>& vch)\n+  {\n+    if (vch.size() > nMaxNumSize)\n+      throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n+    m_value = set_vch(vch);\n+  }\n+\n+  inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+  inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+  inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+  inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+  inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+  inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+  inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n+  inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n+  inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n+  inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n+  inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n+  inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n+\n+  inline CScriptNum operator-()                         const { return CScriptNum(-m_value);     }\n+  inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n+  inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n+  inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n+  inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n+\n+  inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n+  inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n+\n+  inline CScriptNum& operator=( const int64_t& rhs)\n+  {\n+    if( rhs > nMaxTotalValue || rhs < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum=(int64_t) : overflow\");\n+    m_value = rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator+=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    if (m_value + rhs > nMaxTotalValue || m_value + rhs <  nMinTotalValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    m_value += rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator-=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    if (m_value - rhs < nMinTotalValue || m_value - rhs >  nMaxTotalValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    m_value -= rhs;\n+    return *this;\n+  }\n+\n+  int getint() const\n+  {\n+    if (m_value > std::numeric_limits<int>::max())\n+      return std::numeric_limits<int>::max();\n+    else if (m_value < std::numeric_limits<int>::min())\n+      return std::numeric_limits<int>::min();\n+    return m_value;\n+  }\n+\n+  std::vector<unsigned char> getvch() const\n+  {\n+    return serialize(m_value);\n+  }\n+\n+  static std::vector<unsigned char> serialize(const int64_t& value)\n+  {\n+    //  The input here is not range-checked. This is useful for serializing\n+    //  non-arithmetic data that is not bound by CScriptNum's limits.\n+\n+    if(value == 0)\n+        return std::vector<unsigned char>();\n+\n+    std::vector<unsigned char> result;\n+    const bool neg = value < 0;\n+    uint64_t absvalue = neg ? -value : value;\n+\n+    while(absvalue)\n+    {\n+      result.push_back(absvalue & 0xff);\n+      absvalue >>= 8;\n+    }\n+\n+/*\n+    - If the most significant byte is >= 0x80 and the value is positive, push a\n+    new zero-byte to make the significant byte < 0x80 again.\n+\n+    - If the most significant byte is >= 0x80 and the value is negative, push a\n+    new 0x80 byte that will be popped off when converting to an integral.\n+\n+    - If the most significant byte is < 0x80 and the value is negative, add\n+    0x80 to it, since it will be subtracted and interpreted as a negative when\n+    converting to an integral.\n+*/\n+    if (result.back() & 0x80)\n+        result.push_back(neg ? 0x80 : 0);\n+    else if (neg)\n+        result.back() |= 0x80;\n+\n+    return result;\n+  }\n+\n+  static const size_t nMaxNumSize = 4;\n+  static const int64_t nMaxOperandValue = 0x7FFFFFFF;\n+  static const int64_t nMinOperandValue = -nMaxOperandValue;\n+  static const int64_t nMaxTotalValue = 0x7FFFFFFFFFLL;\n+  static const int64_t nMinTotalValue = -nMaxTotalValue;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11347763",
      "id" : 11347763,
      "original_commit_id" : "2ee6bf163b328f60e389e71c4e2d245ba2fe4420",
      "original_position" : 155,
      "path" : "src/script.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965",
      "updated_at" : "2014-04-22T04:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11347763",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69154?v=3",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11350662"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11350662"
         }
      },
      "body" : "@laanwj Note that the sizes are verified in the tests:\r\n```\r\n [\"-2147483647\", \"0x04 0xFFFFFFFF EQUAL\"],\r\n [\"-2147483648\", \"0x05 0x0000008080 EQUAL\"],\r\n```\r\nThat's confusing at first glance, but see what @maaku said above. -2147483647 is -0x7FFFFFFF, sent over the wire as 0xFFFFFFFF. So that's the minimum value of a 4-byte operand.\r\n\r\nI suppose it would be helpful to verify the operand bounds explicitly in the tests as well:\r\nvalid: ```[\"-2147483647\", \"1ADD 2147483646 EQUAL\"]```\r\ninvalid: ```[\"-2147483648\", \"1ADD 1\"]```\r\n\r\nI'll double-check that those aren't already there and push that up.",
      "commit_id" : "b1fdd5475d9040445d7655730f262f214ea87c5f",
      "created_at" : "2014-04-07T15:56:41Z",
      "diff_hunk" : "@@ -25,6 +24,172 @@\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31...2^31],\n+// but results may overflow (and are valid as long as they are not used in a subsequent\n+// numeric operation). CScriptNum enforces those semantics by storing results as\n+// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n+// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n+\n+public:\n+\n+  explicit CScriptNum(const int64_t& n)\n+  {\n+    if( n > nMaxTotalValue || n < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum(int64_t) : overflow\");\n+    m_value = n;\n+  }\n+\n+  explicit CScriptNum(const std::vector<unsigned char>& vch)\n+  {\n+    if (vch.size() > nMaxNumSize)\n+      throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n+    m_value = set_vch(vch);\n+  }\n+\n+  inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+  inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+  inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+  inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+  inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+  inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+  inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n+  inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n+  inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n+  inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n+  inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n+  inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n+\n+  inline CScriptNum operator-()                         const { return CScriptNum(-m_value);     }\n+  inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n+  inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n+  inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n+  inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n+\n+  inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n+  inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n+\n+  inline CScriptNum& operator=( const int64_t& rhs)\n+  {\n+    if( rhs > nMaxTotalValue || rhs < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum=(int64_t) : overflow\");\n+    m_value = rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator+=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    if (m_value + rhs > nMaxTotalValue || m_value + rhs <  nMinTotalValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    m_value += rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator-=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    if (m_value - rhs < nMinTotalValue || m_value - rhs >  nMaxTotalValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    m_value -= rhs;\n+    return *this;\n+  }\n+\n+  int getint() const\n+  {\n+    if (m_value > std::numeric_limits<int>::max())\n+      return std::numeric_limits<int>::max();\n+    else if (m_value < std::numeric_limits<int>::min())\n+      return std::numeric_limits<int>::min();\n+    return m_value;\n+  }\n+\n+  std::vector<unsigned char> getvch() const\n+  {\n+    return serialize(m_value);\n+  }\n+\n+  static std::vector<unsigned char> serialize(const int64_t& value)\n+  {\n+    //  The input here is not range-checked. This is useful for serializing\n+    //  non-arithmetic data that is not bound by CScriptNum's limits.\n+\n+    if(value == 0)\n+        return std::vector<unsigned char>();\n+\n+    std::vector<unsigned char> result;\n+    const bool neg = value < 0;\n+    uint64_t absvalue = neg ? -value : value;\n+\n+    while(absvalue)\n+    {\n+      result.push_back(absvalue & 0xff);\n+      absvalue >>= 8;\n+    }\n+\n+/*\n+    - If the most significant byte is >= 0x80 and the value is positive, push a\n+    new zero-byte to make the significant byte < 0x80 again.\n+\n+    - If the most significant byte is >= 0x80 and the value is negative, push a\n+    new 0x80 byte that will be popped off when converting to an integral.\n+\n+    - If the most significant byte is < 0x80 and the value is negative, add\n+    0x80 to it, since it will be subtracted and interpreted as a negative when\n+    converting to an integral.\n+*/\n+    if (result.back() & 0x80)\n+        result.push_back(neg ? 0x80 : 0);\n+    else if (neg)\n+        result.back() |= 0x80;\n+\n+    return result;\n+  }\n+\n+  static const size_t nMaxNumSize = 4;\n+  static const int64_t nMaxOperandValue = 0x7FFFFFFF;\n+  static const int64_t nMinOperandValue = -nMaxOperandValue;\n+  static const int64_t nMaxTotalValue = 0x7FFFFFFFFFLL;\n+  static const int64_t nMinTotalValue = -nMaxTotalValue;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11350662",
      "id" : 11350662,
      "original_commit_id" : "2ee6bf163b328f60e389e71c4e2d245ba2fe4420",
      "original_position" : 155,
      "path" : "src/script.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965",
      "updated_at" : "2014-04-22T04:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11350662",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11351466"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11351466"
         }
      },
      "body" : "Just checked, and it's already covered in a few places. From existing tests:\r\nvalid:\r\n```\r\n[\"2147483647 -2147483647 ADD\", \"0 EQUAL\"]\r\n[\"0 -2147483647 MIN\", \"-2147483647 NUMEQUAL\"]\r\n[\"0 -2147483647 MAX\", \"0 NUMEQUAL\"]\r\n```\r\ninvalid:\r\n```\r\n[\"-2147483648 0 ADD\", \"NOP\", \"arithmetic operands must be in range [-2^31...2^31] \"]\r\n[\"-2147483648\", \"1ADD 1\", \"Because we use a sign bit, -2147483648 is also 5 bytes\"]\r\n```",
      "commit_id" : "b1fdd5475d9040445d7655730f262f214ea87c5f",
      "created_at" : "2014-04-07T16:12:37Z",
      "diff_hunk" : "@@ -25,6 +24,172 @@\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31...2^31],\n+// but results may overflow (and are valid as long as they are not used in a subsequent\n+// numeric operation). CScriptNum enforces those semantics by storing results as\n+// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n+// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n+\n+public:\n+\n+  explicit CScriptNum(const int64_t& n)\n+  {\n+    if( n > nMaxTotalValue || n < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum(int64_t) : overflow\");\n+    m_value = n;\n+  }\n+\n+  explicit CScriptNum(const std::vector<unsigned char>& vch)\n+  {\n+    if (vch.size() > nMaxNumSize)\n+      throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n+    m_value = set_vch(vch);\n+  }\n+\n+  inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+  inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+  inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+  inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+  inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+  inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+  inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n+  inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n+  inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n+  inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n+  inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n+  inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n+\n+  inline CScriptNum operator-()                         const { return CScriptNum(-m_value);     }\n+  inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n+  inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n+  inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n+  inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n+\n+  inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n+  inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n+\n+  inline CScriptNum& operator=( const int64_t& rhs)\n+  {\n+    if( rhs > nMaxTotalValue || rhs < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum=(int64_t) : overflow\");\n+    m_value = rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator+=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    if (m_value + rhs > nMaxTotalValue || m_value + rhs <  nMinTotalValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    m_value += rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator-=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    if (m_value - rhs < nMinTotalValue || m_value - rhs >  nMaxTotalValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    m_value -= rhs;\n+    return *this;\n+  }\n+\n+  int getint() const\n+  {\n+    if (m_value > std::numeric_limits<int>::max())\n+      return std::numeric_limits<int>::max();\n+    else if (m_value < std::numeric_limits<int>::min())\n+      return std::numeric_limits<int>::min();\n+    return m_value;\n+  }\n+\n+  std::vector<unsigned char> getvch() const\n+  {\n+    return serialize(m_value);\n+  }\n+\n+  static std::vector<unsigned char> serialize(const int64_t& value)\n+  {\n+    //  The input here is not range-checked. This is useful for serializing\n+    //  non-arithmetic data that is not bound by CScriptNum's limits.\n+\n+    if(value == 0)\n+        return std::vector<unsigned char>();\n+\n+    std::vector<unsigned char> result;\n+    const bool neg = value < 0;\n+    uint64_t absvalue = neg ? -value : value;\n+\n+    while(absvalue)\n+    {\n+      result.push_back(absvalue & 0xff);\n+      absvalue >>= 8;\n+    }\n+\n+/*\n+    - If the most significant byte is >= 0x80 and the value is positive, push a\n+    new zero-byte to make the significant byte < 0x80 again.\n+\n+    - If the most significant byte is >= 0x80 and the value is negative, push a\n+    new 0x80 byte that will be popped off when converting to an integral.\n+\n+    - If the most significant byte is < 0x80 and the value is negative, add\n+    0x80 to it, since it will be subtracted and interpreted as a negative when\n+    converting to an integral.\n+*/\n+    if (result.back() & 0x80)\n+        result.push_back(neg ? 0x80 : 0);\n+    else if (neg)\n+        result.back() |= 0x80;\n+\n+    return result;\n+  }\n+\n+  static const size_t nMaxNumSize = 4;\n+  static const int64_t nMaxOperandValue = 0x7FFFFFFF;\n+  static const int64_t nMinOperandValue = -nMaxOperandValue;\n+  static const int64_t nMaxTotalValue = 0x7FFFFFFFFFLL;\n+  static const int64_t nMinTotalValue = -nMaxTotalValue;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11351466",
      "id" : 11351466,
      "original_commit_id" : "2ee6bf163b328f60e389e71c4e2d245ba2fe4420",
      "original_position" : 155,
      "path" : "src/script.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965",
      "updated_at" : "2014-04-22T04:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11351466",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "ACK (my comments about the inclusive/exclusive ranges being unclear in the comments, aside).\r\n\r\nI added 80 more script tests for areas of number handling that I thought were under-tested. All passed, I'll pullreq after this is merged so I don't conflict with it.  Maaku's tests were great though I had some concern that they didn't test the overflows, so I added a test for the byte-pattern a,x,x,x,b where a={1..255}, b={0..255}, x={0,255} and confirmed that it threw in all the same cases.\r\n\r\nOne point where I would like a second opinion is that the change changes from throwing runtime_error to throwing the derived scriptnum_error. I don't see any place where this would make a difference. However, most of our confidence in this code comes from unit tests which wouldn't see long-range effects and if the exception change had an effect it would be long range. AFAICT pulltester doesn't test blocks which get rejected due to arithmetic overflows. This should be fixed: perhaps by creating one block for each of our invalid script testcases, and one block with all the valid onesÃ¢ÂÂ maybe imported from the JSON. We do sync testnet which has the bulk of the unit tests in it, but perhaps we shouldn't release this until there is some full system test (e.g. blocks over p2p) which checks the invalid cases.\r\n",
      "created_at" : "2014-04-17T07:59:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-40690226",
      "id" : 40690226,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-17T08:08:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/40690226",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "@gmaxwell Thanks for the thorough review. New test-cases are most welcome. If you'd like, I'd be more than happy to split this PR into two so that (your) test-cases can go in first, then the scriptnum changes. That way it's clear that the same cases passed before and after. Reconciling some conflicts is hardly a concern compared to the possibility of introducing a consensus change.\r\n\r\nAs for the derived throw, I grepped around a bit at the time and found that it could've only been caught by a (...), but it's very possible that I overlooked something. I considered throwing the old type for the sake of compatibility, but I couldn't find any actual usage to speak of.",
      "created_at" : "2014-04-17T10:17:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-40700123",
      "id" : 40700123,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-17T10:17:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/40700123",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "The code and the tests look very good.\r\n\r\nI have one suggested simplification. In the old code, the only place where bounds-checking was done (afaict) was in CastToBigNum, so when converting a byte vector to a number. I don't think there is any need for going beyond that in CScriptNum (where this logic moved to its constructor).\r\n\r\nThis means the operators themselves don't need bounds checking, and for example operator+= could just be:\r\ninline CScriptNum& operator+=(const CScriptNum& rhs) { m_value += rhs.m_value; }\r\n",
      "created_at" : "2014-04-17T10:41:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-40701692",
      "id" : 40701692,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-17T10:41:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/40701692",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Hmm, I see the reasoning for wanting to be defensive about unexpectedly large values, as - even though conversion to CScriptNum is protected - you don't want overflows inside the int64_t type.\r\n\r\nSuch cases would not be script evaluation errors, though, just implementation errors. An assert should suffice, I think?",
      "created_at" : "2014-04-17T10:48:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-40702092",
      "id" : 40702092,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-17T10:48:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/40702092",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11727170"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11727170"
         }
      },
      "body" : "Nit: I think the actual maximum possible total value is 0x7FFFFFFFFELL.",
      "commit_id" : "b1fdd5475d9040445d7655730f262f214ea87c5f",
      "created_at" : "2014-04-17T10:52:49Z",
      "diff_hunk" : "@@ -25,6 +24,172 @@\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31...2^31],\n+// but results may overflow (and are valid as long as they are not used in a subsequent\n+// numeric operation). CScriptNum enforces those semantics by storing results as\n+// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n+// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n+\n+public:\n+\n+  explicit CScriptNum(const int64_t& n)\n+  {\n+    if( n > nMaxTotalValue || n < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum(int64_t) : overflow\");\n+    m_value = n;\n+  }\n+\n+  explicit CScriptNum(const std::vector<unsigned char>& vch)\n+  {\n+    if (vch.size() > nMaxNumSize)\n+      throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n+    m_value = set_vch(vch);\n+  }\n+\n+  inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+  inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+  inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+  inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+  inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+  inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+  inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n+  inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n+  inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n+  inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n+  inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n+  inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n+\n+  inline CScriptNum operator-()                         const { return CScriptNum(-m_value);     }\n+  inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n+  inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n+  inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n+  inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n+\n+  inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n+  inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n+\n+  inline CScriptNum& operator=( const int64_t& rhs)\n+  {\n+    if( rhs > nMaxTotalValue || rhs < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum=(int64_t) : overflow\");\n+    m_value = rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator+=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    if (m_value + rhs > nMaxTotalValue || m_value + rhs <  nMinTotalValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    m_value += rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator-=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    if (m_value - rhs < nMinTotalValue || m_value - rhs >  nMaxTotalValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    m_value -= rhs;\n+    return *this;\n+  }\n+\n+  int getint() const\n+  {\n+    if (m_value > std::numeric_limits<int>::max())\n+      return std::numeric_limits<int>::max();\n+    else if (m_value < std::numeric_limits<int>::min())\n+      return std::numeric_limits<int>::min();\n+    return m_value;\n+  }\n+\n+  std::vector<unsigned char> getvch() const\n+  {\n+    return serialize(m_value);\n+  }\n+\n+  static std::vector<unsigned char> serialize(const int64_t& value)\n+  {\n+    //  The input here is not range-checked. This is useful for serializing\n+    //  non-arithmetic data that is not bound by CScriptNum's limits.\n+\n+    if(value == 0)\n+        return std::vector<unsigned char>();\n+\n+    std::vector<unsigned char> result;\n+    const bool neg = value < 0;\n+    uint64_t absvalue = neg ? -value : value;\n+\n+    while(absvalue)\n+    {\n+      result.push_back(absvalue & 0xff);\n+      absvalue >>= 8;\n+    }\n+\n+/*\n+    - If the most significant byte is >= 0x80 and the value is positive, push a\n+    new zero-byte to make the significant byte < 0x80 again.\n+\n+    - If the most significant byte is >= 0x80 and the value is negative, push a\n+    new 0x80 byte that will be popped off when converting to an integral.\n+\n+    - If the most significant byte is < 0x80 and the value is negative, add\n+    0x80 to it, since it will be subtracted and interpreted as a negative when\n+    converting to an integral.\n+*/\n+    if (result.back() & 0x80)\n+        result.push_back(neg ? 0x80 : 0);\n+    else if (neg)\n+        result.back() |= 0x80;\n+\n+    return result;\n+  }\n+\n+  static const size_t nMaxNumSize = 4;\n+  static const int64_t nMaxOperandValue = 0x7FFFFFFF;\n+  static const int64_t nMinOperandValue = -nMaxOperandValue;\n+  static const int64_t nMaxTotalValue = 0x7FFFFFFFFFLL;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11727170",
      "id" : 11727170,
      "original_commit_id" : "2ee6bf163b328f60e389e71c4e2d245ba2fe4420",
      "original_position" : 154,
      "path" : "src/script.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965",
      "updated_at" : "2014-04-22T04:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11727170",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "@sipa: I've now written 4 responses to this and deleted them each in favor of doing more research... ultimately, I agree with you.\r\n\r\nAs-is, the only thing these operators protect from is something like:\r\n````\r\nCScript() << CScriptNum(nMaxOperandValue)+1;\r\n````\r\nWhich is incorrect 'protection', because that should be a valid operation.\r\n\r\nDoes anyone object to this change?\r\n\r\nAnyone disagree with removing those bounds checks?",
      "created_at" : "2014-04-17T23:23:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-40773579",
      "id" : 40773579,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-17T23:23:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/40773579",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "I agree with removing them. The additional boundary testing was what concerned me enough to go write a bunch of additional script tests.",
      "created_at" : "2014-04-17T23:27:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-40773782",
      "id" : 40773782,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-17T23:27:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/40773782",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11759096"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11759096"
         }
      },
      "body" : "Bound by which criteria? See the passing test:\r\n```\r\n[\"549755813887\", \"SIZE 5 EQUAL\"]\r\n```\r\nwhere 7FFFFFFFFF == 549755813887",
      "commit_id" : "b1fdd5475d9040445d7655730f262f214ea87c5f",
      "created_at" : "2014-04-17T23:28:16Z",
      "diff_hunk" : "@@ -25,6 +24,172 @@\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31...2^31],\n+// but results may overflow (and are valid as long as they are not used in a subsequent\n+// numeric operation). CScriptNum enforces those semantics by storing results as\n+// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n+// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n+\n+public:\n+\n+  explicit CScriptNum(const int64_t& n)\n+  {\n+    if( n > nMaxTotalValue || n < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum(int64_t) : overflow\");\n+    m_value = n;\n+  }\n+\n+  explicit CScriptNum(const std::vector<unsigned char>& vch)\n+  {\n+    if (vch.size() > nMaxNumSize)\n+      throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n+    m_value = set_vch(vch);\n+  }\n+\n+  inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+  inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+  inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+  inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+  inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+  inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+  inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n+  inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n+  inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n+  inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n+  inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n+  inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n+\n+  inline CScriptNum operator-()                         const { return CScriptNum(-m_value);     }\n+  inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n+  inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n+  inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n+  inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n+\n+  inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n+  inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n+\n+  inline CScriptNum& operator=( const int64_t& rhs)\n+  {\n+    if( rhs > nMaxTotalValue || rhs < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum=(int64_t) : overflow\");\n+    m_value = rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator+=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    if (m_value + rhs > nMaxTotalValue || m_value + rhs <  nMinTotalValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    m_value += rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator-=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    if (m_value - rhs < nMinTotalValue || m_value - rhs >  nMaxTotalValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    m_value -= rhs;\n+    return *this;\n+  }\n+\n+  int getint() const\n+  {\n+    if (m_value > std::numeric_limits<int>::max())\n+      return std::numeric_limits<int>::max();\n+    else if (m_value < std::numeric_limits<int>::min())\n+      return std::numeric_limits<int>::min();\n+    return m_value;\n+  }\n+\n+  std::vector<unsigned char> getvch() const\n+  {\n+    return serialize(m_value);\n+  }\n+\n+  static std::vector<unsigned char> serialize(const int64_t& value)\n+  {\n+    //  The input here is not range-checked. This is useful for serializing\n+    //  non-arithmetic data that is not bound by CScriptNum's limits.\n+\n+    if(value == 0)\n+        return std::vector<unsigned char>();\n+\n+    std::vector<unsigned char> result;\n+    const bool neg = value < 0;\n+    uint64_t absvalue = neg ? -value : value;\n+\n+    while(absvalue)\n+    {\n+      result.push_back(absvalue & 0xff);\n+      absvalue >>= 8;\n+    }\n+\n+/*\n+    - If the most significant byte is >= 0x80 and the value is positive, push a\n+    new zero-byte to make the significant byte < 0x80 again.\n+\n+    - If the most significant byte is >= 0x80 and the value is negative, push a\n+    new 0x80 byte that will be popped off when converting to an integral.\n+\n+    - If the most significant byte is < 0x80 and the value is negative, add\n+    0x80 to it, since it will be subtracted and interpreted as a negative when\n+    converting to an integral.\n+*/\n+    if (result.back() & 0x80)\n+        result.push_back(neg ? 0x80 : 0);\n+    else if (neg)\n+        result.back() |= 0x80;\n+\n+    return result;\n+  }\n+\n+  static const size_t nMaxNumSize = 4;\n+  static const int64_t nMaxOperandValue = 0x7FFFFFFF;\n+  static const int64_t nMinOperandValue = -nMaxOperandValue;\n+  static const int64_t nMaxTotalValue = 0x7FFFFFFFFFLL;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11759096",
      "id" : 11759096,
      "original_commit_id" : "2ee6bf163b328f60e389e71c4e2d245ba2fe4420",
      "original_position" : 154,
      "path" : "src/script.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965",
      "updated_at" : "2014-04-22T04:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11759096",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11759223"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11759223"
         }
      },
      "body" : "Thats never a bignum in that example it's just a byte vector (and can be much larger than 5 bytes).",
      "commit_id" : "b1fdd5475d9040445d7655730f262f214ea87c5f",
      "created_at" : "2014-04-17T23:33:28Z",
      "diff_hunk" : "@@ -25,6 +24,172 @@\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31...2^31],\n+// but results may overflow (and are valid as long as they are not used in a subsequent\n+// numeric operation). CScriptNum enforces those semantics by storing results as\n+// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n+// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n+\n+public:\n+\n+  explicit CScriptNum(const int64_t& n)\n+  {\n+    if( n > nMaxTotalValue || n < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum(int64_t) : overflow\");\n+    m_value = n;\n+  }\n+\n+  explicit CScriptNum(const std::vector<unsigned char>& vch)\n+  {\n+    if (vch.size() > nMaxNumSize)\n+      throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n+    m_value = set_vch(vch);\n+  }\n+\n+  inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+  inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+  inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+  inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+  inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+  inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+  inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n+  inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n+  inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n+  inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n+  inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n+  inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n+\n+  inline CScriptNum operator-()                         const { return CScriptNum(-m_value);     }\n+  inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n+  inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n+  inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n+  inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n+\n+  inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n+  inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n+\n+  inline CScriptNum& operator=( const int64_t& rhs)\n+  {\n+    if( rhs > nMaxTotalValue || rhs < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum=(int64_t) : overflow\");\n+    m_value = rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator+=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    if (m_value + rhs > nMaxTotalValue || m_value + rhs <  nMinTotalValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    m_value += rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator-=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    if (m_value - rhs < nMinTotalValue || m_value - rhs >  nMaxTotalValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    m_value -= rhs;\n+    return *this;\n+  }\n+\n+  int getint() const\n+  {\n+    if (m_value > std::numeric_limits<int>::max())\n+      return std::numeric_limits<int>::max();\n+    else if (m_value < std::numeric_limits<int>::min())\n+      return std::numeric_limits<int>::min();\n+    return m_value;\n+  }\n+\n+  std::vector<unsigned char> getvch() const\n+  {\n+    return serialize(m_value);\n+  }\n+\n+  static std::vector<unsigned char> serialize(const int64_t& value)\n+  {\n+    //  The input here is not range-checked. This is useful for serializing\n+    //  non-arithmetic data that is not bound by CScriptNum's limits.\n+\n+    if(value == 0)\n+        return std::vector<unsigned char>();\n+\n+    std::vector<unsigned char> result;\n+    const bool neg = value < 0;\n+    uint64_t absvalue = neg ? -value : value;\n+\n+    while(absvalue)\n+    {\n+      result.push_back(absvalue & 0xff);\n+      absvalue >>= 8;\n+    }\n+\n+/*\n+    - If the most significant byte is >= 0x80 and the value is positive, push a\n+    new zero-byte to make the significant byte < 0x80 again.\n+\n+    - If the most significant byte is >= 0x80 and the value is negative, push a\n+    new 0x80 byte that will be popped off when converting to an integral.\n+\n+    - If the most significant byte is < 0x80 and the value is negative, add\n+    0x80 to it, since it will be subtracted and interpreted as a negative when\n+    converting to an integral.\n+*/\n+    if (result.back() & 0x80)\n+        result.push_back(neg ? 0x80 : 0);\n+    else if (neg)\n+        result.back() |= 0x80;\n+\n+    return result;\n+  }\n+\n+  static const size_t nMaxNumSize = 4;\n+  static const int64_t nMaxOperandValue = 0x7FFFFFFF;\n+  static const int64_t nMinOperandValue = -nMaxOperandValue;\n+  static const int64_t nMaxTotalValue = 0x7FFFFFFFFFLL;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11759223",
      "id" : 11759223,
      "original_commit_id" : "2ee6bf163b328f60e389e71c4e2d245ba2fe4420",
      "original_position" : 154,
      "path" : "src/script.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965",
      "updated_at" : "2014-04-22T04:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11759223",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11759604"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11759604"
         }
      },
      "body" : "@gmaxwell Erm, I did a poor job with my point on that one.\r\n\r\nI was stating that 7FFFFFFFFF fits neatly into 5 bytes, as shown by '549755813887 SIZE 5 EQUAL', which is the criteria for nMaxTotalValue.",
      "commit_id" : "b1fdd5475d9040445d7655730f262f214ea87c5f",
      "created_at" : "2014-04-17T23:48:47Z",
      "diff_hunk" : "@@ -25,6 +24,172 @@\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31...2^31],\n+// but results may overflow (and are valid as long as they are not used in a subsequent\n+// numeric operation). CScriptNum enforces those semantics by storing results as\n+// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n+// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n+\n+public:\n+\n+  explicit CScriptNum(const int64_t& n)\n+  {\n+    if( n > nMaxTotalValue || n < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum(int64_t) : overflow\");\n+    m_value = n;\n+  }\n+\n+  explicit CScriptNum(const std::vector<unsigned char>& vch)\n+  {\n+    if (vch.size() > nMaxNumSize)\n+      throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n+    m_value = set_vch(vch);\n+  }\n+\n+  inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+  inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+  inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+  inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+  inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+  inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+  inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n+  inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n+  inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n+  inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n+  inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n+  inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n+\n+  inline CScriptNum operator-()                         const { return CScriptNum(-m_value);     }\n+  inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n+  inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n+  inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n+  inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n+\n+  inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n+  inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n+\n+  inline CScriptNum& operator=( const int64_t& rhs)\n+  {\n+    if( rhs > nMaxTotalValue || rhs < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum=(int64_t) : overflow\");\n+    m_value = rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator+=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    if (m_value + rhs > nMaxTotalValue || m_value + rhs <  nMinTotalValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    m_value += rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator-=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    if (m_value - rhs < nMinTotalValue || m_value - rhs >  nMaxTotalValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    m_value -= rhs;\n+    return *this;\n+  }\n+\n+  int getint() const\n+  {\n+    if (m_value > std::numeric_limits<int>::max())\n+      return std::numeric_limits<int>::max();\n+    else if (m_value < std::numeric_limits<int>::min())\n+      return std::numeric_limits<int>::min();\n+    return m_value;\n+  }\n+\n+  std::vector<unsigned char> getvch() const\n+  {\n+    return serialize(m_value);\n+  }\n+\n+  static std::vector<unsigned char> serialize(const int64_t& value)\n+  {\n+    //  The input here is not range-checked. This is useful for serializing\n+    //  non-arithmetic data that is not bound by CScriptNum's limits.\n+\n+    if(value == 0)\n+        return std::vector<unsigned char>();\n+\n+    std::vector<unsigned char> result;\n+    const bool neg = value < 0;\n+    uint64_t absvalue = neg ? -value : value;\n+\n+    while(absvalue)\n+    {\n+      result.push_back(absvalue & 0xff);\n+      absvalue >>= 8;\n+    }\n+\n+/*\n+    - If the most significant byte is >= 0x80 and the value is positive, push a\n+    new zero-byte to make the significant byte < 0x80 again.\n+\n+    - If the most significant byte is >= 0x80 and the value is negative, push a\n+    new 0x80 byte that will be popped off when converting to an integral.\n+\n+    - If the most significant byte is < 0x80 and the value is negative, add\n+    0x80 to it, since it will be subtracted and interpreted as a negative when\n+    converting to an integral.\n+*/\n+    if (result.back() & 0x80)\n+        result.push_back(neg ? 0x80 : 0);\n+    else if (neg)\n+        result.back() |= 0x80;\n+\n+    return result;\n+  }\n+\n+  static const size_t nMaxNumSize = 4;\n+  static const int64_t nMaxOperandValue = 0x7FFFFFFF;\n+  static const int64_t nMinOperandValue = -nMaxOperandValue;\n+  static const int64_t nMaxTotalValue = 0x7FFFFFFFFFLL;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11759604",
      "id" : 11759604,
      "original_commit_id" : "2ee6bf163b328f60e389e71c4e2d245ba2fe4420",
      "original_position" : 154,
      "path" : "src/script.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965",
      "updated_at" : "2014-04-22T04:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11759604",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11760258"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11760258"
         }
      },
      "body" : "Try `9223372036854775807 SIZE 8 EQUAL` -- you'll find it passes too. In this script the number is never treated as a bignum, so it never gets range checked.\r\n\r\nThe correct, most restrictive limit is `0xfffffffe == 0x7fffffff + 0x7fffffff`, but as far as I can tell it doesn't affect consensus code.",
      "commit_id" : "b1fdd5475d9040445d7655730f262f214ea87c5f",
      "created_at" : "2014-04-18T00:16:47Z",
      "diff_hunk" : "@@ -25,6 +24,172 @@\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31...2^31],\n+// but results may overflow (and are valid as long as they are not used in a subsequent\n+// numeric operation). CScriptNum enforces those semantics by storing results as\n+// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n+// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n+\n+public:\n+\n+  explicit CScriptNum(const int64_t& n)\n+  {\n+    if( n > nMaxTotalValue || n < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum(int64_t) : overflow\");\n+    m_value = n;\n+  }\n+\n+  explicit CScriptNum(const std::vector<unsigned char>& vch)\n+  {\n+    if (vch.size() > nMaxNumSize)\n+      throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n+    m_value = set_vch(vch);\n+  }\n+\n+  inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+  inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+  inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+  inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+  inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+  inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+  inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n+  inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n+  inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n+  inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n+  inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n+  inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n+\n+  inline CScriptNum operator-()                         const { return CScriptNum(-m_value);     }\n+  inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n+  inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n+  inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n+  inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n+\n+  inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n+  inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n+\n+  inline CScriptNum& operator=( const int64_t& rhs)\n+  {\n+    if( rhs > nMaxTotalValue || rhs < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum=(int64_t) : overflow\");\n+    m_value = rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator+=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    if (m_value + rhs > nMaxTotalValue || m_value + rhs <  nMinTotalValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    m_value += rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator-=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    if (m_value - rhs < nMinTotalValue || m_value - rhs >  nMaxTotalValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    m_value -= rhs;\n+    return *this;\n+  }\n+\n+  int getint() const\n+  {\n+    if (m_value > std::numeric_limits<int>::max())\n+      return std::numeric_limits<int>::max();\n+    else if (m_value < std::numeric_limits<int>::min())\n+      return std::numeric_limits<int>::min();\n+    return m_value;\n+  }\n+\n+  std::vector<unsigned char> getvch() const\n+  {\n+    return serialize(m_value);\n+  }\n+\n+  static std::vector<unsigned char> serialize(const int64_t& value)\n+  {\n+    //  The input here is not range-checked. This is useful for serializing\n+    //  non-arithmetic data that is not bound by CScriptNum's limits.\n+\n+    if(value == 0)\n+        return std::vector<unsigned char>();\n+\n+    std::vector<unsigned char> result;\n+    const bool neg = value < 0;\n+    uint64_t absvalue = neg ? -value : value;\n+\n+    while(absvalue)\n+    {\n+      result.push_back(absvalue & 0xff);\n+      absvalue >>= 8;\n+    }\n+\n+/*\n+    - If the most significant byte is >= 0x80 and the value is positive, push a\n+    new zero-byte to make the significant byte < 0x80 again.\n+\n+    - If the most significant byte is >= 0x80 and the value is negative, push a\n+    new 0x80 byte that will be popped off when converting to an integral.\n+\n+    - If the most significant byte is < 0x80 and the value is negative, add\n+    0x80 to it, since it will be subtracted and interpreted as a negative when\n+    converting to an integral.\n+*/\n+    if (result.back() & 0x80)\n+        result.push_back(neg ? 0x80 : 0);\n+    else if (neg)\n+        result.back() |= 0x80;\n+\n+    return result;\n+  }\n+\n+  static const size_t nMaxNumSize = 4;\n+  static const int64_t nMaxOperandValue = 0x7FFFFFFF;\n+  static const int64_t nMinOperandValue = -nMaxOperandValue;\n+  static const int64_t nMaxTotalValue = 0x7FFFFFFFFFLL;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11760258",
      "id" : 11760258,
      "original_commit_id" : "2ee6bf163b328f60e389e71c4e2d245ba2fe4420",
      "original_position" : 154,
      "path" : "src/script.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965",
      "updated_at" : "2014-04-22T04:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11760258",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69154?v=3",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11760391"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11760391"
         }
      },
      "body" : "@maaku I considered 0xfffffffe, but decided against assuming that other operators wouldn't be re-enabled/added in the future. The 5byte boundary is the only constraint for consideration here, no?",
      "commit_id" : "b1fdd5475d9040445d7655730f262f214ea87c5f",
      "created_at" : "2014-04-18T00:23:47Z",
      "diff_hunk" : "@@ -25,6 +24,172 @@\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31...2^31],\n+// but results may overflow (and are valid as long as they are not used in a subsequent\n+// numeric operation). CScriptNum enforces those semantics by storing results as\n+// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n+// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n+\n+public:\n+\n+  explicit CScriptNum(const int64_t& n)\n+  {\n+    if( n > nMaxTotalValue || n < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum(int64_t) : overflow\");\n+    m_value = n;\n+  }\n+\n+  explicit CScriptNum(const std::vector<unsigned char>& vch)\n+  {\n+    if (vch.size() > nMaxNumSize)\n+      throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n+    m_value = set_vch(vch);\n+  }\n+\n+  inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+  inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+  inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+  inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+  inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+  inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+  inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n+  inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n+  inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n+  inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n+  inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n+  inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n+\n+  inline CScriptNum operator-()                         const { return CScriptNum(-m_value);     }\n+  inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n+  inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n+  inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n+  inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n+\n+  inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n+  inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n+\n+  inline CScriptNum& operator=( const int64_t& rhs)\n+  {\n+    if( rhs > nMaxTotalValue || rhs < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum=(int64_t) : overflow\");\n+    m_value = rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator+=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    if (m_value + rhs > nMaxTotalValue || m_value + rhs <  nMinTotalValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    m_value += rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator-=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    if (m_value - rhs < nMinTotalValue || m_value - rhs >  nMaxTotalValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    m_value -= rhs;\n+    return *this;\n+  }\n+\n+  int getint() const\n+  {\n+    if (m_value > std::numeric_limits<int>::max())\n+      return std::numeric_limits<int>::max();\n+    else if (m_value < std::numeric_limits<int>::min())\n+      return std::numeric_limits<int>::min();\n+    return m_value;\n+  }\n+\n+  std::vector<unsigned char> getvch() const\n+  {\n+    return serialize(m_value);\n+  }\n+\n+  static std::vector<unsigned char> serialize(const int64_t& value)\n+  {\n+    //  The input here is not range-checked. This is useful for serializing\n+    //  non-arithmetic data that is not bound by CScriptNum's limits.\n+\n+    if(value == 0)\n+        return std::vector<unsigned char>();\n+\n+    std::vector<unsigned char> result;\n+    const bool neg = value < 0;\n+    uint64_t absvalue = neg ? -value : value;\n+\n+    while(absvalue)\n+    {\n+      result.push_back(absvalue & 0xff);\n+      absvalue >>= 8;\n+    }\n+\n+/*\n+    - If the most significant byte is >= 0x80 and the value is positive, push a\n+    new zero-byte to make the significant byte < 0x80 again.\n+\n+    - If the most significant byte is >= 0x80 and the value is negative, push a\n+    new 0x80 byte that will be popped off when converting to an integral.\n+\n+    - If the most significant byte is < 0x80 and the value is negative, add\n+    0x80 to it, since it will be subtracted and interpreted as a negative when\n+    converting to an integral.\n+*/\n+    if (result.back() & 0x80)\n+        result.push_back(neg ? 0x80 : 0);\n+    else if (neg)\n+        result.back() |= 0x80;\n+\n+    return result;\n+  }\n+\n+  static const size_t nMaxNumSize = 4;\n+  static const int64_t nMaxOperandValue = 0x7FFFFFFF;\n+  static const int64_t nMinOperandValue = -nMaxOperandValue;\n+  static const int64_t nMaxTotalValue = 0x7FFFFFFFFFLL;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11760391",
      "id" : 11760391,
      "original_commit_id" : "2ee6bf163b328f60e389e71c4e2d245ba2fe4420",
      "original_position" : 154,
      "path" : "src/script.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965",
      "updated_at" : "2014-04-22T04:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11760391",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11760603"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11760603"
         }
      },
      "body" : "The disabled opcodes cannot be re-enabled in the future. I'm not sure why the 5 byte boundary matters here? If you re-enabled OP_MUL, for example, you could certainly do `0x7fffffff * 0x7fffffff == 0x3fffffff00000001` (eight bytes).",
      "commit_id" : "b1fdd5475d9040445d7655730f262f214ea87c5f",
      "created_at" : "2014-04-18T00:35:02Z",
      "diff_hunk" : "@@ -25,6 +24,172 @@\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31...2^31],\n+// but results may overflow (and are valid as long as they are not used in a subsequent\n+// numeric operation). CScriptNum enforces those semantics by storing results as\n+// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n+// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n+\n+public:\n+\n+  explicit CScriptNum(const int64_t& n)\n+  {\n+    if( n > nMaxTotalValue || n < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum(int64_t) : overflow\");\n+    m_value = n;\n+  }\n+\n+  explicit CScriptNum(const std::vector<unsigned char>& vch)\n+  {\n+    if (vch.size() > nMaxNumSize)\n+      throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n+    m_value = set_vch(vch);\n+  }\n+\n+  inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+  inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+  inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+  inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+  inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+  inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+  inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n+  inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n+  inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n+  inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n+  inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n+  inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n+\n+  inline CScriptNum operator-()                         const { return CScriptNum(-m_value);     }\n+  inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n+  inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n+  inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n+  inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n+\n+  inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n+  inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n+\n+  inline CScriptNum& operator=( const int64_t& rhs)\n+  {\n+    if( rhs > nMaxTotalValue || rhs < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum=(int64_t) : overflow\");\n+    m_value = rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator+=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    if (m_value + rhs > nMaxTotalValue || m_value + rhs <  nMinTotalValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    m_value += rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator-=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    if (m_value - rhs < nMinTotalValue || m_value - rhs >  nMaxTotalValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    m_value -= rhs;\n+    return *this;\n+  }\n+\n+  int getint() const\n+  {\n+    if (m_value > std::numeric_limits<int>::max())\n+      return std::numeric_limits<int>::max();\n+    else if (m_value < std::numeric_limits<int>::min())\n+      return std::numeric_limits<int>::min();\n+    return m_value;\n+  }\n+\n+  std::vector<unsigned char> getvch() const\n+  {\n+    return serialize(m_value);\n+  }\n+\n+  static std::vector<unsigned char> serialize(const int64_t& value)\n+  {\n+    //  The input here is not range-checked. This is useful for serializing\n+    //  non-arithmetic data that is not bound by CScriptNum's limits.\n+\n+    if(value == 0)\n+        return std::vector<unsigned char>();\n+\n+    std::vector<unsigned char> result;\n+    const bool neg = value < 0;\n+    uint64_t absvalue = neg ? -value : value;\n+\n+    while(absvalue)\n+    {\n+      result.push_back(absvalue & 0xff);\n+      absvalue >>= 8;\n+    }\n+\n+/*\n+    - If the most significant byte is >= 0x80 and the value is positive, push a\n+    new zero-byte to make the significant byte < 0x80 again.\n+\n+    - If the most significant byte is >= 0x80 and the value is negative, push a\n+    new 0x80 byte that will be popped off when converting to an integral.\n+\n+    - If the most significant byte is < 0x80 and the value is negative, add\n+    0x80 to it, since it will be subtracted and interpreted as a negative when\n+    converting to an integral.\n+*/\n+    if (result.back() & 0x80)\n+        result.push_back(neg ? 0x80 : 0);\n+    else if (neg)\n+        result.back() |= 0x80;\n+\n+    return result;\n+  }\n+\n+  static const size_t nMaxNumSize = 4;\n+  static const int64_t nMaxOperandValue = 0x7FFFFFFF;\n+  static const int64_t nMinOperandValue = -nMaxOperandValue;\n+  static const int64_t nMaxTotalValue = 0x7FFFFFFFFFLL;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11760603",
      "id" : 11760603,
      "original_commit_id" : "2ee6bf163b328f60e389e71c4e2d245ba2fe4420",
      "original_position" : 154,
      "path" : "src/script.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965",
      "updated_at" : "2014-04-22T04:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11760603",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/69154?v=3",
         "events_url" : "https://api.github.com/users/maaku/events{/privacy}",
         "followers_url" : "https://api.github.com/users/maaku/followers",
         "following_url" : "https://api.github.com/users/maaku/following{/other_user}",
         "gists_url" : "https://api.github.com/users/maaku/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/maaku",
         "id" : 69154,
         "login" : "maaku",
         "organizations_url" : "https://api.github.com/users/maaku/orgs",
         "received_events_url" : "https://api.github.com/users/maaku/received_events",
         "repos_url" : "https://api.github.com/users/maaku/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/maaku/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/maaku/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/maaku"
      }
   },
   {
      "body" : "Crazy idea: If we are potentially going to soft-fork script-upgrade in the near future, it might be worth considering just making the soft-fork remove any opcodes that have weird/complicated implementations if they're not in use...",
      "created_at" : "2014-04-18T07:13:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-40791619",
      "id" : 40791619,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-18T07:13:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/40791619",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1095675?v=3",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11769589"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11769589"
         }
      },
      "body" : "I should not have made this comment, it's immaterial.\r\n\r\nThere is no range limit on the values of operands. There is only a size limit on which byte vectors can be converted to integers.\r\n\r\nHow about:\r\n* Only the CScriptNum constructor check the vector size (if arg.size() > 4 throw scripnum_error).\r\n* The + and - operators get an assertion that prevents int64 overflows.\r\n\r\nI think that should be all?",
      "commit_id" : "b1fdd5475d9040445d7655730f262f214ea87c5f",
      "created_at" : "2014-04-18T11:34:25Z",
      "diff_hunk" : "@@ -25,6 +24,172 @@\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31...2^31],\n+// but results may overflow (and are valid as long as they are not used in a subsequent\n+// numeric operation). CScriptNum enforces those semantics by storing results as\n+// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n+// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n+\n+public:\n+\n+  explicit CScriptNum(const int64_t& n)\n+  {\n+    if( n > nMaxTotalValue || n < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum(int64_t) : overflow\");\n+    m_value = n;\n+  }\n+\n+  explicit CScriptNum(const std::vector<unsigned char>& vch)\n+  {\n+    if (vch.size() > nMaxNumSize)\n+      throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n+    m_value = set_vch(vch);\n+  }\n+\n+  inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+  inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+  inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+  inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+  inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+  inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+  inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n+  inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n+  inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n+  inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n+  inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n+  inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n+\n+  inline CScriptNum operator-()                         const { return CScriptNum(-m_value);     }\n+  inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n+  inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n+  inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n+  inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n+\n+  inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n+  inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n+\n+  inline CScriptNum& operator=( const int64_t& rhs)\n+  {\n+    if( rhs > nMaxTotalValue || rhs < nMinTotalValue)\n+      throw scriptnum_error(\"CScriptNum=(int64_t) : overflow\");\n+    m_value = rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator+=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    if (m_value + rhs > nMaxTotalValue || m_value + rhs <  nMinTotalValue)\n+         throw scriptnum_error(\"CScriptNum+=(int64_t) : overflow\");\n+    m_value += rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator-=( const int64_t& rhs)\n+  {\n+    // If the current value is out of the valid operand range, it cannot be\n+    // used for subsequent operations. Check it as well as the incoming operand\n+    // and resulting value.\n+    if (rhs < nMinOperandValue || rhs > nMaxOperandValue || m_value < nMinOperandValue || m_value > nMaxOperandValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    if (m_value - rhs < nMinTotalValue || m_value - rhs >  nMaxTotalValue)\n+         throw scriptnum_error(\"CScriptNum-=(int64_t) : overflow\");\n+    m_value -= rhs;\n+    return *this;\n+  }\n+\n+  int getint() const\n+  {\n+    if (m_value > std::numeric_limits<int>::max())\n+      return std::numeric_limits<int>::max();\n+    else if (m_value < std::numeric_limits<int>::min())\n+      return std::numeric_limits<int>::min();\n+    return m_value;\n+  }\n+\n+  std::vector<unsigned char> getvch() const\n+  {\n+    return serialize(m_value);\n+  }\n+\n+  static std::vector<unsigned char> serialize(const int64_t& value)\n+  {\n+    //  The input here is not range-checked. This is useful for serializing\n+    //  non-arithmetic data that is not bound by CScriptNum's limits.\n+\n+    if(value == 0)\n+        return std::vector<unsigned char>();\n+\n+    std::vector<unsigned char> result;\n+    const bool neg = value < 0;\n+    uint64_t absvalue = neg ? -value : value;\n+\n+    while(absvalue)\n+    {\n+      result.push_back(absvalue & 0xff);\n+      absvalue >>= 8;\n+    }\n+\n+/*\n+    - If the most significant byte is >= 0x80 and the value is positive, push a\n+    new zero-byte to make the significant byte < 0x80 again.\n+\n+    - If the most significant byte is >= 0x80 and the value is negative, push a\n+    new 0x80 byte that will be popped off when converting to an integral.\n+\n+    - If the most significant byte is < 0x80 and the value is negative, add\n+    0x80 to it, since it will be subtracted and interpreted as a negative when\n+    converting to an integral.\n+*/\n+    if (result.back() & 0x80)\n+        result.push_back(neg ? 0x80 : 0);\n+    else if (neg)\n+        result.back() |= 0x80;\n+\n+    return result;\n+  }\n+\n+  static const size_t nMaxNumSize = 4;\n+  static const int64_t nMaxOperandValue = 0x7FFFFFFF;\n+  static const int64_t nMinOperandValue = -nMaxOperandValue;\n+  static const int64_t nMaxTotalValue = 0x7FFFFFFFFFLL;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11769589",
      "id" : 11769589,
      "original_commit_id" : "2ee6bf163b328f60e389e71c4e2d245ba2fe4420",
      "original_position" : 154,
      "path" : "src/script.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965",
      "updated_at" : "2014-04-22T04:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11769589",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Cleaned up the operators as suggested by @sipa and @gmaxwell . Fixed the tests enough to build, but they need to be cleaned up to remove the old assumptions.\r\n\r\nIf you guys are reasonably happy with the way it looks, I'll cleanup and squash it down for further review (it's gotten pretty messy with all the fixups).",
      "created_at" : "2014-04-18T21:48:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-40847481",
      "id" : 40847481,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-18T21:48:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/40847481",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11788796"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11788796"
         }
      },
      "body" : "This seems to imply that there usually is a range checking when serializing. AFAIK, that is never the case.",
      "commit_id" : "b1fdd5475d9040445d7655730f262f214ea87c5f",
      "created_at" : "2014-04-18T22:06:38Z",
      "diff_hunk" : "@@ -25,6 +24,165 @@ class CTransaction;\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31...2^31],\n+// but results may overflow (and are valid as long as they are not used in a subsequent\n+// numeric operation). CScriptNum enforces those semantics by storing results as\n+// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n+// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n+\n+public:\n+\n+  explicit CScriptNum(const int64_t& n)\n+  {\n+    m_value = n;\n+  }\n+\n+  explicit CScriptNum(const std::vector<unsigned char>& vch)\n+  {\n+    if (vch.size() > nMaxNumSize)\n+      throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n+    m_value = set_vch(vch);\n+  }\n+\n+  inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+  inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+  inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+  inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+  inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+  inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+  inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n+  inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n+  inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n+  inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n+  inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n+  inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n+\n+  inline CScriptNum operator-()                         const { return CScriptNum(-m_value);     }\n+  inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n+  inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n+  inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n+  inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n+\n+  inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n+  inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n+\n+  inline CScriptNum& operator=( const int64_t& rhs)\n+  {\n+    m_value = rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator+=( const int64_t& rhs)\n+  {\n+    if (m_value > 0 && rhs > 0)\n+    {\n+      m_value += rhs;\n+      assert(m_value > 0);\n+    }\n+    else if (m_value < 0 && rhs < 0)\n+    {\n+      m_value += rhs;\n+      assert(m_value < 0);\n+    }\n+    else\n+      m_value += rhs;\n+\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator-=( const int64_t& rhs)\n+  {\n+    return operator+=(-rhs);\n+  }\n+\n+  int getint() const\n+  {\n+    if (m_value > std::numeric_limits<int>::max())\n+      return std::numeric_limits<int>::max();\n+    else if (m_value < std::numeric_limits<int>::min())\n+      return std::numeric_limits<int>::min();\n+    return m_value;\n+  }\n+\n+  std::vector<unsigned char> getvch() const\n+  {\n+    return serialize(m_value);\n+  }\n+\n+  static std::vector<unsigned char> serialize(const int64_t& value)\n+  {\n+    //  The input here is not range-checked. This is useful for serializing",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11788796",
      "id" : 11788796,
      "original_commit_id" : "1dae829acea24498e17faf47cb303d9df901790d",
      "original_position" : 109,
      "path" : "src/script.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965",
      "updated_at" : "2014-04-22T04:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11788796",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11788812"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11788812"
         }
      },
      "body" : "These can move to the unit tests now, I think.",
      "commit_id" : "b1fdd5475d9040445d7655730f262f214ea87c5f",
      "created_at" : "2014-04-18T22:07:34Z",
      "diff_hunk" : "@@ -25,6 +24,165 @@ class CTransaction;\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31...2^31],\n+// but results may overflow (and are valid as long as they are not used in a subsequent\n+// numeric operation). CScriptNum enforces those semantics by storing results as\n+// an int64 and allowing out-of-range values to be returned as a vector of bytes but\n+// throwing an exception if arithmetic is done or the result is interpreted as an integer.\n+\n+public:\n+\n+  explicit CScriptNum(const int64_t& n)\n+  {\n+    m_value = n;\n+  }\n+\n+  explicit CScriptNum(const std::vector<unsigned char>& vch)\n+  {\n+    if (vch.size() > nMaxNumSize)\n+      throw scriptnum_error(\"CScriptNum(const std::vector<unsigned char>&) : overflow\");\n+    m_value = set_vch(vch);\n+  }\n+\n+  inline bool operator==(const int64_t& rhs) const    { return m_value == rhs; }\n+  inline bool operator!=(const int64_t& rhs) const    { return m_value != rhs; }\n+  inline bool operator<=(const int64_t& rhs) const    { return m_value <= rhs; }\n+  inline bool operator< (const int64_t& rhs) const    { return m_value <  rhs; }\n+  inline bool operator>=(const int64_t& rhs) const    { return m_value >= rhs; }\n+  inline bool operator> (const int64_t& rhs) const    { return m_value >  rhs; }\n+\n+  inline bool operator==(const CScriptNum& rhs) const { return operator==(rhs.m_value); }\n+  inline bool operator!=(const CScriptNum& rhs) const { return operator!=(rhs.m_value); }\n+  inline bool operator<=(const CScriptNum& rhs) const { return operator<=(rhs.m_value); }\n+  inline bool operator< (const CScriptNum& rhs) const { return operator< (rhs.m_value); }\n+  inline bool operator>=(const CScriptNum& rhs) const { return operator>=(rhs.m_value); }\n+  inline bool operator> (const CScriptNum& rhs) const { return operator> (rhs.m_value); }\n+\n+  inline CScriptNum operator-()                         const { return CScriptNum(-m_value);     }\n+  inline CScriptNum operator+(   const int64_t& rhs)    const { return CScriptNum(m_value + rhs);}\n+  inline CScriptNum operator-(   const int64_t& rhs)    const { return CScriptNum(m_value - rhs);}\n+  inline CScriptNum operator+(   const CScriptNum& rhs) const { return operator+(rhs.m_value);   }\n+  inline CScriptNum operator-(   const CScriptNum& rhs) const { return operator-(rhs.m_value);   }\n+\n+  inline CScriptNum& operator+=( const CScriptNum& rhs)       { return operator+=(rhs.m_value);  }\n+  inline CScriptNum& operator-=( const CScriptNum& rhs)       { return operator-=(rhs.m_value);  }\n+\n+  inline CScriptNum& operator=( const int64_t& rhs)\n+  {\n+    m_value = rhs;\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator+=( const int64_t& rhs)\n+  {\n+    if (m_value > 0 && rhs > 0)\n+    {\n+      m_value += rhs;\n+      assert(m_value > 0);\n+    }\n+    else if (m_value < 0 && rhs < 0)\n+    {\n+      m_value += rhs;\n+      assert(m_value < 0);\n+    }\n+    else\n+      m_value += rhs;\n+\n+    return *this;\n+  }\n+\n+  inline CScriptNum& operator-=( const int64_t& rhs)\n+  {\n+    return operator+=(-rhs);\n+  }\n+\n+  int getint() const\n+  {\n+    if (m_value > std::numeric_limits<int>::max())\n+      return std::numeric_limits<int>::max();\n+    else if (m_value < std::numeric_limits<int>::min())\n+      return std::numeric_limits<int>::min();\n+    return m_value;\n+  }\n+\n+  std::vector<unsigned char> getvch() const\n+  {\n+    return serialize(m_value);\n+  }\n+\n+  static std::vector<unsigned char> serialize(const int64_t& value)\n+  {\n+    //  The input here is not range-checked. This is useful for serializing\n+    //  non-arithmetic data that is not bound by CScriptNum's limits.\n+\n+    if(value == 0)\n+        return std::vector<unsigned char>();\n+\n+    std::vector<unsigned char> result;\n+    const bool neg = value < 0;\n+    uint64_t absvalue = neg ? -value : value;\n+\n+    while(absvalue)\n+    {\n+      result.push_back(absvalue & 0xff);\n+      absvalue >>= 8;\n+    }\n+\n+/*\n+    - If the most significant byte is >= 0x80 and the value is positive, push a\n+    new zero-byte to make the significant byte < 0x80 again.\n+\n+    - If the most significant byte is >= 0x80 and the value is negative, push a\n+    new 0x80 byte that will be popped off when converting to an integral.\n+\n+    - If the most significant byte is < 0x80 and the value is negative, add\n+    0x80 to it, since it will be subtracted and interpreted as a negative when\n+    converting to an integral.\n+*/\n+    if (result.back() & 0x80)\n+        result.push_back(neg ? 0x80 : 0);\n+    else if (neg)\n+        result.back() |= 0x80;\n+\n+    return result;\n+  }\n+\n+  static const size_t nMaxNumSize = 4;\n+  static const int64_t nMaxOperandValue = 0x7FFFFFFF;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11788812",
      "id" : 11788812,
      "original_commit_id" : "1dae829acea24498e17faf47cb303d9df901790d",
      "original_position" : 145,
      "path" : "src/script.h",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965",
      "updated_at" : "2014-04-22T04:46:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11788812",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "ACK.\r\n\r\nI made a few nits inline, but looks good.\r\n\r\nCan you adapt the coding style, though?",
      "created_at" : "2014-04-18T22:09:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-40848900",
      "id" : 40848900,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-18T22:09:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/40848900",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "Squashed down with the following changes:\r\n- rebased to master.\r\n- replaced busted overflow check with a good one (learned lots in the process).\r\n- added overflow check for operator-(int64_min)\r\n- cleaned up tests to match final constraints.\r\n- Matched coding style (I hope).\r\n\r\n@gmaxwell It would be much appreciated if you could run your additional script tests against the latest changes.",
      "created_at" : "2014-04-22T04:40:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-41003318",
      "id" : 41003318,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-22T04:40:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/41003318",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/417043?v=3",
         "events_url" : "https://api.github.com/users/theuni/events{/privacy}",
         "followers_url" : "https://api.github.com/users/theuni/followers",
         "following_url" : "https://api.github.com/users/theuni/following{/other_user}",
         "gists_url" : "https://api.github.com/users/theuni/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/theuni",
         "id" : 417043,
         "login" : "theuni",
         "organizations_url" : "https://api.github.com/users/theuni/orgs",
         "received_events_url" : "https://api.github.com/users/theuni/received_events",
         "repos_url" : "https://api.github.com/users/theuni/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/theuni/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/theuni/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/theuni"
      }
   },
   {
      "body" : "Automatic sanity-testing: PASSED, see http://jenkins.bluematt.me/pull-tester/b1fdd5475d9040445d7655730f262f214ea87c5f for binaries and test log.\nThis test script verifies pulls every time they are updated. It, however, dies sometimes and fails to test properly.  If you are waiting on a test, please check timestamps to verify that the test.log is moving at http://jenkins.bluematt.me/pull-tester/current/\nContact BlueMatt on freenode if something looks broken.",
      "created_at" : "2014-04-22T05:21:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-41004866",
      "id" : 41004866,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-22T05:21:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/41004866",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2110907?v=3",
         "events_url" : "https://api.github.com/users/BitcoinPullTester/events{/privacy}",
         "followers_url" : "https://api.github.com/users/BitcoinPullTester/followers",
         "following_url" : "https://api.github.com/users/BitcoinPullTester/following{/other_user}",
         "gists_url" : "https://api.github.com/users/BitcoinPullTester/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/BitcoinPullTester",
         "id" : 2110907,
         "login" : "BitcoinPullTester",
         "organizations_url" : "https://api.github.com/users/BitcoinPullTester/orgs",
         "received_events_url" : "https://api.github.com/users/BitcoinPullTester/received_events",
         "repos_url" : "https://api.github.com/users/BitcoinPullTester/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/BitcoinPullTester/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/BitcoinPullTester/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/BitcoinPullTester"
      }
   },
   {
      "body" : "It indeed passes my additional tests. I've also started a full testnet resync and I'll give it another visual code review tomorrow.",
      "created_at" : "2014-04-22T07:12:35Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-41010102",
      "id" : 41010102,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-22T07:12:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/41010102",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11841454"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11841454"
         }
      },
      "body" : "This comment is not wrong, but misleading. An input 0x0000000000 would be rejected, even though it is within that range.",
      "commit_id" : "b1fdd5475d9040445d7655730f262f214ea87c5f",
      "created_at" : "2014-04-22T07:42:08Z",
      "diff_hunk" : "@@ -25,6 +24,155 @@ class CTransaction;\n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n \n+class scriptnum_error : public std::runtime_error\n+{\n+public:\n+    explicit scriptnum_error(const std::string& str) : std::runtime_error(str) {}\n+};\n+\n+class CScriptNum\n+{\n+// Numeric opcodes (OP_1ADD, etc) are restricted to operating on 4-byte integers.\n+// The semantics are subtle, though: operands must be in the range [-2^31 +1...2^31 -1],",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#discussion_r11841454",
      "id" : 11841454,
      "original_commit_id" : "b1fdd5475d9040445d7655730f262f214ea87c5f",
      "original_position" : 21,
      "path" : "src/script.h",
      "position" : 21,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/3965",
      "updated_at" : "2014-04-22T07:42:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/11841454",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "body" : "ACK.",
      "created_at" : "2014-04-22T07:46:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/3965#issuecomment-41012311",
      "id" : 41012311,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/3965",
      "updated_at" : "2014-04-22T07:46:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/41012311",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   }
]
