[
   {
      "author_association" : "MEMBER",
      "body" : "Awesome work, concept ACK.",
      "created_at" : "2020-12-17T15:36:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-747514698",
      "id" : 747514698,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc0NzUxNDY5OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-17T15:36:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/747514698",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #20788 (net: add RAII socket and use it instead of bare SOCKET by vasild)\n* #20764 (cli -netinfo peer connections dashboard updates ð â¨ by jonatack)\n* #20757 (doc: tor.md and -onlynet help updates by jonatack)\n* #20724 (Cleanup of -debug=net log messages by ajtowns)\n* #20582 ([doc] Fix documentation of options onlynet and listenonion by wodry)\n* #19415 (net: Make DNS lookup mockable, add fuzzing harness by practicalswift)\n* #19203 (net: Add regression fuzz harness for CVE-2017-18350. Add FuzzedSocket. Add thin SOCKET wrapper. by practicalswift)\n* #19160 (multiprocess: Add basic spawn and IPC support by ryanofsky)\n* #17944 (netaddress: Simplify reachability logic by dongcarl)\n* #16365 (Log RPC parameters (arguments) if -debug=rpcparams by LarryRuane)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2020-12-17T20:13:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-747675535",
      "id" : 747675535,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc0NzY3NTUzNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-10T08:36:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/747675535",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK\r\n\r\n----------\r\n\r\nOnce this is enabled, we should clearly communicate that using a non-popular overlay has privacy/security side-effects",
      "created_at" : "2020-12-18T09:05:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-747959538",
      "id" : 747959538,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc0Nzk1OTUzOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-18T09:05:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/747959538",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@vasild Nice work!\r\n\r\nI like the abstraction  (`Sock`) you've added on top of the socket API. I'm adding something similar in #19203 (see `MockableSocket` and `FuzzedSocket`) to allow for fuzzing the more low-level parts of our networking code (in this specific case a regression fuzz harness for CVE-2017-18350).\r\n\r\nIf you have time: please check that PR out. It would be great if your socket abstraction also covered the needs of the the \"fuzzed socket\" use case. Ideally I'd like to implement my low-level networking code fuzzers using your socket abstraction (something along the lines of `class FuzzedSock : public Sock`) :)\r\n\r\nAside from of the I2P work I think your socket abstraction would be valuable on a stand-alone PR basis :)",
      "created_at" : "2020-12-18T15:09:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-748139978",
      "id" : 748139978,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc0ODEzOTk3OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-18T15:10:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/748139978",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549152178"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549152178"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Q: in case `retval` contains the maximum allowed data shouldn't it get out of the loop?  I mean, I know this is how the previous version of this method worked but I would like to understand why is this how it is.  ",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2020-12-27T18:58:17Z",
      "diff_hunk" : "@@ -0,0 +1,47 @@\n+// Copyright (c) 2015-2020 The Bitcoin Core developers\n+// Copyright (c) 2017 The Zcash developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <fs.h>\n+\n+#include <limits>\n+#include <stdio.h>\n+#include <string>\n+#include <utility>\n+\n+std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+{\n+    FILE *f = fsbridge::fopen(filename, \"rb\");\n+    if (f == nullptr)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    do {\n+        const size_t n = fread(buffer, 1, sizeof(buffer), f);\n+        // Check for reading errors so we don't return any data if we couldn't\n+        // read the entire file (or up to maxsize)\n+        if (ferror(f)) {\n+            fclose(f);\n+            return std::make_pair(false,\"\");\n+        }\n+        retval.append(buffer, buffer+n);\n+    } while (!feof(f) && retval.size() <= maxsize);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549152178",
      "id" : 549152178,
      "line" : 29,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE1MjE3OA==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/util/readwritefile.cpp",
      "position" : 29,
      "pull_request_review_id" : 558952801,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-09T12:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549152178",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549154854"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549154854"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Non-cpp programmer question: is this idiomatically valid?\r\n \r\n```suggestion\r\nbool WriteBinaryFile(const fs::path &filename, const std::string &data)\r\n{\r\n    FILE *f = fsbridge::fopen(filename, \"wb\");\r\n    if (f == nullptr)\r\n        return false;\r\n    if (fwrite(data.data(), 1, data.size(), f) == data.size()) {\r\n        return fclose(f) == 0;\r\n    }        \r\n    fclose(f);\r\n    return false;\r\n}\r\n```",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2020-12-27T19:26:46Z",
      "diff_hunk" : "@@ -0,0 +1,47 @@\n+// Copyright (c) 2015-2020 The Bitcoin Core developers\n+// Copyright (c) 2017 The Zcash developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <fs.h>\n+\n+#include <limits>\n+#include <stdio.h>\n+#include <string>\n+#include <utility>\n+\n+std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+{\n+    FILE *f = fsbridge::fopen(filename, \"rb\");\n+    if (f == nullptr)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    do {\n+        const size_t n = fread(buffer, 1, sizeof(buffer), f);\n+        // Check for reading errors so we don't return any data if we couldn't\n+        // read the entire file (or up to maxsize)\n+        if (ferror(f)) {\n+            fclose(f);\n+            return std::make_pair(false,\"\");\n+        }\n+        retval.append(buffer, buffer+n);\n+    } while (!feof(f) && retval.size() <= maxsize);\n+    fclose(f);\n+    return std::make_pair(true,retval);\n+}\n+\n+bool WriteBinaryFile(const fs::path &filename, const std::string &data)\n+{\n+    FILE *f = fsbridge::fopen(filename, \"wb\");\n+    if (f == nullptr)\n+        return false;\n+    if (fwrite(data.data(), 1, data.size(), f) != data.size()) {\n+        fclose(f);\n+        return false;\n+    }\n+    if (fclose(f) != 0) {\n+        return false;\n+    }\n+    return true;\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549154854",
      "id" : 549154854,
      "line" : 47,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE1NDg1NA==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 47,
      "original_position" : 47,
      "original_start_line" : 34,
      "path" : "src/util/readwritefile.cpp",
      "position" : 47,
      "pull_request_review_id" : 558952801,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : 34,
      "start_side" : "RIGHT",
      "updated_at" : "2021-01-09T12:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549154854",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549161698"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549161698"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This makes `my`, `my=`, `my==` and so on until `my=====` all equivalent. Is this ok? I would have expected partial padding to be invalid.\r\n",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2020-12-27T20:43:01Z",
      "diff_hunk" : "@@ -262,21 +262,22 @@ std::vector<unsigned char> DecodeBase32(const char* p, bool* pf_invalid)\n         }\n         ++p;\n     }\n-    valid = valid && (p - e) % 8 == 0 && p - q < 8;\n+    const bool pad_ok = (p - e) % 8 == 0 || !require_padding;\n+    valid = valid && pad_ok && p - q < 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549161698",
      "id" : 549161698,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE2MTY5OA==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 266,
      "original_position" : 15,
      "original_start_line" : 265,
      "path" : "src/util/strencodings.cpp",
      "position" : null,
      "pull_request_review_id" : 558952801,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-01-09T12:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549161698",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549430723"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549430723"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Build warning here, logical AND of equal expressions [-Wlogical-op]\r\n",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2020-12-28T17:48:58Z",
      "diff_hunk" : "@@ -958,3 +1075,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEWOULDBLOCK && err != WSAEINTR && err != WSAEINPROGRESS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549430723",
      "id" : 549430723,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzMDcyMw==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 1082,
      "original_position" : 203,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 559240653,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-09T12:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549430723",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549475623"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549475623"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Clarification: I am asking this because if this is allow then invalid addresses could be allowed by `SetSpecial`, I mean, something like `udhdrtrcetjm5sxzskjyr5ztpeszydbh4dpl3pl4utgqqw2v4jna=.b32.i2p` would be okay.",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2020-12-28T20:20:53Z",
      "diff_hunk" : "@@ -262,21 +262,22 @@ std::vector<unsigned char> DecodeBase32(const char* p, bool* pf_invalid)\n         }\n         ++p;\n     }\n-    valid = valid && (p - e) % 8 == 0 && p - q < 8;\n+    const bool pad_ok = (p - e) % 8 == 0 || !require_padding;\n+    valid = valid && pad_ok && p - q < 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549475623",
      "id" : 549475623,
      "in_reply_to_id" : 549161698,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ3NTYyMw==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 266,
      "original_position" : 15,
      "original_start_line" : 265,
      "path" : "src/util/strencodings.cpp",
      "position" : null,
      "pull_request_review_id" : 559290249,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-01-09T12:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549475623",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-12-28T23:05:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-751890774",
      "id" : 751890774,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MTg5MDc3NA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-28T23:05:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/751890774",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549614683"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549614683"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, it should get out of the loop and it does due to `retval.size() <= maxsize`.\r\n\r\nIt is true that if `maxsize==10` and `fread()` returns 7 bytes and then 5 bytes, this function will return a `retval` that contains 12 bytes, exceeding `maxsize`. This is also how it works in `master` right now.\r\n\r\nFor the purposes of this PR it suffices to move `ReadBinaryFile()` out of `torcontrol.cpp` so that it can be reused by other code. So I tried to keep changes to the minimum - moved the function and only fixed a gross bug (commit `util: fix ReadBinaryFile() returning partial contents`).",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2020-12-29T08:27:05Z",
      "diff_hunk" : "@@ -0,0 +1,47 @@\n+// Copyright (c) 2015-2020 The Bitcoin Core developers\n+// Copyright (c) 2017 The Zcash developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <fs.h>\n+\n+#include <limits>\n+#include <stdio.h>\n+#include <string>\n+#include <utility>\n+\n+std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+{\n+    FILE *f = fsbridge::fopen(filename, \"rb\");\n+    if (f == nullptr)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    do {\n+        const size_t n = fread(buffer, 1, sizeof(buffer), f);\n+        // Check for reading errors so we don't return any data if we couldn't\n+        // read the entire file (or up to maxsize)\n+        if (ferror(f)) {\n+            fclose(f);\n+            return std::make_pair(false,\"\");\n+        }\n+        retval.append(buffer, buffer+n);\n+    } while (!feof(f) && retval.size() <= maxsize);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549614683",
      "id" : 549614683,
      "in_reply_to_id" : 549152178,
      "line" : 29,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNDY4Mw==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/util/readwritefile.cpp",
      "position" : 29,
      "pull_request_review_id" : 559425900,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-09T12:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549614683",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549615177"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549615177"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yes, those are the same. I guess, when writing new code, it would be a matter of taste which one to use.",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2020-12-29T08:28:46Z",
      "diff_hunk" : "@@ -0,0 +1,47 @@\n+// Copyright (c) 2015-2020 The Bitcoin Core developers\n+// Copyright (c) 2017 The Zcash developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <fs.h>\n+\n+#include <limits>\n+#include <stdio.h>\n+#include <string>\n+#include <utility>\n+\n+std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+{\n+    FILE *f = fsbridge::fopen(filename, \"rb\");\n+    if (f == nullptr)\n+        return std::make_pair(false,\"\");\n+    std::string retval;\n+    char buffer[128];\n+    do {\n+        const size_t n = fread(buffer, 1, sizeof(buffer), f);\n+        // Check for reading errors so we don't return any data if we couldn't\n+        // read the entire file (or up to maxsize)\n+        if (ferror(f)) {\n+            fclose(f);\n+            return std::make_pair(false,\"\");\n+        }\n+        retval.append(buffer, buffer+n);\n+    } while (!feof(f) && retval.size() <= maxsize);\n+    fclose(f);\n+    return std::make_pair(true,retval);\n+}\n+\n+bool WriteBinaryFile(const fs::path &filename, const std::string &data)\n+{\n+    FILE *f = fsbridge::fopen(filename, \"wb\");\n+    if (f == nullptr)\n+        return false;\n+    if (fwrite(data.data(), 1, data.size(), f) != data.size()) {\n+        fclose(f);\n+        return false;\n+    }\n+    if (fclose(f) != 0) {\n+        return false;\n+    }\n+    return true;\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549615177",
      "id" : 549615177,
      "in_reply_to_id" : 549154854,
      "line" : 47,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTYxNTE3Nw==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 47,
      "original_position" : 47,
      "original_start_line" : 34,
      "path" : "src/util/readwritefile.cpp",
      "position" : 47,
      "pull_request_review_id" : 559426489,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : 34,
      "start_side" : "RIGHT",
      "updated_at" : "2021-01-09T12:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549615177",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "a0dc3a2d3...188ba34b4: rebased to resolve conflicts with `master`",
      "created_at" : "2020-12-29T09:40:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-752013415",
      "id" : 752013415,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MjAxMzQxNQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-29T09:40:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/752013415",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549640692"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549640692"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is this on Windows? Which compiler version? Is it upset that `WSAEAGAIN` equals to `WSAEWOULDBLOCK` and so we end up doing something like `err != 5 && err != 5`?\r\n\r\nI checked that gcc 10.2.1, 9.3.0 and 8.4.0 don't emit the warning if we do `err != 5 && err != 6 && err != 5`, so I just reordered the expressions as a simple fixup ro this. Will include in the next push.",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2020-12-29T09:51:27Z",
      "diff_hunk" : "@@ -958,3 +1075,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEWOULDBLOCK && err != WSAEINTR && err != WSAEINPROGRESS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549640692",
      "id" : 549640692,
      "in_reply_to_id" : 549430723,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY0MDY5Mg==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 1082,
      "original_position" : 203,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 559456309,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-09T12:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549640692",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549650863"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549650863"
         }
      },
      "author_association" : "MEMBER",
      "body" : "gcc Debian 10.2.1",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2020-12-29T10:22:54Z",
      "diff_hunk" : "@@ -958,3 +1075,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEWOULDBLOCK && err != WSAEINTR && err != WSAEINPROGRESS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549650863",
      "id" : 549650863,
      "in_reply_to_id" : 549430723,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY1MDg2Mw==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 1082,
      "original_position" : 203,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 559468253,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-09T12:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549650863",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "188ba34b4...f0577c4d7:\r\n* disallow partial padding when decoding `.b32.i2p` addresses\r\n* fix gcc warning ~~(hopefully)~~",
      "created_at" : "2020-12-29T12:59:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-752066569",
      "id" : 752066569,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MjA2NjU2OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-29T18:00:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/752066569",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549695916"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549695916"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Fixed in f0577c4?",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2020-12-29T13:00:49Z",
      "diff_hunk" : "@@ -958,3 +1075,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEWOULDBLOCK && err != WSAEINTR && err != WSAEINPROGRESS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549695916",
      "id" : 549695916,
      "in_reply_to_id" : 549430723,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY5NTkxNg==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 1082,
      "original_position" : 203,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 559522075,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-09T12:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549695916",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549699366"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549699366"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Hah, good catch! It occurred to me that we need not to support decoding base32 strings without padding in general and instead we can append `====` to the 52 chars before `.b32.i2p` and decode it as padded base32 string.\r\n\r\nThis simplifies this PR as I dropped one commit from it: `util: support DecodeBase32() without padding`. Also, added a check that the address is 52 base32 chars since we expect that adding 4 `=` symbols will make it multiple of 8. You suggested such a check [elsewhere](https://github.com/bitcoin/bitcoin/pull/20254#discussion_r543586946).",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2020-12-29T13:11:46Z",
      "diff_hunk" : "@@ -262,21 +262,22 @@ std::vector<unsigned char> DecodeBase32(const char* p, bool* pf_invalid)\n         }\n         ++p;\n     }\n-    valid = valid && (p - e) % 8 == 0 && p - q < 8;\n+    const bool pad_ok = (p - e) % 8 == 0 || !require_padding;\n+    valid = valid && pad_ok && p - q < 8;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549699366",
      "id" : 549699366,
      "in_reply_to_id" : 549161698,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTY5OTM2Ng==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 266,
      "original_position" : 15,
      "original_start_line" : 265,
      "path" : "src/util/strencodings.cpp",
      "position" : null,
      "pull_request_review_id" : 559525983,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-01-09T12:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549699366",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "f0577c4d7...2ae504c4b: allow uppercase and mixedcase I2P addresses, [suggestion](https://github.com/bitcoin/bitcoin/pull/20254#discussion_r544431918)",
      "created_at" : "2020-12-29T13:27:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-752074602",
      "id" : 752074602,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MjA3NDYwMg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-29T13:27:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/752074602",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549765748"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549765748"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes, thank you -- tested that it is fixed in 188ba34 and in 2ae504c",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2020-12-29T16:23:46Z",
      "diff_hunk" : "@@ -958,3 +1075,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEWOULDBLOCK && err != WSAEINTR && err != WSAEINPROGRESS;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r549765748",
      "id" : 549765748,
      "in_reply_to_id" : 549430723,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTc2NTc0OA==",
      "original_commit_id" : "a0dc3a2d3247f838172c12c9c30987e6cea6ebb6",
      "original_line" : 1082,
      "original_position" : 203,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 559605596,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-09T12:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/549765748",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550341889"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550341889"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Time ago Winsock used to have problems with peeking from sockets. According to the KB article below (old) `recv` with `MSG_PEEK`:\r\n\r\n> The peek operation will report the number of bytes up until the first buffer boundary. The bytes remaining in the other boundaries might never be reported, resulting in an incorrect count of data **for code algorithms that depend upon the peek values to be accurate**. Subsequent peek attempts will not reveal the \"hidden\" data, which can still be received from the buffers.\r\n\r\nI don't know if this is still a problem with winsock2 but even in that case it is probably not a problem this algorithm doesn't depend on the accuracy of the `peek_ret` value. Anyway, something to have in mind.\r\n\r\nhttps://mskb.pkisolutions.com/kb/192599",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2020-12-30T22:14:44Z",
      "diff_hunk" : "@@ -1072,3 +1072,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEINTR && err != WSAEWOULDBLOCK && err != WSAEINPROGRESS;\n+}\n+\n+void SendComplete(const SOCKET& socket,\n+                  const std::string& data,\n+                  const std::chrono::milliseconds& timeout,\n+                  CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = send(socket, data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        Sockets sockets;\n+        sockets.send = {socket};\n+        SocketEvents(sockets, std::min(deadline - now, MAX_WAIT_FOR_IO), interrupt);\n+    }\n+}\n+\n+std::string RecvUntilTerminator(const SOCKET& socket,\n+                                uint8_t terminator,\n+                                const std::chrono::milliseconds& timeout,\n+                                CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    std::string data;\n+    bool terminator_found = false;\n+\n+    // We must not consume any bytes past the terminator from the socket.\n+    // One option is to read one byte at a time and check if we have read a terminator.\n+    // However that is very slow. Instead, we peek at what is in the socket and only read\n+    // as much bytes as possible without crossing the terminator.\n+    // Reading 64 MiB of random data with 262526 terminator chars takes 37 seconds to read\n+    // one byte at a time VS 0.71 seconds with the \"peek\" solution below. Reading one byte\n+    // at a time is about 50 times slower.\n+\n+    for (;;) {\n+        char buf[512];\n+\n+        const ssize_t peek_ret = recv(socket, buf, sizeof(buf), MSG_PEEK);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550341889",
      "id" : 550341889,
      "line" : 1148,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM0MTg4OQ==",
      "original_commit_id" : "06286e5b834f0772af9d847e182aeeabfb3efcb5",
      "original_line" : 1148,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : 269,
      "pull_request_review_id" : 560216246,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-09T12:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550341889",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550341913"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550341913"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think that in case it reaches the deadline it should throw because otherwise the timeout will be infringed.\r\n```c++\r\nif (now >= deadline)\r\n```",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2020-12-30T22:14:53Z",
      "diff_hunk" : "@@ -1072,3 +1072,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEINTR && err != WSAEWOULDBLOCK && err != WSAEINPROGRESS;\n+}\n+\n+void SendComplete(const SOCKET& socket,\n+                  const std::string& data,\n+                  const std::chrono::milliseconds& timeout,\n+                  CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = send(socket, data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        Sockets sockets;\n+        sockets.send = {socket};\n+        SocketEvents(sockets, std::min(deadline - now, MAX_WAIT_FOR_IO), interrupt);\n+    }\n+}\n+\n+std::string RecvUntilTerminator(const SOCKET& socket,\n+                                uint8_t terminator,\n+                                const std::chrono::milliseconds& timeout,\n+                                CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    std::string data;\n+    bool terminator_found = false;\n+\n+    // We must not consume any bytes past the terminator from the socket.\n+    // One option is to read one byte at a time and check if we have read a terminator.\n+    // However that is very slow. Instead, we peek at what is in the socket and only read\n+    // as much bytes as possible without crossing the terminator.\n+    // Reading 64 MiB of random data with 262526 terminator chars takes 37 seconds to read\n+    // one byte at a time VS 0.71 seconds with the \"peek\" solution below. Reading one byte\n+    // at a time is about 50 times slower.\n+\n+    for (;;) {\n+        char buf[512];\n+\n+        const ssize_t peek_ret = recv(socket, buf, sizeof(buf), MSG_PEEK);\n+\n+        switch (peek_ret) {\n+        case -1: {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"recv(): %s\", NetworkErrorString(err)));\n+            }\n+            break;\n+        }\n+        case 0:\n+            throw std::runtime_error(\"Connection unexpectedly closed by peer\");\n+        default:\n+            auto end = buf + peek_ret;\n+            auto terminator_pos = std::find(buf, end, terminator);\n+            terminator_found = terminator_pos != end;\n+\n+            const size_t try_len =\n+                terminator_found ? terminator_pos - buf + 1 : static_cast<size_t>(peek_ret);\n+\n+            const ssize_t read_ret = recv(socket, buf, try_len, 0);\n+\n+            if (static_cast<size_t>(read_ret) != try_len) {\n+                throw std::runtime_error(\n+                    strprintf(\"recv() returned %u bytes on attempt to read %u bytes but previous \"\n+                              \"peek claimed %u bytes are available\",\n+                              read_ret, try_len, peek_ret));\n+            }\n+\n+            // Don't include the terminator in the output.\n+            const size_t append_len = terminator_found ? read_ret - 1 : read_ret;\n+\n+            data.append(buf, buf + append_len);\n+\n+            if (terminator_found) {\n+                return data;\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now > deadline) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550341913",
      "id" : 550341913,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDM0MTkxMw==",
      "original_commit_id" : "06286e5b834f0772af9d847e182aeeabfb3efcb5",
      "original_line" : 1186,
      "original_position" : 115,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 560216246,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-09T12:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550341913",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550496783"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550496783"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Yeah, even if the behavior is still the same, we are fine with it.",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2020-12-31T14:43:30Z",
      "diff_hunk" : "@@ -1072,3 +1072,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEINTR && err != WSAEWOULDBLOCK && err != WSAEINPROGRESS;\n+}\n+\n+void SendComplete(const SOCKET& socket,\n+                  const std::string& data,\n+                  const std::chrono::milliseconds& timeout,\n+                  CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = send(socket, data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        Sockets sockets;\n+        sockets.send = {socket};\n+        SocketEvents(sockets, std::min(deadline - now, MAX_WAIT_FOR_IO), interrupt);\n+    }\n+}\n+\n+std::string RecvUntilTerminator(const SOCKET& socket,\n+                                uint8_t terminator,\n+                                const std::chrono::milliseconds& timeout,\n+                                CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    std::string data;\n+    bool terminator_found = false;\n+\n+    // We must not consume any bytes past the terminator from the socket.\n+    // One option is to read one byte at a time and check if we have read a terminator.\n+    // However that is very slow. Instead, we peek at what is in the socket and only read\n+    // as much bytes as possible without crossing the terminator.\n+    // Reading 64 MiB of random data with 262526 terminator chars takes 37 seconds to read\n+    // one byte at a time VS 0.71 seconds with the \"peek\" solution below. Reading one byte\n+    // at a time is about 50 times slower.\n+\n+    for (;;) {\n+        char buf[512];\n+\n+        const ssize_t peek_ret = recv(socket, buf, sizeof(buf), MSG_PEEK);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550496783",
      "id" : 550496783,
      "in_reply_to_id" : 550341889,
      "line" : 1148,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ5Njc4Mw==",
      "original_commit_id" : "06286e5b834f0772af9d847e182aeeabfb3efcb5",
      "original_line" : 1148,
      "original_position" : 74,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : 269,
      "pull_request_review_id" : 560396665,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-09T12:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550496783",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550497443"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550497443"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Right, and also `SendComplete()` uses `>=`. Changed.",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2020-12-31T14:46:43Z",
      "diff_hunk" : "@@ -1072,3 +1072,131 @@ void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;\n }\n+\n+\n+static inline bool IOErrorIsPermanent(int err)\n+{\n+    return err != WSAEAGAIN && err != WSAEINTR && err != WSAEWOULDBLOCK && err != WSAEINPROGRESS;\n+}\n+\n+void SendComplete(const SOCKET& socket,\n+                  const std::string& data,\n+                  const std::chrono::milliseconds& timeout,\n+                  CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    size_t sent{0};\n+\n+    for (;;) {\n+        const ssize_t ret = send(socket, data.data() + sent, data.size() - sent, MSG_NOSIGNAL);\n+\n+        if (ret > 0) {\n+            sent += static_cast<size_t>(ret);\n+            if (sent == data.size()) {\n+                break;\n+            }\n+        } else {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"send(): %s\", NetworkErrorString(err)));\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now >= deadline) {\n+            throw std::runtime_error(strprintf(\n+                \"Send timeout (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        if (interrupt) {\n+            throw std::runtime_error(strprintf(\n+                \"Send interrupted (sent only %u of %u bytes before that)\", sent, data.size()));\n+        }\n+\n+        // Wait for a short while (or the socket to become ready for sending) before retrying\n+        // if nothing was sent.\n+        Sockets sockets;\n+        sockets.send = {socket};\n+        SocketEvents(sockets, std::min(deadline - now, MAX_WAIT_FOR_IO), interrupt);\n+    }\n+}\n+\n+std::string RecvUntilTerminator(const SOCKET& socket,\n+                                uint8_t terminator,\n+                                const std::chrono::milliseconds& timeout,\n+                                CThreadInterrupt& interrupt)\n+{\n+    const auto deadline = GetTime<std::chrono::milliseconds>() + timeout;\n+    std::string data;\n+    bool terminator_found = false;\n+\n+    // We must not consume any bytes past the terminator from the socket.\n+    // One option is to read one byte at a time and check if we have read a terminator.\n+    // However that is very slow. Instead, we peek at what is in the socket and only read\n+    // as much bytes as possible without crossing the terminator.\n+    // Reading 64 MiB of random data with 262526 terminator chars takes 37 seconds to read\n+    // one byte at a time VS 0.71 seconds with the \"peek\" solution below. Reading one byte\n+    // at a time is about 50 times slower.\n+\n+    for (;;) {\n+        char buf[512];\n+\n+        const ssize_t peek_ret = recv(socket, buf, sizeof(buf), MSG_PEEK);\n+\n+        switch (peek_ret) {\n+        case -1: {\n+            const int err = WSAGetLastError();\n+            if (IOErrorIsPermanent(err)) {\n+                throw std::runtime_error(strprintf(\"recv(): %s\", NetworkErrorString(err)));\n+            }\n+            break;\n+        }\n+        case 0:\n+            throw std::runtime_error(\"Connection unexpectedly closed by peer\");\n+        default:\n+            auto end = buf + peek_ret;\n+            auto terminator_pos = std::find(buf, end, terminator);\n+            terminator_found = terminator_pos != end;\n+\n+            const size_t try_len =\n+                terminator_found ? terminator_pos - buf + 1 : static_cast<size_t>(peek_ret);\n+\n+            const ssize_t read_ret = recv(socket, buf, try_len, 0);\n+\n+            if (static_cast<size_t>(read_ret) != try_len) {\n+                throw std::runtime_error(\n+                    strprintf(\"recv() returned %u bytes on attempt to read %u bytes but previous \"\n+                              \"peek claimed %u bytes are available\",\n+                              read_ret, try_len, peek_ret));\n+            }\n+\n+            // Don't include the terminator in the output.\n+            const size_t append_len = terminator_found ? read_ret - 1 : read_ret;\n+\n+            data.append(buf, buf + append_len);\n+\n+            if (terminator_found) {\n+                return data;\n+            }\n+        }\n+\n+        const auto now = GetTime<std::chrono::milliseconds>();\n+\n+        if (now > deadline) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r550497443",
      "id" : 550497443,
      "in_reply_to_id" : 550341913,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDQ5NzQ0Mw==",
      "original_commit_id" : "06286e5b834f0772af9d847e182aeeabfb3efcb5",
      "original_line" : 1186,
      "original_position" : 115,
      "original_start_line" : null,
      "path" : "src/netbase.cpp",
      "position" : null,
      "pull_request_review_id" : 560401527,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-09T12:24:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/550497443",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "2ae504c4b...9445dd490: consider it a timeout if the current time is exactly equal to the deadline",
      "created_at" : "2020-12-31T14:47:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-752978740",
      "id" : 752978740,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1Mjk3ODc0MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-12-31T14:47:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/752978740",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-01-02T13:32:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-753474301",
      "id" : 753474301,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MzQ3NDMwMQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-02T13:32:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/753474301",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Do we actually want to share our address, though? I would think an anonymous connection is strictly better?",
      "created_at" : "2021-01-03T00:22:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-753548139",
      "id" : 753548139,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1MzU0ODEzOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-03T00:22:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/753548139",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Do we actually want to share our address, though?\r\n\r\nIn I2P, like in IP, connections have \"source address\".\r\n\r\n> I would think an anonymous connection is strictly better?\r\n\r\nWhy? In a P2P network peers are supposed to connect to each other, right? Not hide from each other? If we don't want connections to us, then we don't listen on the I2P address (`-i2pacceptincoming=0`) and nobody can reach back.",
      "created_at" : "2021-01-08T13:39:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-756760413",
      "id" : 756760413,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1Njc2MDQxMw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-08T13:39:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/756760413",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "9445dd490...1cced4679: rebase due to conflicts",
      "created_at" : "2021-01-09T12:25:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-757141983",
      "id" : 757141983,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1NzE0MTk4Mw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-09T12:25:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/757141983",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--4a62be1de6b64f3ed646cdc7932c8cf5-->\nðµï¸ @harding @hebasto have been requested to review this pull request as specified in the REVIEWERS file.",
      "created_at" : "2021-01-13T11:46:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#issuecomment-759396675",
      "id" : 759396675,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20685",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc1OTM5NjY3NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-13T11:46:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/759396675",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556654746"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556654746"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think this is unnecessary.",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2021-01-13T16:22:32Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556654746",
      "id" : 556654746,
      "line" : 194,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY1NDc0Ng==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 194,
      "original_position" : 194,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 194,
      "pull_request_review_id" : 567395797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-13T16:55:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556654746",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556661171"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556661171"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "What if no `VALUE` is received?",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2021-01-13T16:30:59Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556661171",
      "id" : 556661171,
      "line" : 229,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY2MTE3MQ==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 229,
      "original_position" : 229,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 229,
      "pull_request_review_id" : 567395797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-13T16:55:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556661171",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556670261"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556670261"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "If there is some kind of `startsWith` function i think it would be better.  ",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2021-01-13T16:42:52Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.socket = sock.Release();\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    SendComplete(sock.Get(), request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556670261",
      "id" : 556670261,
      "line" : 287,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY3MDI2MQ==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 287,
      "original_position" : 287,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 287,
      "pull_request_review_id" : 567395797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-13T16:55:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556670261",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556675792"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556675792"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "It seems correct to assume that `RESULT` is always returned but in one place in the i2p code I can see this:\r\n\r\n```c++\r\n} else if (ARG_IS(0,\"NAMING\") &&\r\n           ARG_IS(1, \"REPLY\")) {\r\n    if(NULL == (arg = ARG_FIND(\"RESULT\"))) {\r\n        SAMLOGS(\"Naming reply with no result\");\r\n       return 0;\r\n   }\r\n```",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2021-01-13T16:50:23Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.socket = sock.Release();\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    SendComplete(sock.Get(), request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = RecvUntilTerminator(sock.Get(), '\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556675792",
      "id" : 556675792,
      "line" : 306,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY3NTc5Mg==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 306,
      "original_position" : 306,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 306,
      "pull_request_review_id" : 567395797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-13T16:55:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556675792",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556676518"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556676518"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The `Reply` class could have a `isOk()` function, what do you think?",
      "commit_id" : "1cced46791ed781c906ca94444eae146fef17549",
      "created_at" : "2021-01-13T16:51:28Z",
      "diff_hunk" : "@@ -0,0 +1,432 @@\n+// Copyright (c) 2020-2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <compat.h>\n+#include <compat/endian.h>\n+#include <crypto/sha256.h>\n+#include <fs.h>\n+#include <i2p.h>\n+#include <logging.h>\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <random.h>\n+#include <util/strencodings.h>\n+#include <tinyformat.h>\n+#include <util/readwritefile.h>\n+#include <util/spanparsing.h>\n+#include <util/system.h>\n+\n+#include <chrono>\n+#include <stdexcept>\n+#include <string>\n+\n+namespace i2p {\n+\n+/**\n+ * Swap Standard Base64 <-> I2P Base64.\n+ * Standard Base64 uses `+` and `/` as last two characters of its alphabet.\n+ * I2P Base64 uses `-` and `~` respectively.\n+ * So it is easy to detect in which one is the input and convert to the other.\n+ * @param[in] from Input to convert.\n+ * @return converted `from`\n+ */\n+static std::string SwapBase64(const std::string& from)\n+{\n+    std::string to;\n+    to.resize(from.size());\n+    for (size_t i = 0; i < from.size(); ++i) {\n+        switch (from[i]) {\n+        case '-':\n+            to[i] = '+';\n+            break;\n+        case '~':\n+            to[i] = '/';\n+            break;\n+        case '+':\n+            to[i] = '-';\n+            break;\n+        case '/':\n+            to[i] = '~';\n+            break;\n+        default:\n+            to[i] = from[i];\n+            break;\n+        }\n+    }\n+    return to;\n+}\n+\n+/**\n+ * Decode an I2P-style Base64 string.\n+ * @param[in] i2p_b64 I2P-style Base64 string.\n+ * @return decoded `i2p_b64`\n+ * @throw std::runtime_error if decoding fails\n+ */\n+static Binary DecodeI2PBase64(const std::string& i2p_b64)\n+{\n+    const std::string& std_b64 = SwapBase64(i2p_b64);\n+    bool invalid;\n+    Binary decoded = DecodeBase64(std_b64.c_str(), &invalid);\n+    if (invalid) {\n+        throw std::runtime_error(strprintf(\"Cannot decode Base64: '%s'\", i2p_b64));\n+    }\n+    return decoded;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (binary).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestBinToAddr(const Binary& dest)\n+{\n+    CSHA256 hasher;\n+    hasher.Write(dest.data(), dest.size());\n+    unsigned char hash[CSHA256::OUTPUT_SIZE];\n+    hasher.Finalize(hash);\n+\n+    CNetAddr addr;\n+    const std::string addr_str = EncodeBase32(hash, false) + \".b32.i2p\";\n+    if (!addr.SetSpecial(addr_str)) {\n+        throw std::runtime_error(strprintf(\"Cannot parse I2P address: '%s'\", addr_str));\n+    }\n+\n+    return addr;\n+}\n+\n+/**\n+ * Derive the .b32.i2p address of an I2P destination (I2P-style Base64).\n+ * @param[in] dest I2P destination.\n+ * @return the address that corresponds to `dest`\n+ * @throw std::runtime_error if conversion fails\n+ */\n+static CNetAddr DestB64ToAddr(const std::string& dest)\n+{\n+    const Binary& decoded = DecodeI2PBase64(dest);\n+    return DestBinToAddr(decoded);\n+}\n+\n+namespace sam {\n+\n+Sock::Sock() : m_socket(INVALID_SOCKET) {}\n+\n+Sock::Sock(SOCKET s) : m_socket(s) {}\n+\n+Sock::Sock(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+}\n+\n+Sock::~Sock() { Reset(); }\n+\n+Sock& Sock::operator=(Sock&& other)\n+{\n+    Reset();\n+    m_socket = other.m_socket;\n+    other.m_socket = INVALID_SOCKET;\n+    return *this;\n+}\n+\n+SOCKET Sock::Get() const { return m_socket; }\n+\n+SOCKET Sock::Release()\n+{\n+    const SOCKET s = m_socket;\n+    m_socket = INVALID_SOCKET;\n+    return s;\n+}\n+\n+void Sock::Reset() { CloseSocket(m_socket); }\n+\n+Session::Session(const fs::path& private_key_file,\n+                 const CService& control_host,\n+                 CThreadInterrupt* interrupt)\n+    : m_private_key_file(private_key_file), m_control_host(control_host), m_interrupt(interrupt),\n+      m_control_sock(INVALID_SOCKET)\n+{\n+}\n+\n+Session::~Session()\n+{\n+    Disconnect();\n+}\n+\n+bool Session::Accept(Connection& accepted)\n+{\n+    static constexpr auto err_wait_begin = 1s;\n+    static constexpr auto err_wait_cap = 1min;\n+    auto err_wait = err_wait_begin;\n+\n+    while (!*m_interrupt) {\n+        try {\n+            Sock sock;\n+\n+            {\n+                LOCK(m_mutex);\n+                CreateIfNotCreatedAlready();\n+                accepted.me = m_my_addr;\n+                sock = StreamAccept();\n+            }\n+\n+            while (!*m_interrupt) {\n+                Sockets sockets;\n+                sockets.recv.insert({sock.Get()});\n+                sockets.err.insert({sock.Get()});\n+\n+                SocketEvents(sockets, MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                if (sockets.recv.count(sock.Get()) == 0 && sockets.err.count(sock.Get()) == 0) {\n+                    // No incoming connections within MAX_WAIT_FOR_IO.\n+                    continue;\n+                }\n+\n+                const std::string& peer_dest =\n+                    RecvUntilTerminator(sock.Get(), '\\n', MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+                accepted.peer = CService(DestB64ToAddr(peer_dest), Params().GetDefaultPort());\n+                accepted.socket = sock.Release();\n+\n+                err_wait = err_wait_begin;\n+\n+                return true;\n+            }\n+        } catch (const std::runtime_error& e) {\n+            Log(\"Error accepting: %s\", e.what());\n+            m_interrupt->sleep_for(err_wait);\n+            if (err_wait < err_wait_cap) {\n+                err_wait *= 2;\n+            }\n+        }\n+    }\n+    return false;\n+}\n+\n+bool Session::Connect(const CService& to, Connection& conn, bool& proxy_error)\n+{\n+    proxy_error = true;\n+\n+    std::string session_id;\n+    Sock sock;\n+    conn.peer = to;\n+\n+    try {\n+        {\n+            LOCK(m_mutex);\n+            CreateIfNotCreatedAlready();\n+            session_id = m_session_id;\n+            conn.me = m_my_addr;\n+            sock = Hello();\n+        }\n+\n+        const Reply& lookup_reply =\n+            SendRequestAndGetReply(sock, strprintf(\"NAMING LOOKUP NAME=%s\", to.ToStringIP()));\n+\n+        const std::string& dest = lookup_reply.Get(\"VALUE\");\n+\n+        const Reply& connect_reply = SendRequestAndGetReply(\n+            sock, strprintf(\"STREAM CONNECT ID=%s DESTINATION=%s SILENT=false\", session_id, dest),\n+            false);\n+\n+        const std::string& result = connect_reply.Get(\"RESULT\");\n+\n+        if (result == \"OK\") {\n+            conn.socket = sock.Release();\n+            return true;\n+        }\n+\n+        if (result == \"INVALID_ID\") {\n+            LOCK(m_mutex);\n+            Disconnect();\n+            throw std::runtime_error(\"Invalid session id\");\n+        }\n+\n+        if (result == \"CANT_REACH_PEER\" || result == \"TIMEOUT\") {\n+            proxy_error = false;\n+        }\n+\n+        throw std::runtime_error(strprintf(\"'%s'\", connect_reply.full));\n+    } catch (const std::runtime_error& e) {\n+        Log(\"Error connecting to %s: %s\", to.ToString(), e.what());\n+        return false;\n+    }\n+}\n+\n+// Private methods\n+\n+std::string Session::Reply::Get(const std::string& key) const\n+{\n+    const auto& pos = keys.find(key);\n+    if (pos == keys.end() || !pos->second.has_value()) {\n+        throw std::runtime_error(\n+            strprintf(\"Missing %s= in the reply to '%s': '%s'\", key, request, full));\n+    }\n+    return pos->second.value();\n+}\n+\n+template <typename... Args>\n+void Session::Log(const std::string& fmt, const Args&... args) const\n+{\n+    LogPrint(BCLog::I2P, \"I2P: %s\\n\", tfm::format(fmt, args...));\n+}\n+\n+Session::Reply Session::SendRequestAndGetReply(const Sock& sock,\n+                                               const std::string& request,\n+                                               bool check_result_ok) const\n+{\n+    SendComplete(sock.Get(), request + \"\\n\", MAX_WAIT_FOR_IO, *m_interrupt);\n+\n+    Reply reply;\n+\n+\n+    // Don't log the full \"SESSION CREATE ...\" because it contains our private key.\n+    reply.request = request.substr(0, 14) == \"SESSION CREATE\" ? \"SESSION CREATE ...\" : request;\n+\n+    // It could take a few minutes for the I2P router to reply as it is querying the I2P network\n+    // (when doing name lookup, for example). Notice: `RecvUntilTerminator()` is checking\n+    // `m_interrupt` more often, so we would not be stuck here for long if `m_interrupt` is\n+    // signaled.\n+    static constexpr auto recv_timeout = 3min;\n+\n+    reply.full = RecvUntilTerminator(sock.Get(), '\\n', recv_timeout, *m_interrupt);\n+\n+    for (const auto& kv : spanparsing::Split(reply.full, ' ')) {\n+        const auto& pos = std::find(kv.begin(), kv.end(), '=');\n+        if (pos != kv.end()) {\n+            reply.keys.emplace(std::string{kv.begin(), pos}, std::string{pos + 1, kv.end()});\n+        } else {\n+            reply.keys.emplace(std::string{kv.begin(), kv.end()}, std::nullopt);\n+        }\n+    }\n+\n+    if (check_result_ok && reply.Get(\"RESULT\") != \"OK\") {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20685#discussion_r556676518",
      "id" : 556676518,
      "line" : 306,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY3NjUxOA==",
      "original_commit_id" : "1da3155d6e0cb72d4b43623d0a91e84309e2fdae",
      "original_line" : 306,
      "original_position" : 306,
      "original_start_line" : null,
      "path" : "src/i2p.cpp",
      "position" : 306,
      "pull_request_review_id" : 567395797,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20685",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-01-13T16:55:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/556676518",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/127973?v=4",
         "events_url" : "https://api.github.com/users/lontivero/events{/privacy}",
         "followers_url" : "https://api.github.com/users/lontivero/followers",
         "following_url" : "https://api.github.com/users/lontivero/following{/other_user}",
         "gists_url" : "https://api.github.com/users/lontivero/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/lontivero",
         "id" : 127973,
         "login" : "lontivero",
         "node_id" : "MDQ6VXNlcjEyNzk3Mw==",
         "organizations_url" : "https://api.github.com/users/lontivero/orgs",
         "received_events_url" : "https://api.github.com/users/lontivero/received_events",
         "repos_url" : "https://api.github.com/users/lontivero/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/lontivero/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/lontivero/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/lontivero"
      }
   }
]
