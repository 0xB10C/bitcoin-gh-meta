[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #19331 (build: Do not include server symbols in wallet by MarcoFalke)\n* #19277 (util: Add Assert identity function by MarcoFalke)\n* #19204 (p2p: Reduce inv traffic during IBD by MarcoFalke)\n* #19134 (test: Replace global wait_until with BitcoinTestFramework.wait_until and mininode.wait_until by dboures)\n* #19107 (p2p: Refactor, move all header verification into the network layer, without changing behavior by troygiorshev)\n* #18985 (bloom: use Span instead of std::vector for `insert` and `contains` [ZAP3] by jb55)\n* #18923 (wallet: Never schedule MaybeCompactWalletDB when -flushwallet is off by MarcoFalke)\n* #18242 (Add BIP324 encrypted p2p transport de-/serializer (only used in tests) by jonasschnelli)\n* #18044 (Use wtxid for transaction relay by sdaftuar)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2020-06-06T12:51:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-640056405",
      "id" : 640056405,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0MDA1NjQwNQ==",
      "updated_at" : "2020-06-22T07:39:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/640056405",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK.\r\n\r\nI was reading the description and this part is a bit unclear:\r\n\r\n>Transactions are requested from new candidates as soon as old requests expire, or NOTFOUND is received, or invalid transactions are received (i.e. this includes the functionality added by, and replaces,  [#18238](https://github.com/bitcoin/bitcoin/pull/18238) ).\r\n\r\nWhy invalid transactions are re-requested? Maybe I can figure out after reading the code, but right now this is confusing.\r\n\r\n",
      "created_at" : "2020-06-09T15:41:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-641389060",
      "id" : 641389060,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0MTM4OTA2MA==",
      "updated_at" : "2020-06-09T15:41:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/641389060",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Why invalid transactions are re-requested? Maybe I can figure out after reading the code, but right now this is confusing.\r\n\r\nIt requires invalid witnesses. When you request a txid T from peer A, and get a response with a transaction with invalid witness, but txid T, then the announcement (T,A) gets marked as COMPLETED.",
      "created_at" : "2020-06-09T16:29:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-641416882",
      "id" : 641416882,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0MTQxNjg4Mg==",
      "updated_at" : "2020-06-09T16:29:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/641416882",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK ",
      "created_at" : "2020-06-18T17:30:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-646202215",
      "id" : 646202215,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0NjIwMjIxNQ==",
      "updated_at" : "2020-06-18T17:30:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/646202215",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443046657"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443046657"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This isn't required. We never copy construct a priority computer.",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-19T21:14:45Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443046657",
      "id" : 443046657,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0NjY1Nw==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 36,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 434344852,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-20T20:01:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443046657",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443048114"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443048114"
         }
      },
      "author_association" : "MEMBER",
      "body" : "missing `*`. I don't know if this messes with doxygen parsing.",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-19T21:20:01Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443048114",
      "id" : 443048114,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0ODExNA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 434344852,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-20T20:01:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443048114",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443051085"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443051085"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is there a reason to specify the underlying type here? Is it required so that it can be packed into 3 bits in the Entry bitfield below?",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-19T21:30:10Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443051085",
      "id" : 443051085,
      "line" : 110,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MTA4NQ==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 110,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 110,
      "pull_request_review_id" : 434344852,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-20T20:01:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443051085",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443051438"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443051438"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: sort this above `REQUESTED` so it's next to the other `CANDIDATE_` entries.",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-19T21:31:10Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid (lowest priority among all outbound if any; among inbound otherwise),\n+        //! assuming there is no REQUESTED entry already.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443051438",
      "id" : 443051438,
      "line" : 119,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MTQzOA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 119,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 119,
      "pull_request_review_id" : 434344852,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-20T20:01:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443051438",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076494"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076494"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-19T23:26:41Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076494",
      "id" : 443076494,
      "in_reply_to_id" : 443046657,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3NjQ5NA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 36,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 434378979,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-20T20:01:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076494",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076518"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076518"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-19T23:26:47Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076518",
      "id" : 443076518,
      "in_reply_to_id" : 443048114,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3NjUxOA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 434378996,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-20T20:01:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076518",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076681"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076681"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, my concern is that otherwise an unsigned type may be picked, and I don't know how that would interact with it being used as a bitfield.",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-19T23:27:52Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076681",
      "id" : 443076681,
      "in_reply_to_id" : 443051085,
      "line" : 110,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3NjY4MQ==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 110,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 110,
      "pull_request_review_id" : 434379183,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-20T20:01:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076681",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076966"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076966"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That doesn't work directly, as EntryTxid's sort order relies on the ordering of these fields. It could use its own enum with the necessary order, that ExtractTxid maps to, but that feels like overkill.",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-19T23:29:46Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid (lowest priority among all outbound if any; among inbound otherwise),\n+        //! assuming there is no REQUESTED entry already.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076966",
      "id" : 443076966,
      "in_reply_to_id" : 443051438,
      "line" : 119,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3Njk2Ng==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 119,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 119,
      "pull_request_review_id" : 434379485,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-20T20:01:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076966",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443105454"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443105454"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe worth adding a comment in the enum definition that the ordering is relied upon by the code that uses the ByTxid indexes. Reordering in ExtractTxid seems like overkill to me too fwiw.",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-20T06:09:43Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid (lowest priority among all outbound if any; among inbound otherwise),\n+        //! assuming there is no REQUESTED entry already.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443105454",
      "id" : 443105454,
      "in_reply_to_id" : 443051438,
      "line" : 119,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEwNTQ1NA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 119,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 119,
      "pull_request_review_id" : 434406412,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-20T20:01:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443105454",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443148041"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443148041"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-20T17:51:26Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid (lowest priority among all outbound if any; among inbound otherwise),\n+        //! assuming there is no REQUESTED entry already.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443148041",
      "id" : 443148041,
      "in_reply_to_id" : 443051438,
      "line" : 119,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE0ODA0MQ==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 119,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 119,
      "pull_request_review_id" : 434443825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-20T20:01:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443148041",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, I think that's a great move to dissociate message paths by class (addr, block, transaction, filters) instead of having all of them melt down in `net_processing`.\r\n\r\nI will do an approach ACK soon, but sounds to me this add more reliance on `boost` ? Also as it's a critical part of the codebase how do we build confidence of the correctness of this new transaction request logic implementation with regards to substituted old part ? (It would be great to come with a model for this as I think it would be desirable to do the same kind of changes for the messy `COMPACT_BLOCKS part of the codebase)",
      "created_at" : "2020-06-22T09:39:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-647405500",
      "id" : 647405500,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0NzQwNTUwMA==",
      "updated_at" : "2020-06-22T09:39:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/647405500",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> sounds to me this add more reliance on `boost` ?\r\n\r\nIt uses boost multi_index, which is also needed by the mempool (which does lookups by txid and feerate eg). If we found (or created) a replacement for that there, it should work here too, so I don't think it's much of an increase in the dependency.",
      "created_at" : "2020-06-22T17:34:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-647672729",
      "id" : 647672729,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0NzY3MjcyOQ==",
      "updated_at" : "2020-06-22T17:34:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/647672729",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@ariard As @ajtowns said, we're already relying on multi_index for the mempool. I also spent a week or two thinking about how to implement this with custom data structures, but it's... really hard to match the same performance/memory usage characteristics without multi_index. So I think it's just the right tool for the job, plus it's a headers-only library (so it doesn't introduce runtime dependencies, which is a large part of what makes boost annoying).\r\n\r\nAs far as correctness/desirability of the behavior goes:\r\n\r\n* Reasoning about whether the behavior is desirable, when considered standalone, I believe is much easier than the current one. The current behavior is very much defined by interactions of randomized insertion orders in a queue, and has few guarantees about what those actually accomplish. You can look at the fuzz test, which contains a complete reimplementation of the semantics (without optimized performance).\r\n\r\n* At a (very) high level you can see that the existing behavior is maintained (apart from the max-in-flight rule) by looking at the changes in test/functional/p2p_tx_download.py. But at a lower level it's again hard to say much because the existing behavior is already so hard to describe exactly.",
      "created_at" : "2020-06-22T18:55:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-647711219",
      "id" : 647711219,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0NzcxMTIxOQ==",
      "updated_at" : "2020-06-22T18:55:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/647711219",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444343931"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444343931"
         }
      },
      "author_association" : "MEMBER",
      "body" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8\r\n\r\n```suggestion\r\n#endif // BITCOIN_TXREQUEST_H\r\n```\r\n\r\nSee: [Source code organization](https://github.com/bitcoin/bitcoin/blob/master/doc/developer-notes.md#source-code-organization)",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-23T16:12:53Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t\n+            sequence) : m_txid(txid), m_time(time), m_peer(peer), m_sequence(sequence), m_inbound(inbound),\n+            m_state(state), m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_inbound, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, m_state == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, m_state, m_state == State::CANDIDATE_OTHER ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid;\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxid/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxid>,\n+                EntryTxidExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->m_state == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->m_state == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_requested += it->m_state == State::REQUESTED;\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxid>::type::iterator it, State new_state);\n+\n+    //! Convert a CANDIDATE_NEW entry into a CANDIDATE_OTHER. If this makes it the new best CANDIDATE_OTHER (and no\n+    //! REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateNew(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with exptime <= now are turned into COMPLETED.\n+    //! - CANDIDATE_NEW entries with reqtime <= now are turned into CANDIDATE_{OTHER,BEST}.\n+    //! - CANDIDATE_{OTHER,BEST} entries with reqtime > now are turned into CANDIDATE_NEW.\n+    void SetTimePoint(std::chrono::microseconds now);\n+\n+public:\n+    //! Construct a TxRequestTracker with the specified parameters.\n+    TxRequestTracker(std::chrono::microseconds inbound_delay, std::chrono::microseconds timeout,\n+        bool deterministic = false);\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxidExtractor).\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    //! A peer went offline, delete any data related to it.\n+    void DeletedPeer(uint64_t uint64_t);\n+\n+    //! For whatever reason, we no longer need this txid. Delete any data related to it.\n+    void AlreadyHaveTx(const uint256& txid);\n+\n+    //! We received a new inv, enter it into the data structure.\n+    void ReceivedInv(uint64_t peer, bool outbound, const uint256& txid, std::chrono::microseconds now);\n+\n+    //! Find the txids to request now from peer.\n+    std::vector<uint256> GetRequestable(uint64_t peer, std::chrono::microseconds now);\n+\n+    //! Inform the data structure that a txid was requested. This can only be called for txids returned by the last\n+    //! GetRequestable call (which must have been for the same peer), with only other RequestedTx and AlreadyHaveTx\n+    //! calls in between (which must have been for the same peer but different txids).\n+    void RequestedTx(uint64_t peer, const uint256& txid, std::chrono::microseconds now);\n+\n+    //! We received a response (a tx, or a NOTFOUND) for txid from peer. Note that if a good tx is received (such\n+    //! that we don't need it anymore), AlreadyHaveTx should be called instead of (or in addition to)\n+    //! ReceivedResponse.\n+    void ReceivedResponse(uint64_t peer, const uint256& txid);\n+\n+    //! Count how many in-flight transactions a peer has.\n+    size_t CountInFlight(uint64_t peer) const;\n+\n+    //! Count how many transactions are being tracked for a peer (including timed-out ones and in-flight ones).\n+    size_t CountTracked(uint64_t peer) const;\n+\n+    //! Count how many announcements are being tracked in total across all peers and transactions.\n+    size_t Size() const { return m_index.size(); }\n+\n+    //! Query configuration parameter inbound delay.\n+    std::chrono::microseconds GetInboundDelay() const { return m_inbound_delay; }\n+\n+    //! Query configuration parameter timeout.\n+    std::chrono::microseconds GetTimeout() const { return m_timeout; }\n+};\n+\n+#endif",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444343931",
      "id" : 444343931,
      "line" : 341,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MzkzMQ==",
      "original_commit_id" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8",
      "original_line" : 332,
      "original_position" : 332,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 341,
      "pull_request_review_id" : 435940895,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-23T16:34:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444343931",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444348343"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444348343"
         }
      },
      "author_association" : "MEMBER",
      "body" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8\r\n\r\nnanonit: the word \"completed\" associates with a \"success\" for me (but I'm not a native English speaker though). These entries are not processed successfully, i.e., a transaction has not been received. Maybe rename `COMPLETED` to more general `PROCESSED` or something similar?",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-23T16:19:51Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444348343",
      "id" : 444348343,
      "line" : 71,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0ODM0Mw==",
      "original_commit_id" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8",
      "original_line" : 71,
      "original_position" : 71,
      "original_start_line" : 68,
      "path" : "src/txrequest.h",
      "position" : 71,
      "pull_request_review_id" : 435940895,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : 68,
      "start_side" : "RIGHT",
      "updated_at" : "2020-06-23T16:34:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444348343",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444351986"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444351986"
         }
      },
      "author_association" : "MEMBER",
      "body" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8\r\n\r\nIt is not clear for me why the `ReceivedResponse()` \"should be called whenever a transaction ... was received from a peer\". It is not the case for a `COMPLETED` entry, no?",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-23T16:25:41Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444351986",
      "id" : 444351986,
      "line" : 85,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM1MTk4Ng==",
      "original_commit_id" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8",
      "original_line" : 85,
      "original_position" : 85,
      "original_start_line" : 83,
      "path" : "src/txrequest.h",
      "position" : 85,
      "pull_request_review_id" : 435940895,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : 83,
      "start_side" : "RIGHT",
      "updated_at" : "2020-06-23T16:34:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444351986",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444515524"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444515524"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm trying not to leave too many nits at this stage, but what kind of maniac breaks lines between the type and parameter name?!",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-23T21:20:50Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444515524",
      "id" : 444515524,
      "line" : 174,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxNTUyNA==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 174,
      "original_position" : 174,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 174,
      "pull_request_review_id" : 436167063,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-23T21:20:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444515524",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444543479"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444543479"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree that a comment is sufficient. ",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-23T22:29:02Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid (lowest priority among all outbound if any; among inbound otherwise),\n+        //! assuming there is no REQUESTED entry already.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444543479",
      "id" : 444543479,
      "in_reply_to_id" : 443051438,
      "line" : 119,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MzQ3OQ==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 119,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 119,
      "pull_request_review_id" : 436203658,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-23T22:29:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444543479",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444545289"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444545289"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm getting this build warning:\r\n\r\n```\r\nIn file included from txrequest.cpp:5:0:\r\n./txrequest.h:158:25: warning: âTxRequestTracker::Entry::m_stateâ is too small to hold all values of âenum class TxRequestTracker::Stateâ\r\n         State m_state : 3;\r\n                         ^\r\n```\r\n\r\nconfigure output:\r\n\r\n```\r\n  target os     = linux\r\n  build os      = linux-gnu\r\n\r\n  CC            = /usr/bin/ccache gcc\r\n  CFLAGS        = -g -O2\r\n  CPPFLAGS      =   -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2  -DHAVE_BUILD_INFO -D__STDC_FORMAT_MACROS\r\n  CXX           = /usr/bin/ccache g++ -std=c++11\r\n  CXXFLAGS      =   -fstack-reuse=none -Wstack-protector -fstack-protector-all  -Wall -Wextra -Wformat -Wvla -Wswitch -Wformat-security -Wredundant-decls -Wunused-variable -Wdate-time -Wsign-compare  -Wno-unused-parameter -Wno-implicit-fallthrough   -g -O2 -fno-extended-identifiers\r\n  LDFLAGS       = -pthread  -Wl,-z,relro -Wl,-z,now -pie  \r\n  ARFLAGS       = cr\r\n```\r\n\r\ngcc version:\r\n\r\n```\r\nâ gcc --version\r\ngcc (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0\r\n```",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-23T22:34:19Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444545289",
      "id" : 444545289,
      "in_reply_to_id" : 443051085,
      "line" : 110,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0NTI4OQ==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 110,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 110,
      "pull_request_review_id" : 436206011,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-23T22:34:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444545289",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444548281"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444548281"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I didn't understand why you were defining this alias until I tried to recompile without and it barfed. Do you think a comment that this is required for the Key Extractor concept (https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors) would help, or is this well known?",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-23T22:43:32Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t\n+            sequence) : m_txid(txid), m_time(time), m_peer(peer), m_sequence(sequence), m_inbound(inbound),\n+            m_state(state), m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_inbound, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, m_state == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, m_state, m_state == State::CANDIDATE_OTHER ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid;\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444548281",
      "id" : 444548281,
      "line" : 207,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0ODI4MQ==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 207,
      "original_position" : 207,
      "original_start_line" : 206,
      "path" : "src/txrequest.h",
      "position" : 207,
      "pull_request_review_id" : 436209763,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : 206,
      "start_side" : "RIGHT",
      "updated_at" : "2020-06-24T00:38:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444548281",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444549027"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444549027"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`s/CANDIDATE{OTHER,_DELAYED,_BEST}/CANDIDATE_{NEW,BEST,OTHER}/`",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-23T22:45:47Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444549027",
      "id" : 444549027,
      "line" : 149,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0OTAyNw==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 149,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 149,
      "pull_request_review_id" : 436209763,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T00:38:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444549027",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444579417"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444579417"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think this will ever do anything. By the time we process this orphan transaction, we will have already called `AlreadyHaveTx()` in a `SendMessages()` call.",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-24T00:29:53Z",
      "diff_hunk" : "@@ -1951,6 +1835,7 @@ void static ProcessOrphanTx(CConnman* connman, CTxMemPool& mempool, std::set<uin\n         if (setMisbehaving.count(fromPeer)) continue;\n         if (AcceptToMemoryPool(mempool, orphan_state, porphanTx, &removed_txn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n+            g_txrequest.AlreadyHaveTx(orphanHash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444579417",
      "id" : 444579417,
      "line" : 1838,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU3OTQxNw==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 1838,
      "original_position" : 206,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 206,
      "pull_request_review_id" : 436209763,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T00:38:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444579417",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444581417"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444581417"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There's a slight inconsistency here: if the transaction is successfully accepted to the mempool, then we call `AlreadyHaveTx()` immediately to remove it from `g_txrequest`, but if it's an orphan, then we only call `AlreadyHaveTx()` the next time a peer would potentially request it in `SendMessages()` (and I think the `AlreadyHaveTx()` call in `ProcessOrphanTx()` is basically always a no-op).\r\n\r\nFor consistency, perhaps we should only call `AlreadyHaveTx()` in `SendMessages()`.",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-24T00:37:43Z",
      "diff_hunk" : "@@ -2817,16 +2702,14 @@ void ProcessMessage(\n \n         TxValidationState state;\n \n-        CNodeState* nodestate = State(pfrom.GetId());\n-        nodestate->m_tx_download.m_tx_announced.erase(inv.hash);\n-        nodestate->m_tx_download.m_tx_in_flight.erase(inv.hash);\n-        EraseTxRequest(inv.hash);\n+        g_txrequest.ReceivedResponse(pfrom.GetId(), inv.hash);\n \n         std::list<CTransactionRef> lRemovedTxn;\n \n         if (!AlreadyHave(inv, mempool) &&\n             AcceptToMemoryPool(mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             mempool.check(&::ChainstateActive().CoinsTip());\n+            g_txrequest.AlreadyHaveTx(inv.hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444581417",
      "id" : 444581417,
      "line" : 2712,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4MTQxNw==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 2712,
      "original_position" : 234,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 234,
      "pull_request_review_id" : 436209763,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T00:38:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444581417",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444584736"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444584736"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Looks like that warning is kind-of a bug in gcc (you can apparently put any value from the underlying type in the enum, and it's complaining that they won't all fit), but it's not fixed until gcc 8.4 or 9.3 -- https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61414",
      "commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "created_at" : "2020-06-24T00:50:48Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444584736",
      "id" : 444584736,
      "in_reply_to_id" : 443051085,
      "line" : 110,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4NDczNg==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 110,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 110,
      "pull_request_review_id" : 436253001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T00:50:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444584736",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   }
]
