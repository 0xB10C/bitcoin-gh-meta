[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #19331 (build: Do not include server symbols in wallet by MarcoFalke)\n* #19306 (refactor: Replace RecursiveMutex with Mutex in CTxMemPool by hebasto)\n* #19277 (util: Add Assert identity function by MarcoFalke)\n* #19134 (test: Replace global wait_until with BitcoinTestFramework.wait_until and mininode.wait_until by dboures)\n* #19107 (p2p: Refactor, move all header verification into the network layer, without changing behavior by troygiorshev)\n* #18985 (bloom: use Span instead of std::vector for `insert` and `contains` [ZAP3] by jb55)\n* #18923 (wallet: Never schedule MaybeCompactWalletDB when -flushwallet is off by MarcoFalke)\n* #18242 (Add BIP324 encrypted p2p transport de-/serializer (only used in tests) by jonasschnelli)\n* #18044 (Use wtxid for transaction relay by sdaftuar)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2020-06-06T12:51:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-640056405",
      "id" : 640056405,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0MDA1NjQwNQ==",
      "updated_at" : "2020-07-01T08:20:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/640056405",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK.\r\n\r\nI was reading the description and this part is a bit unclear:\r\n\r\n>Transactions are requested from new candidates as soon as old requests expire, or NOTFOUND is received, or invalid transactions are received (i.e. this includes the functionality added by, and replaces,  [#18238](https://github.com/bitcoin/bitcoin/pull/18238) ).\r\n\r\nWhy invalid transactions are re-requested? Maybe I can figure out after reading the code, but right now this is confusing.\r\n\r\n",
      "created_at" : "2020-06-09T15:41:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-641389060",
      "id" : 641389060,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0MTM4OTA2MA==",
      "updated_at" : "2020-06-09T15:41:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/641389060",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> Why invalid transactions are re-requested? Maybe I can figure out after reading the code, but right now this is confusing.\r\n\r\nIt requires invalid witnesses. When you request a txid T from peer A, and get a response with a transaction with invalid witness, but txid T, then the announcement (T,A) gets marked as COMPLETED.",
      "created_at" : "2020-06-09T16:29:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-641416882",
      "id" : 641416882,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0MTQxNjg4Mg==",
      "updated_at" : "2020-06-09T16:29:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/641416882",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK ",
      "created_at" : "2020-06-18T17:30:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-646202215",
      "id" : 646202215,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0NjIwMjIxNQ==",
      "updated_at" : "2020-06-18T17:30:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/646202215",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1500952?v=4",
         "events_url" : "https://api.github.com/users/amitiuttarwar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/amitiuttarwar/followers",
         "following_url" : "https://api.github.com/users/amitiuttarwar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/amitiuttarwar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/amitiuttarwar",
         "id" : 1500952,
         "login" : "amitiuttarwar",
         "node_id" : "MDQ6VXNlcjE1MDA5NTI=",
         "organizations_url" : "https://api.github.com/users/amitiuttarwar/orgs",
         "received_events_url" : "https://api.github.com/users/amitiuttarwar/received_events",
         "repos_url" : "https://api.github.com/users/amitiuttarwar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/amitiuttarwar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/amitiuttarwar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/amitiuttarwar"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443046657"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443046657"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This isn't required. We never copy construct a priority computer.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-19T21:14:45Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443046657",
      "id" : 443046657,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0NjY1Nw==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 36,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 434344852,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443046657",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443048114"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443048114"
         }
      },
      "author_association" : "MEMBER",
      "body" : "missing `*`. I don't know if this messes with doxygen parsing.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-19T21:20:01Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443048114",
      "id" : 443048114,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0ODExNA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 434344852,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443048114",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443051085"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443051085"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is there a reason to specify the underlying type here? Is it required so that it can be packed into 3 bits in the Entry bitfield below?",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-19T21:30:10Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443051085",
      "id" : 443051085,
      "line" : 110,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MTA4NQ==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 110,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 110,
      "pull_request_review_id" : 434344852,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443051085",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443051438"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443051438"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit: sort this above `REQUESTED` so it's next to the other `CANDIDATE_` entries.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-19T21:31:10Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid (lowest priority among all outbound if any; among inbound otherwise),\n+        //! assuming there is no REQUESTED entry already.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443051438",
      "id" : 443051438,
      "line" : 119,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA1MTQzOA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 119,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 119,
      "pull_request_review_id" : 434344852,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443051438",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076494"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076494"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-19T23:26:41Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076494",
      "id" : 443076494,
      "in_reply_to_id" : 443046657,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3NjQ5NA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 36,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 434378979,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076494",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076518"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076518"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-19T23:26:47Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076518",
      "id" : 443076518,
      "in_reply_to_id" : 443048114,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3NjUxOA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 88,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 434378996,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076518",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076681"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076681"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yeah, my concern is that otherwise an unsigned type may be picked, and I don't know how that would interact with it being used as a bitfield.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-19T23:27:52Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076681",
      "id" : 443076681,
      "in_reply_to_id" : 443051085,
      "line" : 110,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3NjY4MQ==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 110,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 110,
      "pull_request_review_id" : 434379183,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076681",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076966"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076966"
         }
      },
      "author_association" : "MEMBER",
      "body" : "That doesn't work directly, as EntryTxid's sort order relies on the ordering of these fields. It could use its own enum with the necessary order, that ExtractTxid maps to, but that feels like overkill.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-19T23:29:46Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid (lowest priority among all outbound if any; among inbound otherwise),\n+        //! assuming there is no REQUESTED entry already.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443076966",
      "id" : 443076966,
      "in_reply_to_id" : 443051438,
      "line" : 119,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA3Njk2Ng==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 119,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 119,
      "pull_request_review_id" : 434379485,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443076966",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443105454"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443105454"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe worth adding a comment in the enum definition that the ordering is relied upon by the code that uses the ByTxid indexes. Reordering in ExtractTxid seems like overkill to me too fwiw.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-20T06:09:43Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid (lowest priority among all outbound if any; among inbound otherwise),\n+        //! assuming there is no REQUESTED entry already.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443105454",
      "id" : 443105454,
      "in_reply_to_id" : 443051438,
      "line" : 119,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzEwNTQ1NA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 119,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 119,
      "pull_request_review_id" : 434406412,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443105454",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443148041"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443148041"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-20T17:51:26Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid (lowest priority among all outbound if any; among inbound otherwise),\n+        //! assuming there is no REQUESTED entry already.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r443148041",
      "id" : 443148041,
      "in_reply_to_id" : 443051438,
      "line" : 119,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE0ODA0MQ==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 119,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 119,
      "pull_request_review_id" : 434443825,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/443148041",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, I think that's a great move to dissociate message paths by class (addr, block, transaction, filters) instead of having all of them melt down in `net_processing`.\r\n\r\nI will do an approach ACK soon, but sounds to me this add more reliance on `boost` ? Also as it's a critical part of the codebase how do we build confidence of the correctness of this new transaction request logic implementation with regards to substituted old part ? (It would be great to come with a model for this as I think it would be desirable to do the same kind of changes for the messy `COMPACT_BLOCKS part of the codebase)",
      "created_at" : "2020-06-22T09:39:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-647405500",
      "id" : 647405500,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0NzQwNTUwMA==",
      "updated_at" : "2020-06-22T09:39:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/647405500",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/23310655?v=4",
         "events_url" : "https://api.github.com/users/ariard/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ariard/followers",
         "following_url" : "https://api.github.com/users/ariard/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ariard/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ariard",
         "id" : 23310655,
         "login" : "ariard",
         "node_id" : "MDQ6VXNlcjIzMzEwNjU1",
         "organizations_url" : "https://api.github.com/users/ariard/orgs",
         "received_events_url" : "https://api.github.com/users/ariard/received_events",
         "repos_url" : "https://api.github.com/users/ariard/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ariard/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ariard/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ariard"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> sounds to me this add more reliance on `boost` ?\r\n\r\nIt uses boost multi_index, which is also needed by the mempool (which does lookups by txid and feerate eg). If we found (or created) a replacement for that there, it should work here too, so I don't think it's much of an increase in the dependency.",
      "created_at" : "2020-06-22T17:34:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-647672729",
      "id" : 647672729,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0NzY3MjcyOQ==",
      "updated_at" : "2020-06-22T17:34:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/647672729",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@ariard As @ajtowns said, we're already relying on boost/multi_index for CTxMemPool. I also spent a week or two thinking about how to implement this with custom data structures, but it's... really hard to match the same performance/memory usage characteristics without multi_index. So I think it's just the right tool for the job, plus it's a headers-only library (so it doesn't introduce runtime dependencies, which is a large part of what makes boost annoying).\r\n\r\nAs far as correctness/desirability of the behavior goes:\r\n\r\n* Reasoning about whether the behavior is desirable, when considered standalone, I believe is much easier than the current one. The current behavior is very much defined by interactions of randomized insertion orders in a queue, and has few guarantees about what those actually accomplish. You can look at the fuzz test, which contains a complete reimplementation of the semantics (without optimized performance).\r\n\r\n* At a (very) high level you can see that the existing behavior is maintained (apart from the max-in-flight rule) by looking at the changes in test/functional/p2p_tx_download.py. But at a lower level it's again hard to say much because the existing behavior is already so hard to describe exactly.",
      "created_at" : "2020-06-22T18:55:08Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-647711219",
      "id" : 647711219,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY0NzcxMTIxOQ==",
      "updated_at" : "2020-06-22T19:59:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/647711219",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444343931"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444343931"
         }
      },
      "author_association" : "MEMBER",
      "body" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8\r\n\r\n```suggestion\r\n#endif // BITCOIN_TXREQUEST_H\r\n```\r\n\r\nSee: [Source code organization](https://github.com/bitcoin/bitcoin/blob/master/doc/developer-notes.md#source-code-organization)",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-23T16:12:53Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t\n+            sequence) : m_txid(txid), m_time(time), m_peer(peer), m_sequence(sequence), m_inbound(inbound),\n+            m_state(state), m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_inbound, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, m_state == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, m_state, m_state == State::CANDIDATE_OTHER ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid;\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxid/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxid>,\n+                EntryTxidExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->m_state == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->m_state == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_requested += it->m_state == State::REQUESTED;\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxid>::type::iterator it, State new_state);\n+\n+    //! Convert a CANDIDATE_NEW entry into a CANDIDATE_OTHER. If this makes it the new best CANDIDATE_OTHER (and no\n+    //! REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateNew(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with exptime <= now are turned into COMPLETED.\n+    //! - CANDIDATE_NEW entries with reqtime <= now are turned into CANDIDATE_{OTHER,BEST}.\n+    //! - CANDIDATE_{OTHER,BEST} entries with reqtime > now are turned into CANDIDATE_NEW.\n+    void SetTimePoint(std::chrono::microseconds now);\n+\n+public:\n+    //! Construct a TxRequestTracker with the specified parameters.\n+    TxRequestTracker(std::chrono::microseconds inbound_delay, std::chrono::microseconds timeout,\n+        bool deterministic = false);\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxidExtractor).\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    //! A peer went offline, delete any data related to it.\n+    void DeletedPeer(uint64_t uint64_t);\n+\n+    //! For whatever reason, we no longer need this txid. Delete any data related to it.\n+    void AlreadyHaveTx(const uint256& txid);\n+\n+    //! We received a new inv, enter it into the data structure.\n+    void ReceivedInv(uint64_t peer, bool outbound, const uint256& txid, std::chrono::microseconds now);\n+\n+    //! Find the txids to request now from peer.\n+    std::vector<uint256> GetRequestable(uint64_t peer, std::chrono::microseconds now);\n+\n+    //! Inform the data structure that a txid was requested. This can only be called for txids returned by the last\n+    //! GetRequestable call (which must have been for the same peer), with only other RequestedTx and AlreadyHaveTx\n+    //! calls in between (which must have been for the same peer but different txids).\n+    void RequestedTx(uint64_t peer, const uint256& txid, std::chrono::microseconds now);\n+\n+    //! We received a response (a tx, or a NOTFOUND) for txid from peer. Note that if a good tx is received (such\n+    //! that we don't need it anymore), AlreadyHaveTx should be called instead of (or in addition to)\n+    //! ReceivedResponse.\n+    void ReceivedResponse(uint64_t peer, const uint256& txid);\n+\n+    //! Count how many in-flight transactions a peer has.\n+    size_t CountInFlight(uint64_t peer) const;\n+\n+    //! Count how many transactions are being tracked for a peer (including timed-out ones and in-flight ones).\n+    size_t CountTracked(uint64_t peer) const;\n+\n+    //! Count how many announcements are being tracked in total across all peers and transactions.\n+    size_t Size() const { return m_index.size(); }\n+\n+    //! Query configuration parameter inbound delay.\n+    std::chrono::microseconds GetInboundDelay() const { return m_inbound_delay; }\n+\n+    //! Query configuration parameter timeout.\n+    std::chrono::microseconds GetTimeout() const { return m_timeout; }\n+};\n+\n+#endif",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444343931",
      "id" : 444343931,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0MzkzMQ==",
      "original_commit_id" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8",
      "original_line" : 332,
      "original_position" : 332,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 435940895,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444343931",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444348343"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444348343"
         }
      },
      "author_association" : "MEMBER",
      "body" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8\r\n\r\nnanonit: the word \"completed\" associates with a \"success\" for me (but I'm not a native English speaker though). These entries are not processed successfully, i.e., a transaction has not been received. Maybe rename `COMPLETED` to more general `PROCESSED` or something similar?",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-23T16:19:51Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444348343",
      "id" : 444348343,
      "line" : 71,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM0ODM0Mw==",
      "original_commit_id" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8",
      "original_line" : 71,
      "original_position" : 71,
      "original_start_line" : 68,
      "path" : "src/txrequest.h",
      "position" : 71,
      "pull_request_review_id" : 435940895,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : 68,
      "start_side" : "RIGHT",
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444348343",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444351986"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444351986"
         }
      },
      "author_association" : "MEMBER",
      "body" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8\r\n\r\nIt is not clear for me why the `ReceivedResponse()` \"should be called whenever a transaction ... was received from a peer\". It is not the case for a `COMPLETED` entry, no?",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-23T16:25:41Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444351986",
      "id" : 444351986,
      "line" : 85,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM1MTk4Ng==",
      "original_commit_id" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8",
      "original_line" : 85,
      "original_position" : 85,
      "original_start_line" : 83,
      "path" : "src/txrequest.h",
      "position" : 85,
      "pull_request_review_id" : 435940895,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : 83,
      "start_side" : "RIGHT",
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444351986",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444515524"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444515524"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm trying not to leave too many nits at this stage, but what kind of maniac breaks lines between the type and parameter name?!",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-23T21:20:50Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444515524",
      "id" : 444515524,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxNTUyNA==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 174,
      "original_position" : 174,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436167063,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444515524",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444543479"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444543479"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Agree that a comment is sufficient. ",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-23T22:29:02Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid (lowest priority among all outbound if any; among inbound otherwise),\n+        //! assuming there is no REQUESTED entry already.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444543479",
      "id" : 444543479,
      "in_reply_to_id" : 443051438,
      "line" : 119,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0MzQ3OQ==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 119,
      "original_position" : 120,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 119,
      "pull_request_review_id" : 436203658,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444543479",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444545289"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444545289"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm getting this build warning:\r\n\r\n```\r\nIn file included from txrequest.cpp:5:0:\r\n./txrequest.h:158:25: warning: âTxRequestTracker::Entry::m_stateâ is too small to hold all values of âenum class TxRequestTracker::Stateâ\r\n         State m_state : 3;\r\n                         ^\r\n```\r\n\r\nconfigure output:\r\n\r\n```\r\n  target os     = linux\r\n  build os      = linux-gnu\r\n\r\n  CC            = /usr/bin/ccache gcc\r\n  CFLAGS        = -g -O2\r\n  CPPFLAGS      =   -U_FORTIFY_SOURCE -D_FORTIFY_SOURCE=2  -DHAVE_BUILD_INFO -D__STDC_FORMAT_MACROS\r\n  CXX           = /usr/bin/ccache g++ -std=c++11\r\n  CXXFLAGS      =   -fstack-reuse=none -Wstack-protector -fstack-protector-all  -Wall -Wextra -Wformat -Wvla -Wswitch -Wformat-security -Wredundant-decls -Wunused-variable -Wdate-time -Wsign-compare  -Wno-unused-parameter -Wno-implicit-fallthrough   -g -O2 -fno-extended-identifiers\r\n  LDFLAGS       = -pthread  -Wl,-z,relro -Wl,-z,now -pie  \r\n  ARFLAGS       = cr\r\n```\r\n\r\ngcc version:\r\n\r\n```\r\nâ gcc --version\r\ngcc (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0\r\n```",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-23T22:34:19Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444545289",
      "id" : 444545289,
      "in_reply_to_id" : 443051085,
      "line" : 110,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0NTI4OQ==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 110,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 110,
      "pull_request_review_id" : 436206011,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444545289",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444548281"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444548281"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I didn't understand why you were defining this alias until I tried to recompile without and it barfed. Do you think a comment that this is required for the Key Extractor concept (https://www.boost.org/doc/libs/1_54_0/libs/multi_index/doc/reference/key_extraction.html#key_extractors) would help, or is this well known?",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-23T22:43:32Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t\n+            sequence) : m_txid(txid), m_time(time), m_peer(peer), m_sequence(sequence), m_inbound(inbound),\n+            m_state(state), m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_inbound, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, m_state == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, m_state, m_state == State::CANDIDATE_OTHER ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid;\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444548281",
      "id" : 444548281,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0ODI4MQ==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 217,
      "original_position" : 207,
      "original_start_line" : 206,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436209763,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444548281",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444549027"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444549027"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`s/CANDIDATE{OTHER,_DELAYED,_BEST}/CANDIDATE_{NEW,BEST,OTHER}/`",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-23T22:45:47Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444549027",
      "id" : 444549027,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0OTAyNw==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 149,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436209763,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444549027",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444579417"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444579417"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I don't think this will ever do anything. By the time we process this orphan transaction, we will have already called `AlreadyHaveTx()` in a `SendMessages()` call.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-24T00:29:53Z",
      "diff_hunk" : "@@ -1951,6 +1835,7 @@ void static ProcessOrphanTx(CConnman* connman, CTxMemPool& mempool, std::set<uin\n         if (setMisbehaving.count(fromPeer)) continue;\n         if (AcceptToMemoryPool(mempool, orphan_state, porphanTx, &removed_txn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n+            g_txrequest.AlreadyHaveTx(orphanHash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444579417",
      "id" : 444579417,
      "line" : 1838,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU3OTQxNw==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 1838,
      "original_position" : 206,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 206,
      "pull_request_review_id" : 436209763,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444579417",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444581417"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444581417"
         }
      },
      "author_association" : "MEMBER",
      "body" : "There's a slight inconsistency here: if the transaction is successfully accepted to the mempool, then we call `AlreadyHaveTx()` immediately to remove it from `g_txrequest`, but if it's an orphan, then we only call `AlreadyHaveTx()` the next time a peer would potentially request it in `SendMessages()` (and I think the `AlreadyHaveTx()` call in `ProcessOrphanTx()` is basically always a no-op).\r\n\r\nFor consistency, perhaps we should only call `AlreadyHaveTx()` in `SendMessages()`.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-24T00:37:43Z",
      "diff_hunk" : "@@ -2817,16 +2702,14 @@ void ProcessMessage(\n \n         TxValidationState state;\n \n-        CNodeState* nodestate = State(pfrom.GetId());\n-        nodestate->m_tx_download.m_tx_announced.erase(inv.hash);\n-        nodestate->m_tx_download.m_tx_in_flight.erase(inv.hash);\n-        EraseTxRequest(inv.hash);\n+        g_txrequest.ReceivedResponse(pfrom.GetId(), inv.hash);\n \n         std::list<CTransactionRef> lRemovedTxn;\n \n         if (!AlreadyHave(inv, mempool) &&\n             AcceptToMemoryPool(mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             mempool.check(&::ChainstateActive().CoinsTip());\n+            g_txrequest.AlreadyHaveTx(inv.hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444581417",
      "id" : 444581417,
      "line" : 2712,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4MTQxNw==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 2712,
      "original_position" : 234,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 234,
      "pull_request_review_id" : 436209763,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444581417",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444584736"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444584736"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Looks like that warning is kind-of a bug in gcc (you can [apparently](https://gcc.gnu.org/legacy-ml/gcc/2017-10/msg00129.html) put any value from the underlying type in the enum, and it's complaining that they won't all fit), but it's not fixed until gcc 8.4 or 9.3 -- https://gcc.gnu.org/bugzilla/show_bug.cgi?id=61414\r\n\r\nEDIT: (the example given in the linked list post for putting values from the underlying type in a scoped enum without a static_cast doesn't work for me in g++, so not really sure what's going on there)",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-24T00:50:48Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444584736",
      "id" : 444584736,
      "in_reply_to_id" : 443051085,
      "line" : 110,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4NDczNg==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 110,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 110,
      "pull_request_review_id" : 436253001,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444584736",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444615293"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444615293"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I've struggled with a good name for this, actually, and changed it a few times. The problem is that it corresponds to a number of scenarios:\r\n\r\n* We've received the transaction (but we don't know (yet) if it's a valid one)\r\n* We've received the transaction with an invalid witness\r\n* We've received a NOTFOUND message for the transaction\r\n* The request timed out\r\n\r\nI don't think `PROCESSED` is an improvement, but I admit `COMPLETED` isn't perfect either.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-24T02:50:57Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444615293",
      "id" : 444615293,
      "in_reply_to_id" : 444348343,
      "line" : 71,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYxNTI5Mw==",
      "original_commit_id" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8",
      "original_line" : 71,
      "original_position" : 71,
      "original_start_line" : 68,
      "path" : "src/txrequest.h",
      "position" : 71,
      "pull_request_review_id" : 436289015,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : 68,
      "start_side" : "RIGHT",
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444615293",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444615509"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444615509"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`ReceivedResponse` is what marks the entry as `COMPLETED`.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-24T02:51:50Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444615509",
      "id" : 444615509,
      "in_reply_to_id" : 444351986,
      "line" : 85,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYxNTUwOQ==",
      "original_commit_id" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8",
      "original_line" : 85,
      "original_position" : 85,
      "original_start_line" : 83,
      "path" : "src/txrequest.h",
      "position" : 85,
      "pull_request_review_id" : 436289287,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : 83,
      "start_side" : "RIGHT",
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444615509",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444615824"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444615824"
         }
      },
      "author_association" : "MEMBER",
      "body" : "@jnewbery Does it help if you remove the `: uint8_t`?\r\n\r\nIf this is too annoying we can just store the state as a non-`enum` type.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-24T02:53:14Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444615824",
      "id" : 444615824,
      "in_reply_to_id" : 443051085,
      "line" : 110,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYxNTgyNA==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 110,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 110,
      "pull_request_review_id" : 436289700,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444615824",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444616552"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444616552"
         }
      },
      "author_association" : "MEMBER",
      "body" : "ð¤ª",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-24T02:56:11Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444616552",
      "id" : 444616552,
      "in_reply_to_id" : 444515524,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYxNjU1Mg==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 174,
      "original_position" : 174,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436290592,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444616552",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625237"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625237"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done. Changed to store it as a `uint8_t`.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-24T03:33:55Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/identity.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    PriorityComputer(const PriorityComputer& other) = default;\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is succesfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a response\n+ *   for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is succesfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    enum class State : uint8_t {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625237",
      "id" : 444625237,
      "in_reply_to_id" : 443051085,
      "line" : 110,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYyNTIzNw==",
      "original_commit_id" : "0b836eafc029127b42e699d579cdecb985b938b7",
      "original_line" : 110,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 110,
      "pull_request_review_id" : 436300947,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:33:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625237",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625278"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625278"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-24T03:34:05Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t\n+            sequence) : m_txid(txid), m_time(time), m_peer(peer), m_sequence(sequence), m_inbound(inbound),\n+            m_state(state), m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_inbound, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, m_state == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, m_state, m_state == State::CANDIDATE_OTHER ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid;\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }\n+    };\n+\n+    //! Data type for the main data structure (Entry objects with ByPeer/ByTxid/ByTime indexes).\n+    using Index = boost::multi_index_container<\n+        Entry,\n+        boost::multi_index::indexed_by<\n+            boost::multi_index::ordered_unique<\n+                boost::multi_index::tag<ByPeer>,\n+                boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTxid>,\n+                EntryTxidExtractor\n+            >,\n+            boost::multi_index::ordered_non_unique<\n+                boost::multi_index::tag<ByTime>,\n+                boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>\n+            >\n+        >\n+    >;\n+\n+    //! This tracker's main data structure.\n+    Index m_index;\n+\n+    //! Per-peer statistics object.\n+    struct PeerInfo {\n+        size_t m_total = 0; //!< Total number of entries for this peer.\n+        size_t m_requested = 0; //!< Total number of REQUESTED entries for this peer.\n+\n+        friend bool operator==(const PeerInfo& a, const PeerInfo& b)\n+        {\n+            return std::tie(a.m_total, a.m_requested) == std::tie(b.m_total, b.m_requested);\n+        }\n+    };\n+\n+    //! Map with this tracker's per-peer statistics.\n+    std::unordered_map<uint64_t, PeerInfo> m_peerinfo;\n+\n+    //! Wrapper around Index::...::erase that keeps m_peerinfo up to date.\n+    template<typename Tag>\n+    typename Index::index<Tag>::type::iterator Erase(typename Index::index<Tag>::type::iterator it)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->m_state == State::REQUESTED;\n+        if (--peerit->second.m_total == 0) m_peerinfo.erase(peerit);\n+        return m_index.get<Tag>().erase(it);\n+    }\n+\n+    //! Wrapper around Index::...::modify that keeps m_peerinfo up to date.\n+    template<typename Tag, typename Modifier>\n+    void Modify(typename Index::index<Tag>::type::iterator it, Modifier modifier)\n+    {\n+        auto peerit = m_peerinfo.find(it->m_peer);\n+        peerit->second.m_requested -= it->m_state == State::REQUESTED;\n+        m_index.get<Tag>().modify(it, std::move(modifier));\n+        peerit->second.m_requested += it->m_state == State::REQUESTED;\n+    }\n+\n+    //! Change the state of an entry to something non-IsSelected(). If it was IsSelected(), the next best entry will\n+    //! be marked CANDIDATE_BEST.\n+    void ChangeAndReselect(typename Index::index<ByTxid>::type::iterator it, State new_state);\n+\n+    //! Convert a CANDIDATE_NEW entry into a CANDIDATE_OTHER. If this makes it the new best CANDIDATE_OTHER (and no\n+    //! REQUESTED exists) and better than the CANDIDATE_BEST (if any), it becomes the new CANDIDATE_BEST.\n+    void PromoteCandidateNew(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Convert any entry to a COMPLETED one. If there are no non-COMPLETED entries left for this txid, they are all\n+    //! deleted. If this was a REQUESTED entry, and there are other CANDIDATEs left, the best one is made\n+    //! CANDIDATE_BEST. Returns whether the Entry still exists.\n+    bool MakeCompleted(typename Index::index<ByTxid>::type::iterator it);\n+\n+    //! Make the data structure consistent with a given point in time:\n+    //! - REQUESTED entries with exptime <= now are turned into COMPLETED.\n+    //! - CANDIDATE_NEW entries with reqtime <= now are turned into CANDIDATE_{OTHER,BEST}.\n+    //! - CANDIDATE_{OTHER,BEST} entries with reqtime > now are turned into CANDIDATE_NEW.\n+    void SetTimePoint(std::chrono::microseconds now);\n+\n+public:\n+    //! Construct a TxRequestTracker with the specified parameters.\n+    TxRequestTracker(std::chrono::microseconds inbound_delay, std::chrono::microseconds timeout,\n+        bool deterministic = false);\n+\n+    // Disable copying and assigning (a default copy won't work due the stateful EntryTxidExtractor).\n+    TxRequestTracker(const TxRequestTracker&) = delete;\n+    TxRequestTracker& operator=(const TxRequestTracker&) = delete;\n+\n+    //! A peer went offline, delete any data related to it.\n+    void DeletedPeer(uint64_t uint64_t);\n+\n+    //! For whatever reason, we no longer need this txid. Delete any data related to it.\n+    void AlreadyHaveTx(const uint256& txid);\n+\n+    //! We received a new inv, enter it into the data structure.\n+    void ReceivedInv(uint64_t peer, bool outbound, const uint256& txid, std::chrono::microseconds now);\n+\n+    //! Find the txids to request now from peer.\n+    std::vector<uint256> GetRequestable(uint64_t peer, std::chrono::microseconds now);\n+\n+    //! Inform the data structure that a txid was requested. This can only be called for txids returned by the last\n+    //! GetRequestable call (which must have been for the same peer), with only other RequestedTx and AlreadyHaveTx\n+    //! calls in between (which must have been for the same peer but different txids).\n+    void RequestedTx(uint64_t peer, const uint256& txid, std::chrono::microseconds now);\n+\n+    //! We received a response (a tx, or a NOTFOUND) for txid from peer. Note that if a good tx is received (such\n+    //! that we don't need it anymore), AlreadyHaveTx should be called instead of (or in addition to)\n+    //! ReceivedResponse.\n+    void ReceivedResponse(uint64_t peer, const uint256& txid);\n+\n+    //! Count how many in-flight transactions a peer has.\n+    size_t CountInFlight(uint64_t peer) const;\n+\n+    //! Count how many transactions are being tracked for a peer (including timed-out ones and in-flight ones).\n+    size_t CountTracked(uint64_t peer) const;\n+\n+    //! Count how many announcements are being tracked in total across all peers and transactions.\n+    size_t Size() const { return m_index.size(); }\n+\n+    //! Query configuration parameter inbound delay.\n+    std::chrono::microseconds GetInboundDelay() const { return m_inbound_delay; }\n+\n+    //! Query configuration parameter timeout.\n+    std::chrono::microseconds GetTimeout() const { return m_timeout; }\n+};\n+\n+#endif",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625278",
      "id" : 444625278,
      "in_reply_to_id" : 444343931,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYyNTI3OA==",
      "original_commit_id" : "3d5b4f20015246b7a0dd74b2dc89f389204dd9b8",
      "original_line" : 332,
      "original_position" : 332,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436301005,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:34:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625278",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625313"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625313"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-24T03:34:16Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625313",
      "id" : 444625313,
      "in_reply_to_id" : 444515524,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYyNTMxMw==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 174,
      "original_position" : 174,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436301047,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:34:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625313",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625506"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625506"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Yes sorry John, you're obviously an idiot if you don't know the boost reference documentation by heart ;)\r\n\r\nDone.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-24T03:35:03Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in.\n+        State m_state : 3;\n+        //! Whether this was the very first announcement for this txid.\n+        //! It's only modified right after insertion, at which point it doesn't affect position\n+        //! in any of the indexes. Make it mutable to enable changing without triggering reindex.\n+        mutable bool m_first : 1;\n+\n+        //! Whether this entry is selected. There can be at most 1 selected peer per txid.\n+        bool IsSelected() const { return m_state == State::CANDIDATE_BEST || m_state == State::REQUESTED; }\n+\n+        //! Whether this entry is waiting for a certain time to pass.\n+        bool IsWaiting() const { return m_state == State::REQUESTED || m_state == State::CANDIDATE_NEW; }\n+\n+        //! Whether this entry can feasibly be selected if the current IsSelected() one disappears.\n+        bool IsSelectable() const { return m_state == State::CANDIDATE_OTHER || m_state == State::CANDIDATE_BEST; }\n+\n+        //! Construct a new entry from scratch\n+        Entry(const uint256& txid, uint64_t peer, bool inbound, State state, std::chrono::microseconds time, uint64_t\n+            sequence) : m_txid(txid), m_time(time), m_peer(peer), m_sequence(sequence), m_inbound(inbound),\n+            m_state(state), m_first(false) {}\n+\n+        //! Compute this Entry's priority.\n+        uint64_t ComputePriority(const PriorityComputer& computer) const\n+        {\n+            return computer(m_txid, m_peer, m_inbound, m_first);\n+        }\n+\n+        //! Extract the EntryPeer from this Entry.\n+        EntryPeer ExtractPeer() const { return EntryPeer{m_peer, m_state == State::CANDIDATE_BEST, m_txid}; }\n+\n+        //! Extract the EntryTxid from this Entry.\n+        EntryTxid ExtractTxid(const PriorityComputer& computer) const\n+        {\n+            return EntryTxid{m_txid, m_state, m_state == State::CANDIDATE_OTHER ? ComputePriority(computer) : 0};\n+        }\n+\n+        //! Extract the EntryTime from this Entry.\n+        EntryTime ExtractTime() const { return EntryTime{IsWaiting() ? 0 : IsSelectable() ? 2 : 1, m_time}; }\n+    };\n+\n+    //! This tracker's priority computer.\n+    const PriorityComputer m_computer;\n+\n+    //! An extractor for EntryTxids (with encapsulated PriorityComputer reference).\n+    struct EntryTxidExtractor {\n+    private:\n+        const PriorityComputer& m_computer;\n+    public:\n+        EntryTxidExtractor(const PriorityComputer& computer) : m_computer(computer) {}\n+        using result_type = EntryTxid;\n+        result_type operator()(const Entry& entry) const { return entry.ExtractTxid(m_computer); }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625506",
      "id" : 444625506,
      "in_reply_to_id" : 444548281,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYyNTUwNg==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 217,
      "original_position" : 207,
      "original_start_line" : 206,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436301257,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-06-24T03:35:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625506",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625532"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625532"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-24T03:35:12Z",
      "diff_hunk" : "@@ -0,0 +1,341 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE{OTHER,_DELAYED,_BEST} the reqtime; for REQUESTED the exptime",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444625532",
      "id" : 444625532,
      "in_reply_to_id" : 444549027,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYyNTUzMg==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 149,
      "original_position" : 149,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : null,
      "pull_request_review_id" : 436301291,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:35:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444625532",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444627285"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444627285"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thinking about the case where someone malleates the witness for a tx relayed by txid not wtxid; should we maybe ... I don't know, track the other peers that offered the tx as part of the orphan record, so that we can try getting the correct witness data once we have the parents and can actually see if maybe the witness data was malleated?",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-24T03:42:48Z",
      "diff_hunk" : "@@ -2817,16 +2702,14 @@ void ProcessMessage(\n \n         TxValidationState state;\n \n-        CNodeState* nodestate = State(pfrom.GetId());\n-        nodestate->m_tx_download.m_tx_announced.erase(inv.hash);\n-        nodestate->m_tx_download.m_tx_in_flight.erase(inv.hash);\n-        EraseTxRequest(inv.hash);\n+        g_txrequest.ReceivedResponse(pfrom.GetId(), inv.hash);\n \n         std::list<CTransactionRef> lRemovedTxn;\n \n         if (!AlreadyHave(inv, mempool) &&\n             AcceptToMemoryPool(mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             mempool.check(&::ChainstateActive().CoinsTip());\n+            g_txrequest.AlreadyHaveTx(inv.hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444627285",
      "id" : 444627285,
      "in_reply_to_id" : 444581417,
      "line" : 2712,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYyNzI4NQ==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 2712,
      "original_position" : 234,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 234,
      "pull_request_review_id" : 436303362,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T03:42:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444627285",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444894338"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444894338"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Pieter and I were discussing just this yesterday. The behaviour you describe (not rerequesting an orphan transaction from another announcing peer if we later discover that its witness is mutated) also exists in master. As soon as we put a transaction in `mapOrphanTransactions` it'll return true from `AlreadyHave()` and will then be removed from each peer's `TxDownloadState`.\r\n\r\nI think it's ok to keep this behaviour. Orphan handling is to some extent best effort, so shouldn't be relied on for timely transaction propagation. If an adversary is able to poison a transaction in the orphan set, then we won't rerequest it from other peers when `AcceptToMemoryPool()` fails, but it won't be added to our recent rejects filter, and if just one other peer later announces it to us, we'll attempt to fetch it again.",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-24T13:30:33Z",
      "diff_hunk" : "@@ -2817,16 +2702,14 @@ void ProcessMessage(\n \n         TxValidationState state;\n \n-        CNodeState* nodestate = State(pfrom.GetId());\n-        nodestate->m_tx_download.m_tx_announced.erase(inv.hash);\n-        nodestate->m_tx_download.m_tx_in_flight.erase(inv.hash);\n-        EraseTxRequest(inv.hash);\n+        g_txrequest.ReceivedResponse(pfrom.GetId(), inv.hash);\n \n         std::list<CTransactionRef> lRemovedTxn;\n \n         if (!AlreadyHave(inv, mempool) &&\n             AcceptToMemoryPool(mempool, state, ptx, &lRemovedTxn, false /* bypass_limits */, 0 /* nAbsurdFee */)) {\n             mempool.check(&::ChainstateActive().CoinsTip());\n+            g_txrequest.AlreadyHaveTx(inv.hash);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r444894338",
      "id" : 444894338,
      "in_reply_to_id" : 444581417,
      "line" : 2712,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDg5NDMzOA==",
      "original_commit_id" : "1edf64025ef71125cd3bc506b7fa7125ffb1b958",
      "original_line" : 2712,
      "original_position" : 234,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 234,
      "pull_request_review_id" : 436647539,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-24T13:30:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/444894338",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/1063656?v=4",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "node_id" : "MDQ6VXNlcjEwNjM2NTY=",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r446623480"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/446623480"
         }
      },
      "author_association" : "MEMBER",
      "body" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51\r\n\r\nThere is `SipHashUint256Extra(uint64_t, uint64_t, uint256&, uint32_t)` in the `crypto/siphash` module.\r\nIs it worth to add the reusable `SipHashUint256Extra64(uint64_t, uint64_t, uint256&, uint64_t)` there?",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-28T09:03:53Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r446623480",
      "id" : 446623480,
      "line" : 39,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyMzQ4MA==",
      "original_commit_id" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51",
      "original_line" : 39,
      "original_position" : 39,
      "original_start_line" : null,
      "path" : "src/txrequest.h",
      "position" : 39,
      "pull_request_review_id" : 438760405,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-28T09:03:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/446623480",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r446629277"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/446629277"
         }
      },
      "author_association" : "MEMBER",
      "body" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51\r\n\r\nNo warnings are observed on GCC 9.3.0.\r\nWhat GCC version you are referring to?",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-28T09:59:41Z",
      "diff_hunk" : "@@ -0,0 +1,342 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TXREQUEST_H\n+#define BITCOIN_TXREQUEST_H\n+\n+#include <crypto/siphash.h>\n+#include <uint256.h>\n+\n+#include <boost/multi_index_container.hpp>\n+#include <boost/multi_index/mem_fun.hpp>\n+#include <boost/multi_index/ordered_index.hpp>\n+\n+#include <chrono>\n+#include <unordered_map>\n+#include <vector>\n+\n+#include <stdint.h>\n+\n+\n+/** A functor with embedded salt that computes priority of a txid/peer combination.\n+ *\n+ * The priority is used to order candidates for a given txid; lower priority values are selected first. It has the\n+ * following properties:\n+ * - Priorities for outbound peers are always lower than inbound peers, making them always preferred.\n+ * - Within the set of outbound peers and within the set of inbound peers:\n+ *   - The very first announcement for a given txid is always lowest.\n+ *   - Announcements after the first one are ordered uniformly randomly (using a salted hash of txid/peer).\n+ */\n+class PriorityComputer {\n+    const uint64_t m_k0, m_k1;\n+public:\n+    explicit PriorityComputer(bool deterministic);\n+    uint64_t operator()(const uint256& txid, uint64_t peer, bool inbound, bool first) const\n+    {\n+        uint64_t low_bits = 0;\n+        if (!first) {\n+            low_bits = CSipHasher(m_k0, m_k1).Write(txid.begin(), txid.size()).Write(peer).Finalize() >> 1;\n+        }\n+        return low_bits | uint64_t(inbound) << 63;\n+    }\n+};\n+\n+/** Data structure to keep track of, and schedule, transaction downloads from peers.\n+ *\n+ * === High level behavior ===\n+ *\n+ * Transaction downloads are attempted in random order, first choosing among outbound peers, then inbound ones.\n+ * Inbound peers are only considered after a (configurable) inbound delay, to give time to outbound peers. When a\n+ * NOTFOUND is received, an invalid transaction is received, or a download times out (after a configurable delay),\n+ * the next candidate is immediately scheduled according to the same rules above. The same transaction is never\n+ * re-requested from the same peer, unless the transaction was forgotten about in the mean time. This happens\n+ * whenever no candidates remain, or when a transaction is successfully received.\n+ *\n+ *\n+ * === Specification ===\n+ *\n+ * The data structure maintains a collection of entries:\n+ *\n+ * - CANDIDATE (txid, peer, reqtime) entries representing txids that were announced by peer, and become available for\n+ *   download after reqtime has passed (which is immediately for outbound peers, and inbound_delay after announcement\n+ *   for inbound ones).\n+ *\n+ * - REQUESTED (txid, peer, exptime) entries representing txids that have been requested, and we're awaiting a\n+ *   response for from that peer. The exptime value determines when the request times out.\n+ *\n+ * - COMPLETED (txid, peer) entries representing txids that have been requested from a peer, but they timed out, a\n+ *   NOTFOUND message was received for them, or an invalid response was received. They're only kept around to prevent\n+ *   downloading them again. If only COMPLETED entries exist for a given txid remain (so no CANDIDATE or REQUESTED\n+ *   ones), all of them are deleted (this is an invariant, and maintained by all operations below).\n+ *\n+ * The following operations are supported on this data structure:\n+ *\n+ * - ReceivedInv(txid, peer) adds a new CANDIDATE entry, unless one already exists for that (txid, peer) combination\n+ *   (whether it's CANDIDATE, REQUESTED, or COMPLETED).\n+ *\n+ * - DeletedPeer(peer) deletes all entries for a given peer. It should be called when a peer goes offline.\n+ *\n+ * - AlreadyHaveTx(txid) deletes all entries for a given txid. It should be called when a transaction is successfully\n+ *   added to the mempool, seen in a block, or for whatever reason we no longer care about it.\n+ *\n+ * - ReceivedResponse(peer, txid) converts any CANDIDATE or REQUESTED entry to a COMPLETED one. It should be called\n+ *   whenever a transaction or NOTFOUND was received from a peer. When the transaction is acceptable, AlreadyHaveTx\n+ *   should be called instead of (or in addition to) this operation.\n+ *\n+ * - GetRequestable(peer) does the following:\n+ *   - Convert all REQUESTED entries (for all txids/peers) with (exptime <= now) to COMPLETED entries.\n+ *   - Requestable txids are selected: txids which have no REQUESTED entry, and for which this peer has the\n+ *     lowest-priority CANDIDATE entry among all CANDIDATEs with (reqtime <= now) at the time of the GetRequestable\n+ *     call. As the high bit of the priority is whether or not the peer is inbound, this will always prefer an\n+ *     outbound peer as long as one is available.\n+ *   - The selected txids are sorted in order of announcement and returned (even if multiple were added at the same\n+ *     time, or even when the clock went backwards while they were being added).\n+ *\n+ * - RequestedTx(peer, txid) converts the CANDIDATE entry for the provided peer and txid into a REQUESTED one, with\n+ *   exptime set to (now + timeout). It can ONLY be called immediately after GetRequestable was called (for the same\n+ *   peer), with only AlreadyHaveTx and other RequestedTx calls (both for other txids) in between. Any other\n+ *   non-const operation removes the ability to call RequestedTx.\n+ */\n+class TxRequestTracker {\n+    //! Configuration option: delay before downloading from inbound connection.\n+    const std::chrono::microseconds m_inbound_delay;\n+    //! Configuration option: timeout after requesting a download.\n+    const std::chrono::microseconds m_timeout;\n+\n+    //! The various states a (txid,node) pair can be in.\n+    //! Note that CANDIDATE is split up into 3 substates (NEW, BEST, OTHER), allowing more efficient implementation.\n+    //! Also note that the sorting order of EntryTxid relies on the specific order of values in this enum.\n+    enum class State : uint8_t {\n+        //! A CANDIDATE entry whose reqtime is in the future.\n+        CANDIDATE_NEW,\n+        //! The best CANDIDATE for a given txid; only if there is no REQUESTED entry already for that txid.\n+        //! The CANDIDATE_BEST is the lowest-priority entry among all CANDIDATE_OTHER (and _BEST) ones for that txid.\n+        CANDIDATE_BEST,\n+        //! A REQUESTED entry.\n+        REQUESTED,\n+        //! A CANDIDATE entry that's not CANDIDATE_NEW or CANDIDATE_BEST.\n+        CANDIDATE_OTHER,\n+        //! A COMPLETED entry.\n+        COMPLETED,\n+    };\n+\n+    //! Tag for the EntryPeer-based index.\n+    struct ByPeer {};\n+    //! Tag for the EntryTxid-based index.\n+    struct ByTxid {};\n+    //! Tag for the EntryTime-based index.\n+    struct ByTime {};\n+\n+    //! The ByPeer index is sorted by (peer, state == CANDIDATE_BEST, txid)\n+    using EntryPeer = std::tuple<uint64_t, bool, const uint256&>;\n+\n+    //! The ByTxid index is sorted by (txid, state, priority [CANDIDATE_OTHER]; 0 [otherwise])\n+    using EntryTxid = std::tuple<const uint256&, State, uint64_t>;\n+\n+    //! The ByTime index is sorted by (0 [CANDIDATE_NEW,REQUESTED]; 1 [COMPLETED];\n+    // 2 [CANDIDATE_OTHER,CANDIDATE_BEST], time)\n+    using EntryTime = std::pair<int, std::chrono::microseconds>;\n+\n+    //! The current sequence number. Increases for every announcement. This is used to sort txids returned by\n+    //! GetRequestable in announcement order.\n+    uint64_t m_sequence{0};\n+\n+    //! An announcement entry.\n+    struct Entry {\n+        //! Txid that was announced.\n+        const uint256 m_txid;\n+        //! For CANDIDATE_{NEW,BEST,OTHER} the reqtime; for REQUESTED the exptime\n+        std::chrono::microseconds m_time;\n+        //! What peer the request was from.\n+        const uint64_t m_peer;\n+        //! What sequence number this announcement has.\n+        const uint64_t m_sequence : 59;\n+        //! Whether it's from an outbound peer or not.\n+        const bool m_inbound : 1;\n+        //! What state this announcement is in\n+        //! This is a uint8_t instead of a State to silence a GCC warning.\n+        uint8_t m_state : 3;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r446629277",
      "id" : 446629277,
      "line" : 159,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYyOTI3Nw==",
      "original_commit_id" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51",
      "original_line" : 159,
      "original_position" : 159,
      "original_start_line" : 158,
      "path" : "src/txrequest.h",
      "position" : 159,
      "pull_request_review_id" : 438764703,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : 158,
      "start_side" : "RIGHT",
      "updated_at" : "2020-06-28T09:59:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/446629277",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r446633732"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/446633732"
         }
      },
      "author_association" : "MEMBER",
      "body" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51\r\n\r\nCould passing the `peer` to `SetTimePoint()` improve efficiency by not processing entries related to other peers?",
      "commit_id" : "3df92de7c9778043cbd8927c8309de3b10abed1c",
      "created_at" : "2020-06-28T10:41:55Z",
      "diff_hunk" : "@@ -0,0 +1,241 @@\n+// Copyright (c) 2020 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <txrequest.h>\n+\n+#include <crypto/siphash.h>\n+#include <net.h>\n+#include <random.h>\n+#include <uint256.h>\n+\n+#include <chrono>\n+#include <utility>\n+\n+#include <assert.h>\n+\n+PriorityComputer::PriorityComputer(bool deterministic) :\n+    m_k0{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)},\n+    m_k1{deterministic ? 0 : GetRand(0xFFFFFFFFFFFFFFFF)} {}\n+\n+TxRequestTracker::TxRequestTracker(std::chrono::microseconds inbound_delay, std::chrono::microseconds timeout,\n+    bool deterministic) :\n+    m_inbound_delay(inbound_delay),\n+    m_timeout(timeout),\n+    m_computer(deterministic),\n+    // Explicitly initialize m_index as we need to pass a reference to m_computer to\n+    // EntryTxidExtractor.\n+    m_index(boost::make_tuple(\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryPeer, &Entry::ExtractPeer>(),\n+            std::less<EntryPeer>()\n+        ),\n+        boost::make_tuple(\n+            EntryTxidExtractor(m_computer),\n+            std::less<EntryTxid>()\n+        ),\n+        boost::make_tuple(\n+            boost::multi_index::const_mem_fun<Entry, EntryTime, &Entry::ExtractTime>(),\n+            std::less<EntryTime>()\n+        )\n+    )) {}\n+\n+void TxRequestTracker::PromoteCandidateNew(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    assert(it->GetState() == State::CANDIDATE_NEW);\n+    // Convert CANDIDATE_NEW to CANDIDATE_OTHER first.\n+    Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_OTHER); });\n+    // The following code relies on the fact that the ByTxid is sorted by txid, and then by state (first _NEW, then\n+    // _BEST/REQUESTED, then _OTHER). Within the _OTHER entries, the best one (lowest priority) comes first. Thus, if\n+    // an existing _BEST exists for the same txid that this entry may be preferred over, it must immediately precede\n+    // the newly created _OTHER.\n+    if (it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid ||\n+        std::prev(it)->GetState() == State::CANDIDATE_NEW) {\n+        // This is the new best CANDIDATE_OTHER, and there is no IsSelected() entry for this txid already.\n+        Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+    } else if (std::prev(it)->GetState() == State::CANDIDATE_BEST) {\n+        uint64_t priority_old = std::prev(it)->ComputePriority(m_computer);\n+        uint64_t priority_new = it->ComputePriority(m_computer);\n+        if (priority_new < priority_old) {\n+            // There is a CANDIDATE_BEST entry already, but this one is better.\n+            Modify<ByTxid>(std::prev(it), [](Entry& entry){ entry.SetState(State::CANDIDATE_OTHER); });\n+            Modify<ByTxid>(it, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::ChangeAndReselect(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it,\n+    TxRequestTracker::State new_state)\n+{\n+    if (it->IsSelected()) {\n+        auto it_next = std::next(it);\n+        // The next best CANDIDATE_OTHER, if any, immediately follows the REQUESTED or CANDIDATE_BEST entry in the\n+        // ByTxid index.\n+        if (it_next != m_index.get<ByTxid>().end() && it_next->m_txid == it->m_txid &&\n+            it_next->GetState() == State::CANDIDATE_OTHER) {\n+            // If one such CANDIDATE_OTHER exists (for this txid), convert it to CANDIDATE_BEST.\n+            Modify<ByTxid>(it_next, [](Entry& entry){ entry.SetState(State::CANDIDATE_BEST); });\n+        }\n+    }\n+    Modify<ByTxid>(it, [new_state](Entry& entry){ entry.SetState(new_state); });\n+    assert(!it->IsSelected());\n+}\n+\n+bool TxRequestTracker::MakeCompleted(typename TxRequestTracker::Index::index<ByTxid>::type::iterator it)\n+{\n+    // Nothing to be done if it's already COMPLETED.\n+    if (it->GetState() == State::COMPLETED) return true;\n+\n+    if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != it->m_txid) &&\n+        (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != it->m_txid ||\n+        std::next(it)->GetState() == State::COMPLETED)) {\n+        // This is the first entry for this txid, and the last non-COMPLETED one. There are only COMPLETED ones left.\n+        // Delete them all.\n+        uint256 txid = it->m_txid;\n+        do {\n+            it = Erase<ByTxid>(it);\n+        } while (it != m_index.get<ByTxid>().end() && it->m_txid == txid);\n+        return false;\n+    }\n+\n+    // Mark the entry COMPLETED, and select the best best entry if needed.\n+    ChangeAndReselect(it, State::COMPLETED);\n+\n+    return true;\n+}\n+\n+void TxRequestTracker::SetTimePoint(std::chrono::microseconds now)\n+{\n+    // Iterate over all CANDIDATE_NEW and REQUESTED from old to new, as long as they're in the past,\n+    // and convert them to CANDIDATE_OTHER and COMPLETED respectively.\n+    while (!m_index.empty()) {\n+        auto it = m_index.get<ByTime>().begin();\n+        if (it->GetState() == State::CANDIDATE_NEW && it->m_time <= now) {\n+            PromoteCandidateNew(m_index.project<ByTxid>(it));\n+        } else if (it->GetState() == State::REQUESTED && it->m_time <= now) {\n+            MakeCompleted(m_index.project<ByTxid>(it));\n+        } else {\n+            break;\n+        }\n+    }\n+\n+    while (!m_index.empty()) {\n+        // If time went backwards, we may need to demote CANDIDATE_BEST and CANDIDATE_OTHER entries back\n+        // to CANDIDATE_NEW. This is an unusual edge case, and unlikely to matter in production. However,\n+        // it makes it much easier to specify and test TxRequestTracker's behaviour.\n+        auto it = std::prev(m_index.get<ByTime>().end());\n+        if (it->IsSelectable() && it->m_time > now) {\n+            ChangeAndReselect(m_index.project<ByTxid>(it), State::CANDIDATE_NEW);\n+        } else {\n+            break;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::AlreadyHaveTx(const uint256& txid)\n+{\n+    auto it = m_index.get<ByTxid>().lower_bound(EntryTxid{txid, State::CANDIDATE_NEW, 0});\n+    while (it != m_index.get<ByTxid>().end() && it->m_txid == txid) {\n+        it = Erase<ByTxid>(it);\n+    }\n+}\n+\n+static const uint256 UINT256_ZERO;\n+\n+void TxRequestTracker::DeletedPeer(uint64_t peer)\n+{\n+    auto& index = m_index.get<ByPeer>();\n+    auto it = index.lower_bound(EntryPeer{peer, false, UINT256_ZERO});\n+    while (it != index.end() && it->m_peer == peer) {\n+        // Check what to continue with after this iteration. Note that 'it' may change position, and std::next(it)\n+        // may be deleted in the process, so this needs to be decided beforehand.\n+        auto it_next = (std::next(it) == index.end() || std::next(it)->m_peer != peer) ? index.end() : std::next(it);\n+        // If the entry isn't already COMPLETED, first make it COMPLETED (which will mark other CANDIDATEs as\n+        // CANDIDATE_BEST, or delete all of a txid's entries if no non-COMPLETED ones are left).\n+        if (MakeCompleted(m_index.project<ByTxid>(it))) {\n+            // Then actually delete the entry (unless it was already deleted by MakeCompleted).\n+            Erase<ByPeer>(it);\n+        }\n+        it = it_next;\n+    }\n+}\n+\n+void TxRequestTracker::ReceivedInv(uint64_t peer, bool outbound, const uint256& txid, std::chrono::microseconds now)\n+{\n+    // Bail out if we already have a CANDIDATE_BEST entry for this (txid, peer) combination. The case where there is\n+    // a non-CANDIDATE_BEST entry already will be caught by the uniqueness property of the ByPeer index\n+    // automatically.\n+    if (m_index.get<ByPeer>().count(EntryPeer{peer, true, txid})) return;\n+\n+    auto time = outbound ? now : now + m_inbound_delay;\n+    auto ret = m_index.get<ByPeer>().emplace(txid, peer, !outbound, time, m_sequence);\n+    if (ret.second) {\n+        auto it = m_index.project<ByTxid>(ret.first);\n+        ++m_peerinfo[peer].m_total;\n+        ++m_sequence;\n+        if ((it == m_index.get<ByTxid>().begin() || std::prev(it)->m_txid != txid) &&\n+            (std::next(it) == m_index.get<ByTxid>().end() || std::next(it)->m_txid != txid)) {\n+            // This is both the first and the last entry for a given txid; set its m_first.\n+            ret.first->m_first = true;\n+        }\n+    }\n+}\n+\n+void TxRequestTracker::RequestedTx(uint64_t peer, const uint256& txid, std::chrono::microseconds now)\n+{\n+    auto it = m_index.get<ByPeer>().find(EntryPeer{peer, true, txid});\n+    // RequestedTx can only be called on CANDIDATE_BEST entries (this is implied by its condition that it can only be\n+    // called on txids returned by GetRequestable (and only AlreadyHave and RequestedTx can be called in between,\n+    // which preserve the state of other txids).\n+    assert(it != m_index.get<ByPeer>().end());\n+    assert(it->GetState() == State::CANDIDATE_BEST);\n+    Modify<ByPeer>(it, [now,this](Entry& entry) {\n+        entry.SetState(State::REQUESTED);\n+        entry.m_time = now + m_timeout;\n+    });\n+}\n+\n+void TxRequestTracker::ReceivedResponse(uint64_t peer, const uint256& txid)\n+{\n+    // We need to search the ByPeer index for both (peer, false, txid) and (peer, true, txid).\n+    auto it = m_index.get<ByPeer>().find(EntryPeer{peer, false, txid});\n+    if (it == m_index.get<ByPeer>().end()) it = m_index.get<ByPeer>().find(EntryPeer{peer, true, txid});\n+    if (it != m_index.get<ByPeer>().end()) MakeCompleted(m_index.project<ByTxid>(it));\n+}\n+\n+size_t TxRequestTracker::CountInFlight(uint64_t peer) const\n+{\n+    auto it = m_peerinfo.find(peer);\n+    if (it != m_peerinfo.end()) return it->second.m_requested;\n+    return 0;\n+}\n+\n+size_t TxRequestTracker::CountTracked(uint64_t peer) const\n+{\n+    auto it = m_peerinfo.find(peer);\n+    if (it != m_peerinfo.end()) return it->second.m_total;\n+    return 0;\n+}\n+\n+std::vector<uint256> TxRequestTracker::GetRequestable(uint64_t peer, std::chrono::microseconds now)\n+{\n+    // Move time.\n+    SetTimePoint(now);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#discussion_r446633732",
      "id" : 446633732,
      "line" : 223,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjYzMzczMg==",
      "original_commit_id" : "272a615fad6f93e1b7f9b6245ce9090d07fb4a51",
      "original_line" : 223,
      "original_position" : 223,
      "original_start_line" : null,
      "path" : "src/txrequest.cpp",
      "position" : 223,
      "pull_request_review_id" : 438767993,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19184",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-28T10:42:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/446633732",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-06-29T14:23:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-651155144",
      "id" : 651155144,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1MTE1NTE0NA==",
      "updated_at" : "2020-06-29T14:23:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/651155144",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@gmaxwell suggested that the \"first\" feature (the very first peer to announce a transaction gets priority over other outbound or other inbounds) is changed to instead apply to the first not-max-in-flight peer. The idea is that this would prevent an attacker who races announcements, but doesn't respond, will (as soon as they reach their max-in-flight) not be able to interfere with chains of dependent transactions (which we'd like to request from the same peer).\r\n\r\nThis seems like a good idea, and easy to implement, but it'll require some changes to tests.",
      "created_at" : "2020-07-01T04:40:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-652185602",
      "id" : 652185602,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1MjE4NTYwMg==",
      "updated_at" : "2020-07-01T04:40:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/652185602",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-07-01T14:25:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19184#issuecomment-652450597",
      "id" : 652450597,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19184",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1MjQ1MDU5Nw==",
      "updated_at" : "2020-07-01T14:25:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/652450597",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   }
]
