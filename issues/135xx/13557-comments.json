[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198708045"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198708045"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Inconsistent class name (PartiallySignedInput vs PSBTOutput).",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T05:01:33Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198708045",
      "id" : 198708045,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODcwODA0NQ==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 298,
      "path" : "src/script/sign.h",
      "position" : 358,
      "pull_request_review_id" : 132687160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198708045",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198708146"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198708146"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Perhaps add a comment to explain this function and the one below.",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T05:02:39Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198708146",
      "id" : 198708146,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODcwODE0Ng==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 44,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132687160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198708146",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198764592"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198764592"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Make SignatureData able to store signatures and scripts\"\r\n\r\nnit, `++i`",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T09:04:02Z",
      "diff_hunk" : "@@ -169,15 +171,106 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     sigdata.scriptSig = PushAll(result);\n \n     // Test solution\n-    return solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    sigdata.complete = solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    return sigdata.complete;\n }\n \n-SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn)\n+bool SignatureExtractorChecker::CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    if (checker->CheckSig(scriptSig, vchPubKey, scriptCode, sigversion)) {\n+        CPubKey pubkey(vchPubKey);\n+        sigdata->signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));\n+        return true;\n+    }\n+    return false;\n+}\n+\n+namespace\n+{\n+struct Stacks\n+{\n+    std::vector<valtype> script;\n+    std::vector<valtype> witness;\n+\n+    Stacks() {}\n+    explicit Stacks(const std::vector<valtype>& scriptSigStack_) : script(scriptSigStack_), witness() {}\n+    explicit Stacks(const SignatureData& data) : witness(data.scriptWitness.stack) {\n+        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SigVersion::BASE);\n+    }\n+\n+    SignatureData Output() const {\n+        SignatureData result;\n+        result.scriptSig = PushAll(script);\n+        result.scriptWitness.stack = witness;\n+        return result;\n+    }\n+};\n+}\n+\n+// Extracts signatures and scripts from incomplete scriptSigs. Please do not extend this, use PSBT instead\n+SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn, const CTxOut& txout)\n {\n     SignatureData data;\n     assert(tx.vin.size() > nIn);\n     data.scriptSig = tx.vin[nIn].scriptSig;\n     data.scriptWitness = tx.vin[nIn].scriptWitness;\n+    Stacks stack(data);\n+\n+    // Get signatures\n+    MutableTransactionSignatureChecker tx_checker(&tx, nIn, txout.nValue);\n+    SignatureExtractorChecker extractor_checker(&data, &tx_checker);\n+    if (VerifyScript(data.scriptSig, txout.scriptPubKey, &data.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, extractor_checker)) {\n+        data.complete = true;\n+        return data;\n+    }\n+\n+    // Get scripts\n+    txnouttype script_type;\n+    std::vector<std::vector<unsigned char>> solutions;\n+    Solver(txout.scriptPubKey, script_type, solutions);\n+    SigVersion sigversion = SigVersion::BASE;\n+    CScript next_script = txout.scriptPubKey;\n+\n+    if (script_type == TX_SCRIPTHASH && !stack.script.empty() && !stack.script.back().empty()) {\n+        // Get the redeemScript\n+        CScript redeem_script(stack.script.back().begin(), stack.script.back().end());\n+        data.redeem_script = redeem_script;\n+        next_script = std::move(redeem_script);\n+\n+        // Get redeemScript type\n+        Solver(next_script, script_type, solutions);\n+        stack.script.pop_back();\n+    }\n+    if (script_type == TX_WITNESS_V0_SCRIPTHASH && !stack.witness.empty() && !stack.witness.back().empty()) {\n+        // Get the witnessScript\n+        CScript witness_script(stack.witness.back().begin(), stack.witness.back().end());\n+        data.witness_script = witness_script;\n+        next_script = std::move(witness_script);\n+\n+        // Get witnessScript type\n+        Solver(next_script, script_type, solutions);\n+        stack.witness.pop_back();\n+        stack.script = std::move(stack.witness);\n+        stack.witness.clear();\n+        sigversion = SigVersion::WITNESS_V0;\n+    }\n+    if (script_type == TX_MULTISIG && !stack.script.empty()) {\n+        // Build a map of pubkey -> signature by matching sigs to pubkeys:\n+        assert(solutions.size() > 1);\n+        unsigned int num_pubkeys = solutions.size()-2;\n+        unsigned int last_success_key = 0;\n+        for (const valtype& sig : stack.script) {\n+            for (unsigned int i = last_success_key; i < num_pubkeys; i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198764592",
      "id" : 198764592,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc2NDU5Mg==",
      "original_commit_id" : "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
      "original_position" : 104,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132751570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198764592",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198766870"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198766870"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit  \"Make SignatureData able to store signatures and scripts\"\r\n\r\n`class SignatureExtractorChecker final`?",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T09:09:27Z",
      "diff_hunk" : "@@ -81,4 +91,15 @@ void UpdateInput(CTxIn& input, const SignatureData& data);\n  * Solvability is unrelated to whether we consider this output to be ours. */\n bool IsSolvable(const SigningProvider& provider, const CScript& script);\n \n+class SignatureExtractorChecker : public BaseSignatureChecker",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198766870",
      "id" : 198766870,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc2Njg3MA==",
      "original_commit_id" : "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
      "original_position" : 40,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132751570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198766870",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198769412"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198769412"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Make SignatureData able to store signatures and scripts\"\r\n\r\nThis is called when `pubkey.GetID()` doesn't exists in signatures, maybe assert it is new:\r\n```cpp\r\nauto i = sigdata->signatures.emplace(...);\r\nassert(i.second);\r\n```",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T09:15:36Z",
      "diff_hunk" : "@@ -169,15 +171,106 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     sigdata.scriptSig = PushAll(result);\n \n     // Test solution\n-    return solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    sigdata.complete = solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    return sigdata.complete;\n }\n \n-SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn)\n+bool SignatureExtractorChecker::CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    if (checker->CheckSig(scriptSig, vchPubKey, scriptCode, sigversion)) {\n+        CPubKey pubkey(vchPubKey);\n+        sigdata->signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198769412",
      "id" : 198769412,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc2OTQxMg==",
      "original_commit_id" : "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
      "original_position" : 23,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132751570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198769412",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198769810"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198769810"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Make SignatureData able to store signatures and scripts\"\r\n\r\nUse references instead of pointers?",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T09:16:40Z",
      "diff_hunk" : "@@ -81,4 +91,15 @@ void UpdateInput(CTxIn& input, const SignatureData& data);\n  * Solvability is unrelated to whether we consider this output to be ours. */\n bool IsSolvable(const SigningProvider& provider, const CScript& script);\n \n+class SignatureExtractorChecker : public BaseSignatureChecker\n+{\n+private:\n+    SignatureData* sigdata;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198769810",
      "id" : 198769810,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc2OTgxMA==",
      "original_commit_id" : "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
      "original_position" : 43,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132751570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198769810",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198771222"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198771222"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Replace CombineSignatures with ProduceSignature\"\r\n\r\nLooks like these could be references:\r\n```cpp\r\nstatic bool GetCScript(const SigningProvider& provider, const SignatureData& sigdata, const CScriptID &scriptid, CScript& script)\r\n```\r\nand remove `provider != nullptr` below.",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T09:20:06Z",
      "diff_hunk" : "@@ -33,14 +33,60 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n+static bool GetCScript(const SigningProvider* provider, const SignatureData* sigdata, const CScriptID &scriptid, CScript& script)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198771222",
      "id" : 198771222,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc3MTIyMg==",
      "original_commit_id" : "c5d47a58fdeea1a3ed206e5cdb2c37d70942c819",
      "original_position" : 4,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132751570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198771222",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198773739"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198773739"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Otherwise fix space before `scriptid` argument. Same below in the definition.",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T09:25:59Z",
      "diff_hunk" : "@@ -33,14 +33,60 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n+static bool GetCScript(const SigningProvider* provider, const SignatureData* sigdata, const CScriptID &scriptid, CScript& script)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198773739",
      "id" : 198773739,
      "in_reply_to_id" : 198771222,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc3MzczOQ==",
      "original_commit_id" : "c5d47a58fdeea1a3ed206e5cdb2c37d70942c819",
      "original_position" : 4,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132751570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198773739",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198774215"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198774215"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Replace CombineSignatures with ProduceSignature\"\r\n\r\nAs pointed by @MarcoFalke, don't use references to iterators. Check throughout too.",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T09:27:04Z",
      "diff_hunk" : "@@ -33,14 +33,60 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n+static bool GetCScript(const SigningProvider* provider, const SignatureData* sigdata, const CScriptID &scriptid, CScript& script)\n+{\n+    if (provider != nullptr && provider->GetCScript(scriptid, script)) {\n+        return true;\n+    }\n+    // Look for scripts in SignatureData\n+    if (CScriptID(sigdata->redeem_script) == scriptid) {\n+        script = sigdata->redeem_script;\n+        return true;\n+    } else if (CScriptID(sigdata->witness_script) == scriptid) {\n+        script = sigdata->witness_script;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+static bool GetPubKey(const SigningProvider* provider, const SignatureData* sigdata, const CKeyID &address, CPubKey& pubkey)\n+{\n+    if (provider != nullptr && provider->GetPubKey(address, pubkey)) {\n+        return true;\n+    }\n+    // Look for pubkey in all partial sigs\n+    const auto& it = sigdata->signatures.find(address);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198774215",
      "id" : 198774215,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc3NDIxNQ==",
      "original_commit_id" : "c5d47a58fdeea1a3ed206e5cdb2c37d70942c819",
      "original_position" : 26,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132751570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198774215",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->Note to reviewers: This pull request conflicts with the following ones:\n\n* #13449 ([WIP] support new multisig template in wallet for Solver, signing, and signature combining by instagibbs)\n* #13429 (Return the script type from Solver by Empact)\n* #13360 ([Policy] Reject SIGHASH_SINGLE with output out of bound by jl2012)\n* #13359 (wallet: Directly operate with CMutableTransaction by MarcoFalke)\n* #13266 (refactoring: Inline DataFromTransaction via new SignatureData constructor by Empact)\n* #13144 (RPC: Improve error messages on RPC endpoints that use GetTransaction by jimpo)\n* #13098 (Skip tx-rehashing on historic blocks by MarcoFalke)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-06-28T09:28:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-400972753",
      "id" : 400972753,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMDk3Mjc1Mw==",
      "updated_at" : "2018-06-28T09:28:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/400972753",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@promag Just so you know, those commits are part of #13425 ",
      "created_at" : "2018-06-28T17:52:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-401119664",
      "id" : 401119664,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMTExOTY2NA==",
      "updated_at" : "2018-06-28T17:52:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401119664",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Ops @achow101 do you want me to comment there?",
      "created_at" : "2018-06-28T18:01:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-401122013",
      "id" : 401122013,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMTEyMjAxMw==",
      "updated_at" : "2018-06-28T18:01:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401122013",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198933070"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198933070"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think this can be written as just `std::vector<unsigned char> sig; s >> sig`.",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T18:01:31Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198933070",
      "id" : 198933070,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODkzMzA3MA==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 200,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132687160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198933070",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198934388"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198934388"
         }
      },
      "author_association" : "MEMBER",
      "body" : "For this one and the next, check whether you don't already have the other UTXO type?",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T18:06:09Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198934388",
      "id" : 198934388,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODkzNDM4OA==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 172,
      "path" : "src/script/sign.h",
      "position" : 253,
      "pull_request_review_id" : 132687160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198934388",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198937087"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198937087"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Here you can again just use `std::vector<unsigned char> val_bytes; s >> val_bytes;`.",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T18:15:21Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198937087",
      "id" : 198937087,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODkzNzA4Nw==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 281,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132687160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198937087",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198937464"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198937464"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can you abstract out the serialization/deserialization code for derivation paths and scripts into separate functions? Otherwise it is needlessly duplicated across input and outputs.",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T18:16:37Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198937464",
      "id" : 198937464,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODkzNzQ2NA==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 380,
      "path" : "src/script/sign.h",
      "position" : 436,
      "pull_request_review_id" : 132687160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198937464",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198946369"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198946369"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Do you still need `num_ins` and `use_in_index`?",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T18:44:44Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    uint64_t num_ins = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198946369",
      "id" : 198946369,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk0NjM2OQ==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 438,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132687160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198946369",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198947030"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198947030"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why the `!s.empty()` check here? If we reach EOF in the stream an error should be raised, not ignore it.",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T18:46:56Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    bool IsNull() const;\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return a.tx.GetHash() == b.tx.GetHash();\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // unsigned tx flag\n+        SerializeToVector(s, PSBT_GLOBAL_UNSIGNED_TX);\n+\n+        // Write serialized tx to a stream\n+        SerializeToVector(s, tx);\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        // Write inputs\n+        for (const PartiallySignedInput& input : inputs) {\n+            s << input;\n+        }\n+        // Write outputs\n+        for (const PSBTOutput& output : outputs) {\n+            s << output;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // Read global data\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                break;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_GLOBAL_UNSIGNED_TX:\n+                    if (!CTransaction(tx).IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, unsigned tx already provided\");\n+                    }\n+                    UnserializeFromVector(s, tx);\n+                    // Make sure that all scriptSigs and scriptWitnesses are empty\n+                    for (const CTxIn& txin : tx.vin) {\n+                        if (!txin.scriptSig.empty() || !txin.scriptWitness.IsNull()) {\n+                            throw std::ios_base::failure(\"Unsigned tx does not have empty scriptSigs and scriptWitnesses.\");\n+                        }\n+                    }\n+                    break;\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                }\n+            }\n+        }\n+\n+        // Make sure that we got an unsigned tx\n+        if (CTransaction(tx).IsNull()) {\n+            throw std::ios_base::failure(\"No unsigned transcation was provided\");\n+        }\n+\n+        // Read input data\n+        unsigned int i = 0;\n+        while (!s.empty() && i < tx.vin.size()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198947030",
      "id" : 198947030,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk0NzAzMA==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 553,
      "path" : "src/script/sign.h",
      "position" : 580,
      "pull_request_review_id" : 132687160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198947030",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954379"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954379"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T19:11:57Z",
      "diff_hunk" : "@@ -169,15 +171,106 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     sigdata.scriptSig = PushAll(result);\n \n     // Test solution\n-    return solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    sigdata.complete = solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    return sigdata.complete;\n }\n \n-SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn)\n+bool SignatureExtractorChecker::CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    if (checker->CheckSig(scriptSig, vchPubKey, scriptCode, sigversion)) {\n+        CPubKey pubkey(vchPubKey);\n+        sigdata->signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));\n+        return true;\n+    }\n+    return false;\n+}\n+\n+namespace\n+{\n+struct Stacks\n+{\n+    std::vector<valtype> script;\n+    std::vector<valtype> witness;\n+\n+    Stacks() {}\n+    explicit Stacks(const std::vector<valtype>& scriptSigStack_) : script(scriptSigStack_), witness() {}\n+    explicit Stacks(const SignatureData& data) : witness(data.scriptWitness.stack) {\n+        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SigVersion::BASE);\n+    }\n+\n+    SignatureData Output() const {\n+        SignatureData result;\n+        result.scriptSig = PushAll(script);\n+        result.scriptWitness.stack = witness;\n+        return result;\n+    }\n+};\n+}\n+\n+// Extracts signatures and scripts from incomplete scriptSigs. Please do not extend this, use PSBT instead\n+SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn, const CTxOut& txout)\n {\n     SignatureData data;\n     assert(tx.vin.size() > nIn);\n     data.scriptSig = tx.vin[nIn].scriptSig;\n     data.scriptWitness = tx.vin[nIn].scriptWitness;\n+    Stacks stack(data);\n+\n+    // Get signatures\n+    MutableTransactionSignatureChecker tx_checker(&tx, nIn, txout.nValue);\n+    SignatureExtractorChecker extractor_checker(&data, &tx_checker);\n+    if (VerifyScript(data.scriptSig, txout.scriptPubKey, &data.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, extractor_checker)) {\n+        data.complete = true;\n+        return data;\n+    }\n+\n+    // Get scripts\n+    txnouttype script_type;\n+    std::vector<std::vector<unsigned char>> solutions;\n+    Solver(txout.scriptPubKey, script_type, solutions);\n+    SigVersion sigversion = SigVersion::BASE;\n+    CScript next_script = txout.scriptPubKey;\n+\n+    if (script_type == TX_SCRIPTHASH && !stack.script.empty() && !stack.script.back().empty()) {\n+        // Get the redeemScript\n+        CScript redeem_script(stack.script.back().begin(), stack.script.back().end());\n+        data.redeem_script = redeem_script;\n+        next_script = std::move(redeem_script);\n+\n+        // Get redeemScript type\n+        Solver(next_script, script_type, solutions);\n+        stack.script.pop_back();\n+    }\n+    if (script_type == TX_WITNESS_V0_SCRIPTHASH && !stack.witness.empty() && !stack.witness.back().empty()) {\n+        // Get the witnessScript\n+        CScript witness_script(stack.witness.back().begin(), stack.witness.back().end());\n+        data.witness_script = witness_script;\n+        next_script = std::move(witness_script);\n+\n+        // Get witnessScript type\n+        Solver(next_script, script_type, solutions);\n+        stack.witness.pop_back();\n+        stack.script = std::move(stack.witness);\n+        stack.witness.clear();\n+        sigversion = SigVersion::WITNESS_V0;\n+    }\n+    if (script_type == TX_MULTISIG && !stack.script.empty()) {\n+        // Build a map of pubkey -> signature by matching sigs to pubkeys:\n+        assert(solutions.size() > 1);\n+        unsigned int num_pubkeys = solutions.size()-2;\n+        unsigned int last_success_key = 0;\n+        for (const valtype& sig : stack.script) {\n+            for (unsigned int i = last_success_key; i < num_pubkeys; i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954379",
      "id" : 198954379,
      "in_reply_to_id" : 198764592,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDM3OQ==",
      "original_commit_id" : "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
      "original_position" : 104,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132981605,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954379",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954398"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954398"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T19:12:02Z",
      "diff_hunk" : "@@ -81,4 +91,15 @@ void UpdateInput(CTxIn& input, const SignatureData& data);\n  * Solvability is unrelated to whether we consider this output to be ours. */\n bool IsSolvable(const SigningProvider& provider, const CScript& script);\n \n+class SignatureExtractorChecker : public BaseSignatureChecker",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954398",
      "id" : 198954398,
      "in_reply_to_id" : 198766870,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDM5OA==",
      "original_commit_id" : "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
      "original_position" : 40,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132981628,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954398",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954415"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954415"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T19:12:07Z",
      "diff_hunk" : "@@ -169,15 +171,106 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     sigdata.scriptSig = PushAll(result);\n \n     // Test solution\n-    return solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    sigdata.complete = solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    return sigdata.complete;\n }\n \n-SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn)\n+bool SignatureExtractorChecker::CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    if (checker->CheckSig(scriptSig, vchPubKey, scriptCode, sigversion)) {\n+        CPubKey pubkey(vchPubKey);\n+        sigdata->signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954415",
      "id" : 198954415,
      "in_reply_to_id" : 198769412,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDQxNQ==",
      "original_commit_id" : "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
      "original_position" : 23,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132981653,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954415",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954423"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954423"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T19:12:11Z",
      "diff_hunk" : "@@ -81,4 +91,15 @@ void UpdateInput(CTxIn& input, const SignatureData& data);\n  * Solvability is unrelated to whether we consider this output to be ours. */\n bool IsSolvable(const SigningProvider& provider, const CScript& script);\n \n+class SignatureExtractorChecker : public BaseSignatureChecker\n+{\n+private:\n+    SignatureData* sigdata;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954423",
      "id" : 198954423,
      "in_reply_to_id" : 198769810,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDQyMw==",
      "original_commit_id" : "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
      "original_position" : 43,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132981667,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954423",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954439"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954439"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T19:12:16Z",
      "diff_hunk" : "@@ -33,14 +33,60 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n+static bool GetCScript(const SigningProvider* provider, const SignatureData* sigdata, const CScriptID &scriptid, CScript& script)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954439",
      "id" : 198954439,
      "in_reply_to_id" : 198771222,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDQzOQ==",
      "original_commit_id" : "c5d47a58fdeea1a3ed206e5cdb2c37d70942c819",
      "original_position" : 4,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132981693,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954439",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954471"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954471"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T19:12:24Z",
      "diff_hunk" : "@@ -33,14 +33,60 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n+static bool GetCScript(const SigningProvider* provider, const SignatureData* sigdata, const CScriptID &scriptid, CScript& script)\n+{\n+    if (provider != nullptr && provider->GetCScript(scriptid, script)) {\n+        return true;\n+    }\n+    // Look for scripts in SignatureData\n+    if (CScriptID(sigdata->redeem_script) == scriptid) {\n+        script = sigdata->redeem_script;\n+        return true;\n+    } else if (CScriptID(sigdata->witness_script) == scriptid) {\n+        script = sigdata->witness_script;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+static bool GetPubKey(const SigningProvider* provider, const SignatureData* sigdata, const CKeyID &address, CPubKey& pubkey)\n+{\n+    if (provider != nullptr && provider->GetPubKey(address, pubkey)) {\n+        return true;\n+    }\n+    // Look for pubkey in all partial sigs\n+    const auto& it = sigdata->signatures.find(address);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954471",
      "id" : 198954471,
      "in_reply_to_id" : 198774215,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDQ3MQ==",
      "original_commit_id" : "c5d47a58fdeea1a3ed206e5cdb2c37d70942c819",
      "original_position" : 26,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132981734,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954471",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198964995"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198964995"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If we reach EOF in the stream, this loop will exit and the if block below will throw the error as the number of inputs/outputs will differ from the number of inputs/outputs in the unsigned tx. ",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T19:52:47Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    bool IsNull() const;\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return a.tx.GetHash() == b.tx.GetHash();\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // unsigned tx flag\n+        SerializeToVector(s, PSBT_GLOBAL_UNSIGNED_TX);\n+\n+        // Write serialized tx to a stream\n+        SerializeToVector(s, tx);\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        // Write inputs\n+        for (const PartiallySignedInput& input : inputs) {\n+            s << input;\n+        }\n+        // Write outputs\n+        for (const PSBTOutput& output : outputs) {\n+            s << output;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // Read global data\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                break;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_GLOBAL_UNSIGNED_TX:\n+                    if (!CTransaction(tx).IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, unsigned tx already provided\");\n+                    }\n+                    UnserializeFromVector(s, tx);\n+                    // Make sure that all scriptSigs and scriptWitnesses are empty\n+                    for (const CTxIn& txin : tx.vin) {\n+                        if (!txin.scriptSig.empty() || !txin.scriptWitness.IsNull()) {\n+                            throw std::ios_base::failure(\"Unsigned tx does not have empty scriptSigs and scriptWitnesses.\");\n+                        }\n+                    }\n+                    break;\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                }\n+            }\n+        }\n+\n+        // Make sure that we got an unsigned tx\n+        if (CTransaction(tx).IsNull()) {\n+            throw std::ios_base::failure(\"No unsigned transcation was provided\");\n+        }\n+\n+        // Read input data\n+        unsigned int i = 0;\n+        while (!s.empty() && i < tx.vin.size()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198964995",
      "id" : 198964995,
      "in_reply_to_id" : 198947030,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NDk5NQ==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 553,
      "path" : "src/script/sign.h",
      "position" : 580,
      "pull_request_review_id" : 132994672,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198964995",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965231"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965231"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done. Renamed PartiallySignedInput to PSBTInput",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T19:53:37Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965231",
      "id" : 198965231,
      "in_reply_to_id" : 198708045,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTIzMQ==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 298,
      "path" : "src/script/sign.h",
      "position" : 358,
      "pull_request_review_id" : 132994952,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965231",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965252"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965252"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T19:53:42Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965252",
      "id" : 198965252,
      "in_reply_to_id" : 198708146,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTI1Mg==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 44,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132994984,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965252",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965304"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965304"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T19:53:57Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965304",
      "id" : 198965304,
      "in_reply_to_id" : 198933070,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTMwNA==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 200,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132995071,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965304",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965331"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965331"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T19:54:03Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965331",
      "id" : 198965331,
      "in_reply_to_id" : 198934388,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTMzMQ==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 172,
      "path" : "src/script/sign.h",
      "position" : 253,
      "pull_request_review_id" : 132995102,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965331",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965350"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965350"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T19:54:07Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965350",
      "id" : 198965350,
      "in_reply_to_id" : 198937087,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTM1MA==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 281,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132995127,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965350",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965361"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965361"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T19:54:11Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965361",
      "id" : 198965361,
      "in_reply_to_id" : 198937464,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTM2MQ==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 380,
      "path" : "src/script/sign.h",
      "position" : 436,
      "pull_request_review_id" : 132995146,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965361",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965374"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965374"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Removed",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T19:54:16Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    uint64_t num_ins = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965374",
      "id" : 198965374,
      "in_reply_to_id" : 198946369,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTM3NA==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 438,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132995170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965374",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198991851"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198991851"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You could also write it as `uint8_t PSBT_MAGIC_BYTES[4] = \"PSBT\";`. Byte arrays can be serialized directly now.",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T21:28:24Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198991851",
      "id" : 198991851,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5MTg1MQ==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 18,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133027924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198991851",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198991986"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198991986"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`constexpr`",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T21:28:47Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198991986",
      "id" : 198991986,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5MTk4Ng==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 41,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133027924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198991986",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198992193"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198992193"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Add `template <typename Stream>` before.",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T21:29:28Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198992193",
      "id" : 198992193,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5MjE5Mw==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 68,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133027924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198992193",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198992304"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198992304"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Add `template<typename Stream>` before.",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T21:29:51Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+static void SerializeHDKeypaths(std::vector<uint32_t>>& hd_keypaths, Stream& s)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198992304",
      "id" : 198992304,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5MjMwNA==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 97,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133027924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198992304",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198993246"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198993246"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Make the field type a function argument; it differs between input and output types.",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T21:32:56Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+static void SerializeHDKeypaths(std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198993246",
      "id" : 198993246,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5MzI0Ng==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 100,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133027924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198993246",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198994362"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198994362"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah, I see. That will probably give a more useful error.",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T21:36:45Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    bool IsNull() const;\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return a.tx.GetHash() == b.tx.GetHash();\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // unsigned tx flag\n+        SerializeToVector(s, PSBT_GLOBAL_UNSIGNED_TX);\n+\n+        // Write serialized tx to a stream\n+        SerializeToVector(s, tx);\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        // Write inputs\n+        for (const PartiallySignedInput& input : inputs) {\n+            s << input;\n+        }\n+        // Write outputs\n+        for (const PSBTOutput& output : outputs) {\n+            s << output;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // Read global data\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                break;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_GLOBAL_UNSIGNED_TX:\n+                    if (!CTransaction(tx).IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, unsigned tx already provided\");\n+                    }\n+                    UnserializeFromVector(s, tx);\n+                    // Make sure that all scriptSigs and scriptWitnesses are empty\n+                    for (const CTxIn& txin : tx.vin) {\n+                        if (!txin.scriptSig.empty() || !txin.scriptWitness.IsNull()) {\n+                            throw std::ios_base::failure(\"Unsigned tx does not have empty scriptSigs and scriptWitnesses.\");\n+                        }\n+                    }\n+                    break;\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                }\n+            }\n+        }\n+\n+        // Make sure that we got an unsigned tx\n+        if (CTransaction(tx).IsNull()) {\n+            throw std::ios_base::failure(\"No unsigned transcation was provided\");\n+        }\n+\n+        // Read input data\n+        unsigned int i = 0;\n+        while (!s.empty() && i < tx.vin.size()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198994362",
      "id" : 198994362,
      "in_reply_to_id" : 198947030,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5NDM2Mg==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 553,
      "path" : "src/script/sign.h",
      "position" : 580,
      "pull_request_review_id" : 133027924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198994362",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998355"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998355"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "02a2c55a966ba0f70c6a706e647572f5f24bd5af",
      "created_at" : "2018-06-28T21:53:34Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998355",
      "id" : 198998355,
      "in_reply_to_id" : 198991986,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5ODM1NQ==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 41,
      "path" : "src/script/sign.h",
      "position" : 80,
      "pull_request_review_id" : 133035647,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998355",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998372"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998372"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T21:53:41Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998372",
      "id" : 198998372,
      "in_reply_to_id" : 198992193,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5ODM3Mg==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 68,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133035666,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:53:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998372",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998457"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998457"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T21:54:03Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+static void SerializeHDKeypaths(std::vector<uint32_t>>& hd_keypaths, Stream& s)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998457",
      "id" : 198998457,
      "in_reply_to_id" : 198992304,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5ODQ1Nw==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 97,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133035769,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:54:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998457",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998482"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998482"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed",
      "commit_id" : "860b516e1639fbcf7cc6e439b9877f8e2a54888c",
      "created_at" : "2018-06-28T21:54:09Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+static void SerializeHDKeypaths(std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998482",
      "id" : 198998482,
      "in_reply_to_id" : 198993246,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5ODQ4Mg==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 100,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133035800,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-28T21:54:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998482",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   }
]
