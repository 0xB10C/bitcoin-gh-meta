[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198708045"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198708045"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Inconsistent class name (PartiallySignedInput vs PSBTOutput).",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T05:01:33Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198708045",
      "id" : 198708045,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODcwODA0NQ==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 298,
      "path" : "src/script/sign.h",
      "position" : 358,
      "pull_request_review_id" : 132687160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198708045",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198708146"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198708146"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Perhaps add a comment to explain this function and the one below.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T05:02:39Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198708146",
      "id" : 198708146,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODcwODE0Ng==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 44,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132687160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198708146",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198764592"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198764592"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Make SignatureData able to store signatures and scripts\"\r\n\r\nnit, `++i`",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T09:04:02Z",
      "diff_hunk" : "@@ -169,15 +171,106 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     sigdata.scriptSig = PushAll(result);\n \n     // Test solution\n-    return solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    sigdata.complete = solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    return sigdata.complete;\n }\n \n-SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn)\n+bool SignatureExtractorChecker::CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    if (checker->CheckSig(scriptSig, vchPubKey, scriptCode, sigversion)) {\n+        CPubKey pubkey(vchPubKey);\n+        sigdata->signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));\n+        return true;\n+    }\n+    return false;\n+}\n+\n+namespace\n+{\n+struct Stacks\n+{\n+    std::vector<valtype> script;\n+    std::vector<valtype> witness;\n+\n+    Stacks() {}\n+    explicit Stacks(const std::vector<valtype>& scriptSigStack_) : script(scriptSigStack_), witness() {}\n+    explicit Stacks(const SignatureData& data) : witness(data.scriptWitness.stack) {\n+        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SigVersion::BASE);\n+    }\n+\n+    SignatureData Output() const {\n+        SignatureData result;\n+        result.scriptSig = PushAll(script);\n+        result.scriptWitness.stack = witness;\n+        return result;\n+    }\n+};\n+}\n+\n+// Extracts signatures and scripts from incomplete scriptSigs. Please do not extend this, use PSBT instead\n+SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn, const CTxOut& txout)\n {\n     SignatureData data;\n     assert(tx.vin.size() > nIn);\n     data.scriptSig = tx.vin[nIn].scriptSig;\n     data.scriptWitness = tx.vin[nIn].scriptWitness;\n+    Stacks stack(data);\n+\n+    // Get signatures\n+    MutableTransactionSignatureChecker tx_checker(&tx, nIn, txout.nValue);\n+    SignatureExtractorChecker extractor_checker(&data, &tx_checker);\n+    if (VerifyScript(data.scriptSig, txout.scriptPubKey, &data.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, extractor_checker)) {\n+        data.complete = true;\n+        return data;\n+    }\n+\n+    // Get scripts\n+    txnouttype script_type;\n+    std::vector<std::vector<unsigned char>> solutions;\n+    Solver(txout.scriptPubKey, script_type, solutions);\n+    SigVersion sigversion = SigVersion::BASE;\n+    CScript next_script = txout.scriptPubKey;\n+\n+    if (script_type == TX_SCRIPTHASH && !stack.script.empty() && !stack.script.back().empty()) {\n+        // Get the redeemScript\n+        CScript redeem_script(stack.script.back().begin(), stack.script.back().end());\n+        data.redeem_script = redeem_script;\n+        next_script = std::move(redeem_script);\n+\n+        // Get redeemScript type\n+        Solver(next_script, script_type, solutions);\n+        stack.script.pop_back();\n+    }\n+    if (script_type == TX_WITNESS_V0_SCRIPTHASH && !stack.witness.empty() && !stack.witness.back().empty()) {\n+        // Get the witnessScript\n+        CScript witness_script(stack.witness.back().begin(), stack.witness.back().end());\n+        data.witness_script = witness_script;\n+        next_script = std::move(witness_script);\n+\n+        // Get witnessScript type\n+        Solver(next_script, script_type, solutions);\n+        stack.witness.pop_back();\n+        stack.script = std::move(stack.witness);\n+        stack.witness.clear();\n+        sigversion = SigVersion::WITNESS_V0;\n+    }\n+    if (script_type == TX_MULTISIG && !stack.script.empty()) {\n+        // Build a map of pubkey -> signature by matching sigs to pubkeys:\n+        assert(solutions.size() > 1);\n+        unsigned int num_pubkeys = solutions.size()-2;\n+        unsigned int last_success_key = 0;\n+        for (const valtype& sig : stack.script) {\n+            for (unsigned int i = last_success_key; i < num_pubkeys; i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198764592",
      "id" : 198764592,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc2NDU5Mg==",
      "original_commit_id" : "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
      "original_position" : 104,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132751570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198764592",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198766870"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198766870"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit  \"Make SignatureData able to store signatures and scripts\"\r\n\r\n`class SignatureExtractorChecker final`?",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T09:09:27Z",
      "diff_hunk" : "@@ -81,4 +91,15 @@ void UpdateInput(CTxIn& input, const SignatureData& data);\n  * Solvability is unrelated to whether we consider this output to be ours. */\n bool IsSolvable(const SigningProvider& provider, const CScript& script);\n \n+class SignatureExtractorChecker : public BaseSignatureChecker",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198766870",
      "id" : 198766870,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc2Njg3MA==",
      "original_commit_id" : "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
      "original_position" : 40,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132751570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198766870",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198769412"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198769412"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Make SignatureData able to store signatures and scripts\"\r\n\r\nThis is called when `pubkey.GetID()` doesn't exists in signatures, maybe assert it is new:\r\n```cpp\r\nauto i = sigdata->signatures.emplace(...);\r\nassert(i.second);\r\n```",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T09:15:36Z",
      "diff_hunk" : "@@ -169,15 +171,106 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     sigdata.scriptSig = PushAll(result);\n \n     // Test solution\n-    return solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    sigdata.complete = solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    return sigdata.complete;\n }\n \n-SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn)\n+bool SignatureExtractorChecker::CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    if (checker->CheckSig(scriptSig, vchPubKey, scriptCode, sigversion)) {\n+        CPubKey pubkey(vchPubKey);\n+        sigdata->signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198769412",
      "id" : 198769412,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc2OTQxMg==",
      "original_commit_id" : "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
      "original_position" : 23,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132751570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198769412",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198769810"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198769810"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Make SignatureData able to store signatures and scripts\"\r\n\r\nUse references instead of pointers?",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T09:16:40Z",
      "diff_hunk" : "@@ -81,4 +91,15 @@ void UpdateInput(CTxIn& input, const SignatureData& data);\n  * Solvability is unrelated to whether we consider this output to be ours. */\n bool IsSolvable(const SigningProvider& provider, const CScript& script);\n \n+class SignatureExtractorChecker : public BaseSignatureChecker\n+{\n+private:\n+    SignatureData* sigdata;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198769810",
      "id" : 198769810,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc2OTgxMA==",
      "original_commit_id" : "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
      "original_position" : 43,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132751570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198769810",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198771222"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198771222"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Replace CombineSignatures with ProduceSignature\"\r\n\r\nLooks like these could be references:\r\n```cpp\r\nstatic bool GetCScript(const SigningProvider& provider, const SignatureData& sigdata, const CScriptID &scriptid, CScript& script)\r\n```\r\nand remove `provider != nullptr` below.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T09:20:06Z",
      "diff_hunk" : "@@ -33,14 +33,60 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n+static bool GetCScript(const SigningProvider* provider, const SignatureData* sigdata, const CScriptID &scriptid, CScript& script)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198771222",
      "id" : 198771222,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc3MTIyMg==",
      "original_commit_id" : "c5d47a58fdeea1a3ed206e5cdb2c37d70942c819",
      "original_position" : 4,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132751570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198771222",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198773739"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198773739"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Otherwise fix space before `scriptid` argument. Same below in the definition.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T09:25:59Z",
      "diff_hunk" : "@@ -33,14 +33,60 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n+static bool GetCScript(const SigningProvider* provider, const SignatureData* sigdata, const CScriptID &scriptid, CScript& script)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198773739",
      "id" : 198773739,
      "in_reply_to_id" : 198771222,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc3MzczOQ==",
      "original_commit_id" : "c5d47a58fdeea1a3ed206e5cdb2c37d70942c819",
      "original_position" : 4,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132751570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198773739",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198774215"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198774215"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Commit \"Replace CombineSignatures with ProduceSignature\"\r\n\r\nAs pointed by @MarcoFalke, don't use references to iterators. Check throughout too.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T09:27:04Z",
      "diff_hunk" : "@@ -33,14 +33,60 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n+static bool GetCScript(const SigningProvider* provider, const SignatureData* sigdata, const CScriptID &scriptid, CScript& script)\n+{\n+    if (provider != nullptr && provider->GetCScript(scriptid, script)) {\n+        return true;\n+    }\n+    // Look for scripts in SignatureData\n+    if (CScriptID(sigdata->redeem_script) == scriptid) {\n+        script = sigdata->redeem_script;\n+        return true;\n+    } else if (CScriptID(sigdata->witness_script) == scriptid) {\n+        script = sigdata->witness_script;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+static bool GetPubKey(const SigningProvider* provider, const SignatureData* sigdata, const CKeyID &address, CPubKey& pubkey)\n+{\n+    if (provider != nullptr && provider->GetPubKey(address, pubkey)) {\n+        return true;\n+    }\n+    // Look for pubkey in all partial sigs\n+    const auto& it = sigdata->signatures.find(address);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198774215",
      "id" : 198774215,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODc3NDIxNQ==",
      "original_commit_id" : "c5d47a58fdeea1a3ed206e5cdb2c37d70942c819",
      "original_position" : 26,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132751570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198774215",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->Note to reviewers: This pull request conflicts with the following ones:\n\n* #13449 ([WIP] support new multisig template in wallet for Solver, signing, and signature combining by instagibbs)\n* #13429 (Return the script type from Solver by Empact)\n* #13360 ([Policy] Reject SIGHASH_SINGLE with output out of bound by jl2012)\n* #13359 (wallet: Directly operate with CMutableTransaction by MarcoFalke)\n* #13266 (refactoring: Inline DataFromTransaction via new SignatureData constructor by Empact)\n* #13144 (RPC: Improve error messages on RPC endpoints that use GetTransaction by jimpo)\n* #13098 (Skip tx-rehashing on historic blocks by MarcoFalke)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-06-28T09:28:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-400972753",
      "id" : 400972753,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMDk3Mjc1Mw==",
      "updated_at" : "2018-06-28T09:28:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/400972753",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@promag Just so you know, those commits are part of #13425 ",
      "created_at" : "2018-06-28T17:52:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-401119664",
      "id" : 401119664,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMTExOTY2NA==",
      "updated_at" : "2018-06-28T17:52:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401119664",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Ops @achow101 do you want me to comment there?",
      "created_at" : "2018-06-28T18:01:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-401122013",
      "id" : 401122013,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMTEyMjAxMw==",
      "updated_at" : "2018-06-28T18:01:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401122013",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198933070"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198933070"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think this can be written as just `std::vector<unsigned char> sig; s >> sig`.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T18:01:31Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198933070",
      "id" : 198933070,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODkzMzA3MA==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 200,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132687160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198933070",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "No need to comment twice. I will update that PR and then rebase this onto that.",
      "created_at" : "2018-06-28T18:05:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-401123362",
      "id" : 401123362,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMTEyMzM2Mg==",
      "updated_at" : "2018-06-28T18:05:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401123362",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198934388"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198934388"
         }
      },
      "author_association" : "MEMBER",
      "body" : "For this one and the next, check whether you don't already have the other UTXO type?",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T18:06:09Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198934388",
      "id" : 198934388,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODkzNDM4OA==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 172,
      "path" : "src/script/sign.h",
      "position" : 253,
      "pull_request_review_id" : 132687160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198934388",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198937087"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198937087"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Here you can again just use `std::vector<unsigned char> val_bytes; s >> val_bytes;`.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T18:15:21Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198937087",
      "id" : 198937087,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODkzNzA4Nw==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 281,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132687160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198937087",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198937464"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198937464"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Can you abstract out the serialization/deserialization code for derivation paths and scripts into separate functions? Otherwise it is needlessly duplicated across input and outputs.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T18:16:37Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198937464",
      "id" : 198937464,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODkzNzQ2NA==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 380,
      "path" : "src/script/sign.h",
      "position" : 438,
      "pull_request_review_id" : 132687160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198937464",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198946369"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198946369"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Do you still need `num_ins` and `use_in_index`?",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T18:44:44Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    uint64_t num_ins = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198946369",
      "id" : 198946369,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk0NjM2OQ==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 438,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132687160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198946369",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198947030"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198947030"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why the `!s.empty()` check here? If we reach EOF in the stream an error should be raised, not ignore it.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T18:46:56Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    bool IsNull() const;\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return a.tx.GetHash() == b.tx.GetHash();\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // unsigned tx flag\n+        SerializeToVector(s, PSBT_GLOBAL_UNSIGNED_TX);\n+\n+        // Write serialized tx to a stream\n+        SerializeToVector(s, tx);\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        // Write inputs\n+        for (const PartiallySignedInput& input : inputs) {\n+            s << input;\n+        }\n+        // Write outputs\n+        for (const PSBTOutput& output : outputs) {\n+            s << output;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // Read global data\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                break;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_GLOBAL_UNSIGNED_TX:\n+                    if (!CTransaction(tx).IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, unsigned tx already provided\");\n+                    }\n+                    UnserializeFromVector(s, tx);\n+                    // Make sure that all scriptSigs and scriptWitnesses are empty\n+                    for (const CTxIn& txin : tx.vin) {\n+                        if (!txin.scriptSig.empty() || !txin.scriptWitness.IsNull()) {\n+                            throw std::ios_base::failure(\"Unsigned tx does not have empty scriptSigs and scriptWitnesses.\");\n+                        }\n+                    }\n+                    break;\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                }\n+            }\n+        }\n+\n+        // Make sure that we got an unsigned tx\n+        if (CTransaction(tx).IsNull()) {\n+            throw std::ios_base::failure(\"No unsigned transcation was provided\");\n+        }\n+\n+        // Read input data\n+        unsigned int i = 0;\n+        while (!s.empty() && i < tx.vin.size()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198947030",
      "id" : 198947030,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk0NzAzMA==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 553,
      "path" : "src/script/sign.h",
      "position" : 584,
      "pull_request_review_id" : 132687160,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198947030",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954379"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954379"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T19:11:57Z",
      "diff_hunk" : "@@ -169,15 +171,106 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     sigdata.scriptSig = PushAll(result);\n \n     // Test solution\n-    return solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    sigdata.complete = solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    return sigdata.complete;\n }\n \n-SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn)\n+bool SignatureExtractorChecker::CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    if (checker->CheckSig(scriptSig, vchPubKey, scriptCode, sigversion)) {\n+        CPubKey pubkey(vchPubKey);\n+        sigdata->signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));\n+        return true;\n+    }\n+    return false;\n+}\n+\n+namespace\n+{\n+struct Stacks\n+{\n+    std::vector<valtype> script;\n+    std::vector<valtype> witness;\n+\n+    Stacks() {}\n+    explicit Stacks(const std::vector<valtype>& scriptSigStack_) : script(scriptSigStack_), witness() {}\n+    explicit Stacks(const SignatureData& data) : witness(data.scriptWitness.stack) {\n+        EvalScript(script, data.scriptSig, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SigVersion::BASE);\n+    }\n+\n+    SignatureData Output() const {\n+        SignatureData result;\n+        result.scriptSig = PushAll(script);\n+        result.scriptWitness.stack = witness;\n+        return result;\n+    }\n+};\n+}\n+\n+// Extracts signatures and scripts from incomplete scriptSigs. Please do not extend this, use PSBT instead\n+SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn, const CTxOut& txout)\n {\n     SignatureData data;\n     assert(tx.vin.size() > nIn);\n     data.scriptSig = tx.vin[nIn].scriptSig;\n     data.scriptWitness = tx.vin[nIn].scriptWitness;\n+    Stacks stack(data);\n+\n+    // Get signatures\n+    MutableTransactionSignatureChecker tx_checker(&tx, nIn, txout.nValue);\n+    SignatureExtractorChecker extractor_checker(&data, &tx_checker);\n+    if (VerifyScript(data.scriptSig, txout.scriptPubKey, &data.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, extractor_checker)) {\n+        data.complete = true;\n+        return data;\n+    }\n+\n+    // Get scripts\n+    txnouttype script_type;\n+    std::vector<std::vector<unsigned char>> solutions;\n+    Solver(txout.scriptPubKey, script_type, solutions);\n+    SigVersion sigversion = SigVersion::BASE;\n+    CScript next_script = txout.scriptPubKey;\n+\n+    if (script_type == TX_SCRIPTHASH && !stack.script.empty() && !stack.script.back().empty()) {\n+        // Get the redeemScript\n+        CScript redeem_script(stack.script.back().begin(), stack.script.back().end());\n+        data.redeem_script = redeem_script;\n+        next_script = std::move(redeem_script);\n+\n+        // Get redeemScript type\n+        Solver(next_script, script_type, solutions);\n+        stack.script.pop_back();\n+    }\n+    if (script_type == TX_WITNESS_V0_SCRIPTHASH && !stack.witness.empty() && !stack.witness.back().empty()) {\n+        // Get the witnessScript\n+        CScript witness_script(stack.witness.back().begin(), stack.witness.back().end());\n+        data.witness_script = witness_script;\n+        next_script = std::move(witness_script);\n+\n+        // Get witnessScript type\n+        Solver(next_script, script_type, solutions);\n+        stack.witness.pop_back();\n+        stack.script = std::move(stack.witness);\n+        stack.witness.clear();\n+        sigversion = SigVersion::WITNESS_V0;\n+    }\n+    if (script_type == TX_MULTISIG && !stack.script.empty()) {\n+        // Build a map of pubkey -> signature by matching sigs to pubkeys:\n+        assert(solutions.size() > 1);\n+        unsigned int num_pubkeys = solutions.size()-2;\n+        unsigned int last_success_key = 0;\n+        for (const valtype& sig : stack.script) {\n+            for (unsigned int i = last_success_key; i < num_pubkeys; i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954379",
      "id" : 198954379,
      "in_reply_to_id" : 198764592,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDM3OQ==",
      "original_commit_id" : "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
      "original_position" : 104,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132981605,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954379",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954398"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954398"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T19:12:02Z",
      "diff_hunk" : "@@ -81,4 +91,15 @@ void UpdateInput(CTxIn& input, const SignatureData& data);\n  * Solvability is unrelated to whether we consider this output to be ours. */\n bool IsSolvable(const SigningProvider& provider, const CScript& script);\n \n+class SignatureExtractorChecker : public BaseSignatureChecker",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954398",
      "id" : 198954398,
      "in_reply_to_id" : 198766870,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDM5OA==",
      "original_commit_id" : "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
      "original_position" : 40,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132981628,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954398",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954415"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954415"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T19:12:07Z",
      "diff_hunk" : "@@ -169,15 +171,106 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     sigdata.scriptSig = PushAll(result);\n \n     // Test solution\n-    return solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    sigdata.complete = solved && VerifyScript(sigdata.scriptSig, fromPubKey, &sigdata.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, creator.Checker());\n+    return sigdata.complete;\n }\n \n-SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn)\n+bool SignatureExtractorChecker::CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+{\n+    if (checker->CheckSig(scriptSig, vchPubKey, scriptCode, sigversion)) {\n+        CPubKey pubkey(vchPubKey);\n+        sigdata->signatures.emplace(pubkey.GetID(), SigPair(pubkey, scriptSig));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954415",
      "id" : 198954415,
      "in_reply_to_id" : 198769412,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDQxNQ==",
      "original_commit_id" : "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
      "original_position" : 23,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132981653,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954415",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954423"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954423"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T19:12:11Z",
      "diff_hunk" : "@@ -81,4 +91,15 @@ void UpdateInput(CTxIn& input, const SignatureData& data);\n  * Solvability is unrelated to whether we consider this output to be ours. */\n bool IsSolvable(const SigningProvider& provider, const CScript& script);\n \n+class SignatureExtractorChecker : public BaseSignatureChecker\n+{\n+private:\n+    SignatureData* sigdata;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954423",
      "id" : 198954423,
      "in_reply_to_id" : 198769810,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDQyMw==",
      "original_commit_id" : "a86d0679db0eb0a12e4ced4ee09c18b0bd81dd84",
      "original_position" : 43,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132981667,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954423",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954439"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954439"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T19:12:16Z",
      "diff_hunk" : "@@ -33,14 +33,60 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n+static bool GetCScript(const SigningProvider* provider, const SignatureData* sigdata, const CScriptID &scriptid, CScript& script)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954439",
      "id" : 198954439,
      "in_reply_to_id" : 198771222,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDQzOQ==",
      "original_commit_id" : "c5d47a58fdeea1a3ed206e5cdb2c37d70942c819",
      "original_position" : 4,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132981693,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954439",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954471"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954471"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T19:12:24Z",
      "diff_hunk" : "@@ -33,14 +33,60 @@ bool MutableTransactionSignatureCreator::CreateSig(const SigningProvider& provid\n     return true;\n }\n \n+static bool GetCScript(const SigningProvider* provider, const SignatureData* sigdata, const CScriptID &scriptid, CScript& script)\n+{\n+    if (provider != nullptr && provider->GetCScript(scriptid, script)) {\n+        return true;\n+    }\n+    // Look for scripts in SignatureData\n+    if (CScriptID(sigdata->redeem_script) == scriptid) {\n+        script = sigdata->redeem_script;\n+        return true;\n+    } else if (CScriptID(sigdata->witness_script) == scriptid) {\n+        script = sigdata->witness_script;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+static bool GetPubKey(const SigningProvider* provider, const SignatureData* sigdata, const CKeyID &address, CPubKey& pubkey)\n+{\n+    if (provider != nullptr && provider->GetPubKey(address, pubkey)) {\n+        return true;\n+    }\n+    // Look for pubkey in all partial sigs\n+    const auto& it = sigdata->signatures.find(address);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198954471",
      "id" : 198954471,
      "in_reply_to_id" : 198774215,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk1NDQ3MQ==",
      "original_commit_id" : "c5d47a58fdeea1a3ed206e5cdb2c37d70942c819",
      "original_position" : 26,
      "path" : "src/script/sign.cpp",
      "position" : null,
      "pull_request_review_id" : 132981734,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198954471",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198964995"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198964995"
         }
      },
      "author_association" : "MEMBER",
      "body" : "If we reach EOF in the stream, this loop will exit and the if block below will throw the error as the number of inputs/outputs will differ from the number of inputs/outputs in the unsigned tx. ",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T19:52:47Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    bool IsNull() const;\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return a.tx.GetHash() == b.tx.GetHash();\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // unsigned tx flag\n+        SerializeToVector(s, PSBT_GLOBAL_UNSIGNED_TX);\n+\n+        // Write serialized tx to a stream\n+        SerializeToVector(s, tx);\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        // Write inputs\n+        for (const PartiallySignedInput& input : inputs) {\n+            s << input;\n+        }\n+        // Write outputs\n+        for (const PSBTOutput& output : outputs) {\n+            s << output;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // Read global data\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                break;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_GLOBAL_UNSIGNED_TX:\n+                    if (!CTransaction(tx).IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, unsigned tx already provided\");\n+                    }\n+                    UnserializeFromVector(s, tx);\n+                    // Make sure that all scriptSigs and scriptWitnesses are empty\n+                    for (const CTxIn& txin : tx.vin) {\n+                        if (!txin.scriptSig.empty() || !txin.scriptWitness.IsNull()) {\n+                            throw std::ios_base::failure(\"Unsigned tx does not have empty scriptSigs and scriptWitnesses.\");\n+                        }\n+                    }\n+                    break;\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                }\n+            }\n+        }\n+\n+        // Make sure that we got an unsigned tx\n+        if (CTransaction(tx).IsNull()) {\n+            throw std::ios_base::failure(\"No unsigned transcation was provided\");\n+        }\n+\n+        // Read input data\n+        unsigned int i = 0;\n+        while (!s.empty() && i < tx.vin.size()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198964995",
      "id" : 198964995,
      "in_reply_to_id" : 198947030,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NDk5NQ==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 553,
      "path" : "src/script/sign.h",
      "position" : 584,
      "pull_request_review_id" : 132994672,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198964995",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965231"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965231"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done. Renamed PartiallySignedInput to PSBTInput",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T19:53:37Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965231",
      "id" : 198965231,
      "in_reply_to_id" : 198708045,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTIzMQ==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 298,
      "path" : "src/script/sign.h",
      "position" : 358,
      "pull_request_review_id" : 132994952,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965231",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965252"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965252"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T19:53:42Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965252",
      "id" : 198965252,
      "in_reply_to_id" : 198708146,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTI1Mg==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 44,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132994984,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965252",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965304"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965304"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T19:53:57Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965304",
      "id" : 198965304,
      "in_reply_to_id" : 198933070,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTMwNA==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 200,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132995071,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965304",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965331"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965331"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T19:54:03Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965331",
      "id" : 198965331,
      "in_reply_to_id" : 198934388,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTMzMQ==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 172,
      "path" : "src/script/sign.h",
      "position" : 253,
      "pull_request_review_id" : 132995102,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965331",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965350"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965350"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T19:54:07Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965350",
      "id" : 198965350,
      "in_reply_to_id" : 198937087,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTM1MA==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 281,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132995127,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965350",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965361"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965361"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T19:54:11Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965361",
      "id" : 198965361,
      "in_reply_to_id" : 198937464,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTM2MQ==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 380,
      "path" : "src/script/sign.h",
      "position" : 438,
      "pull_request_review_id" : 132995146,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965361",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965374"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965374"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Removed",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T19:54:16Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    uint64_t num_ins = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198965374",
      "id" : 198965374,
      "in_reply_to_id" : 198946369,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk2NTM3NA==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 438,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 132995170,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198965374",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198991851"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198991851"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You could also write it as `uint8_t PSBT_MAGIC_BYTES[4] = \"PSBT\";`. Byte arrays can be serialized directly now.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T21:28:24Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198991851",
      "id" : 198991851,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5MTg1MQ==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 18,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133027924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198991851",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198991986"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198991986"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`constexpr`",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T21:28:47Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198991986",
      "id" : 198991986,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5MTk4Ng==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 41,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133027924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198991986",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198992193"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198992193"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Add `template <typename Stream>` before.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T21:29:28Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198992193",
      "id" : 198992193,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5MjE5Mw==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 68,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133027924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198992193",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198992304"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198992304"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Add `template<typename Stream>` before.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T21:29:51Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+static void SerializeHDKeypaths(std::vector<uint32_t>>& hd_keypaths, Stream& s)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198992304",
      "id" : 198992304,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5MjMwNA==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 97,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133027924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198992304",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198993246"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198993246"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Make the field type a function argument; it differs between input and output types.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T21:32:56Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+static void SerializeHDKeypaths(std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198993246",
      "id" : 198993246,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5MzI0Ng==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 100,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133027924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198993246",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198994362"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198994362"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ah, I see. That will probably give a more useful error.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T21:36:45Z",
      "diff_hunk" : "@@ -73,6 +76,580 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+/** A structure for PSBTs which contain per input information */\n+struct PartiallySignedInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    PartiallySignedInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            SerializeToVector(s, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            for (auto keypath_pair : hd_keypaths) {\n+                SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+                WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+                for (auto& path : keypath_pair.second) {\n+                    s << path;\n+                }\n+            }\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, non_witness_utxo);\n+                    break;\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> sig;\n+                    sig.resize(value_len);\n+                    s >> MakeSpan(sig);\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, sig));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, std::vector<uint32_t>> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        for (auto keypath_pair : hd_keypaths) {\n+            SerializeToVector(s, PSBT_OUT_BIP32_DERIVATION, MakeSpan(keypath_pair.first));\n+            WriteCompactSize(s, keypath_pair.second.size() * sizeof(uint32_t));\n+            for (auto& path : keypath_pair.second) {\n+                s << path;\n+            }\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                return;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (hd_keypaths.count(pubkey) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output pubkey derivation path already provided\");\n+                    }\n+\n+                    // Read in key path\n+                    std::vector<uint32_t> keypath;\n+                    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+                        uint32_t index;\n+                        s >> index;\n+                        keypath.push_back(index);\n+                    }\n+\n+                    // Add to map\n+                    hd_keypaths.emplace(pubkey, keypath);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    CMutableTransaction tx;\n+    std::vector<PartiallySignedInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    uint64_t num_ins = 0;\n+    bool use_in_index = false;\n+\n+    bool IsNull() const;\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return a.tx.GetHash() == b.tx.GetHash();\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES << (char)0xff; // psbt 0xff\n+\n+        // unsigned tx flag\n+        SerializeToVector(s, PSBT_GLOBAL_UNSIGNED_TX);\n+\n+        // Write serialized tx to a stream\n+        SerializeToVector(s, tx);\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        // Write inputs\n+        for (const PartiallySignedInput& input : inputs) {\n+            s << input;\n+        }\n+        // Write outputs\n+        for (const PSBTOutput& output : outputs) {\n+            s << output;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        int magic;\n+        s >> magic;\n+        if (magic != PSBT_MAGIC_BYTES) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+        unsigned char magic_sep;\n+        s >> magic_sep;\n+\n+        // Read global data\n+        while(!s.empty()) {\n+            // read size of key\n+            uint64_t key_len = ReadCompactSize(s);\n+\n+            // the key length is 0 if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key_len == 0) {\n+                break;\n+            }\n+\n+            // Read key\n+            std::vector<unsigned char> key;\n+            key.resize(key_len);\n+            s >> MakeSpan(key);\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_GLOBAL_UNSIGNED_TX:\n+                    if (!CTransaction(tx).IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, unsigned tx already provided\");\n+                    }\n+                    UnserializeFromVector(s, tx);\n+                    // Make sure that all scriptSigs and scriptWitnesses are empty\n+                    for (const CTxIn& txin : tx.vin) {\n+                        if (!txin.scriptSig.empty() || !txin.scriptWitness.IsNull()) {\n+                            throw std::ios_base::failure(\"Unsigned tx does not have empty scriptSigs and scriptWitnesses.\");\n+                        }\n+                    }\n+                    break;\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    uint64_t value_len = ReadCompactSize(s);\n+                    std::vector<unsigned char> val_bytes;\n+                    val_bytes.resize(value_len);\n+                    s >> MakeSpan(val_bytes);\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                }\n+            }\n+        }\n+\n+        // Make sure that we got an unsigned tx\n+        if (CTransaction(tx).IsNull()) {\n+            throw std::ios_base::failure(\"No unsigned transcation was provided\");\n+        }\n+\n+        // Read input data\n+        unsigned int i = 0;\n+        while (!s.empty() && i < tx.vin.size()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198994362",
      "id" : 198994362,
      "in_reply_to_id" : 198947030,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5NDM2Mg==",
      "original_commit_id" : "bfb37cb7412e154a074b7d1bde42e3358131d6b3",
      "original_position" : 553,
      "path" : "src/script/sign.h",
      "position" : 584,
      "pull_request_review_id" : 133027924,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198994362",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998355"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998355"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T21:53:34Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998355",
      "id" : 198998355,
      "in_reply_to_id" : 198991986,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5ODM1NQ==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 41,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133035647,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998355",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998372"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998372"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T21:53:41Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998372",
      "id" : 198998372,
      "in_reply_to_id" : 198992193,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5ODM3Mg==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 68,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133035666,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998372",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998457"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998457"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T21:54:03Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+static void SerializeHDKeypaths(std::vector<uint32_t>>& hd_keypaths, Stream& s)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998457",
      "id" : 198998457,
      "in_reply_to_id" : 198992304,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5ODQ1Nw==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 97,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133035769,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998457",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998482"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998482"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T21:54:09Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key. which indicates that this is the separator. The separator has no value.\n+static const uint8_t PSBT_SEPARATOR = 0x00;\n+\n+// Takes a stream and multiple arguments and serializes them into a vector and then into the stream\n+// The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n+template<typename Stream, typename... X>\n+void SerializeToVector(Stream& s, const X&... args)\n+{\n+    std::vector<unsigned char> ret;\n+    CVectorWriter ss(SER_NETWORK, PROTOCOL_VERSION, ret, 0);\n+    SerializeMany(ss, args...);\n+    s << ret;\n+}\n+\n+// Takes a stream and multiple arguments and unserializes them first as a vector then each object individually in the order provided in the arguments\n+template<typename Stream, typename... X>\n+void UnserializeFromVector(Stream& s, X&... args)\n+{\n+    std::vector<unsigned char> data;\n+    s >> data;\n+    CDataStream ss(data, SER_NETWORK, PROTOCOL_VERSION);\n+    UnserializeMany(ss, args...);\n+    if (!ss.eof()) {\n+        throw std::ios_base::failure(\"Size of value was not the stated size\");\n+    }\n+}\n+\n+// Deserialize HD keypaths into a map\n+static void DeserializeHDKeypaths(const std::vector<unsigned char>& key, std::map<CPubKey, std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    // Make sure that the key is the size of pubkey + 1\n+    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+        throw std::ios_base::failure(\"Size of key was not the expected size for the type BIP32 keypath\");\n+    }\n+    // Read in the pubkey from key\n+    CPubKey pubkey(key.begin() + 1, key.end());\n+    if (!pubkey.IsFullyValid()) {\n+       throw std::ios_base::failure(\"Invalid pubkey\");\n+    }\n+    if (hd_keypaths.count(pubkey) > 0) {\n+        throw std::ios_base::failure(\"Duplicate Key, pubkey derivation path already provided\");\n+    }\n+\n+    // Read in key path\n+    uint64_t value_len = ReadCompactSize(s);\n+    std::vector<uint32_t> keypath;\n+    for (unsigned int i = 0; i < value_len; i += sizeof(uint32_t)) {\n+        uint32_t index;\n+        s >> index;\n+        keypath.push_back(index);\n+    }\n+\n+    // Add to map\n+    hd_keypaths.emplace(pubkey, keypath);\n+}\n+\n+// Serialize HD keypaths to a stream from a map\n+static void SerializeHDKeypaths(std::vector<uint32_t>>& hd_keypaths, Stream& s)\n+{\n+    for (auto keypath_pair : hd_keypaths) {\n+        SerializeToVector(s, PSBT_IN_BIP32_DERIVATION, MakeSpan(keypath_pair.first));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r198998482",
      "id" : 198998482,
      "in_reply_to_id" : 198993246,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5ODk5ODQ4Mg==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 100,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133035800,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/198998482",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199004472"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199004472"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T22:22:11Z",
      "diff_hunk" : "@@ -73,6 +76,565 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n+\n+\n+// Note: These constants are in reverse byte order because serialization uses LSB\n+static constexpr uint32_t PSBT_MAGIC_BYTES = 0x74627370;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199004472",
      "id" : 199004472,
      "in_reply_to_id" : 198991851,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwNDQ3Mg==",
      "original_commit_id" : "fdd7cd5a1d2cfa2c676e87cd341dfc06d709d4aa",
      "original_position" : 18,
      "path" : "src/script/sign.h",
      "position" : null,
      "pull_request_review_id" : 133042762,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199004472",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199005299"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199005299"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Would it make sense to abstract out this convert-base64-to-psbt RPC routine into a separate function? It's probably called from many RPCs.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T22:25:51Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199005299",
      "id" : 199005299,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwNTI5OQ==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 101,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : 340,
      "pull_request_review_id" : 133043120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199005299",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199005647"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199005647"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Also add unknowns to the decode?",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T22:26:40Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199005647",
      "id" : 199005647,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwNTY0Nw==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 197,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133043120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199005647",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199005825"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199005825"
         }
      },
      "author_association" : "MEMBER",
      "body" : "What do you think about combing fingerprint and path into one string (like proposed in my descriptor language)?",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T22:27:23Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199005825",
      "id" : 199005825,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwNTgyNQ==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 84,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133043120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199005825",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199006165"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199006165"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It feels like this should be written as a method or function operating on `PartiallySignedTransaction` objects, rather than inside the RPC code.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T22:28:30Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199006165",
      "id" : 199006165,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwNjE2NQ==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 327,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133043120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199006165",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199006515"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199006515"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm not sure what this entire UTXO handling section does. Is it sufficient to (a) rely on a generic combine PSBT function somewhere (suggested below) which also combined the utxo data, and then perhaps convert the logic in this section to a sanity check function?",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T22:29:48Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199006515",
      "id" : 199006515,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwNjUxNQ==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 294,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133043120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199006515",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199006766"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199006766"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: `else` on the same line as `}` (and elsewhere).",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T22:31:12Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+        if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+            continue;\n+        }\n+\n+        // Fill a SignatureData with input info\n+        SignatureData sigdata;\n+        input.FillSignatureData(sigdata);\n+\n+        // Get UTXO\n+        CTxOut utxo;\n+        if (input.non_witness_utxo) {\n+            utxo = input.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!input.witness_utxo.IsNull()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199006766",
      "id" : 199006766,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwNjc2Ng==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 439,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133043120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199006766",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199009612"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199009612"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Not hex encoded.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T22:46:22Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199009612",
      "id" : 199009612,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwOTYxMg==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 28,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133043120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199009612",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199009777"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199009777"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Explain that this implements the Combiner and Finalizer roles?",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T22:47:11Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199009777",
      "id" : 199009777,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAwOTc3Nw==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 242,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : 500,
      "pull_request_review_id" : 133043120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199009777",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199010254"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199010254"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fully signed transaction, no? It seems the explanation of this and the field above are swapped.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T22:49:48Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199010254",
      "id" : 199010254,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAxMDI1NA==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 394,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133043120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199010254",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199010547"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199010547"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This whole section that extracts UTXOs and data from a PSBT input and invokes ProduceSignature on it seems like something that can be abstracted out.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T22:51:30Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+        if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+            continue;\n+        }\n+\n+        // Fill a SignatureData with input info",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199010547",
      "id" : 199010547,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAxMDU0Nw==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 429,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133043120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199010547",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199010700"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199010700"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This RPC does not do any funding, I think.\r\n\r\nExplain that this implements a Creator role.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T22:52:26Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+        if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+            continue;\n+        }\n+\n+        // Fill a SignatureData with input info\n+        SignatureData sigdata;\n+        input.FillSignatureData(sigdata);\n+\n+        // Get UTXO\n+        CTxOut utxo;\n+        if (input.non_witness_utxo) {\n+            utxo = input.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!input.witness_utxo.IsNull()) {\n+            utxo = input.witness_utxo;\n+        }\n+        // No UTXO, don't do anything\n+        else {\n+            continue;\n+        }\n+\n+        MutableTransactionSignatureCreator creator(&psbtx.tx, i, utxo.nValue, 1);\n+        bool sig_complete = ProduceSignature(DUMMY_SIGNING_PROVIDER, creator, utxo.scriptPubKey, sigdata);\n+        input.FromSignatureData(sigdata);\n+        complete &= sig_complete;\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"base64\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates and funds a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199010700",
      "id" : 199010700,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAxMDcwMA==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 478,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133043120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199010700",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199012847"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199012847"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You can use `ReadLE32` for this, it's more efficient.\r\n\r\nIf instead this would be BE (`ReadBE32` also exists), you can get rid of `Uint32ToUint8VectorLE` and instead print using `strprintf(\"%08x\", fingerprint)`.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T23:04:06Z",
      "diff_hunk" : "@@ -91,6 +91,15 @@ class base_blob\n                ((uint64_t)ptr[7]) << 56;\n     }\n \n+    uint32_t GetUint32LE(int pos) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199012847",
      "id" : 199012847,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAxMjg0Nw==",
      "original_commit_id" : "ed7a484d92034e79b753c9594c2b099d3be959f4",
      "original_position" : 4,
      "path" : "src/uint256.h",
      "position" : null,
      "pull_request_review_id" : 133043120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199012847",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199013256"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199013256"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Perhaps clarify that it's intended to work with `createrawtransaction` and `fundrawtransaction`, and `createpsbt`/`createfundedpsbt` should be used for new applications.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T23:06:42Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+        if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+            continue;\n+        }\n+\n+        // Fill a SignatureData with input info\n+        SignatureData sigdata;\n+        input.FillSignatureData(sigdata);\n+\n+        // Get UTXO\n+        CTxOut utxo;\n+        if (input.non_witness_utxo) {\n+            utxo = input.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!input.witness_utxo.IsNull()) {\n+            utxo = input.witness_utxo;\n+        }\n+        // No UTXO, don't do anything\n+        else {\n+            continue;\n+        }\n+\n+        MutableTransactionSignatureCreator creator(&psbtx.tx, i, utxo.nValue, 1);\n+        bool sig_complete = ProduceSignature(DUMMY_SIGNING_PROVIDER, creator, utxo.scriptPubKey, sigdata);\n+        input.FromSignatureData(sigdata);\n+        complete &= sig_complete;\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"base64\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates and funds a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"base64\\\": \\\"value\\\",      (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199013256",
      "id" : 199013256,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAxMzI1Ng==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 542,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133043120,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199013256",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "General comment on naming of RPC field names and input arguments, `\"base64\"` isn't very informative I think. I suggest using `\"psbt\"` anywhere you have an input or output in base64. There isn't any other encoding used, so there should never be any confusion. Using `\"hex\"` for fully signed or legacy partially signed transaction makes sense for consistency with the existing RPCs.",
      "created_at" : "2018-06-28T23:13:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-401200508",
      "id" : 401200508,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMTIwMDUwOA==",
      "updated_at" : "2018-06-28T23:13:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401200508",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199017225"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199017225"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think it is clearer to list the fingerprint separately.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T23:30:52Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199017225",
      "id" : 199017225,
      "in_reply_to_id" : 199005825,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAxNzIyNQ==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 84,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133056768,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199017225",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199017473"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199017473"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why?",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T23:32:31Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199017473",
      "id" : 199017473,
      "in_reply_to_id" : 199006165,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAxNzQ3Mw==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 327,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133057086,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199017473",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199017650"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199017650"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Because it's not RPC specific. It's cleaner to put the operations on the lowest level they can go.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-28T23:34:04Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199017650",
      "id" : 199017650,
      "in_reply_to_id" : 199006165,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAxNzY1MA==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 327,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133057324,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:23:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199017650",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199037960"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199037960"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-29T02:24:01Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199037960",
      "id" : 199037960,
      "in_reply_to_id" : 199005299,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzNzk2MA==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 101,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : 340,
      "pull_request_review_id" : 133080543,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:24:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199037960",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199037966"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199037966"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-29T02:24:06Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199037966",
      "id" : 199037966,
      "in_reply_to_id" : 199005647,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzNzk2Ng==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 197,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133080551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:24:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199037966",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199037978"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199037978"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-29T02:24:12Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199037978",
      "id" : 199037978,
      "in_reply_to_id" : 199006165,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzNzk3OA==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 327,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133080568,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:24:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199037978",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038045"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038045"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I have refactored the merging stuff into a Merge() method for each PSBT struct. I also added a sanity checking method for each.",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-29T02:24:57Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038045",
      "id" : 199038045,
      "in_reply_to_id" : 199006515,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODA0NQ==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 294,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133080652,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:24:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038045",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038057"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038057"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-29T02:25:03Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+        if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+            continue;\n+        }\n+\n+        // Fill a SignatureData with input info\n+        SignatureData sigdata;\n+        input.FillSignatureData(sigdata);\n+\n+        // Get UTXO\n+        CTxOut utxo;\n+        if (input.non_witness_utxo) {\n+            utxo = input.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!input.witness_utxo.IsNull()) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038057",
      "id" : 199038057,
      "in_reply_to_id" : 199006766,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODA1Nw==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 439,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133080663,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:25:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038057",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038063"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038063"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-29T02:25:09Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038063",
      "id" : 199038063,
      "in_reply_to_id" : 199009612,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODA2Mw==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 28,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133080672,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:25:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038063",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038068"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038068"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-29T02:25:14Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038068",
      "id" : 199038068,
      "in_reply_to_id" : 199009777,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODA2OA==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 242,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : 500,
      "pull_request_review_id" : 133080683,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:25:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038068",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038075"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038075"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Fixed",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-29T02:25:19Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038075",
      "id" : 199038075,
      "in_reply_to_id" : 199010254,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODA3NQ==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 394,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133080693,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:25:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038075",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038094"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038094"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-29T02:25:27Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+        if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+            continue;\n+        }\n+\n+        // Fill a SignatureData with input info",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038094",
      "id" : 199038094,
      "in_reply_to_id" : 199010547,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODA5NA==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 429,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133080707,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:25:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038094",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038105"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038105"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-29T02:25:34Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+        if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+            continue;\n+        }\n+\n+        // Fill a SignatureData with input info\n+        SignatureData sigdata;\n+        input.FillSignatureData(sigdata);\n+\n+        // Get UTXO\n+        CTxOut utxo;\n+        if (input.non_witness_utxo) {\n+            utxo = input.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!input.witness_utxo.IsNull()) {\n+            utxo = input.witness_utxo;\n+        }\n+        // No UTXO, don't do anything\n+        else {\n+            continue;\n+        }\n+\n+        MutableTransactionSignatureCreator creator(&psbtx.tx, i, utxo.nValue, 1);\n+        bool sig_complete = ProduceSignature(DUMMY_SIGNING_PROVIDER, creator, utxo.scriptPubKey, sigdata);\n+        input.FromSignatureData(sigdata);\n+        complete &= sig_complete;\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"base64\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates and funds a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038105",
      "id" : 199038105,
      "in_reply_to_id" : 199010700,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODEwNQ==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 478,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133080722,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:25:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038105",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038146"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038146"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-29T02:26:02Z",
      "diff_hunk" : "@@ -91,6 +91,15 @@ class base_blob\n                ((uint64_t)ptr[7]) << 56;\n     }\n \n+    uint32_t GetUint32LE(int pos) const",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038146",
      "id" : 199038146,
      "in_reply_to_id" : 199012847,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODE0Ng==",
      "original_commit_id" : "ed7a484d92034e79b753c9594c2b099d3be959f4",
      "original_position" : 4,
      "path" : "src/uint256.h",
      "position" : null,
      "pull_request_review_id" : 133080779,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:26:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038146",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038156"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038156"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "00d2d6b87df1f665a324549105f7e6f32d88ab6e",
      "created_at" : "2018-06-29T02:26:08Z",
      "diff_hunk" : "@@ -1262,6 +1262,598 @@ static UniValue testmempoolaccept(const JSONRPCRequest& request)\n     return result;\n }\n \n+static std::string WriteHDKeypath(std::vector<uint32_t>& keypath)\n+{\n+    std::string keypath_str = \"m/\";\n+    for (uint32_t num : keypath) {\n+        bool hardened = false;\n+        if (num & 0x80000000) {\n+            hardened = true;\n+            num &= ~0x80000000;\n+        }\n+\n+        keypath_str += std::to_string(num);\n+        if (hardened) {\n+            keypath_str += \"'\";\n+        }\n+        keypath_str += \"/\";\n+    }\n+    return keypath_str;\n+}\n+\n+UniValue decodepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"decodepsbt \\\"base64string\\\"\\n\"\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded partially signed Bitcoin transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"      (string, required) The PSBT base64 string\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"tx\\\" : {                   (json object) The decoded network-serialized unsigned transaction.\\n\"\n+            \"    ...                                      The layout is the same as the output of decoderawtransaction.\\n\"\n+            \"  },\\n\"\n+            \"  \\\"inputs\\\" : [                 (array of json objects)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"non_witness_utxo\\\" : {   (json object, optional) Decoded network transaction for non-witness UTXOs\\n\"\n+            \"        ...\\n\"\n+            \"      },\\n\"\n+            \"      \\\"witness_utxo\\\" : {            (json object, optional) Transaction output for witness UTXOs\\n\"\n+            \"        \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n+            \"        \\\"scriptPubKey\\\" : {          (json object)\\n\"\n+            \"          \\\"asm\\\" : \\\"asm\\\",            (string) The asm\\n\"\n+            \"          \\\"hex\\\" : \\\"hex\\\",            (string) The hex\\n\"\n+            \"          \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n+            \"          \\\"type\\\" : \\\"pubkeyhash\\\",    (string) The type, eg 'pubkeyhash'\\n\"\n+            \"          \\\"addresses\\\" : [           (json array of string)\\n\"\n+            \"            \\\"address\\\"               (string) Bitcoin address\\n\"\n+            \"            ,...\\n\"\n+            \"          ]\\n\"\n+            \"        }\\n\"\n+            \"      },\\n\"\n+            \"      \\\"partial_signatures\\\" : [             (array of json objects, optional)\\n\"\n+            \"        {\\n\"\n+            \"          \\\"pubkey\\\" : \\\"pubkey\\\",             (string) The public key this signature corresponds to\\n\"\n+            \"          \\\"signature\\\" : \\\"signature\\\",       (string) The signature\\n\"\n+            \"        }\\n\"\n+            \"        ,...\\n\"\n+            \"      ]\\n\"\n+            \"      \\\"sighash\\\" : \\\"type\\\",                  (string, optional) The sighash type recommended to be used\\n\"\n+            \"  \\\"redeem_scripts\\\" : {       (json object, optional)\\n\"\n+            \"      \\\"script\\\" : {           (json object)\\n\"\n+            \"        \\\"asm\\\":\\\"asm\\\",         (string) Script public key\\n\"\n+            \"        \\\"hex\\\":\\\"hex\\\",         (string) Hex encoded public key\\n\"\n+            \"        \\\"type\\\":\\\"type\\\",       (string) The output type\\n\"\n+            \"        \\\"reqSigs\\\": n,        (numeric) The required signatures\\n\"\n+            \"        \\\"addresses\\\": [       (json array of string)\\n\"\n+            \"          \\\"address\\\"           (string) Bitcoin address\\n\"\n+            \"           ,...\\n\"\n+            \"        ],\\n\"\n+            \"    }\\n\"\n+            \"  \\\"witness_scripts\\\" : {       (array of json objects, optional)\\n\"\n+            \"      \\\"script\\\" : {            (json object)\\n\"\n+            \"        \\\"asm\\\" : \\\"asm\\\",        (string) The asm of the script\\n\"\n+            \"        \\\"hex\\\" : \\\"hex\\\",        (string) The hex of the script\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"  \\\"bip32_derivs\\\" : [          (array of json objects, optional)\\n\"\n+            \"    {\\n\"\n+            \"      \\\"pubkey\\\" : \\\"pubkey\\\",                     (string) The public key this path corresponds to\\n\"\n+            \"      \\\"master_fingerprint\\\" : \\\"fingerprint\\\"     (string) The fingerprint of the master key\\n\"\n+            \"      \\\"path\\\" : \\\"path\\\",                         (string) The path\\n\"\n+            \"      }\\n\"\n+            \"    }\\n\"\n+            \"    ,...\\n\"\n+            \"  ],\\n\"\n+            \"  }\\n\"\n+            \"  ,...\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"decodepsbt\", \"\\\"base64string\\\"\")\n+    );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    // Add the decoded tx\n+    UniValue tx_univ(UniValue::VOBJ);\n+    TxToUniv(CTransaction(psbtx.tx), uint256(), tx_univ, false);\n+    result.pushKV(\"tx\", tx_univ);\n+\n+    // inputs\n+    UniValue inputs(UniValue::VARR);\n+    for (const PSBTInput& input : psbtx.inputs) {\n+        UniValue in(UniValue::VOBJ);\n+        if (!input.IsNull()) {\n+            // UTXOs\n+            if (!input.witness_utxo.IsNull()) {\n+                const CTxOut& txout = input.witness_utxo;\n+\n+                UniValue out(UniValue::VOBJ);\n+\n+                out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n+\n+                UniValue o(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n+                out.pushKV(\"scriptPubKey\", o);\n+                in.pushKV(\"witness_utxo\", out);\n+            } else if (input.non_witness_utxo) {\n+                UniValue non_wit(UniValue::VOBJ);\n+                TxToUniv(*input.non_witness_utxo, uint256(), non_wit, false);\n+                in.pushKV(\"non_witness_utxo\", non_wit);\n+            }\n+\n+            // Partial sigs\n+            if (!input.partial_sigs.empty()) {\n+                UniValue partial_sigs(UniValue::VARR);\n+                for (const auto& sig : input.partial_sigs) {\n+                    UniValue sig_univ(UniValue::VOBJ);\n+                    sig_univ.pushKV(\"pubkey\", HexStr(sig.second.first));\n+                    sig_univ.pushKV(\"signature\", HexStr(sig.second.second));\n+                    partial_sigs.push_back(sig_univ);\n+                }\n+                in.pushKV(\"partial_signatures\", partial_sigs);\n+            }\n+\n+            // Sighash\n+            if (input.sighash_type > 0) {\n+                in.pushKV(\"sighash\", SighashToStr((unsigned char)input.sighash_type));\n+            }\n+\n+            // Redeem script and witness script\n+            if (!input.redeem_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.redeem_script, r, false);\n+                in.pushKV(\"redeem_script\", r);\n+            }\n+            if (!input.witness_script.empty()) {\n+                UniValue r(UniValue::VOBJ);\n+                ScriptPubKeyToUniv(input.witness_script, r, false);\n+                in.pushKV(\"witness_script\", r);\n+            }\n+\n+            // keypaths\n+            if (!input.hd_keypaths.empty()) {\n+                UniValue keypaths(UniValue::VARR);\n+                for (auto entry : input.hd_keypaths) {\n+                    UniValue keypath(UniValue::VOBJ);\n+                    keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                    uint32_t fingerprint = entry.second.at(0);\n+                    keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                    entry.second.erase(entry.second.begin());\n+                    keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                    keypaths.push_back(keypath);\n+                }\n+                in.pushKV(\"bip32_derivs\", keypaths);\n+            }\n+\n+            // Final scriptSig and scriptwitness\n+            if (!input.final_script_sig.empty()) {\n+                in.pushKV(\"final_scriptSig\", HexStr(input.final_script_sig));\n+            }\n+            if (!input.final_script_witness.IsNull()) {\n+                in.pushKV(\"final_scripWitness\", input.final_script_witness.ToString());\n+            }\n+        }\n+        inputs.push_back(in);\n+    }\n+    result.pushKV(\"inputs\", inputs);\n+\n+    // outputs\n+    UniValue outputs(UniValue::VARR);\n+    for (const PSBTOutput& output : psbtx.outputs) {\n+        UniValue out(UniValue::VOBJ);\n+        // Redeem script and witness script\n+        if (!output.redeem_script.empty()) {\n+            out.pushKV(\"redeem_script\", HexStr(output.redeem_script));\n+        }\n+        if (!output.witness_script.empty()) {\n+            out.pushKV(\"witness_script\", HexStr(output.witness_script));\n+        }\n+\n+        // keypaths\n+        if (!output.hd_keypaths.empty()) {\n+            UniValue keypaths(UniValue::VARR);\n+            for (auto entry : output.hd_keypaths) {\n+                UniValue keypath(UniValue::VOBJ);\n+                keypath.pushKV(\"pubkey\", HexStr(entry.first));\n+\n+                uint32_t fingerprint = entry.second.at(0);\n+                keypath.pushKV(\"master_fingerprint\", HexStr(Uint32ToUint8VectorLE(fingerprint)));\n+\n+                entry.second.erase(entry.second.begin());\n+                keypath.pushKV(\"path\", WriteHDKeypath(entry.second));\n+                keypaths.push_back(keypath);\n+            }\n+            out.pushKV(\"bip32_derivs\", keypaths);\n+        }\n+        outputs.push_back(out);\n+    }\n+    result.pushKV(\"outputs\", outputs);\n+\n+    return result;\n+}\n+\n+UniValue combinepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinepsbt [\\\"base64string\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed Bitcoin transactions into one transaction.\\n\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"                   (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"base64string\\\"             (string) A base64 string of a PSBT\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded partially signed transaction\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinepsbt\", \"[\\\"mybase64_1\\\", \\\"mybase64_2\\\", \\\"mybase64_3\\\"]\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    std::vector<PartiallySignedTransaction> psbtxs;\n+    UniValue txs = request.params[0].get_array();\n+    for (unsigned int i = 0; i < txs.size(); ++i) {\n+        PartiallySignedTransaction psbtx;\n+        std::vector<unsigned char> txData = DecodeBase64(txs[i].get_str().c_str());\n+        CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+        try {\n+            ssData >> psbtx;\n+            if (!ssData.empty()) {\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+            }\n+        } catch (const std::exception& e) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+        }\n+        psbtxs.push_back(psbtx);\n+    }\n+\n+    // Check that each psbt refers to the same transactions\n+    for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+        if (psbtx != psbtxs[0]) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n+        }\n+    }\n+\n+    PartiallySignedTransaction merged_psbtx(psbtxs[0]); // Copy the first one\n+    // Merge input data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vin.size(); ++i) {\n+        CTxIn& txin = merged_psbtx.tx.vin[i];\n+\n+        // Find the utxo from one of the psbtxs\n+        CTxOut utxo;\n+        CTransactionRef non_witness_utxo = nullptr;\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // First find the non-witness utxo\n+            if (psbtx.inputs.at(i).non_witness_utxo) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n]) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).non_witness_utxo->vout[txin.prevout.n];\n+                    non_witness_utxo = psbtx.inputs.at(i).non_witness_utxo;\n+                }\n+            }\n+            // Now find the witness utxo if the non witness doesn't exist\n+            else if (!psbtx.inputs.at(i).witness_utxo.IsNull()) {\n+                // If we have already seen the utxo, we want to make sure that these match\n+                if (!utxo.IsNull()) {\n+                    if (utxo != psbtx.inputs.at(i).witness_utxo) {\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Input UTXOs for input %d do not match.\", i));\n+                    }\n+                } else {\n+                    utxo = psbtx.inputs.at(i).witness_utxo;\n+                }\n+            }\n+            // If there is no nonwitness or witness utxo, the continue and see if it is in another psbt\n+            else {\n+                continue;\n+            }\n+        }\n+\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.inputs.at(i).partial_sigs.insert(psbtx.inputs.at(i).partial_sigs.begin(), psbtx.inputs.at(i).partial_sigs.end());\n+            merged_psbtx.inputs.at(i).hd_keypaths.insert(psbtx.inputs.at(i).hd_keypaths.begin(), psbtx.inputs.at(i).hd_keypaths.end());\n+            merged_psbtx.inputs.at(i).unknown.insert(psbtx.inputs.at(i).unknown.begin(), psbtx.inputs.at(i).unknown.end());\n+            if (merged_psbtx.inputs.at(i).redeem_script.empty() && !psbtx.inputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.inputs.at(i).redeem_script = psbtx.inputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).witness_script.empty() && !psbtx.inputs.at(i).witness_script.empty()) {\n+                merged_psbtx.inputs.at(i).witness_script = psbtx.inputs.at(i).witness_script;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_sig.empty() && !psbtx.inputs.at(i).final_script_sig.empty()) {\n+                merged_psbtx.inputs.at(i).final_script_sig = psbtx.inputs.at(i).final_script_sig;\n+            }\n+            if (merged_psbtx.inputs.at(i).final_script_witness.IsNull() && !psbtx.inputs.at(i).final_script_witness.IsNull()) {\n+                merged_psbtx.inputs.at(i).final_script_witness = psbtx.inputs.at(i).final_script_witness;\n+            }\n+        }\n+\n+        // Only do this if there was a utxo\n+        if (!utxo.IsNull()) {\n+            // Put the UTXO in the merged psbtx\n+            if (non_witness_utxo) {\n+                merged_psbtx.inputs.at(i).non_witness_utxo = non_witness_utxo;\n+            } else {\n+                merged_psbtx.inputs.at(i).witness_utxo = utxo;\n+            }\n+        }\n+    }\n+\n+    // Merge the output data\n+    for (unsigned int i = 0; i < merged_psbtx.tx.vout.size(); ++i) {\n+        for (const PartiallySignedTransaction& psbtx : psbtxs) {\n+            // Merge input data\n+            merged_psbtx.outputs.at(i).hd_keypaths.insert(psbtx.outputs.at(i).hd_keypaths.begin(), psbtx.outputs.at(i).hd_keypaths.end());\n+            merged_psbtx.outputs.at(i).unknown.insert(psbtx.outputs.at(i).unknown.begin(), psbtx.outputs.at(i).unknown.end());\n+            if (merged_psbtx.outputs.at(i).redeem_script.empty() && !psbtx.outputs.at(i).redeem_script.empty()) {\n+                merged_psbtx.outputs.at(i).redeem_script = psbtx.outputs.at(i).redeem_script;\n+            }\n+            if (merged_psbtx.outputs.at(i).witness_script.empty() && !psbtx.outputs.at(i).witness_script.empty()) {\n+                merged_psbtx.outputs.at(i).witness_script = psbtx.outputs.at(i).witness_script;\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << merged_psbtx;\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue finalizepsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"finalizepsbt \\\"base64string\\\" ( extract )\\n\"\n+            \"Finalize the inputs of a PSBT. If the transaction is fully signed, it will produce a\\n\"\n+            \"network serialized transaction which can be broadcast with sendrawtransaction\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"base64string\\\"            (string) A base64 string of a PSBT\\n\"\n+            \"2. \\\"extract\\\"              (boolean, optional, default=true) If true and the transaction is complete, \\n\"\n+            \"                             extract and return the complete transaction in normal network serialization.\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"base64\\\" : \\\"value\\\",        (string) The base64-encoded network transaction\\n\"\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded partially signed transaction if extracted\\n\"\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n+            \"  ]\\n\"\n+            \"}\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"finalizepsbt\", \"\\\"base64string\\\"\")\n+        );\n+\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL}, true);\n+\n+    // Unserialize the transactions\n+    PartiallySignedTransaction psbtx;\n+    std::vector<unsigned char> txData = DecodeBase64(request.params[0].get_str().c_str());\n+    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n+    try {\n+        ssData >> psbtx;\n+        if (!ssData.empty()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed, extra data after PSBT\");\n+        }\n+    } catch (const std::exception& e) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", e.what()));\n+    }\n+\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx.vin.size(); ++i) {\n+        CTxIn txin = psbtx.tx.vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        // if this input has a final scriptsig or scriptwitness, don't do anything with it\n+        if (!input.final_script_sig.empty() || !input.final_script_witness.IsNull()) {\n+            continue;\n+        }\n+\n+        // Fill a SignatureData with input info\n+        SignatureData sigdata;\n+        input.FillSignatureData(sigdata);\n+\n+        // Get UTXO\n+        CTxOut utxo;\n+        if (input.non_witness_utxo) {\n+            utxo = input.non_witness_utxo->vout[txin.prevout.n];\n+        }\n+        // Now find the witness utxo if the non witness doesn't exist\n+        else if (!input.witness_utxo.IsNull()) {\n+            utxo = input.witness_utxo;\n+        }\n+        // No UTXO, don't do anything\n+        else {\n+            continue;\n+        }\n+\n+        MutableTransactionSignatureCreator creator(&psbtx.tx, i, utxo.nValue, 1);\n+        bool sig_complete = ProduceSignature(DUMMY_SIGNING_PROVIDER, creator, utxo.scriptPubKey, sigdata);\n+        input.FromSignatureData(sigdata);\n+        complete &= sig_complete;\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    if (complete && extract) {\n+        CMutableTransaction mtx(psbtx.tx);\n+        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n+            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+        }\n+        ssTx << mtx;\n+        result.push_back(Pair(\"hex\", HexStr(ssTx.begin(), ssTx.end())));\n+    } else {\n+        ssTx << psbtx;\n+        result.push_back(Pair(\"base64\", EncodeBase64((unsigned char*)ssTx.data(), ssTx.size())));\n+    }\n+    result.push_back(Pair(\"complete\", complete));\n+\n+    return result;\n+}\n+\n+UniValue createpsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n+        throw std::runtime_error(\n+                            \"createpsbt [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] [{\\\"address\\\":amount},{\\\"data\\\":\\\"hex\\\"},...] ( locktime ) ( replaceable )\\n\"\n+                            \"\\nCreates and funds a transaction in the Partially Signed Transaction format. Inputs will be added if supplied inputs are not enough\\n\"\n+                            \"\\nArguments:\\n\"\n+                            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n+                            \"     [\\n\"\n+                            \"       {\\n\"\n+                            \"         \\\"txid\\\":\\\"id\\\",      (string, required) The transaction id\\n\"\n+                            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n+                            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n+                            \"       } \\n\"\n+                            \"       ,...\\n\"\n+                            \"     ]\\n\"\n+                            \"2. \\\"outputs\\\"               (array, required) a json array with outputs (key-value pairs)\\n\"\n+                            \"   [\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"address\\\": x.xxx,    (obj, optional) A key-value pair. The key (string) is the bitcoin address, the value (float or string) is the amount in \" + CURRENCY_UNIT + \"\\n\"\n+                            \"    },\\n\"\n+                            \"    {\\n\"\n+                            \"      \\\"data\\\": \\\"hex\\\"        (obj, optional) A key-value pair. The key must be \\\"data\\\", the value is hex encoded data\\n\"\n+                            \"    }\\n\"\n+                            \"    ,...                     More key-value pairs of the above form. For compatibility reasons, a dictionary, which holds the key-value pairs directly, is also\\n\"\n+                            \"                             accepted as second parameter.\\n\"\n+                            \"   ]\\n\"\n+                            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+                            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+                            \"\\nResult:\\n\"\n+                            \"  \\\"base64\\\": \\\"value\\\",      (string)  The resulting raw transaction (base64-encoded string)\\n\"\n+                            \"\\nExamples:\\n\"\n+                            + HelpExampleCli(\"createpsbt\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"[{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}]\\\"\")\n+                            );\n+\n+\n+    RPCTypeCheck(request.params, {\n+        UniValue::VARR,\n+        UniValueType(), // ARR or OBJ, checked later\n+        UniValue::VNUM,\n+        UniValue::VBOOL,\n+        }, true\n+    );\n+\n+    CMutableTransaction rawTx = ConstructTransaction(request.params[0], request.params[1], request.params[2], request.params[3]);\n+\n+    // Make a blank psbt\n+    PartiallySignedTransaction psbtx;\n+    psbtx.tx = rawTx;\n+    for (unsigned int i = 0; i < rawTx.vin.size(); ++i) {\n+        psbtx.inputs.push_back(PSBTInput());\n+    }\n+    for (unsigned int i = 0; i < rawTx.vout.size(); ++i) {\n+        psbtx.outputs.push_back(PSBTOutput());\n+    }\n+\n+    // Serialize the PSBT\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << psbtx;\n+\n+    return EncodeBase64((unsigned char*)ssTx.data(), ssTx.size());\n+}\n+\n+UniValue converttopsbt(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+        throw std::runtime_error(\n+                            \"converttopsbt \\\"hexstring\\\" ( permitsigdata iswitness )\\n\"\n+                            \"\\nConverts a network serialized transaction to a PSBT.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#discussion_r199038156",
      "id" : 199038156,
      "in_reply_to_id" : 199013256,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDE5OTAzODE1Ng==",
      "original_commit_id" : "af544a96fa3a74f960723d5c34f3b015e683ae57",
      "original_position" : 542,
      "path" : "src/rpc/rawtransaction.cpp",
      "position" : null,
      "pull_request_review_id" : 133080790,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/13557",
      "updated_at" : "2018-06-29T02:26:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/199038156",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I did a bit of commit splitting and have reduced the size of the RPCs commit by splitting it up. Hopefully this will make review easier.",
      "created_at" : "2018-06-29T02:26:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/13557#issuecomment-401228577",
      "id" : 401228577,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/13557",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwMTIyODU3Nw==",
      "updated_at" : "2018-06-29T02:26:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/401228577",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   }
]
