[
   {
      "author_association" : "MEMBER",
      "body" : "How does it react to diverse network policies?",
      "created_at" : "2020-03-04T20:04:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-594803706",
      "id" : 594803706,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5NDgwMzcwNg==",
      "updated_at" : "2020-03-04T20:04:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/594803706",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK",
      "created_at" : "2020-03-04T20:13:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-594810354",
      "id" : 594810354,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5NDgxMDM1NA==",
      "updated_at" : "2020-03-04T20:13:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/594810354",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2020-03-04T20:40:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-594823883",
      "id" : 594823883,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5NDgyMzg4Mw==",
      "updated_at" : "2020-03-04T20:40:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/594823883",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r387925726"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/387925726"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I'm afraid `std::to_string` is locale dependent.\r\n\r\n---\r\n\r\nFor those interested in permanently killing the locale dependency bug class, consider reviewing:\r\n* #18124 â init: Clarify C and C++ locale assumptions. Add locale sanity checks to verify assumptions at run-time\r\n* #18126 â tests: Add fuzzing harness testing the locale independence of the `strencodings.h` functions\r\n* #18147 â qt: Kill the locale dependency bug class by not allowing Qt to mess with `LC_NUMERIC`\r\n",
      "commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "created_at" : "2020-03-04T20:49:13Z",
      "diff_hunk" : "@@ -3258,6 +3403,331 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         return true;\n     }\n \n+    // Received from an inbound peer planning to reconcilie transactions with us, or\n+    // from an outgoing peer demonstrating readiness to do reconciliations.\n+    // If received from outgoing, adds the peer to the reconciliation queue.\n+    if (strCommand == NetMsgType::SENDRECON) {\n+        if (!pfrom->m_tx_relay) return true;\n+        if(pfrom->m_recon_state != nullptr) return true; // Do not support reconciliation salt/version updates.\n+\n+        bool recon_sender, recon_responder;\n+        uint64_t remote_salt;\n+        uint32_t recon_version;\n+        vRecv >> recon_sender >> recon_responder >> recon_version >> remote_salt;\n+        if (recon_version != 1) return true;\n+\n+        // According to current erlay spec.\n+        if (recon_sender == recon_responder) return true;\n+\n+        if (pfrom->fInbound) {\n+            if (!recon_sender) return true;\n+            // Do not flood through inbound connections which support reconciliation to save bandwidth.\n+            pfrom->m_flood_to = false;\n+        } else {\n+            if (!recon_responder) return true;\n+            uint64_t outbound_flooding = connman->GetOutboundCountByTxRelayType(true);\n+            if (outbound_flooding > MAX_OUTBOUND_FLOOD_TO)\n+                pfrom->m_flood_to = false;\n+        }\n+\n+        pfrom->m_recon_state = MakeUnique<CNode::ReconState>();\n+        pfrom->m_recon_state->sender = recon_sender;\n+        pfrom->m_recon_state->responder = recon_responder;\n+        pfrom->m_recon_state->local_q = DEFAULT_RECON_Q;\n+\n+        uint64_t local_salt = connman->m_local_recon_salt;\n+\n+        std::string salt1, salt2;\n+        if (remote_salt < local_salt) {\n+            salt1 = std::to_string(remote_salt);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r387925726",
      "id" : 387925726,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzkyNTcyNg==",
      "original_commit_id" : "b93eb384cdaeaceaab89f855753bae6231a8ce77",
      "original_line" : 3440,
      "original_position" : 529,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : null,
      "pull_request_review_id" : 369111380,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-28T01:04:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/387925726",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@luke-jr \r\n\r\nWhen it comes to network policies, I'm using the same code originally used by regular gossip (\"Determine transactions to relay\" in net_processing.cpp). So nothing should be lost or sent wastefully as a result of policy discrepancies.",
      "created_at" : "2020-03-07T19:23:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-596129273",
      "id" : 596129273,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5NjEyOTI3Mw==",
      "updated_at" : "2020-03-07T19:23:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/596129273",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@luke-jr  I'm understanding your question as being inspired by earlier 'mempool sync' ideas that would bleed bandwidth if there was a long lasting mempool discrepancy.\r\n\r\nErlay isn't a mempool sync. It's uses a way of communicating lists of things you want to relay which only takes bandwidth proportional to the difference rather than the total size.  So there is no on-going bandwidth usage due to differences in *mempool* content. Bandwidth is used is roughly  A*ntx_relayed + B*peers*(difference_in_tx_relayed) + C*peers.  for some constants A,B,C. \r\n\r\nIf a peer has a radically different relay policy than you, it works fine and continues to save bandwidth below what usage would be without erlay even though the erlay savings itself comes largely from eliminating data that both sides would send.\r\n\r\nDoes that answer your question?",
      "created_at" : "2020-03-08T22:57:38Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-596262994",
      "id" : 596262994,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5NjI2Mjk5NA==",
      "updated_at" : "2020-03-08T22:57:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/596262994",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/858454?v=4",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "node_id" : "MDQ6VXNlcjg1ODQ1NA==",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@naumenkogs When trying out this PR I ran in to two small testing issues:\r\n\r\n* The suffix of the functional test `p2p_erlay` is `.p2p` (`p2p_erlay.p2p`) instead of the expected `.py` (`p2p_erlay.py`) :)\r\n* It seems like `make check` runs the `minisketch` binaries `test-exhaust` and `test-exhaust-verify`. The running times of these are quite substantial - is there some way to do a quick sanity check as part of `make check` instead of exhaustive testing? :)\r\n",
      "created_at" : "2020-03-09T19:57:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-596749292",
      "id" : 596749292,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5Njc0OTI5Mg==",
      "updated_at" : "2020-03-09T20:03:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/596749292",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@practicalswift The unit test minisketch binaries actually run forever. I need to fix that.",
      "created_at" : "2020-03-09T20:48:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-596771889",
      "id" : 596771889,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5Njc3MTg4OQ==",
      "updated_at" : "2020-03-09T20:48:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/596771889",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@naumenkogs \r\n\r\nI did some robustness testing of this code by pulling in PRs #17989 (`ProcessMessage(â¦)` fuzzer). and #18288 (MemorySanitizer) and found an use of uninitialized memory (UUM) that is remotely triggerable.\r\n\r\nYou can reproduce the issue by pulling in the commits from those PR:s and simply run:\r\n\r\n```\r\n$ src/test/fuzz/process_message\r\nâ¦\r\n```\r\n\r\nThe issue will be hit within a few seconds: `libFuzzer` is amazing :)\r\n\r\nNotice also how `libFuzzer` will automatically find the newly added message names (`wtxidrelay`, `sendrecon`, `reqrecon`, `sketch`, `reqbisec` and `reconcildiff`) and probe using them all! The fuzzer harness does not need to be teached about the existence of those :)\r\n\r\nPerhaps this UUM is the reason of the intermittent test failure you're seeing?\r\n\r\nI encourage everybody to review (or at least Concept ACK :)) #17989 (`ProcessMessage(â¦)` fuzzer). and #18288 (MemorySanitizer): having them merged would be great for robustness/security.",
      "created_at" : "2020-03-09T22:10:51Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-596803815",
      "id" : 596803815,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5NjgwMzgxNQ==",
      "updated_at" : "2020-03-09T22:10:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/596803815",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Needs rebase :)",
      "created_at" : "2020-03-11T16:45:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-597743053",
      "id" : 597743053,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5Nzc0MzA1Mw==",
      "updated_at" : "2020-03-11T16:45:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/597743053",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I made some latest changes to make sure it can be plugged into a real network.\r\nPlease help with testing this by running a couple inter-connected Erlay nodes, and observing bandwidth (and ideally tx relay latency).\r\n\r\n@practicalswift I was planning to rebase once #18044 is merged.",
      "created_at" : "2020-03-11T19:26:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-597823928",
      "id" : 597823928,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5NzgyMzkyOA==",
      "updated_at" : "2020-03-11T19:26:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/597823928",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I ran 2 non-reachable nodes for around 24 hours, one is regular [wtxid-node](https://github.com/bitcoin/bitcoin/pull/18044) connected to legacy nodes, one is Erlay node connected to reconciliation-supporting nodes on the same host.\r\n\r\nBandwidth breakdown (in megabytes):\r\n\r\n|  | Legacy (sent) | Erlay (sent) | Legacy (received) | Erlay (received) |\r\n|----------------------------------|---------------|--------------|-------------------|------------------|\r\n| inv | 38 | 0.4 | 22 | 5.3 |\r\n| getdata | 6 | 5.7 | 1 | 0 |\r\n| sketch | - | - | - | 1.2 |\r\n| reqrecon, reqbisec, reconcildiff | - | 0.7 | - | - |\r\n| tx, blocktxn | 3 | 0.3 | 75 | 75 |\r\n| total (incl. other) | 48 |  7.1 | 103 | 84 |\r\n\r\nNotice overall 40% bandwidth saving.\r\nPlease help by running similar experiments and sharing bandwidth results :)\r\nHere's the [script](https://gist.github.com/naumenkogs/9bee7178dbe582e47d8db16f1019ddee) I hacked together for bandwidth analysis (run nodes with debug=1)\r\nPlease sanitize your results before publishing: sometimes there's noisy bandwidth like extra blocks due to some reasons I'm not aware of. ",
      "created_at" : "2020-03-15T17:41:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-599241490",
      "id" : 599241490,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU5OTI0MTQ5MA==",
      "updated_at" : "2020-03-18T02:07:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/599241490",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "More experiments: now I ran the same 2 nodes for 24 hours, but connected to 16 instead of 8 nodes (yeah, all 16 peers of Erlay node support reconciliation).\r\n\r\nLegacy wtxid-relay node spent 150 megabytes for announcements, while Erlay node spent 24 megabytes. Since these 2 days might have had different activity, it makes sense to compare the growth.. Legacy grew 2.23x (I guess due to more INVs in total), Erlay grew 1.8x. So, as expected, not only it's decent savings comparing to legacy, it also grows slower with connectivity.\r\n\r\nBased on the following facts I also make a guess that there's no point in tweaking Erlay forward for better performance:\r\n- only 0.0016 reconciliation failed (fully or partially) âÂ meaning we don't underestimate much\r\n- only 15% of the announcement bandwidth is sketches âÂ meaning we don't overestimate much\r\n- only 15% of the announcement bandwidth is *outbound* invs (which are much more likely to still be a little wasteful, because those peers are better connected than us and likely don't need those announemens)\r\n\r\nFinally, I measured delay in receiving transactions. I take the earliest time I received a transaction, and take latency from there, comparing to:\r\n- an average receiving time at all legacy nodes: 0.92s \r\n- at the Erlay node: 1.47s\r\n\r\nI think this is expected and fine, as we talk in the paper, but let me know if you think differently.",
      "created_at" : "2020-03-18T02:12:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-600388543",
      "id" : 600388543,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwMDM4ODU0Mw==",
      "updated_at" : "2020-03-18T02:39:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/600388543",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #20359 (depends: Various config.site.in improvements and linting by dongcarl)\n* #20295 (rpc: getblockfrompeer by Sjors)\n* #20223 (Drop the leading 0 from the version number by achow101)\n* #20217 (net: Remove g_relay_txes by jnewbery)\n* #20121 (configure: Allow users to explicitly enable libsecp256k1's GMP bignum support by luke-jr)\n* #20019 (depends: Properly pass $PATH to configure and pin by dongcarl)\n* #19910 (net processing: Move peer_map to PeerManager by jnewbery)\n* #19858 (Periodically make block-relay connections and sync headers by sdaftuar)\n* #19315 ([tests] Allow outbound & block-relay-only connections in functional tests. by amitiuttarwar)\n* #18242 (Add BIP324 encrypted p2p transport de-/serializer (only used in tests) by jonasschnelli)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2020-03-20T01:01:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-601483568",
      "id" : 601483568,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwMTQ4MzU2OA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-11-19T09:55:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/601483568",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-03-30T20:31:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-606232360",
      "id" : 606232360,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwNjIzMjM2MA==",
      "updated_at" : "2020-03-30T20:31:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/606232360",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@mzumsande thank you for taking a look! I'll do my best to find the cause.\r\n\r\nSome external eyes looking at the code would definitely help to both confirm the approach and troubleshoot issues like this :)",
      "created_at" : "2020-04-19T21:42:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-616229738",
      "id" : 616229738,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYxNjIyOTczOA==",
      "updated_at" : "2020-04-19T21:42:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/616229738",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412301986"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/412301986"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think that this is UB (if no wtxid for a shortid is found, there is a LogPrint, but the item is still dereferenced).\r\nWhile this should explain the strange wtxids with lots of 0s, it doesn't explain the why no mapping is found to begin with.",
      "commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "created_at" : "2020-04-21T16:19:22Z",
      "diff_hunk" : "@@ -628,6 +628,135 @@ int CNode::GetSendVersion() const\n     return nSendVersion;\n }\n \n+void CNode::FinalizeReconciliation(bool clear_local_set, LocalQAction action, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    // According to the erlay spec, reconciliation is initiated by inbound peers.\n+    if (m_recon_state->sender) {\n+        assert(m_recon_state->incoming_recon != CNode::ReconPhase::NONE);\n+        m_recon_state->incoming_recon = CNode::ReconPhase::NONE;\n+    } else {\n+        // When reconciliation initialized by us is done, update local q for future reconciliations.\n+        if (action == LocalQAction::Q_RECOMPUTE) {\n+            assert(m_recon_state->outgoing_recon != CNode::ReconPhase::NONE);\n+            uint8_t local_set_size;\n+            if (m_recon_state->outgoing_recon == CNode::ReconPhase::BISEC_REQUESTED) {\n+                local_set_size = m_recon_state->local_set_snapshot.size();\n+            } else {\n+                local_set_size = m_recon_state->local_set.size();\n+            }\n+            uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+            uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+            uint8_t min_size = std::min(local_set_size, remote_set_size);\n+            uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+            if (min_size != 0)\n+                m_recon_state->local_q = double(actual_difference - set_size_diff) / min_size;\n+        } else if (action == LocalQAction::Q_INCREASE) {\n+            m_recon_state->local_q *= 1.1;\n+        } else if (action == LocalQAction::Q_SET_DEFAULT) {\n+            m_recon_state->local_q = DEFAULT_RECON_Q;\n+        }\n+        m_recon_state->outgoing_recon = CNode::ReconPhase::NONE;\n+    }\n+    if (clear_local_set) m_recon_state->local_set.clear();\n+\n+    m_recon_state->local_short_id_mapping.clear();\n+    // This is currently belt-and-suspenders, as the code should work even without these calls.\n+    m_recon_state->local_set_snapshot.clear();\n+    m_recon_state->capacity_snapshot = 0;\n+    m_recon_state->remote_sketch_snapshot = nullptr;\n+    m_recon_state->local_sketch_snapshot = nullptr;\n+}\n+\n+uint32_t CNode::ComputeShortID(uint256 wtxid)\n+{\n+    uint64_t k0 = m_recon_state->salt.GetUint64(0);\n+    uint64_t k1 = m_recon_state->salt.GetUint64(1);\n+    uint64_t s = SipHashUint256(k0, k1, wtxid);\n+    uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+    m_recon_state->local_short_id_mapping.insert(std::pair<uint32_t, uint256>(short_txid, wtxid));\n+    return short_txid;\n+}\n+\n+minisketch* CNode::ComputeSketch(bool use_own_q, BisectionChunk bisection_chunk, uint16_t capacity)\n+{\n+    std::vector<uint32_t> short_ids;\n+    if (m_recon_state->incoming_recon == ReconPhase::BISEC_REQUESTED || m_recon_state->outgoing_recon == ReconPhase::BISEC_REQUESTED) {\n+        // During bisection, all the relevant transactions are stored in the snapshot.\n+        // Original set is used to not miss transactions received during the reconciliation elsewhere.\n+        if (m_recon_state->local_set_snapshot.size() == 0) {\n+            return nullptr;\n+        }\n+        for (uint256 wtxid : m_recon_state->local_set_snapshot) {\n+            short_ids.push_back(ComputeShortID(wtxid));\n+        }\n+\n+        std::vector<uint32_t> bisec_short_ids;\n+        for (uint32_t short_id : short_ids) {\n+            if (bisection_chunk == BISECTION_LOW) {\n+                if (short_id <= BISECTION_MEDIAN) {\n+                    bisec_short_ids.push_back(short_id);\n+                }\n+            } else {\n+                if (short_id > BISECTION_MEDIAN) {\n+                    bisec_short_ids.push_back(short_id);\n+                }\n+            }\n+        }\n+        short_ids = bisec_short_ids;\n+        // For bisection, use capacity used in the initial reconciliation.\n+        capacity = m_recon_state->capacity_snapshot;\n+    } else {\n+        for (uint256 wtxid : m_recon_state->local_set) {\n+            short_ids.push_back(ComputeShortID(wtxid));\n+        }\n+\n+        if (capacity == 0) {\n+            // Estimate locally, as requested by the calling function.\n+            int set_size_diff = m_recon_state->local_set.size() - m_recon_state->remote_set_size;\n+            double q = use_own_q ? m_recon_state->local_q : m_recon_state->remote_q;\n+            capacity = 1 + q * fmin(m_recon_state->local_set.size(), m_recon_state->remote_set_size) +\n+                       abs(set_size_diff);\n+        }\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+        // If bisection is required, we will use this capacity from the initial reconciliation.\n+        m_recon_state->capacity_snapshot = capacity;\n+    }\n+    if (short_ids.size() == 0) return nullptr;\n+    minisketch* sketch = minisketch_create(RECON_FIELD_SIZE, 0, capacity);\n+    for (uint32_t short_id : short_ids) {\n+        minisketch_add_uint64(sketch, short_id);\n+    }\n+    return sketch;\n+}\n+\n+std::vector<uint256> CNode::GetRelevantIDsFromShortIDs(uint64_t diff[], uint8_t diff_size, std::vector<uint32_t>& local_missing, CConnman* connman)\n+{\n+    std::vector<uint256> remote_missing;\n+    for (int i = 0; i < diff_size; ++i) {\n+        auto local_tx = m_recon_state->local_short_id_mapping.find(diff[i]);\n+        if (local_tx != m_recon_state->local_short_id_mapping.end()) {\n+            remote_missing.push_back(local_tx->second);\n+        } else {\n+            local_missing.push_back(diff[i]);\n+        }\n+    }\n+    return remote_missing;\n+}\n+\n+std::vector<uint256> CNode::GetWTXIDsFromShortIDs(const std::vector<uint32_t> remote_missing_short_ids, CConnman* connman)\n+{\n+    std::vector<uint256> remote_missing;\n+    for (size_t i = 0; i < remote_missing_short_ids.size(); ++i) {\n+        auto local_tx = m_recon_state->local_short_id_mapping.find(remote_missing_short_ids[i]);\n+        if (local_tx == m_recon_state->local_short_id_mapping.end()) {\n+            LogPrint(BCLog::NET, \"Unknown transaction requested by short id=%d by peer=%d\\n\", remote_missing_short_ids[i], GetId());\n+        }\n+        remote_missing.push_back(local_tx->second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412301986",
      "id" : 412301986,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMwMTk4Ng==",
      "original_commit_id" : "1b695eabc2083384596e146ff3da5846be3058e0",
      "original_line" : 760,
      "original_position" : 127,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 397465590,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-28T01:04:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/412301986",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412342381"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/412342381"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I found an issue, will commit the fix later today!\r\nBasically, sometimes reconcil. difference finding gives a false positive: it looks like a success, but some difference elements are missing.\r\nThis is just a natural property of math in minisketch. I'll submit a workaround.",
      "commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "created_at" : "2020-04-21T17:17:13Z",
      "diff_hunk" : "@@ -628,6 +628,135 @@ int CNode::GetSendVersion() const\n     return nSendVersion;\n }\n \n+void CNode::FinalizeReconciliation(bool clear_local_set, LocalQAction action, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    // According to the erlay spec, reconciliation is initiated by inbound peers.\n+    if (m_recon_state->sender) {\n+        assert(m_recon_state->incoming_recon != CNode::ReconPhase::NONE);\n+        m_recon_state->incoming_recon = CNode::ReconPhase::NONE;\n+    } else {\n+        // When reconciliation initialized by us is done, update local q for future reconciliations.\n+        if (action == LocalQAction::Q_RECOMPUTE) {\n+            assert(m_recon_state->outgoing_recon != CNode::ReconPhase::NONE);\n+            uint8_t local_set_size;\n+            if (m_recon_state->outgoing_recon == CNode::ReconPhase::BISEC_REQUESTED) {\n+                local_set_size = m_recon_state->local_set_snapshot.size();\n+            } else {\n+                local_set_size = m_recon_state->local_set.size();\n+            }\n+            uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+            uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+            uint8_t min_size = std::min(local_set_size, remote_set_size);\n+            uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+            if (min_size != 0)\n+                m_recon_state->local_q = double(actual_difference - set_size_diff) / min_size;\n+        } else if (action == LocalQAction::Q_INCREASE) {\n+            m_recon_state->local_q *= 1.1;\n+        } else if (action == LocalQAction::Q_SET_DEFAULT) {\n+            m_recon_state->local_q = DEFAULT_RECON_Q;\n+        }\n+        m_recon_state->outgoing_recon = CNode::ReconPhase::NONE;\n+    }\n+    if (clear_local_set) m_recon_state->local_set.clear();\n+\n+    m_recon_state->local_short_id_mapping.clear();\n+    // This is currently belt-and-suspenders, as the code should work even without these calls.\n+    m_recon_state->local_set_snapshot.clear();\n+    m_recon_state->capacity_snapshot = 0;\n+    m_recon_state->remote_sketch_snapshot = nullptr;\n+    m_recon_state->local_sketch_snapshot = nullptr;\n+}\n+\n+uint32_t CNode::ComputeShortID(uint256 wtxid)\n+{\n+    uint64_t k0 = m_recon_state->salt.GetUint64(0);\n+    uint64_t k1 = m_recon_state->salt.GetUint64(1);\n+    uint64_t s = SipHashUint256(k0, k1, wtxid);\n+    uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+    m_recon_state->local_short_id_mapping.insert(std::pair<uint32_t, uint256>(short_txid, wtxid));\n+    return short_txid;\n+}\n+\n+minisketch* CNode::ComputeSketch(bool use_own_q, BisectionChunk bisection_chunk, uint16_t capacity)\n+{\n+    std::vector<uint32_t> short_ids;\n+    if (m_recon_state->incoming_recon == ReconPhase::BISEC_REQUESTED || m_recon_state->outgoing_recon == ReconPhase::BISEC_REQUESTED) {\n+        // During bisection, all the relevant transactions are stored in the snapshot.\n+        // Original set is used to not miss transactions received during the reconciliation elsewhere.\n+        if (m_recon_state->local_set_snapshot.size() == 0) {\n+            return nullptr;\n+        }\n+        for (uint256 wtxid : m_recon_state->local_set_snapshot) {\n+            short_ids.push_back(ComputeShortID(wtxid));\n+        }\n+\n+        std::vector<uint32_t> bisec_short_ids;\n+        for (uint32_t short_id : short_ids) {\n+            if (bisection_chunk == BISECTION_LOW) {\n+                if (short_id <= BISECTION_MEDIAN) {\n+                    bisec_short_ids.push_back(short_id);\n+                }\n+            } else {\n+                if (short_id > BISECTION_MEDIAN) {\n+                    bisec_short_ids.push_back(short_id);\n+                }\n+            }\n+        }\n+        short_ids = bisec_short_ids;\n+        // For bisection, use capacity used in the initial reconciliation.\n+        capacity = m_recon_state->capacity_snapshot;\n+    } else {\n+        for (uint256 wtxid : m_recon_state->local_set) {\n+            short_ids.push_back(ComputeShortID(wtxid));\n+        }\n+\n+        if (capacity == 0) {\n+            // Estimate locally, as requested by the calling function.\n+            int set_size_diff = m_recon_state->local_set.size() - m_recon_state->remote_set_size;\n+            double q = use_own_q ? m_recon_state->local_q : m_recon_state->remote_q;\n+            capacity = 1 + q * fmin(m_recon_state->local_set.size(), m_recon_state->remote_set_size) +\n+                       abs(set_size_diff);\n+        }\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+        // If bisection is required, we will use this capacity from the initial reconciliation.\n+        m_recon_state->capacity_snapshot = capacity;\n+    }\n+    if (short_ids.size() == 0) return nullptr;\n+    minisketch* sketch = minisketch_create(RECON_FIELD_SIZE, 0, capacity);\n+    for (uint32_t short_id : short_ids) {\n+        minisketch_add_uint64(sketch, short_id);\n+    }\n+    return sketch;\n+}\n+\n+std::vector<uint256> CNode::GetRelevantIDsFromShortIDs(uint64_t diff[], uint8_t diff_size, std::vector<uint32_t>& local_missing, CConnman* connman)\n+{\n+    std::vector<uint256> remote_missing;\n+    for (int i = 0; i < diff_size; ++i) {\n+        auto local_tx = m_recon_state->local_short_id_mapping.find(diff[i]);\n+        if (local_tx != m_recon_state->local_short_id_mapping.end()) {\n+            remote_missing.push_back(local_tx->second);\n+        } else {\n+            local_missing.push_back(diff[i]);\n+        }\n+    }\n+    return remote_missing;\n+}\n+\n+std::vector<uint256> CNode::GetWTXIDsFromShortIDs(const std::vector<uint32_t> remote_missing_short_ids, CConnman* connman)\n+{\n+    std::vector<uint256> remote_missing;\n+    for (size_t i = 0; i < remote_missing_short_ids.size(); ++i) {\n+        auto local_tx = m_recon_state->local_short_id_mapping.find(remote_missing_short_ids[i]);\n+        if (local_tx == m_recon_state->local_short_id_mapping.end()) {\n+            LogPrint(BCLog::NET, \"Unknown transaction requested by short id=%d by peer=%d\\n\", remote_missing_short_ids[i], GetId());\n+        }\n+        remote_missing.push_back(local_tx->second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412342381",
      "id" : 412342381,
      "in_reply_to_id" : 412301986,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0MjM4MQ==",
      "original_commit_id" : "1b695eabc2083384596e146ff3da5846be3058e0",
      "original_line" : 760,
      "original_position" : 127,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 397511447,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-28T01:04:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/412342381",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412382710"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/412382710"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Still not sure why it would be UB here? It just accesses the existing array element..",
      "commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "created_at" : "2020-04-21T18:13:33Z",
      "diff_hunk" : "@@ -628,6 +628,135 @@ int CNode::GetSendVersion() const\n     return nSendVersion;\n }\n \n+void CNode::FinalizeReconciliation(bool clear_local_set, LocalQAction action, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    // According to the erlay spec, reconciliation is initiated by inbound peers.\n+    if (m_recon_state->sender) {\n+        assert(m_recon_state->incoming_recon != CNode::ReconPhase::NONE);\n+        m_recon_state->incoming_recon = CNode::ReconPhase::NONE;\n+    } else {\n+        // When reconciliation initialized by us is done, update local q for future reconciliations.\n+        if (action == LocalQAction::Q_RECOMPUTE) {\n+            assert(m_recon_state->outgoing_recon != CNode::ReconPhase::NONE);\n+            uint8_t local_set_size;\n+            if (m_recon_state->outgoing_recon == CNode::ReconPhase::BISEC_REQUESTED) {\n+                local_set_size = m_recon_state->local_set_snapshot.size();\n+            } else {\n+                local_set_size = m_recon_state->local_set.size();\n+            }\n+            uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+            uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+            uint8_t min_size = std::min(local_set_size, remote_set_size);\n+            uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+            if (min_size != 0)\n+                m_recon_state->local_q = double(actual_difference - set_size_diff) / min_size;\n+        } else if (action == LocalQAction::Q_INCREASE) {\n+            m_recon_state->local_q *= 1.1;\n+        } else if (action == LocalQAction::Q_SET_DEFAULT) {\n+            m_recon_state->local_q = DEFAULT_RECON_Q;\n+        }\n+        m_recon_state->outgoing_recon = CNode::ReconPhase::NONE;\n+    }\n+    if (clear_local_set) m_recon_state->local_set.clear();\n+\n+    m_recon_state->local_short_id_mapping.clear();\n+    // This is currently belt-and-suspenders, as the code should work even without these calls.\n+    m_recon_state->local_set_snapshot.clear();\n+    m_recon_state->capacity_snapshot = 0;\n+    m_recon_state->remote_sketch_snapshot = nullptr;\n+    m_recon_state->local_sketch_snapshot = nullptr;\n+}\n+\n+uint32_t CNode::ComputeShortID(uint256 wtxid)\n+{\n+    uint64_t k0 = m_recon_state->salt.GetUint64(0);\n+    uint64_t k1 = m_recon_state->salt.GetUint64(1);\n+    uint64_t s = SipHashUint256(k0, k1, wtxid);\n+    uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+    m_recon_state->local_short_id_mapping.insert(std::pair<uint32_t, uint256>(short_txid, wtxid));\n+    return short_txid;\n+}\n+\n+minisketch* CNode::ComputeSketch(bool use_own_q, BisectionChunk bisection_chunk, uint16_t capacity)\n+{\n+    std::vector<uint32_t> short_ids;\n+    if (m_recon_state->incoming_recon == ReconPhase::BISEC_REQUESTED || m_recon_state->outgoing_recon == ReconPhase::BISEC_REQUESTED) {\n+        // During bisection, all the relevant transactions are stored in the snapshot.\n+        // Original set is used to not miss transactions received during the reconciliation elsewhere.\n+        if (m_recon_state->local_set_snapshot.size() == 0) {\n+            return nullptr;\n+        }\n+        for (uint256 wtxid : m_recon_state->local_set_snapshot) {\n+            short_ids.push_back(ComputeShortID(wtxid));\n+        }\n+\n+        std::vector<uint32_t> bisec_short_ids;\n+        for (uint32_t short_id : short_ids) {\n+            if (bisection_chunk == BISECTION_LOW) {\n+                if (short_id <= BISECTION_MEDIAN) {\n+                    bisec_short_ids.push_back(short_id);\n+                }\n+            } else {\n+                if (short_id > BISECTION_MEDIAN) {\n+                    bisec_short_ids.push_back(short_id);\n+                }\n+            }\n+        }\n+        short_ids = bisec_short_ids;\n+        // For bisection, use capacity used in the initial reconciliation.\n+        capacity = m_recon_state->capacity_snapshot;\n+    } else {\n+        for (uint256 wtxid : m_recon_state->local_set) {\n+            short_ids.push_back(ComputeShortID(wtxid));\n+        }\n+\n+        if (capacity == 0) {\n+            // Estimate locally, as requested by the calling function.\n+            int set_size_diff = m_recon_state->local_set.size() - m_recon_state->remote_set_size;\n+            double q = use_own_q ? m_recon_state->local_q : m_recon_state->remote_q;\n+            capacity = 1 + q * fmin(m_recon_state->local_set.size(), m_recon_state->remote_set_size) +\n+                       abs(set_size_diff);\n+        }\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+        // If bisection is required, we will use this capacity from the initial reconciliation.\n+        m_recon_state->capacity_snapshot = capacity;\n+    }\n+    if (short_ids.size() == 0) return nullptr;\n+    minisketch* sketch = minisketch_create(RECON_FIELD_SIZE, 0, capacity);\n+    for (uint32_t short_id : short_ids) {\n+        minisketch_add_uint64(sketch, short_id);\n+    }\n+    return sketch;\n+}\n+\n+std::vector<uint256> CNode::GetRelevantIDsFromShortIDs(uint64_t diff[], uint8_t diff_size, std::vector<uint32_t>& local_missing, CConnman* connman)\n+{\n+    std::vector<uint256> remote_missing;\n+    for (int i = 0; i < diff_size; ++i) {\n+        auto local_tx = m_recon_state->local_short_id_mapping.find(diff[i]);\n+        if (local_tx != m_recon_state->local_short_id_mapping.end()) {\n+            remote_missing.push_back(local_tx->second);\n+        } else {\n+            local_missing.push_back(diff[i]);\n+        }\n+    }\n+    return remote_missing;\n+}\n+\n+std::vector<uint256> CNode::GetWTXIDsFromShortIDs(const std::vector<uint32_t> remote_missing_short_ids, CConnman* connman)\n+{\n+    std::vector<uint256> remote_missing;\n+    for (size_t i = 0; i < remote_missing_short_ids.size(); ++i) {\n+        auto local_tx = m_recon_state->local_short_id_mapping.find(remote_missing_short_ids[i]);\n+        if (local_tx == m_recon_state->local_short_id_mapping.end()) {\n+            LogPrint(BCLog::NET, \"Unknown transaction requested by short id=%d by peer=%d\\n\", remote_missing_short_ids[i], GetId());\n+        }\n+        remote_missing.push_back(local_tx->second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412382710",
      "id" : 412382710,
      "in_reply_to_id" : 412301986,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM4MjcxMA==",
      "original_commit_id" : "1b695eabc2083384596e146ff3da5846be3058e0",
      "original_line" : 760,
      "original_position" : 127,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 397555862,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-28T01:04:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/412382710",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412384640"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/412384640"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You can't dereference local_tx when it is .end().",
      "commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "created_at" : "2020-04-21T18:16:16Z",
      "diff_hunk" : "@@ -628,6 +628,135 @@ int CNode::GetSendVersion() const\n     return nSendVersion;\n }\n \n+void CNode::FinalizeReconciliation(bool clear_local_set, LocalQAction action, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    // According to the erlay spec, reconciliation is initiated by inbound peers.\n+    if (m_recon_state->sender) {\n+        assert(m_recon_state->incoming_recon != CNode::ReconPhase::NONE);\n+        m_recon_state->incoming_recon = CNode::ReconPhase::NONE;\n+    } else {\n+        // When reconciliation initialized by us is done, update local q for future reconciliations.\n+        if (action == LocalQAction::Q_RECOMPUTE) {\n+            assert(m_recon_state->outgoing_recon != CNode::ReconPhase::NONE);\n+            uint8_t local_set_size;\n+            if (m_recon_state->outgoing_recon == CNode::ReconPhase::BISEC_REQUESTED) {\n+                local_set_size = m_recon_state->local_set_snapshot.size();\n+            } else {\n+                local_set_size = m_recon_state->local_set.size();\n+            }\n+            uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+            uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+            uint8_t min_size = std::min(local_set_size, remote_set_size);\n+            uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+            if (min_size != 0)\n+                m_recon_state->local_q = double(actual_difference - set_size_diff) / min_size;\n+        } else if (action == LocalQAction::Q_INCREASE) {\n+            m_recon_state->local_q *= 1.1;\n+        } else if (action == LocalQAction::Q_SET_DEFAULT) {\n+            m_recon_state->local_q = DEFAULT_RECON_Q;\n+        }\n+        m_recon_state->outgoing_recon = CNode::ReconPhase::NONE;\n+    }\n+    if (clear_local_set) m_recon_state->local_set.clear();\n+\n+    m_recon_state->local_short_id_mapping.clear();\n+    // This is currently belt-and-suspenders, as the code should work even without these calls.\n+    m_recon_state->local_set_snapshot.clear();\n+    m_recon_state->capacity_snapshot = 0;\n+    m_recon_state->remote_sketch_snapshot = nullptr;\n+    m_recon_state->local_sketch_snapshot = nullptr;\n+}\n+\n+uint32_t CNode::ComputeShortID(uint256 wtxid)\n+{\n+    uint64_t k0 = m_recon_state->salt.GetUint64(0);\n+    uint64_t k1 = m_recon_state->salt.GetUint64(1);\n+    uint64_t s = SipHashUint256(k0, k1, wtxid);\n+    uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+    m_recon_state->local_short_id_mapping.insert(std::pair<uint32_t, uint256>(short_txid, wtxid));\n+    return short_txid;\n+}\n+\n+minisketch* CNode::ComputeSketch(bool use_own_q, BisectionChunk bisection_chunk, uint16_t capacity)\n+{\n+    std::vector<uint32_t> short_ids;\n+    if (m_recon_state->incoming_recon == ReconPhase::BISEC_REQUESTED || m_recon_state->outgoing_recon == ReconPhase::BISEC_REQUESTED) {\n+        // During bisection, all the relevant transactions are stored in the snapshot.\n+        // Original set is used to not miss transactions received during the reconciliation elsewhere.\n+        if (m_recon_state->local_set_snapshot.size() == 0) {\n+            return nullptr;\n+        }\n+        for (uint256 wtxid : m_recon_state->local_set_snapshot) {\n+            short_ids.push_back(ComputeShortID(wtxid));\n+        }\n+\n+        std::vector<uint32_t> bisec_short_ids;\n+        for (uint32_t short_id : short_ids) {\n+            if (bisection_chunk == BISECTION_LOW) {\n+                if (short_id <= BISECTION_MEDIAN) {\n+                    bisec_short_ids.push_back(short_id);\n+                }\n+            } else {\n+                if (short_id > BISECTION_MEDIAN) {\n+                    bisec_short_ids.push_back(short_id);\n+                }\n+            }\n+        }\n+        short_ids = bisec_short_ids;\n+        // For bisection, use capacity used in the initial reconciliation.\n+        capacity = m_recon_state->capacity_snapshot;\n+    } else {\n+        for (uint256 wtxid : m_recon_state->local_set) {\n+            short_ids.push_back(ComputeShortID(wtxid));\n+        }\n+\n+        if (capacity == 0) {\n+            // Estimate locally, as requested by the calling function.\n+            int set_size_diff = m_recon_state->local_set.size() - m_recon_state->remote_set_size;\n+            double q = use_own_q ? m_recon_state->local_q : m_recon_state->remote_q;\n+            capacity = 1 + q * fmin(m_recon_state->local_set.size(), m_recon_state->remote_set_size) +\n+                       abs(set_size_diff);\n+        }\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+        // If bisection is required, we will use this capacity from the initial reconciliation.\n+        m_recon_state->capacity_snapshot = capacity;\n+    }\n+    if (short_ids.size() == 0) return nullptr;\n+    minisketch* sketch = minisketch_create(RECON_FIELD_SIZE, 0, capacity);\n+    for (uint32_t short_id : short_ids) {\n+        minisketch_add_uint64(sketch, short_id);\n+    }\n+    return sketch;\n+}\n+\n+std::vector<uint256> CNode::GetRelevantIDsFromShortIDs(uint64_t diff[], uint8_t diff_size, std::vector<uint32_t>& local_missing, CConnman* connman)\n+{\n+    std::vector<uint256> remote_missing;\n+    for (int i = 0; i < diff_size; ++i) {\n+        auto local_tx = m_recon_state->local_short_id_mapping.find(diff[i]);\n+        if (local_tx != m_recon_state->local_short_id_mapping.end()) {\n+            remote_missing.push_back(local_tx->second);\n+        } else {\n+            local_missing.push_back(diff[i]);\n+        }\n+    }\n+    return remote_missing;\n+}\n+\n+std::vector<uint256> CNode::GetWTXIDsFromShortIDs(const std::vector<uint32_t> remote_missing_short_ids, CConnman* connman)\n+{\n+    std::vector<uint256> remote_missing;\n+    for (size_t i = 0; i < remote_missing_short_ids.size(); ++i) {\n+        auto local_tx = m_recon_state->local_short_id_mapping.find(remote_missing_short_ids[i]);\n+        if (local_tx == m_recon_state->local_short_id_mapping.end()) {\n+            LogPrint(BCLog::NET, \"Unknown transaction requested by short id=%d by peer=%d\\n\", remote_missing_short_ids[i], GetId());\n+        }\n+        remote_missing.push_back(local_tx->second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412384640",
      "id" : 412384640,
      "in_reply_to_id" : 412301986,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM4NDY0MA==",
      "original_commit_id" : "1b695eabc2083384596e146ff3da5846be3058e0",
      "original_line" : 760,
      "original_position" : 127,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 397557979,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-28T01:04:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/412384640",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412389472"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/412389472"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I may be off, but if `local_tx == m_recon_state->local_short_id_mapping.end()`, `local_tx->second` is still accessed after the LogPrint - isn't that illegal? ",
      "commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "created_at" : "2020-04-21T18:23:20Z",
      "diff_hunk" : "@@ -628,6 +628,135 @@ int CNode::GetSendVersion() const\n     return nSendVersion;\n }\n \n+void CNode::FinalizeReconciliation(bool clear_local_set, LocalQAction action, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    // According to the erlay spec, reconciliation is initiated by inbound peers.\n+    if (m_recon_state->sender) {\n+        assert(m_recon_state->incoming_recon != CNode::ReconPhase::NONE);\n+        m_recon_state->incoming_recon = CNode::ReconPhase::NONE;\n+    } else {\n+        // When reconciliation initialized by us is done, update local q for future reconciliations.\n+        if (action == LocalQAction::Q_RECOMPUTE) {\n+            assert(m_recon_state->outgoing_recon != CNode::ReconPhase::NONE);\n+            uint8_t local_set_size;\n+            if (m_recon_state->outgoing_recon == CNode::ReconPhase::BISEC_REQUESTED) {\n+                local_set_size = m_recon_state->local_set_snapshot.size();\n+            } else {\n+                local_set_size = m_recon_state->local_set.size();\n+            }\n+            uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+            uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+            uint8_t min_size = std::min(local_set_size, remote_set_size);\n+            uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+            if (min_size != 0)\n+                m_recon_state->local_q = double(actual_difference - set_size_diff) / min_size;\n+        } else if (action == LocalQAction::Q_INCREASE) {\n+            m_recon_state->local_q *= 1.1;\n+        } else if (action == LocalQAction::Q_SET_DEFAULT) {\n+            m_recon_state->local_q = DEFAULT_RECON_Q;\n+        }\n+        m_recon_state->outgoing_recon = CNode::ReconPhase::NONE;\n+    }\n+    if (clear_local_set) m_recon_state->local_set.clear();\n+\n+    m_recon_state->local_short_id_mapping.clear();\n+    // This is currently belt-and-suspenders, as the code should work even without these calls.\n+    m_recon_state->local_set_snapshot.clear();\n+    m_recon_state->capacity_snapshot = 0;\n+    m_recon_state->remote_sketch_snapshot = nullptr;\n+    m_recon_state->local_sketch_snapshot = nullptr;\n+}\n+\n+uint32_t CNode::ComputeShortID(uint256 wtxid)\n+{\n+    uint64_t k0 = m_recon_state->salt.GetUint64(0);\n+    uint64_t k1 = m_recon_state->salt.GetUint64(1);\n+    uint64_t s = SipHashUint256(k0, k1, wtxid);\n+    uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+    m_recon_state->local_short_id_mapping.insert(std::pair<uint32_t, uint256>(short_txid, wtxid));\n+    return short_txid;\n+}\n+\n+minisketch* CNode::ComputeSketch(bool use_own_q, BisectionChunk bisection_chunk, uint16_t capacity)\n+{\n+    std::vector<uint32_t> short_ids;\n+    if (m_recon_state->incoming_recon == ReconPhase::BISEC_REQUESTED || m_recon_state->outgoing_recon == ReconPhase::BISEC_REQUESTED) {\n+        // During bisection, all the relevant transactions are stored in the snapshot.\n+        // Original set is used to not miss transactions received during the reconciliation elsewhere.\n+        if (m_recon_state->local_set_snapshot.size() == 0) {\n+            return nullptr;\n+        }\n+        for (uint256 wtxid : m_recon_state->local_set_snapshot) {\n+            short_ids.push_back(ComputeShortID(wtxid));\n+        }\n+\n+        std::vector<uint32_t> bisec_short_ids;\n+        for (uint32_t short_id : short_ids) {\n+            if (bisection_chunk == BISECTION_LOW) {\n+                if (short_id <= BISECTION_MEDIAN) {\n+                    bisec_short_ids.push_back(short_id);\n+                }\n+            } else {\n+                if (short_id > BISECTION_MEDIAN) {\n+                    bisec_short_ids.push_back(short_id);\n+                }\n+            }\n+        }\n+        short_ids = bisec_short_ids;\n+        // For bisection, use capacity used in the initial reconciliation.\n+        capacity = m_recon_state->capacity_snapshot;\n+    } else {\n+        for (uint256 wtxid : m_recon_state->local_set) {\n+            short_ids.push_back(ComputeShortID(wtxid));\n+        }\n+\n+        if (capacity == 0) {\n+            // Estimate locally, as requested by the calling function.\n+            int set_size_diff = m_recon_state->local_set.size() - m_recon_state->remote_set_size;\n+            double q = use_own_q ? m_recon_state->local_q : m_recon_state->remote_q;\n+            capacity = 1 + q * fmin(m_recon_state->local_set.size(), m_recon_state->remote_set_size) +\n+                       abs(set_size_diff);\n+        }\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+        // If bisection is required, we will use this capacity from the initial reconciliation.\n+        m_recon_state->capacity_snapshot = capacity;\n+    }\n+    if (short_ids.size() == 0) return nullptr;\n+    minisketch* sketch = minisketch_create(RECON_FIELD_SIZE, 0, capacity);\n+    for (uint32_t short_id : short_ids) {\n+        minisketch_add_uint64(sketch, short_id);\n+    }\n+    return sketch;\n+}\n+\n+std::vector<uint256> CNode::GetRelevantIDsFromShortIDs(uint64_t diff[], uint8_t diff_size, std::vector<uint32_t>& local_missing, CConnman* connman)\n+{\n+    std::vector<uint256> remote_missing;\n+    for (int i = 0; i < diff_size; ++i) {\n+        auto local_tx = m_recon_state->local_short_id_mapping.find(diff[i]);\n+        if (local_tx != m_recon_state->local_short_id_mapping.end()) {\n+            remote_missing.push_back(local_tx->second);\n+        } else {\n+            local_missing.push_back(diff[i]);\n+        }\n+    }\n+    return remote_missing;\n+}\n+\n+std::vector<uint256> CNode::GetWTXIDsFromShortIDs(const std::vector<uint32_t> remote_missing_short_ids, CConnman* connman)\n+{\n+    std::vector<uint256> remote_missing;\n+    for (size_t i = 0; i < remote_missing_short_ids.size(); ++i) {\n+        auto local_tx = m_recon_state->local_short_id_mapping.find(remote_missing_short_ids[i]);\n+        if (local_tx == m_recon_state->local_short_id_mapping.end()) {\n+            LogPrint(BCLog::NET, \"Unknown transaction requested by short id=%d by peer=%d\\n\", remote_missing_short_ids[i], GetId());\n+        }\n+        remote_missing.push_back(local_tx->second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412389472",
      "id" : 412389472,
      "in_reply_to_id" : 412301986,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM4OTQ3Mg==",
      "original_commit_id" : "1b695eabc2083384596e146ff3da5846be3058e0",
      "original_line" : 760,
      "original_position" : 127,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 397563221,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-28T01:04:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/412389472",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412404625"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/412404625"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oh, i see you are definitely right, it's a bug!",
      "commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "created_at" : "2020-04-21T18:46:18Z",
      "diff_hunk" : "@@ -628,6 +628,135 @@ int CNode::GetSendVersion() const\n     return nSendVersion;\n }\n \n+void CNode::FinalizeReconciliation(bool clear_local_set, LocalQAction action, uint8_t actual_local_missing, uint8_t actual_remote_missing)\n+{\n+    // According to the erlay spec, reconciliation is initiated by inbound peers.\n+    if (m_recon_state->sender) {\n+        assert(m_recon_state->incoming_recon != CNode::ReconPhase::NONE);\n+        m_recon_state->incoming_recon = CNode::ReconPhase::NONE;\n+    } else {\n+        // When reconciliation initialized by us is done, update local q for future reconciliations.\n+        if (action == LocalQAction::Q_RECOMPUTE) {\n+            assert(m_recon_state->outgoing_recon != CNode::ReconPhase::NONE);\n+            uint8_t local_set_size;\n+            if (m_recon_state->outgoing_recon == CNode::ReconPhase::BISEC_REQUESTED) {\n+                local_set_size = m_recon_state->local_set_snapshot.size();\n+            } else {\n+                local_set_size = m_recon_state->local_set.size();\n+            }\n+            uint8_t remote_set_size = local_set_size + actual_local_missing - actual_remote_missing;\n+            uint8_t set_size_diff = std::abs(local_set_size - remote_set_size);\n+            uint8_t min_size = std::min(local_set_size, remote_set_size);\n+            uint8_t actual_difference = actual_local_missing + actual_remote_missing;\n+            if (min_size != 0)\n+                m_recon_state->local_q = double(actual_difference - set_size_diff) / min_size;\n+        } else if (action == LocalQAction::Q_INCREASE) {\n+            m_recon_state->local_q *= 1.1;\n+        } else if (action == LocalQAction::Q_SET_DEFAULT) {\n+            m_recon_state->local_q = DEFAULT_RECON_Q;\n+        }\n+        m_recon_state->outgoing_recon = CNode::ReconPhase::NONE;\n+    }\n+    if (clear_local_set) m_recon_state->local_set.clear();\n+\n+    m_recon_state->local_short_id_mapping.clear();\n+    // This is currently belt-and-suspenders, as the code should work even without these calls.\n+    m_recon_state->local_set_snapshot.clear();\n+    m_recon_state->capacity_snapshot = 0;\n+    m_recon_state->remote_sketch_snapshot = nullptr;\n+    m_recon_state->local_sketch_snapshot = nullptr;\n+}\n+\n+uint32_t CNode::ComputeShortID(uint256 wtxid)\n+{\n+    uint64_t k0 = m_recon_state->salt.GetUint64(0);\n+    uint64_t k1 = m_recon_state->salt.GetUint64(1);\n+    uint64_t s = SipHashUint256(k0, k1, wtxid);\n+    uint32_t short_txid = 1 + (s & 0xFFFFFFFF);\n+    m_recon_state->local_short_id_mapping.insert(std::pair<uint32_t, uint256>(short_txid, wtxid));\n+    return short_txid;\n+}\n+\n+minisketch* CNode::ComputeSketch(bool use_own_q, BisectionChunk bisection_chunk, uint16_t capacity)\n+{\n+    std::vector<uint32_t> short_ids;\n+    if (m_recon_state->incoming_recon == ReconPhase::BISEC_REQUESTED || m_recon_state->outgoing_recon == ReconPhase::BISEC_REQUESTED) {\n+        // During bisection, all the relevant transactions are stored in the snapshot.\n+        // Original set is used to not miss transactions received during the reconciliation elsewhere.\n+        if (m_recon_state->local_set_snapshot.size() == 0) {\n+            return nullptr;\n+        }\n+        for (uint256 wtxid : m_recon_state->local_set_snapshot) {\n+            short_ids.push_back(ComputeShortID(wtxid));\n+        }\n+\n+        std::vector<uint32_t> bisec_short_ids;\n+        for (uint32_t short_id : short_ids) {\n+            if (bisection_chunk == BISECTION_LOW) {\n+                if (short_id <= BISECTION_MEDIAN) {\n+                    bisec_short_ids.push_back(short_id);\n+                }\n+            } else {\n+                if (short_id > BISECTION_MEDIAN) {\n+                    bisec_short_ids.push_back(short_id);\n+                }\n+            }\n+        }\n+        short_ids = bisec_short_ids;\n+        // For bisection, use capacity used in the initial reconciliation.\n+        capacity = m_recon_state->capacity_snapshot;\n+    } else {\n+        for (uint256 wtxid : m_recon_state->local_set) {\n+            short_ids.push_back(ComputeShortID(wtxid));\n+        }\n+\n+        if (capacity == 0) {\n+            // Estimate locally, as requested by the calling function.\n+            int set_size_diff = m_recon_state->local_set.size() - m_recon_state->remote_set_size;\n+            double q = use_own_q ? m_recon_state->local_q : m_recon_state->remote_q;\n+            capacity = 1 + q * fmin(m_recon_state->local_set.size(), m_recon_state->remote_set_size) +\n+                       abs(set_size_diff);\n+        }\n+        capacity = std::min(capacity, MAX_SKETCH_CAPACITY);\n+        // If bisection is required, we will use this capacity from the initial reconciliation.\n+        m_recon_state->capacity_snapshot = capacity;\n+    }\n+    if (short_ids.size() == 0) return nullptr;\n+    minisketch* sketch = minisketch_create(RECON_FIELD_SIZE, 0, capacity);\n+    for (uint32_t short_id : short_ids) {\n+        minisketch_add_uint64(sketch, short_id);\n+    }\n+    return sketch;\n+}\n+\n+std::vector<uint256> CNode::GetRelevantIDsFromShortIDs(uint64_t diff[], uint8_t diff_size, std::vector<uint32_t>& local_missing, CConnman* connman)\n+{\n+    std::vector<uint256> remote_missing;\n+    for (int i = 0; i < diff_size; ++i) {\n+        auto local_tx = m_recon_state->local_short_id_mapping.find(diff[i]);\n+        if (local_tx != m_recon_state->local_short_id_mapping.end()) {\n+            remote_missing.push_back(local_tx->second);\n+        } else {\n+            local_missing.push_back(diff[i]);\n+        }\n+    }\n+    return remote_missing;\n+}\n+\n+std::vector<uint256> CNode::GetWTXIDsFromShortIDs(const std::vector<uint32_t> remote_missing_short_ids, CConnman* connman)\n+{\n+    std::vector<uint256> remote_missing;\n+    for (size_t i = 0; i < remote_missing_short_ids.size(); ++i) {\n+        auto local_tx = m_recon_state->local_short_id_mapping.find(remote_missing_short_ids[i]);\n+        if (local_tx == m_recon_state->local_short_id_mapping.end()) {\n+            LogPrint(BCLog::NET, \"Unknown transaction requested by short id=%d by peer=%d\\n\", remote_missing_short_ids[i], GetId());\n+        }\n+        remote_missing.push_back(local_tx->second);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412404625",
      "id" : 412404625,
      "in_reply_to_id" : 412301986,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQwNDYyNQ==",
      "original_commit_id" : "1b695eabc2083384596e146ff3da5846be3058e0",
      "original_line" : 760,
      "original_position" : 127,
      "original_start_line" : null,
      "path" : "src/net.cpp",
      "position" : null,
      "pull_request_review_id" : 397579849,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-28T01:04:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/412404625",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Alright, all the tests should be passing now, also rebased.\r\n\r\nThere's one last test that fails consistently: p2p_segwit.py.\r\nI'll take a look at that, and upgrade the code for recent minisketch (with reconciliation capacity checksum thing) soon.\r\n\r\nOne good idea for the future: test that legacy nodes talk OK alright to erlay nodes (I checked it only manually).\r\n",
      "created_at" : "2020-04-21T20:31:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-617398513",
      "id" : 617398513,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYxNzM5ODUxMw==",
      "updated_at" : "2020-04-21T20:31:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/617398513",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@naumenkogs Please have a look at this: https://github.com/sipa/minisketch/pull/23",
      "created_at" : "2020-04-21T20:40:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-617402629",
      "id" : 617402629,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYxNzQwMjYyOQ==",
      "updated_at" : "2020-04-21T20:40:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/617402629",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412586167"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/412586167"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "One more potential issue: If I understand it correctly, `m_recon_state` is null if our peer does not signal Erlay support. So we should check if `m_recon_state` is non-null before accessing its members here.\r\n\r\nOtherwise an attacker could not signal Erlay but then send Erlay-specific messages to crash our node. Same applies for the other new messages `NetMsgType::SKETCH` etc. below.",
      "commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "created_at" : "2020-04-22T00:39:24Z",
      "diff_hunk" : "@@ -3417,6 +3447,274 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         return true;\n     }\n \n+    std::chrono::microseconds current_time = GetTime<std::chrono::microseconds>();\n+\n+    // Record an (expected) reconciliation request with parameters to respond when time comes.\n+    // All initial reconciliation responses will be done at the same time to prevent tx-related privacy leaks.\n+    if (strCommand == NetMsgType::REQRECON) {\n+        if (!pfrom->m_recon_state->sender) return true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412586167",
      "id" : 412586167,
      "line" : 3492,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NjE2Nw==",
      "original_commit_id" : "0a262c092f6fe29d6964fe6fd1f1d98d08db44dd",
      "original_line" : 3492,
      "original_position" : 69,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 577,
      "pull_request_review_id" : 397767143,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-28T01:04:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/412586167",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/48763452?v=4",
         "events_url" : "https://api.github.com/users/mzumsande/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mzumsande/followers",
         "following_url" : "https://api.github.com/users/mzumsande/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mzumsande/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mzumsande",
         "id" : 48763452,
         "login" : "mzumsande",
         "node_id" : "MDQ6VXNlcjQ4NzYzNDUy",
         "organizations_url" : "https://api.github.com/users/mzumsande/orgs",
         "received_events_url" : "https://api.github.com/users/mzumsande/received_events",
         "repos_url" : "https://api.github.com/users/mzumsande/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mzumsande/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mzumsande/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mzumsande"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412589714"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/412589714"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Definitely an issue, will address!\r\nI had asserts all over, and then was replacing them with returns, but this one requires 2 checks for m_recon_state and for sender :)",
      "commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "created_at" : "2020-04-22T00:50:10Z",
      "diff_hunk" : "@@ -3417,6 +3447,274 @@ bool ProcessMessage(CNode* pfrom, const std::string& msg_type, CDataStream& vRec\n         return true;\n     }\n \n+    std::chrono::microseconds current_time = GetTime<std::chrono::microseconds>();\n+\n+    // Record an (expected) reconciliation request with parameters to respond when time comes.\n+    // All initial reconciliation responses will be done at the same time to prevent tx-related privacy leaks.\n+    if (strCommand == NetMsgType::REQRECON) {\n+        if (!pfrom->m_recon_state->sender) return true;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r412589714",
      "id" : 412589714,
      "in_reply_to_id" : 412586167,
      "line" : 3492,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4OTcxNA==",
      "original_commit_id" : "0a262c092f6fe29d6964fe6fd1f1d98d08db44dd",
      "original_line" : 3492,
      "original_position" : 69,
      "original_start_line" : null,
      "path" : "src/net_processing.cpp",
      "position" : 577,
      "pull_request_review_id" : 397770157,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-28T01:04:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/412589714",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-04-25T13:10:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-619377457",
      "id" : 619377457,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYxOTM3NzQ1Nw==",
      "updated_at" : "2020-04-25T13:10:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/619377457",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).",
      "created_at" : "2020-04-29T08:46:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-621070747",
      "id" : 621070747,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYyMTA3MDc0Nw==",
      "updated_at" : "2020-04-29T08:46:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/621070747",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "This should be in reviewable state now: I split commits more, fixed all the tests, made it more stable, addressed feedback by @mzumsande, updated with new helpers from minisketch.\r\n\r\nTravis failed last time because of the little issue with minisketch release build, but it should work just fine for local testing and experiments!\r\nWill rebase again when #18044 is rebased to not create much discrepancy there.",
      "created_at" : "2020-05-07T14:15:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-625282154",
      "id" : 625282154,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYyNTI4MjE1NA==",
      "updated_at" : "2020-05-07T14:15:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/625282154",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r436293837"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/436293837"
         }
      },
      "author_association" : "NONE",
      "body" : "this could say BIP 330",
      "commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "created_at" : "2020-06-06T19:20:37Z",
      "diff_hunk" : "@@ -362,12 +402,13 @@ const uint32_t MSG_TYPE_MASK    = 0xffffffff >> 2;\n  * These numbers are defined by the protocol. When adding a new value, be sure\n  * to mention it in the respective BIP.\n  */\n-enum GetDataMsg\n+enum GetDataMsg : uint32_t\n {\n     UNDEFINED = 0,\n     MSG_TX = 1,\n     MSG_BLOCK = 2,\n-    // The following can only occur in getdata. Invs always use TX or BLOCK.\n+    MSG_WTX = 5, // Defined in BIP XXX",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r436293837",
      "id" : 436293837,
      "line" : 410,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MzgzNw==",
      "original_commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "original_line" : 410,
      "original_position" : 58,
      "original_start_line" : null,
      "path" : "src/protocol.h",
      "position" : 58,
      "pull_request_review_id" : 425762827,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-06T19:20:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/436293837",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/284023?v=4",
         "events_url" : "https://api.github.com/users/ysangkok/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ysangkok/followers",
         "following_url" : "https://api.github.com/users/ysangkok/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ysangkok/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ysangkok",
         "id" : 284023,
         "login" : "ysangkok",
         "node_id" : "MDQ6VXNlcjI4NDAyMw==",
         "organizations_url" : "https://api.github.com/users/ysangkok/orgs",
         "received_events_url" : "https://api.github.com/users/ysangkok/received_events",
         "repos_url" : "https://api.github.com/users/ysangkok/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ysangkok/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ysangkok/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ysangkok"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r436293867"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/436293867"
         }
      },
      "author_association" : "NONE",
      "body" : "also, could say BIP 330",
      "commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "created_at" : "2020-06-06T19:20:59Z",
      "diff_hunk" : "@@ -234,6 +234,46 @@ extern const char *GETBLOCKTXN;\n  * @since protocol version 70014 as described by BIP 152\n  */\n extern const char *BLOCKTXN;\n+/**\n+ * Indicates that a node prefers to relay transactions via wtxid, rather than\n+ * txid.\n+ * @since protocol version 70016 as described by BIP XXX.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r436293867",
      "id" : 436293867,
      "line" : 240,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Mzg2Nw==",
      "original_commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "original_line" : 240,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "src/protocol.h",
      "position" : 7,
      "pull_request_review_id" : 425762847,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-06T19:20:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/436293867",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/284023?v=4",
         "events_url" : "https://api.github.com/users/ysangkok/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ysangkok/followers",
         "following_url" : "https://api.github.com/users/ysangkok/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ysangkok/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ysangkok",
         "id" : 284023,
         "login" : "ysangkok",
         "node_id" : "MDQ6VXNlcjI4NDAyMw==",
         "organizations_url" : "https://api.github.com/users/ysangkok/orgs",
         "received_events_url" : "https://api.github.com/users/ysangkok/received_events",
         "repos_url" : "https://api.github.com/users/ysangkok/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ysangkok/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ysangkok/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ysangkok"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r436294048"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/436294048"
         }
      },
      "author_association" : "NONE",
      "body" : "wouldn't it be better to have this guarded by an ifdef?",
      "commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "created_at" : "2020-06-06T19:23:41Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include \"../include/minisketch.h\"\n+#include <string.h>\n+#include <memory>\n+#include <vector>\n+#include <algorithm>\n+#include <random>\n+#include <iostream>\n+#include <thread>\n+#include \"util.h\"\n+\n+uint64_t Combination(uint64_t n, uint64_t k) {\n+    if (n - k < k) k = n - k;\n+    uint64_t ret = 1;\n+    for (uint64_t i = 1; i <= k; ++i) {\n+        ret = (ret * n) / i;\n+        --n;\n+    }\n+    return ret;\n+}\n+\n+void TestAll(int bits, int impl, int count, uint32_t threadid, uint32_t threads, std::vector<uint64_t>& ret) {\n+    minisketch* state = minisketch_create(bits, impl, count);\n+    if (!state) return;\n+\n+    // Iterate over all (bits)-bit sketches with (count) syndromes.\n+    for (uint64_t x = threadid; (x >> (bits * count)) == 0; x += threads) {\n+        // Construct the serialization and load it.\n+        unsigned char ser[8];\n+        ser[0] = x;\n+        ser[1] = x >> 8;\n+        ser[2] = x >> 16;\n+        ser[3] = x >> 24;\n+        ser[4] = x >> 32;\n+        ser[5] = x >> 40;\n+        ser[6] = x >> 48;\n+        ser[7] = x >> 56;\n+\n+        minisketch_deserialize(state, ser);\n+\n+        // Compute all the solutions.\n+        uint64_t roots[64];\n+        int num_roots = minisketch_decode(state, 64, roots);\n+\n+        // If there are solutions:\n+        if (num_roots >= 0) {\n+            // Asking for one root less should fail.\n+            CHECK(num_roots < 1 || minisketch_decode(state, num_roots - 1, roots) == -1);\n+            // Reconstruct the sketch from the solutions.\n+            minisketch* state2 = minisketch_create(bits, 0, count);\n+            for (int i = 0; i < num_roots; ++i) {\n+                minisketch_add_uint64(state2, roots[i]);\n+            }\n+            // Serialize it.\n+            unsigned char nser[8] = {0};\n+            minisketch_serialize(state2, nser);\n+            // Compare it to the original.\n+            CHECK(memcmp(ser, nser, 8) == 0);\n+            // Count it.\n+            if (num_roots +1 >= (int)ret.size()) ret.resize(num_roots + 2);\n+            ret[num_roots + 1]++;\n+            minisketch_destroy(state2);\n+        } else {\n+            if (ret.size() == 0) ret.resize(1);\n+            ret[0]++;\n+        }\n+    }\n+    minisketch_destroy(state);\n+}\n+\n+std::vector<uint64_t> TestAll(int bits, int impl, int count, uint32_t threads) {\n+    std::vector<std::vector<uint64_t>> outputs;\n+    std::vector<std::thread> thread_list;\n+    thread_list.reserve(threads);\n+    outputs.resize(threads);\n+    for (uint32_t i = 0; i < threads; ++i) {\n+        thread_list.emplace_back([=,&outputs](){ TestAll(bits, impl, count, i, threads, outputs[i]); });\n+    }\n+    std::vector<uint64_t> ret;\n+    for (uint32_t i = 0; i < threads; ++i) {\n+        thread_list[i].join();\n+        if (ret.size() < outputs[i].size()) ret.resize(outputs[i].size());\n+        for (size_t j = 0; j < outputs[i].size(); ++j) {\n+            ret[j] += outputs[i][j];\n+        }\n+    }\n+    if (ret.size()) {\n+        for (int i = 1; i <= count + 1; ++i) {\n+            CHECK(ret[i] == Combination((uint64_t(1) << bits) - 1, i - 1));\n+        }\n+    }\n+    return ret;\n+}\n+\n+void TestRand(int bits, int impl, int count, int iter) {\n+    std::vector<uint64_t> elems(count);\n+    std::vector<uint64_t> roots(count + 1);\n+    std::random_device rnd;\n+    std::uniform_int_distribution<uint64_t> dist(1, bits == 64 ? -1 : ((uint64_t(1) << bits) - 1));\n+\n+    for (int i = 0; i < iter; ++i) {\n+        bool overfill = iter & 1; // Test some cases with overfull sketches that may not decode.\n+        minisketch* state = minisketch_create(bits, impl, count);\n+        if (!state) return;\n+        minisketch* basestate = minisketch_create(bits, 0, count);\n+        for (int j = 0; j < count + 3*overfill; ++j) {\n+            uint64_t r = dist(rnd);\n+            if (!overfill) elems[j] = r;\n+            minisketch_add_uint64(state, r);\n+            minisketch_add_uint64(basestate, r);\n+        }\n+        roots.assign(count + 1, 0);\n+        std::vector<unsigned char> data, basedata;\n+        basedata.resize(((count + 1) * bits + 7) / 8);\n+        data.resize(((count + 1) * bits + 7) / 8);\n+        minisketch_serialize(basestate, basedata.data());\n+        minisketch_serialize(state, data.data());\n+        CHECK(data == basedata);\n+        minisketch_deserialize(state, basedata.data());\n+        int num_roots = minisketch_decode(state, count + 1, roots.data());\n+        CHECK(overfill || num_roots >= 0);\n+        CHECK(num_roots < 1 || minisketch_decode(state, num_roots - 1, roots.data()) == -1); // Decoding with a too-low maximum should fail.\n+        if (!overfill) {\n+            std::sort(roots.begin(), roots.begin() + num_roots);\n+//            fprintf(stderr, \"Solut: \");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r436294048",
      "id" : 436294048,
      "line" : 130,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NDA0OA==",
      "original_commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "original_line" : 130,
      "original_position" : 130,
      "original_start_line" : null,
      "path" : "src/minisketch/src/test-exhaust.cpp",
      "position" : 130,
      "pull_request_review_id" : 425763015,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-06T19:23:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/436294048",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/284023?v=4",
         "events_url" : "https://api.github.com/users/ysangkok/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ysangkok/followers",
         "following_url" : "https://api.github.com/users/ysangkok/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ysangkok/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ysangkok",
         "id" : 284023,
         "login" : "ysangkok",
         "node_id" : "MDQ6VXNlcjI4NDAyMw==",
         "organizations_url" : "https://api.github.com/users/ysangkok/orgs",
         "received_events_url" : "https://api.github.com/users/ysangkok/received_events",
         "repos_url" : "https://api.github.com/users/ysangkok/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ysangkok/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ysangkok/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ysangkok"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r436297436"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/436297436"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think https://github.com/sipa/minisketch master branch is a better place for these comments :)",
      "commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "created_at" : "2020-06-06T20:14:23Z",
      "diff_hunk" : "@@ -0,0 +1,231 @@\n+/**********************************************************************\n+ * Copyright (c) 2018 Pieter Wuille, Greg Maxwell, Gleb Naumenko      *\n+ * Distributed under the MIT software license, see the accompanying   *\n+ * file LICENSE or http://www.opensource.org/licenses/mit-license.php.*\n+ **********************************************************************/\n+\n+#include \"../include/minisketch.h\"\n+#include <string.h>\n+#include <memory>\n+#include <vector>\n+#include <algorithm>\n+#include <random>\n+#include <iostream>\n+#include <thread>\n+#include \"util.h\"\n+\n+uint64_t Combination(uint64_t n, uint64_t k) {\n+    if (n - k < k) k = n - k;\n+    uint64_t ret = 1;\n+    for (uint64_t i = 1; i <= k; ++i) {\n+        ret = (ret * n) / i;\n+        --n;\n+    }\n+    return ret;\n+}\n+\n+void TestAll(int bits, int impl, int count, uint32_t threadid, uint32_t threads, std::vector<uint64_t>& ret) {\n+    minisketch* state = minisketch_create(bits, impl, count);\n+    if (!state) return;\n+\n+    // Iterate over all (bits)-bit sketches with (count) syndromes.\n+    for (uint64_t x = threadid; (x >> (bits * count)) == 0; x += threads) {\n+        // Construct the serialization and load it.\n+        unsigned char ser[8];\n+        ser[0] = x;\n+        ser[1] = x >> 8;\n+        ser[2] = x >> 16;\n+        ser[3] = x >> 24;\n+        ser[4] = x >> 32;\n+        ser[5] = x >> 40;\n+        ser[6] = x >> 48;\n+        ser[7] = x >> 56;\n+\n+        minisketch_deserialize(state, ser);\n+\n+        // Compute all the solutions.\n+        uint64_t roots[64];\n+        int num_roots = minisketch_decode(state, 64, roots);\n+\n+        // If there are solutions:\n+        if (num_roots >= 0) {\n+            // Asking for one root less should fail.\n+            CHECK(num_roots < 1 || minisketch_decode(state, num_roots - 1, roots) == -1);\n+            // Reconstruct the sketch from the solutions.\n+            minisketch* state2 = minisketch_create(bits, 0, count);\n+            for (int i = 0; i < num_roots; ++i) {\n+                minisketch_add_uint64(state2, roots[i]);\n+            }\n+            // Serialize it.\n+            unsigned char nser[8] = {0};\n+            minisketch_serialize(state2, nser);\n+            // Compare it to the original.\n+            CHECK(memcmp(ser, nser, 8) == 0);\n+            // Count it.\n+            if (num_roots +1 >= (int)ret.size()) ret.resize(num_roots + 2);\n+            ret[num_roots + 1]++;\n+            minisketch_destroy(state2);\n+        } else {\n+            if (ret.size() == 0) ret.resize(1);\n+            ret[0]++;\n+        }\n+    }\n+    minisketch_destroy(state);\n+}\n+\n+std::vector<uint64_t> TestAll(int bits, int impl, int count, uint32_t threads) {\n+    std::vector<std::vector<uint64_t>> outputs;\n+    std::vector<std::thread> thread_list;\n+    thread_list.reserve(threads);\n+    outputs.resize(threads);\n+    for (uint32_t i = 0; i < threads; ++i) {\n+        thread_list.emplace_back([=,&outputs](){ TestAll(bits, impl, count, i, threads, outputs[i]); });\n+    }\n+    std::vector<uint64_t> ret;\n+    for (uint32_t i = 0; i < threads; ++i) {\n+        thread_list[i].join();\n+        if (ret.size() < outputs[i].size()) ret.resize(outputs[i].size());\n+        for (size_t j = 0; j < outputs[i].size(); ++j) {\n+            ret[j] += outputs[i][j];\n+        }\n+    }\n+    if (ret.size()) {\n+        for (int i = 1; i <= count + 1; ++i) {\n+            CHECK(ret[i] == Combination((uint64_t(1) << bits) - 1, i - 1));\n+        }\n+    }\n+    return ret;\n+}\n+\n+void TestRand(int bits, int impl, int count, int iter) {\n+    std::vector<uint64_t> elems(count);\n+    std::vector<uint64_t> roots(count + 1);\n+    std::random_device rnd;\n+    std::uniform_int_distribution<uint64_t> dist(1, bits == 64 ? -1 : ((uint64_t(1) << bits) - 1));\n+\n+    for (int i = 0; i < iter; ++i) {\n+        bool overfill = iter & 1; // Test some cases with overfull sketches that may not decode.\n+        minisketch* state = minisketch_create(bits, impl, count);\n+        if (!state) return;\n+        minisketch* basestate = minisketch_create(bits, 0, count);\n+        for (int j = 0; j < count + 3*overfill; ++j) {\n+            uint64_t r = dist(rnd);\n+            if (!overfill) elems[j] = r;\n+            minisketch_add_uint64(state, r);\n+            minisketch_add_uint64(basestate, r);\n+        }\n+        roots.assign(count + 1, 0);\n+        std::vector<unsigned char> data, basedata;\n+        basedata.resize(((count + 1) * bits + 7) / 8);\n+        data.resize(((count + 1) * bits + 7) / 8);\n+        minisketch_serialize(basestate, basedata.data());\n+        minisketch_serialize(state, data.data());\n+        CHECK(data == basedata);\n+        minisketch_deserialize(state, basedata.data());\n+        int num_roots = minisketch_decode(state, count + 1, roots.data());\n+        CHECK(overfill || num_roots >= 0);\n+        CHECK(num_roots < 1 || minisketch_decode(state, num_roots - 1, roots.data()) == -1); // Decoding with a too-low maximum should fail.\n+        if (!overfill) {\n+            std::sort(roots.begin(), roots.begin() + num_roots);\n+//            fprintf(stderr, \"Solut: \");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#discussion_r436297436",
      "id" : 436297436,
      "in_reply_to_id" : 436294048,
      "line" : 130,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5NzQzNg==",
      "original_commit_id" : "5f81325bf1d2a32f6dcfb9a9b8c5106af6289b9f",
      "original_line" : 130,
      "original_position" : 130,
      "original_start_line" : null,
      "path" : "src/minisketch/src/test-exhaust.cpp",
      "position" : 130,
      "pull_request_review_id" : 425765935,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18261",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-06-06T20:14:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/436297436",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased on #18044, but we will probably get #19184 before Erlay first, so please review that first.\r\nAlthough this PR is in a reviewable state right now!\r\n\r\nThis PR currently doesn't pass travis tests because of the minisketch build issue after the recent patch. Should work locally and shouldn't stop people from reviewing this work :)",
      "created_at" : "2020-07-28T07:35:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-664831828",
      "id" : 664831828,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NDgzMTgyOA==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-28T07:36:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/664831828",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-07-30T14:30:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-666400842",
      "id" : 666400842,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY2NjQwMDg0Mg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-07-30T14:30:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/666400842",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-09-02T12:19:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-685695376",
      "id" : 685695376,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY4NTY5NTM3Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-02T12:19:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/685695376",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "It seems like the tests are failing and that a rebase is needed.\r\n\r\nI'm super excited about Erlay! :) What is the plan ahead?",
      "created_at" : "2020-10-02T09:08:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-702616037",
      "id" : 702616037,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwMjYxNjAzNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-02T09:08:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/702616037",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@practicalswift we kinda agreed that #19988 is a prerequisite, I hope Erlay becomes a priority right after :)",
      "created_at" : "2020-10-02T11:26:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-702679529",
      "id" : 702679529,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcwMjY3OTUyOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-10-02T11:26:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/702679529",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased, added a bunch of comments and restructured commits for better review.\r\n\r\nMarking it as reviewable now, although my fight with Travis builds is not over yet :)",
      "created_at" : "2020-11-17T13:34:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-728930036",
      "id" : 728930036,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDcyODkzMDAzNg==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-11-17T13:34:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/728930036",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2020-11-19T12:21:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18261#issuecomment-730339345",
      "id" : 730339345,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18261",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDczMDMzOTM0NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-11-19T12:21:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/730339345",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   }
]
