[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK\r\n\r\nThe numbers look very promising!\r\n\r\nSeems like this could be one of those rare optimization opportunities actually worth pursuing :)",
      "created_at" : "2021-08-15T18:46:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899094330",
      "id" : 899094330,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841lxc6",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-15T18:46:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899094330",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r689129302"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129302"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "last in first out?",
      "commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "created_at" : "2021-08-15T18:56:43Z",
      "diff_hunk" : "@@ -0,0 +1,356 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a freelist for further use.This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory, the freelist is stored inplace. This typically safes\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a freelist and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The freelist is a simple first-in-last-out linked list, it doesn't reorder elements. So freeing and malloc'ing again",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r689129302",
      "id" : 689129302,
      "line" : 34,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4OTEyOTMwMg==",
      "original_commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "original_line" : 34,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 34,
      "pull_request_review_id" : 730212106,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-15T18:56:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129302",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r689129360"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129360"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "gie -> give",
      "commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "created_at" : "2021-08-15T18:57:28Z",
      "diff_hunk" : "@@ -0,0 +1,356 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a freelist for further use.This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory, the freelist is stored inplace. This typically safes\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a freelist and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The freelist is a simple first-in-last-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as it's chunk size. Note that due to this heuristic we cannot implement an\n+ * `std::pmr::memory_resource` because it does not gie the information about the number of elements.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r689129360",
      "id" : 689129360,
      "line" : 46,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4OTEyOTM2MA==",
      "original_commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "original_line" : 46,
      "original_position" : 46,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 46,
      "pull_request_review_id" : 730212152,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-15T18:57:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129360",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm curious what the impact would be on the performance if you allocated N chunks at a time, always, to fill a page.\r\n\r\nE.g., if you want to allocate one node, always allocate something like `aligned_alloc(sysconf(_SC_PAGESIZE), size)` and divide it up into a bunch of pointers for the free list.\r\n\r\nCool properties of doing so: Better cache alignment on items added around the same time, fewer things to keep in the allocated chunks list, if you were to sort the list by pointer (perhaps lazily, when we're not doing anything else) you would get something with good cache alignment again. ",
      "created_at" : "2021-08-15T19:11:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899097140",
      "id" : 899097140,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841lyI0",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-15T19:11:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899097140",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I'm curious what the impact would be on the performance if you allocated N chunks at a time, always, to fill a page.\r\n\r\nI've run the benchmark with `::aligned_alloc(sysconf(_SC_PAGESIZE), ...);` and only allocating a single page, and at least in the benchmark there's no difference:\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|              140.95 |        7,094,953.03 |    0.2% |      0.08 | `NodeAllocator_StdUnorderedMap`\r\n|              115.57 |        8,652,942.75 |    0.1% |      0.06 | `NodeAllocator_StdUnorderedMapWithNodeAllocator` ::operator new\r\n|              115.33 |        8,670,873.08 |    0.2% |      0.06 | `NodeAllocator_StdUnorderedMapWithNodeAllocator`aligned_alloc",
      "created_at" : "2021-08-16T05:52:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899241874",
      "id" : 899241874,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841mVeS",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T05:52:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899241874",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Do you have specific code for that? The changes sounded a bit more complex than just aligning the allocator. Did you divide the allocation into N free list chunks? Or just over-allocate?",
      "created_at" : "2021-08-16T09:19:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899359234",
      "id" : 899359234,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841myIC",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T09:19:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899359234",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Do you have specific code for that? The changes sounded a bit more complex than just aligning the allocator. Did you divide the allocation into N free list chunks? Or just over-allocate?\r\n\r\n`MemoryResource::AllocateNewBlock` is the only place where I actually malloc a new block that's divided into the chunks. Here I've replaced the `::operator new(num_chunks* m_chunk_size_bytes)` with `::alligned_alloc(sysconf(_SC_PAGESIZE), num_chunks* m_chunk_size_bytes)`. And use `free` in `~MemoryResource`.\r\nI also changed the default allocation size `m_block_size_bytes` from 262144 to `sysconf(_SC_PAGESIZE)`. \r\n\r\nSo for node size of 104 bytes and page size 4096, this should allocate a page-alligned block with 39*104=4056 bytes.",
      "created_at" : "2021-08-16T10:03:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899385299",
      "id" : 899385299,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841m4fT",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T10:03:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899385299",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Some fresh benches in (high dbcache). Continuing to see fairly substantial time/memory improvements with this change.\r\n\r\n![ibd local range 500000 540000](https://user-images.githubusercontent.com/73197/129577300-d73f42aa-8598-4418-9375-2a7c4521701a.png)\r\n\r\n#### commands index\r\n|          bench name           |                                                                                                     command                                                                                                      |\r\n|-------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| ibd.local.range.500000.540000 | `bitcoind -dbcache=10000 -debug=coindb -debug=bench -listen=0 -connect=0 -addnode=127.0.0.1:8888 -prune=9999999 -printtoconsole=0 -assumevalid=000000000000000000176c192f42ad13ab159fdb20198b87e7ba3c001e47b876` |\r\n\r\n\r\n#### #22702 vs. $mergebase (absolute)\r\n|                  bench name                   |  x  |           #22702           |        $mergebase         |\r\n|-----------------------------------------------|----:|----------------------------|---------------------------|\r\n| ibd.local.range.500000.540000.total_secs      |   3 | 2888.4055 (Â± 24.7775)      | 3131.5871 (Â± 4.8045)      |\r\n| ibd.local.range.500000.540000.peak_rss_KiB    |   3 | 5886729.3333 (Â± 3815.6315) | 6352470.6667 (Â± 979.1552) |\r\n| ibd.local.range.500000.540000.cpu_kernel_secs |   3 | 263.5433 (Â± 1.9605)        | 269.2233 (Â± 2.6299)       |\r\n| ibd.local.range.500000.540000.cpu_user_secs   |   3 | 12852.1300 (Â± 15.0661)     | 13134.5300 (Â± 2.9587)     |\r\n\r\n\r\n#### #22702 vs. $mergebase (relative)\r\n|                  bench name                   |  x  | #22702 | $mergebase |\r\n|-----------------------------------------------|----:|-------:|-----------:|\r\n| ibd.local.range.500000.540000.total_secs      |   3 |      1 |      1.084 |\r\n| ibd.local.range.500000.540000.peak_rss_KiB    |   3 |      1 |      1.079 |\r\n| ibd.local.range.500000.540000.cpu_kernel_secs |   3 |      1 |      1.022 |\r\n| ibd.local.range.500000.540000.cpu_user_secs   |   3 |      1 |      1.022 |\r\n\r\n",
      "created_at" : "2021-08-16T14:13:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899545273",
      "id" : 899545273,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841nfi5",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T14:13:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899545273",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for the benchmark! Good to see its 8.4% faster. I think the only reason the memory is lower is because the `memusage::DynamicUsage` now overestimates the memory requirements of the `std::unordered_map` that uses the node_allocator. I guess I should correct that. Then the memory usage should stay roughly the same (as it should, that's what `-dbcache` is for), but the number of transactions that can be cached will increase.",
      "created_at" : "2021-08-16T17:46:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899698242",
      "id" : 899698242,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841oE5C",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T17:46:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899698242",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> `MemoryResource::AllocateNewBlock` is the only place where I actually malloc a new block that's divided into the chunks. Here I've replaced the `::operator new(num_chunks* m_chunk_size_bytes)` with `::alligned_alloc(sysconf(_SC_PAGESIZE), num_chunks* m_chunk_size_bytes)`. And use `free` in `~MemoryResource`.\r\n> I also changed the default allocation size `m_block_size_bytes` from 262144 to `sysconf(_SC_PAGESIZE)`.\r\n\r\nhmm yeah it's interesting to think through the alignment issues. I think I understand the code a bit better now so it makes sense that most of you allocations are already aligned. One thing that strikes me is that it seems that you have these 104 byte chunks (13 uint64_t s). You might get better properties if you pad them out to the nearest 32/64/128 bytes (memory overhead 24 bytes :( ), because then you'll never have nodes across cache lines. Memory usage is a bit worse though, but cache perfomance may be better this way? https://www.usenix.org/legacy/publications/library/proceedings/als00/2000papers/papers/full_papers/sears/sears_html/index.html for reference.\r\n\r\n",
      "created_at" : "2021-08-16T19:22:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899759585",
      "id" : 899759585,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841oT3h",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T19:22:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899759585",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "might also be interesting to bump the CScript prevector size from 28 to 35 (7 bytes). This would help with the above as well because if we're 104/128 byte aligned we have the capacity & then we'd also save a prevector allocation (which means the vector costs 25 bytes + 34-35 bytes) for a non p2sh segwit v0-v1 output, and also means even more indirection.\r\n\r\nThis might have system impacts very broadly because prevector is a leaky optimization sadly.",
      "created_at" : "2021-08-16T19:29:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899763888",
      "id" : 899763888,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841oU6w",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T19:29:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899763888",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r690258262"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690258262"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Tested that `IsMultiple()` can be removed (Debian Clang 13)\r\n\r\n```\r\ntest/node_allocator_tests.cpp:245:16: warning: unused function 'isMultiple' [-Wunused-function]\r\nconstexpr bool isMultiple(size_t a, size_t b)\r\n               ^\r\n1 warning generated.\r\n```\r\n",
      "commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "created_at" : "2021-08-17T10:55:25Z",
      "diff_hunk" : "@@ -0,0 +1,313 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <unordered_map>\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, chunk_size, num_free_chunks, num_blocks) \\\n+    BOOST_CHECK_EQUAL(chunk_size, mr.ChunkSize());                         \\\n+    BOOST_CHECK_EQUAL(num_free_chunks, mr.NumFreeChunks());                \\\n+    BOOST_CHECK_EQUAL(num_blocks, mr.NumBlocks());\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource mr;\n+    void* ptr = mr.Allocate<char>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, node_allocator::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    node_allocator::MemoryResource mr;\n+    Map m(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr});\n+    size_t num_free_chunks = 0;\n+    {\n+        Map a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr});\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_chunks = mr.NumFreeChunks();\n+\n+        // create a copy of the map, destroy the map => now a lot more free chunks should be available\n+        {\n+            Map b = a;\n+        }\n+\n+        BOOST_CHECK(mr.NumFreeChunks() > num_free_chunks);\n+        num_free_chunks = mr.NumFreeChunks();\n+\n+        // creating another copy, and then destroying everything should reuse all the chunks\n+        {\n+            Map b = a;\n+        }\n+        BOOST_CHECK_EQUAL(mr.NumFreeChunks(), num_free_chunks);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(mr.NumFreeChunks(), num_free_chunks);\n+    }\n+    // a is destroyed, still all chunks should stay roughly the same.\n+    BOOST_CHECK(mr.NumFreeChunks() <= num_free_chunks + 5);\n+\n+    m = Map(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr});\n+\n+    // now we got everything free\n+    BOOST_CHECK(mr.NumFreeChunks() > num_free_chunks + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, node_allocator::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    node_allocator::MemoryResource mr_a;\n+    node_allocator::MemoryResource mr_b;\n+\n+    {\n+        Map map_a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_a});\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            Map map_b(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_b});\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(mr_b.NumFreeChunks(), 0);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+        BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+        // but we'll get more free chunks in mr_a\n+        CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free chunks.\n+    CHECK_IN_RANGE(mr_a.NumFreeChunks(), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, node_allocator::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    node_allocator::MemoryResource mr_a;\n+    node_allocator::MemoryResource mr_b;\n+\n+    {\n+        Map map_a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_a});\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            Map map_b(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_b});\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b.\n+        CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+        BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+        // but we'll get more free chunks in mr_a\n+        CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, but since it was moved, no more free chunks.\n+    CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 102U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_swap)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, node_allocator::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    node_allocator::MemoryResource mr_a;\n+    node_allocator::MemoryResource mr_b;\n+\n+    {\n+        Map map_a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_a});\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            Map map_b(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_b});\n+            map_b[123] = 321;\n+\n+            auto alloc_a = map_a.get_allocator();\n+            auto alloc_b = map_b.get_allocator();\n+\n+            std::swap(map_a, map_b);\n+\n+            // maps have swapped, so their allocator have swapped too. No additional allocations have occored!\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK(alloc_a == map_b.get_allocator());\n+            BOOST_CHECK(alloc_b == map_a.get_allocator());\n+        }\n+\n+        // map_b destroyed, so mr_a must have plenty of free chunks now\n+        CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+\n+        // nothing happened to map_a, so mr_b still has no free chunks\n+        BOOST_CHECK_EQUAL(mr_b.NumFreeChunks(), 0);\n+    }\n+\n+    // finally map_a is destroyed, so we got an entry back for mr_b.\n+    CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+    CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+}\n+\n+// some structs that with defined alignment and customizeable size\n+\n+namespace {\n+\n+template <size_t S>\n+struct alignas(1) A1 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(2) A2 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(4) A4 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(8) A8 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(16) A16 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(32) A32 {\n+    char data[S];\n+};\n+\n+constexpr bool isMultiple(size_t a, size_t b)\n+{\n+    return (a / b) * b == a;\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r690258262",
      "id" : 690258262,
      "line" : 248,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MDI1ODI2Mg==",
      "original_commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "original_line" : 248,
      "original_position" : 248,
      "original_start_line" : null,
      "path" : "src/test/node_allocator_tests.cpp",
      "position" : 248,
      "pull_request_review_id" : 731616678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-17T11:27:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690258262",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r690263859"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690263859"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Perhaps rule of 5 (https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-five, https://www.stroustrup.com/C++11FAQ.html#default)\r\n```diff \r\n     /**\r\n-     * Copying a memory resource is not allowed, it is an immobile object.\r\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\r\n      */\r\n     MemoryResource(const MemoryResource&) = delete;\r\n     MemoryResource& operator=(const MemoryResource&) = delete;\r\n+    MemoryResource(MemoryResource&&) = delete;\r\n+    MemoryResource& operator=(MemoryResource&&) = delete;\r\n```",
      "commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "created_at" : "2021-08-17T11:04:06Z",
      "diff_hunk" : "@@ -0,0 +1,356 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a freelist for further use.This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory, the freelist is stored inplace. This typically safes\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a freelist and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The freelist is a simple first-in-last-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as it's chunk size. Note that due to this heuristic we cannot implement an\n+ * `std::pmr::memory_resource` because it does not gie the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a freelist.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * Inplace linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object and uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying a memory resource is not allowed, it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r690263859",
      "id" : 690263859,
      "line" : 91,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MDI2Mzg1OQ==",
      "original_commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "original_line" : 91,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 91,
      "pull_request_review_id" : 731616678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-17T11:27:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690263859",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I've benchmarked the performance of `CChainState::ConnectBlock` between cde8a991f525b72d3a7ac76e0c83aaa611169f22 (PR) and the mergebase 803ef70fd9f65ef800567ff9456fac525bc3e3c2 (MB) using the [`validation::connect_block`](https://github.com/bitcoin/bitcoin/blob/master/doc/tracing.md#tracepoint-validationblock_connected) tracepoint. The tracepoint reports the time it took to connect each block. This means my results don't include the time it took to download and, AFAIK, not the time it took to persist the block to disk. I didn't look at memory usage. \r\n\r\nI've oriented myself on @jamesob's parameters and synced the blocks 500.000 to 540.000 from a localhost peer three times for the PR and the MB. I used the default dbcache (shouldn't matter for my measurements as cache flushes don't happen while inside `CChainState::ConnectBlock`). I've used an idle workstation with an i5 6500 and an NVME drive. Room and hardware temperature between runs changed which could have impacted performance. A `bpftrace` script to hook into the tracepoint can be found [here](https://gist.github.com/0xB10C/7f9010d44f1d97fbf1c83ec7f98155fd).\r\n\r\nTotal time spent in  `CChainState::ConnectBlock` per run for PR and MB: \r\n| run | 1         | 2     | 3     | \r\n|-----|-----------|-------|-------|\r\n| PR  | **1427s** | 1487s | 1486s | \r\n| MB  | **1577s** | 1670s | 1661s |\r\n\r\n![image](https://user-images.githubusercontent.com/19157360/129805353-5b48c0c1-1184-49c2-800c-196f1eed89c8.png)\r\n(PR run 2 and run 3 are overlapping quite a bit and indistinguishably here)\r\n\r\nMy results confirm that less time is spent in `CChainState::ConnectBlock` with PR compared to MB. A performance improvement between 6% - 10% is likely. \r\n\r\n\r\nTo rule out temperature effects on performance, these measurements could be redone with a properly cooled server/workstation.",
      "created_at" : "2021-08-17T22:04:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-900662089",
      "id" : 900662089,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841rwNJ",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-17T22:14:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/900662089",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19157360?v=4",
         "events_url" : "https://api.github.com/users/0xB10C/events{/privacy}",
         "followers_url" : "https://api.github.com/users/0xB10C/followers",
         "following_url" : "https://api.github.com/users/0xB10C/following{/other_user}",
         "gists_url" : "https://api.github.com/users/0xB10C/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/0xB10C",
         "id" : 19157360,
         "login" : "0xB10C",
         "node_id" : "MDQ6VXNlcjE5MTU3MzYw",
         "organizations_url" : "https://api.github.com/users/0xB10C/orgs",
         "received_events_url" : "https://api.github.com/users/0xB10C/received_events",
         "repos_url" : "https://api.github.com/users/0xB10C/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/0xB10C/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/0xB10C/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/0xB10C"
      }
   }
]
