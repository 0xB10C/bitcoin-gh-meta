[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK\r\n\r\nThe numbers look very promising!\r\n\r\nSeems like this could be one of those rare optimization opportunities actually worth pursuing :)",
      "created_at" : "2021-08-15T18:46:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899094330",
      "id" : 899094330,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841lxc6",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-15T18:46:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899094330",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r689129302"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129302"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "last in first out?",
      "commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "created_at" : "2021-08-15T18:56:43Z",
      "diff_hunk" : "@@ -0,0 +1,356 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a freelist for further use.This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory, the freelist is stored inplace. This typically safes\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a freelist and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The freelist is a simple first-in-last-out linked list, it doesn't reorder elements. So freeing and malloc'ing again",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r689129302",
      "id" : 689129302,
      "line" : 34,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4OTEyOTMwMg==",
      "original_commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "original_line" : 34,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 34,
      "pull_request_review_id" : 730212106,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-15T18:56:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129302",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r689129360"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129360"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "gie -> give",
      "commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "created_at" : "2021-08-15T18:57:28Z",
      "diff_hunk" : "@@ -0,0 +1,356 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a freelist for further use.This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory, the freelist is stored inplace. This typically safes\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a freelist and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The freelist is a simple first-in-last-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as it's chunk size. Note that due to this heuristic we cannot implement an\n+ * `std::pmr::memory_resource` because it does not gie the information about the number of elements.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r689129360",
      "id" : 689129360,
      "line" : 46,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4OTEyOTM2MA==",
      "original_commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "original_line" : 46,
      "original_position" : 46,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 46,
      "pull_request_review_id" : 730212152,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-15T18:57:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129360",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm curious what the impact would be on the performance if you allocated N chunks at a time, always, to fill a page.\r\n\r\nE.g., if you want to allocate one node, always allocate something like `aligned_alloc(sysconf(_SC_PAGESIZE), size)` and divide it up into a bunch of pointers for the free list.\r\n\r\nCool properties of doing so: Better cache alignment on items added around the same time, fewer things to keep in the allocated chunks list, if you were to sort the list by pointer (perhaps lazily, when we're not doing anything else) you would get something with good cache alignment again. ",
      "created_at" : "2021-08-15T19:11:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899097140",
      "id" : 899097140,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841lyI0",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-15T19:11:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899097140",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I'm curious what the impact would be on the performance if you allocated N chunks at a time, always, to fill a page.\r\n\r\nI've run the benchmark with `::aligned_alloc(sysconf(_SC_PAGESIZE), ...);` and only allocating a single page, and at least in the benchmark there's no difference:\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|              140.95 |        7,094,953.03 |    0.2% |      0.08 | `NodeAllocator_StdUnorderedMap`\r\n|              115.57 |        8,652,942.75 |    0.1% |      0.06 | `NodeAllocator_StdUnorderedMapWithNodeAllocator` ::operator new\r\n|              115.33 |        8,670,873.08 |    0.2% |      0.06 | `NodeAllocator_StdUnorderedMapWithNodeAllocator`aligned_alloc",
      "created_at" : "2021-08-16T05:52:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899241874",
      "id" : 899241874,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841mVeS",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T05:52:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899241874",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Do you have specific code for that? The changes sounded a bit more complex than just aligning the allocator. Did you divide the allocation into N free list chunks? Or just over-allocate?",
      "created_at" : "2021-08-16T09:19:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899359234",
      "id" : 899359234,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841myIC",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T09:19:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899359234",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Do you have specific code for that? The changes sounded a bit more complex than just aligning the allocator. Did you divide the allocation into N free list chunks? Or just over-allocate?\r\n\r\n`MemoryResource::AllocateNewBlock` is the only place where I actually malloc a new block that's divided into the chunks. Here I've replaced the `::operator new(num_chunks* m_chunk_size_bytes)` with `::alligned_alloc(sysconf(_SC_PAGESIZE), num_chunks* m_chunk_size_bytes)`. And use `free` in `~MemoryResource`.\r\nI also changed the default allocation size `m_block_size_bytes` from 262144 to `sysconf(_SC_PAGESIZE)`. \r\n\r\nSo for node size of 104 bytes and page size 4096, this should allocate a page-alligned block with 39*104=4056 bytes.",
      "created_at" : "2021-08-16T10:03:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899385299",
      "id" : 899385299,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841m4fT",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T10:03:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899385299",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Some fresh benches in (high dbcache). Continuing to see fairly substantial time/memory improvements with this change.\r\n\r\n![ibd local range 500000 540000](https://user-images.githubusercontent.com/73197/129577300-d73f42aa-8598-4418-9375-2a7c4521701a.png)\r\n\r\n#### commands index\r\n|          bench name           |                                                                                                     command                                                                                                      |\r\n|-------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| ibd.local.range.500000.540000 | `bitcoind -dbcache=10000 -debug=coindb -debug=bench -listen=0 -connect=0 -addnode=127.0.0.1:8888 -prune=9999999 -printtoconsole=0 -assumevalid=000000000000000000176c192f42ad13ab159fdb20198b87e7ba3c001e47b876` |\r\n\r\n\r\n#### #22702 vs. $mergebase (absolute)\r\n|                  bench name                   |  x  |           #22702           |        $mergebase         |\r\n|-----------------------------------------------|----:|----------------------------|---------------------------|\r\n| ibd.local.range.500000.540000.total_secs      |   3 | 2888.4055 (Â± 24.7775)      | 3131.5871 (Â± 4.8045)      |\r\n| ibd.local.range.500000.540000.peak_rss_KiB    |   3 | 5886729.3333 (Â± 3815.6315) | 6352470.6667 (Â± 979.1552) |\r\n| ibd.local.range.500000.540000.cpu_kernel_secs |   3 | 263.5433 (Â± 1.9605)        | 269.2233 (Â± 2.6299)       |\r\n| ibd.local.range.500000.540000.cpu_user_secs   |   3 | 12852.1300 (Â± 15.0661)     | 13134.5300 (Â± 2.9587)     |\r\n\r\n\r\n#### #22702 vs. $mergebase (relative)\r\n|                  bench name                   |  x  | #22702 | $mergebase |\r\n|-----------------------------------------------|----:|-------:|-----------:|\r\n| ibd.local.range.500000.540000.total_secs      |   3 |      1 |      1.084 |\r\n| ibd.local.range.500000.540000.peak_rss_KiB    |   3 |      1 |      1.079 |\r\n| ibd.local.range.500000.540000.cpu_kernel_secs |   3 |      1 |      1.022 |\r\n| ibd.local.range.500000.540000.cpu_user_secs   |   3 |      1 |      1.022 |\r\n\r\n",
      "created_at" : "2021-08-16T14:13:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899545273",
      "id" : 899545273,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841nfi5",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T14:13:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899545273",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for the benchmark! Good to see its 8.4% faster. I think the only reason the memory is lower is because the `memusage::DynamicUsage` now overestimates the memory requirements of the `std::unordered_map` that uses the node_allocator. I guess I should correct that. Then the memory usage should stay roughly the same (as it should, that's what `-dbcache` is for), but the number of transactions that can be cached will increase.",
      "created_at" : "2021-08-16T17:46:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899698242",
      "id" : 899698242,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841oE5C",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T17:46:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899698242",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> `MemoryResource::AllocateNewBlock` is the only place where I actually malloc a new block that's divided into the chunks. Here I've replaced the `::operator new(num_chunks* m_chunk_size_bytes)` with `::alligned_alloc(sysconf(_SC_PAGESIZE), num_chunks* m_chunk_size_bytes)`. And use `free` in `~MemoryResource`.\r\n> I also changed the default allocation size `m_block_size_bytes` from 262144 to `sysconf(_SC_PAGESIZE)`.\r\n\r\nhmm yeah it's interesting to think through the alignment issues. I think I understand the code a bit better now so it makes sense that most of you allocations are already aligned. One thing that strikes me is that it seems that you have these 104 byte chunks (13 uint64_t s). You might get better properties if you pad them out to the nearest 32/64/128 bytes (memory overhead 24 bytes :( ), because then you'll never have nodes across cache lines. Memory usage is a bit worse though, but cache perfomance may be better this way? https://www.usenix.org/legacy/publications/library/proceedings/als00/2000papers/papers/full_papers/sears/sears_html/index.html for reference.\r\n\r\n",
      "created_at" : "2021-08-16T19:22:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899759585",
      "id" : 899759585,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841oT3h",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T19:22:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899759585",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "might also be interesting to bump the CScript prevector size from 28 to 35 (7 bytes). This would help with the above as well because if we're 104/128 byte aligned we have the capacity & then we'd also save a prevector allocation (which means the vector costs 25 bytes + 34-35 bytes) for a non p2sh segwit v0-v1 output, and also means even more indirection.\r\n\r\nThis might have system impacts very broadly because prevector is a leaky optimization sadly.",
      "created_at" : "2021-08-16T19:29:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899763888",
      "id" : 899763888,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841oU6w",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T19:29:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899763888",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r690258262"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690258262"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Tested that `IsMultiple()` can be removed (Debian Clang 13)\r\n\r\n```\r\ntest/node_allocator_tests.cpp:245:16: warning: unused function 'isMultiple' [-Wunused-function]\r\nconstexpr bool isMultiple(size_t a, size_t b)\r\n               ^\r\n1 warning generated.\r\n```\r\n",
      "commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "created_at" : "2021-08-17T10:55:25Z",
      "diff_hunk" : "@@ -0,0 +1,313 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <unordered_map>\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, chunk_size, num_free_chunks, num_blocks) \\\n+    BOOST_CHECK_EQUAL(chunk_size, mr.ChunkSize());                         \\\n+    BOOST_CHECK_EQUAL(num_free_chunks, mr.NumFreeChunks());                \\\n+    BOOST_CHECK_EQUAL(num_blocks, mr.NumBlocks());\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource mr;\n+    void* ptr = mr.Allocate<char>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, node_allocator::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    node_allocator::MemoryResource mr;\n+    Map m(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr});\n+    size_t num_free_chunks = 0;\n+    {\n+        Map a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr});\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_chunks = mr.NumFreeChunks();\n+\n+        // create a copy of the map, destroy the map => now a lot more free chunks should be available\n+        {\n+            Map b = a;\n+        }\n+\n+        BOOST_CHECK(mr.NumFreeChunks() > num_free_chunks);\n+        num_free_chunks = mr.NumFreeChunks();\n+\n+        // creating another copy, and then destroying everything should reuse all the chunks\n+        {\n+            Map b = a;\n+        }\n+        BOOST_CHECK_EQUAL(mr.NumFreeChunks(), num_free_chunks);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(mr.NumFreeChunks(), num_free_chunks);\n+    }\n+    // a is destroyed, still all chunks should stay roughly the same.\n+    BOOST_CHECK(mr.NumFreeChunks() <= num_free_chunks + 5);\n+\n+    m = Map(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr});\n+\n+    // now we got everything free\n+    BOOST_CHECK(mr.NumFreeChunks() > num_free_chunks + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, node_allocator::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    node_allocator::MemoryResource mr_a;\n+    node_allocator::MemoryResource mr_b;\n+\n+    {\n+        Map map_a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_a});\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            Map map_b(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_b});\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(mr_b.NumFreeChunks(), 0);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+        BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+        // but we'll get more free chunks in mr_a\n+        CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free chunks.\n+    CHECK_IN_RANGE(mr_a.NumFreeChunks(), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, node_allocator::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    node_allocator::MemoryResource mr_a;\n+    node_allocator::MemoryResource mr_b;\n+\n+    {\n+        Map map_a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_a});\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            Map map_b(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_b});\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b.\n+        CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+        BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+        // but we'll get more free chunks in mr_a\n+        CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, but since it was moved, no more free chunks.\n+    CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 102U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_swap)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, node_allocator::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    node_allocator::MemoryResource mr_a;\n+    node_allocator::MemoryResource mr_b;\n+\n+    {\n+        Map map_a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_a});\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            Map map_b(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_b});\n+            map_b[123] = 321;\n+\n+            auto alloc_a = map_a.get_allocator();\n+            auto alloc_b = map_b.get_allocator();\n+\n+            std::swap(map_a, map_b);\n+\n+            // maps have swapped, so their allocator have swapped too. No additional allocations have occored!\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK(alloc_a == map_b.get_allocator());\n+            BOOST_CHECK(alloc_b == map_a.get_allocator());\n+        }\n+\n+        // map_b destroyed, so mr_a must have plenty of free chunks now\n+        CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+\n+        // nothing happened to map_a, so mr_b still has no free chunks\n+        BOOST_CHECK_EQUAL(mr_b.NumFreeChunks(), 0);\n+    }\n+\n+    // finally map_a is destroyed, so we got an entry back for mr_b.\n+    CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+    CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+}\n+\n+// some structs that with defined alignment and customizeable size\n+\n+namespace {\n+\n+template <size_t S>\n+struct alignas(1) A1 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(2) A2 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(4) A4 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(8) A8 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(16) A16 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(32) A32 {\n+    char data[S];\n+};\n+\n+constexpr bool isMultiple(size_t a, size_t b)\n+{\n+    return (a / b) * b == a;\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r690258262",
      "id" : 690258262,
      "line" : 248,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MDI1ODI2Mg==",
      "original_commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "original_line" : 248,
      "original_position" : 248,
      "original_start_line" : null,
      "path" : "src/test/node_allocator_tests.cpp",
      "position" : 248,
      "pull_request_review_id" : 731616678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-17T11:27:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690258262",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r690263859"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690263859"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Perhaps rule of 5 (https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-five, https://www.stroustrup.com/C++11FAQ.html#default)\r\n```diff \r\n     /**\r\n-     * Copying a memory resource is not allowed, it is an immobile object.\r\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\r\n      */\r\n     MemoryResource(const MemoryResource&) = delete;\r\n     MemoryResource& operator=(const MemoryResource&) = delete;\r\n+    MemoryResource(MemoryResource&&) = delete;\r\n+    MemoryResource& operator=(MemoryResource&&) = delete;\r\n```",
      "commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "created_at" : "2021-08-17T11:04:06Z",
      "diff_hunk" : "@@ -0,0 +1,356 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a freelist for further use.This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory, the freelist is stored inplace. This typically safes\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a freelist and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The freelist is a simple first-in-last-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as it's chunk size. Note that due to this heuristic we cannot implement an\n+ * `std::pmr::memory_resource` because it does not gie the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a freelist.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * Inplace linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object and uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying a memory resource is not allowed, it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r690263859",
      "id" : 690263859,
      "line" : 91,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MDI2Mzg1OQ==",
      "original_commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "original_line" : 91,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 91,
      "pull_request_review_id" : 731616678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-17T11:27:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690263859",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I've benchmarked the performance of `CChainState::ConnectBlock` between cde8a991f525b72d3a7ac76e0c83aaa611169f22 (PR) and the mergebase 803ef70fd9f65ef800567ff9456fac525bc3e3c2 (MB) using the [`validation::connect_block`](https://github.com/bitcoin/bitcoin/blob/master/doc/tracing.md#tracepoint-validationblock_connected) tracepoint. The tracepoint reports the time it took to connect each block. This means my results don't include the time it took to download and, AFAIK, not the time it took to persist the block to disk. I didn't look at memory usage. \r\n\r\nI've oriented myself on @jamesob's parameters and synced the blocks 500.000 to 540.000 from a localhost peer three times for the PR and the MB. I used the default dbcache (shouldn't matter for my measurements as cache flushes don't happen while inside `CChainState::ConnectBlock`). I've used an idle workstation with an i5 6500 and an NVME drive. Room and hardware temperature between runs changed which could have impacted performance. A `bpftrace` script to hook into the tracepoint can be found [here](https://gist.github.com/0xB10C/7f9010d44f1d97fbf1c83ec7f98155fd).\r\n\r\nTotal time spent in  `CChainState::ConnectBlock` per run for PR and MB: \r\n| run | 1         | 2     | 3     | \r\n|-----|-----------|-------|-------|\r\n| PR  | **1427s** | 1487s | 1486s | \r\n| MB  | **1577s** | 1670s | 1661s |\r\n\r\n![image](https://user-images.githubusercontent.com/19157360/129805353-5b48c0c1-1184-49c2-800c-196f1eed89c8.png)\r\n(PR run 2 and run 3 are overlapping quite a bit and indistinguishably here)\r\n\r\nMy results confirm that less time is spent in `CChainState::ConnectBlock` with PR compared to MB. A performance improvement between 6% - 10% is likely. \r\n\r\n\r\nTo rule out temperature effects on performance, these measurements could be redone with a properly cooled server/workstation.\r\n\r\n---\r\n\r\n**EDIT:** I did another three runs of PR and MB with calling `pyperf system tune` beforehand as @martinus suggested. PR is still faster.\r\n\r\n| run | 4         | 5     | 6     | \r\n|-----|-----------|-------|-------|\r\n| PR  | 1585s | **1537s** | 1546s | \r\n| MB  | 1647s | 1688s | **1644s** |\r\n\r\n![image](https://user-images.githubusercontent.com/19157360/130277740-548c4070-8dfd-4059-b8eb-acf152a8728f.png)\r\n \r\n\r\n\r\n\r\n",
      "created_at" : "2021-08-17T22:04:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-900662089",
      "id" : 900662089,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841rwNJ",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-20T18:32:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/900662089",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19157360?v=4",
         "events_url" : "https://api.github.com/users/0xB10C/events{/privacy}",
         "followers_url" : "https://api.github.com/users/0xB10C/followers",
         "following_url" : "https://api.github.com/users/0xB10C/following{/other_user}",
         "gists_url" : "https://api.github.com/users/0xB10C/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/0xB10C",
         "id" : 19157360,
         "login" : "0xB10C",
         "node_id" : "MDQ6VXNlcjE5MTU3MzYw",
         "organizations_url" : "https://api.github.com/users/0xB10C/orgs",
         "received_events_url" : "https://api.github.com/users/0xB10C/received_events",
         "repos_url" : "https://api.github.com/users/0xB10C/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/0xB10C/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/0xB10C/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/0xB10C"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@JeremyRubin I actually tried to bump it up to 128 byte to see what that does, but I didn't see any major difference. The benchmark got maybe 1% slower, but maybe the benchmark is also not very realistic. I also tried to reduce the size by 8 byte (which can be done by making use of the `Coin`'s padding in `CCoinsCacheEntry`, I might open anothe PR for that), and it got about ~1% faster. I think though that even with no performance benefit the node_allocator is worthwhile because it has lower memory overhead, so we can cache more entries with the same `-dbcache` setting.\r\n\r\n@jonatack Thanks for the review! I'm not sure though how I should best incorporate your changes? Should I copy them and add a `Co-authored-by` in the commit message? (I've never done that)\r\n\r\n@0xB10C Thanks for the benchmark! You might get a bit more stable result with [pyperf](https://pyperf.readthedocs.io/en/latest/): I always use `sudo pyperf system tune` before I run a benchmark which does a few things to make benchmarks much more stable (e.g. locks the CPU to a fixed frequency, disables turbo boost)",
      "created_at" : "2021-08-18T07:03:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-900871568",
      "id" : 900871568,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841sjWQ",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-18T07:03:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/900871568",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> @jonatack Thanks for the review! I'm not sure though how I should best incorporate your changes? Should I copy them and add a `Co-authored-by` in the commit message? (I've never done that)\r\n\r\nThanks! I'd say squash in the changes you want to keep. You can add an empty line followed by `Co-authored-by: Jon Atack <jon@atack.com>` to the bottom of a commit message if you like, but it was just a regular average review :)\r\n",
      "created_at" : "2021-08-18T21:00:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-901426870",
      "id" : 901426870,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841uq62",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-18T21:00:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/901426870",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Bench results with more modest dbcache (800): 6% speedup, 6.7% less memory usage.\r\n\r\n|          bench name           |                                                                                                    command                                                                                                     |\r\n|-------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| ibd.local.range.500000.540000 | `bitcoind -dbcache=800 -debug=coindb -debug=bench -listen=0 -connect=0 -addnode=127.0.0.1:8888 -prune=9999999 -printtoconsole=0 -assumevalid=000000000000000000176c192f42ad13ab159fdb20198b87e7ba3c001e47b876` |\r\n\r\n|                  bench name                   |  x  |           #22702            |         $mergebase          |\r\n|-----------------------------------------------|----:|-----------------------------|-----------------------------|\r\n| ibd.local.range.500000.540000.total_secs      |   3 | 3519.2667 (Â± 58.0440)       | 3752.9732 (Â± 54.8626)       |\r\n| ibd.local.range.500000.540000.peak_rss_KiB    |   3 | 2282000.0000 (Â± 45539.0428) | 2443188.0000 (Â± 22211.2803) |\r\n| ibd.local.range.500000.540000.cpu_kernel_secs |   3 | 491.2067 (Â± 4.5352)         | 493.7567 (Â± 13.1047)        |\r\n| ibd.local.range.500000.540000.cpu_user_secs   |   3 | 13717.5467 (Â± 15.0752)      | 13957.7867 (Â± 18.7773)      |\r\n\r\n|                  bench name                   |  x  | #22702 | $mergebase |\r\n|-----------------------------------------------|----:|-------:|-----------:|\r\n| ibd.local.range.500000.540000.total_secs      |   3 |      1 |      1.066 |\r\n| ibd.local.range.500000.540000.peak_rss_KiB    |   3 |      1 |      1.071 |\r\n| ibd.local.range.500000.540000.cpu_kernel_secs |   3 |      1 |      1.005 |\r\n| ibd.local.range.500000.540000.cpu_user_secs   |   3 |      1 |      1.018 |",
      "created_at" : "2021-08-19T16:17:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-902047745",
      "id" : 902047745,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841xCgB",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-19T16:17:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902047745",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I've now updated the code with correct memory estimation, and benchmarked it. I had a fully synchronized node, and ran `-reindex-chainstate` from block 0 to 690000. All done on a Intel i7 8700, locked to 3200 MHz. I used this command:\r\n\r\n```sh\r\n/usr/bin/time -v bitcoind -datadir=/run/media/martinus/big/bitcoin/db -dbcache=5000 -assumevalid=00000000000000000002a23d6df20eecec15b21d32c75833cce28f113de888b7 -reindex-chainstate -printtoconsole=0 -stopatheight=690000\r\n```\r\nThe PR ran quite a bit faster than master, 20.8%, with practically the same memory usage. Here some interesting data from `/usr/bin/time`:\r\n\r\n| what | mergebase | #22702 | Change \r\n---|---:|---:|---:\r\nElapsed (wall clock) time (h:mm:ss or m:ss) | 4:06:05 | 3:14:49 | 20.8% lower\r\nMaximum resident set size (kbytes) | 6837496 | 6856104 | 0.27% more\r\nMinor (reclaiming a frame) page faults | 101689566 | 70194069 | 31% fewer\r\nFile system inputs | 693891464 | 687479120 | 0.9% fewer\r\nFile system outputs | 239830024 | 188574064 | 21.4% fewer\r\n\r\nHere are some graphs that I created from parsing the `debug.log` file:\r\n\r\n![Progress in Million Transactions over Time(1)](https://user-images.githubusercontent.com/14386/130218881-c724daa3-f1ab-46e4-848f-a467fe875e4f.png)\r\n\r\n![Size of Cache in MiB over Time](https://user-images.githubusercontent.com/14386/130218975-c04af0ce-d36b-4fd6-9a4d-64b43040650c.png)\r\n\r\n`CCoinsMap` requires currently 104 byte for one node, and `node_allocator` basically uses exactly that (a bit more for house keeping of the allocated blocks but that's practically negigable), and the `std::unordered_map`'s default requires 128 byte (16 byte house keeping, and 8 more byte for 16 byte alignment). So we can cache quite a bit more transactions in the same amount of memory:\r\n\r\n![Size of Cache in Million tx over Time](https://user-images.githubusercontent.com/14386/130219000-5f9674cd-fffb-41c8-aa48-85ce51daca77.png)\r\n\r\nDue to the different allocation behavior (it allocates one big chunk of memory right as the first Coin is added), I also had to update the checks in `validation_flush_tests.cpp`",
      "created_at" : "2021-08-20T17:03:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-902831715",
      "id" : 902831715,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII58410B5j",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-20T17:08:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902831715",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693212773"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693212773"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This does not sound like a disadvantage when formulated this way?",
      "commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "created_at" : "2021-08-20T20:51:51Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693212773",
      "id" : 693212773,
      "line" : 37,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzIxMjc3Mw==",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 37,
      "original_position" : 37,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 37,
      "pull_request_review_id" : 735378772,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-20T21:27:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693212773",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693215356"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693215356"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\"A contains\" ... what is A?",
      "commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "created_at" : "2021-08-20T20:58:04Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, std::size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSize() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        if (m_chunk_size_bytes == 0) {\n+            return 0;\n+        }\n+        size_t alloc_size = (m_block_size_bytes / m_chunk_size_bytes) * m_chunk_size_bytes;\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to m_block_size_bytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        auto const num_chunks = m_block_size_bytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    //! A single linked list of all data available in the pool. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693215356",
      "id" : 693215356,
      "line" : 267,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzIxNTM1Ng==",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 267,
      "original_position" : 267,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 267,
      "pull_request_review_id" : 735378772,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-20T21:27:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693215356",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693219259"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693219259"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think this comment is incorrect (this is the size of one chunk; blocks are a multiple of that).",
      "commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "created_at" : "2021-08-20T21:07:09Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, std::size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSize() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        if (m_chunk_size_bytes == 0) {\n+            return 0;\n+        }\n+        size_t alloc_size = (m_block_size_bytes / m_chunk_size_bytes) * m_chunk_size_bytes;\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to m_block_size_bytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        auto const num_chunks = m_block_size_bytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    //! A single linked list of all data available in the pool. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! The pool's size for the memory blocks. First call to Allocate() determines the used size.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693219259",
      "id" : 693219259,
      "line" : 270,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzIxOTI1OQ==",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 270,
      "original_position" : 270,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 270,
      "pull_request_review_id" : 735378772,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-20T21:27:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693219259",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693225214"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693225214"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Perhaps add a comment here explaining that the `next` pointer of in-use elements actually doesn't matter until it's deallocated, so it doesn't need initialization here.",
      "commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "created_at" : "2021-08-20T21:21:34Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693225214",
      "id" : 693225214,
      "line" : 168,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzIyNTIxNA==",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 168,
      "original_position" : 168,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 168,
      "pull_request_review_id" : 735378772,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-20T21:27:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693225214",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693308019"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693308019"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "yes I wanted to clarify that the linked list's can become relatively random access pattern into the memory, which can be slower due to lots of cache misses. I'll fix the comment",
      "commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "created_at" : "2021-08-21T05:35:40Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693308019",
      "id" : 693308019,
      "in_reply_to_id" : 693212773,
      "line" : 37,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzMwODAxOQ==",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 37,
      "original_position" : 37,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 37,
      "pull_request_review_id" : 735469428,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-21T05:35:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693308019",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693308135"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693308135"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should be just \"Contains all allocated blocks of memory\"",
      "commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "created_at" : "2021-08-21T05:36:28Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, std::size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSize() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        if (m_chunk_size_bytes == 0) {\n+            return 0;\n+        }\n+        size_t alloc_size = (m_block_size_bytes / m_chunk_size_bytes) * m_chunk_size_bytes;\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to m_block_size_bytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        auto const num_chunks = m_block_size_bytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    //! A single linked list of all data available in the pool. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693308135",
      "id" : 693308135,
      "in_reply_to_id" : 693215356,
      "line" : 267,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzMwODEzNQ==",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 267,
      "original_position" : 267,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 267,
      "pull_request_review_id" : 735469503,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-21T05:36:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693308135",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Unfortunately Microsofts implementation of unordered_map behaves quite a bit different from libc++ and libstdc++, so the heuristic that I'm using to detect the node size doesn't work. I've added a WIP to the header until I've fixed this. Most likely I'll ditch the heuristic completely, and properly calculate the correct size. I'm already doing that in the tests anyways (except for windows)",
      "created_at" : "2021-08-22T17:28:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-903302726",
      "id" : 903302726,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841105G",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-22T17:28:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/903302726",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r696103452"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696103452"
         }
      },
      "author_association" : "MEMBER",
      "body" : "As far as I can tell, this can remain `1 << 10` (1024).\r\n\r\nIn both cases, invoking the test with `src/test/test_bitcoin -t validation_flush_tests -l test_suite` prints `CoinsTip usage percentage: 0.997634`\r\n```suggestion\r\n            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 1 << 10), // 1024\r\n```",
      "commit_id" : "c6561fd394aab850ac2d8bc6889eaaa274c4abda",
      "created_at" : "2021-08-25T20:50:36Z",
      "diff_hunk" : "@@ -135,7 +143,7 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n         BOOST_CHECK(usage_percentage >= 0.9);\n         BOOST_CHECK(usage_percentage < 1);\n         BOOST_CHECK_EQUAL(\n-            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, 1 << 10),\n+            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, 512),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r696103452",
      "id" : 696103452,
      "line" : 146,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NjEwMzQ1Mg==",
      "original_commit_id" : "c6561fd394aab850ac2d8bc6889eaaa274c4abda",
      "original_line" : 146,
      "original_position" : 67,
      "original_start_line" : null,
      "path" : "src/test/validation_flush_tests.cpp",
      "position" : 67,
      "pull_request_review_id" : 738531236,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-25T21:31:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696103452",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r696124457"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696124457"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n            // map_a now uses mr_b, since propagate_on_container_move_assignment is std::true_type\r\n```",
      "commit_id" : "c6561fd394aab850ac2d8bc6889eaaa274c4abda",
      "created_at" : "2021-08-25T21:25:28Z",
      "diff_hunk" : "@@ -0,0 +1,371 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <unordered_map>\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, chunk_size, num_free_chunks, num_blocks) \\\n+    BOOST_CHECK_EQUAL(chunk_size, mr.ChunkSizeBytes());                    \\\n+    BOOST_CHECK_EQUAL(num_free_chunks, mr.NumFreeChunks());                \\\n+    BOOST_CHECK_EQUAL(num_blocks, mr.NumBlocks());\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource mr(sizeof(void*));\n+    void* ptr = mr.Allocate<char>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    auto mr = Factory::CreateMemoryResource();\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_chunks = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_chunks = mr.NumFreeChunks();\n+\n+        // create a copy of the map, destroy the map => now a lot more free chunks should be available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(mr.NumFreeChunks() > num_free_chunks);\n+        num_free_chunks = mr.NumFreeChunks();\n+\n+        // creating another copy, and then destroying everything should reuse all the chunks\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(mr.NumFreeChunks(), num_free_chunks);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(mr.NumFreeChunks(), num_free_chunks);\n+    }\n+    // a is destroyed, still all chunks should stay roughly the same.\n+    BOOST_CHECK(mr.NumFreeChunks() <= num_free_chunks + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(mr.NumFreeChunks() > num_free_chunks + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    auto mr_a = Factory::CreateMemoryResource();\n+    auto mr_b = Factory::CreateMemoryResource();\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(mr_b.NumFreeChunks(), 0);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+        BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+        // but we'll get more free chunks in mr_a\n+        CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free chunks.\n+    CHECK_IN_RANGE(mr_a.NumFreeChunks(), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    auto mr_a = Factory::CreateMemoryResource();\n+    auto mr_b = Factory::CreateMemoryResource();\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r696124457",
      "id" : 696124457,
      "line" : 152,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NjEyNDQ1Nw==",
      "original_commit_id" : "c6561fd394aab850ac2d8bc6889eaaa274c4abda",
      "original_line" : 152,
      "original_position" : 152,
      "original_start_line" : null,
      "path" : "src/test/node_allocator_tests.cpp",
      "position" : 152,
      "pull_request_review_id" : 738531236,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-25T21:31:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696124457",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171063"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171063"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "thanks, I've updated the comment",
      "commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "created_at" : "2021-08-27T05:53:58Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, std::size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSize() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        if (m_chunk_size_bytes == 0) {\n+            return 0;\n+        }\n+        size_t alloc_size = (m_block_size_bytes / m_chunk_size_bytes) * m_chunk_size_bytes;\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to m_block_size_bytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        auto const num_chunks = m_block_size_bytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    //! A single linked list of all data available in the pool. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! The pool's size for the memory blocks. First call to Allocate() determines the used size.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171063",
      "id" : 697171063,
      "in_reply_to_id" : 693219259,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzE3MTA2Mw==",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 270,
      "original_position" : 270,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 740162998,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-27T05:53:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171063",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171107"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171107"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I've updated the comment",
      "commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "created_at" : "2021-08-27T05:54:08Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171107",
      "id" : 697171107,
      "in_reply_to_id" : 693225214,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzE3MTEwNw==",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 158,
      "original_position" : 168,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 740163071,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-27T05:54:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171107",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171287"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171287"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks again, I've squashed your review and rebased",
      "commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "created_at" : "2021-08-27T05:54:40Z",
      "diff_hunk" : "@@ -135,7 +143,7 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n         BOOST_CHECK(usage_percentage >= 0.9);\n         BOOST_CHECK(usage_percentage < 1);\n         BOOST_CHECK_EQUAL(\n-            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, 1 << 10),\n+            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, 512),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171287",
      "id" : 697171287,
      "in_reply_to_id" : 696103452,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzE3MTI4Nw==",
      "original_commit_id" : "c6561fd394aab850ac2d8bc6889eaaa274c4abda",
      "original_line" : 146,
      "original_position" : 67,
      "original_start_line" : null,
      "path" : "src/test/validation_flush_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 740163322,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-27T05:54:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171287",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I've run the same benchmark as https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-902831715 again, but this time with `-dbcache=10000`, and on my brand new much faster SSD (NVMe Corsair MP400). The results are very similar as before, just both runs are relatively faster. Interestingly, with such a large dbsize the branch never needs to flush the cache, only when finished, while master has to flush once because it got full around the 190 minute mark. That's also why memory usage of the branch is a bit lower here.\r\n\r\n| what | mergebase | #22702 | Change \r\n---|---:|---:|---:\r\nElapsed (wall clock) time (h:mm:ss or m:ss) | 3:29:56 | 2:43:43 | 22.0% faster\r\nMaximum resident set size (kbytes) | 10303716 | 9637256 | 6.4% lower\r\nMinor (reclaiming a frame) page faults | 24088467 | 3836829 | 84% fewer\r\nFile system inputs | 693485000 | 696413568 | 0.4% more\r\nFile system outputs | 109392776 | 81335536 | 25.6% fewer\r\n\r\nAgain, graphs are generated from parsing the `debug.log` files, on an Intel i7 8700 locked to 3.2 GHz:\r\n![Progress in Million Transactions over Time](https://user-images.githubusercontent.com/14386/131080470-18a5a79a-0849-4897-8dee-5eec709d6ab4.png)\r\n![Size of Cache in MiB over Time](https://user-images.githubusercontent.com/14386/131080505-23278cc5-8977-4a73-beec-4f2ece769fae.png)\r\n![Size of Cache in Million tx over Time](https://user-images.githubusercontent.com/14386/131080519-b01abbdb-1300-4acb-aa82-17d83278fdc1.png)\r\n",
      "created_at" : "2021-08-27T06:27:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-906958642",
      "id" : 906958642,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5842Dxcy",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-27T06:27:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/906958642",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I've removed `[WIP]` in the title after the code cleanup & fixes, everything should work now as expected on all platforms",
      "created_at" : "2021-08-27T07:46:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-907000522",
      "id" : 907000522,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5842D7rK",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-27T07:46:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/907000522",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r701533891"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/701533891"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "will this be handled correctly in the case of overflow?",
      "commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "created_at" : "2021-09-03T02:00:35Z",
      "diff_hunk" : "@@ -0,0 +1,52 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <coins.h>\n+#include <memusage.h>\n+#include <support/allocators/node_allocator.h>\n+\n+#include <cstring>\n+#include <iostream>\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::Bench& bench, Map& map)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(1);\n+    tx.vin[0].scriptSig = CScript() << OP_2;\n+    tx.vin[0].scriptWitness.stack.push_back({2});\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = CScript() << OP_2 << OP_EQUAL;\n+    tx.vout[0].nValue = 10 * COIN;\n+\n+    COutPoint p{tx.GetHash(), 0};\n+\n+    bench.epochIterations(5000 * 10).run([&] {\n+        // modify hash a bit so we get a new entry in the map\n+        ++p.n;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r701533891",
      "id" : 701533891,
      "line" : 29,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMTUzMzg5MQ==",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/bench/node_allocator.cpp",
      "position" : 29,
      "pull_request_review_id" : 745649234,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-09-03T04:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/701533891",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/15256660?v=4",
         "events_url" : "https://api.github.com/users/benthecarman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/benthecarman/followers",
         "following_url" : "https://api.github.com/users/benthecarman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/benthecarman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/benthecarman",
         "id" : 15256660,
         "login" : "benthecarman",
         "node_id" : "MDQ6VXNlcjE1MjU2NjYw",
         "organizations_url" : "https://api.github.com/users/benthecarman/orgs",
         "received_events_url" : "https://api.github.com/users/benthecarman/received_events",
         "repos_url" : "https://api.github.com/users/benthecarman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/benthecarman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/benthecarman"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r701594319"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/701594319"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think `p.n` cannot overflow here. It is initialized to 0, and since I've specified the number of iterations each measurement will have exactly 50000 iterations. I do this so I can be sure each measurement has exactly the same number of calls to `map.clear();`, which gives more stable benchmark results. Nanobench defaults to 11 measurements, so in total n will reach 550000.",
      "commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "created_at" : "2021-09-03T05:29:14Z",
      "diff_hunk" : "@@ -0,0 +1,52 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <coins.h>\n+#include <memusage.h>\n+#include <support/allocators/node_allocator.h>\n+\n+#include <cstring>\n+#include <iostream>\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::Bench& bench, Map& map)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(1);\n+    tx.vin[0].scriptSig = CScript() << OP_2;\n+    tx.vin[0].scriptWitness.stack.push_back({2});\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = CScript() << OP_2 << OP_EQUAL;\n+    tx.vout[0].nValue = 10 * COIN;\n+\n+    COutPoint p{tx.GetHash(), 0};\n+\n+    bench.epochIterations(5000 * 10).run([&] {\n+        // modify hash a bit so we get a new entry in the map\n+        ++p.n;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r701594319",
      "id" : 701594319,
      "in_reply_to_id" : 701533891,
      "line" : 29,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMTU5NDMxOQ==",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/bench/node_allocator.cpp",
      "position" : 29,
      "pull_request_review_id" : 745717791,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-09-03T05:29:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/701594319",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I think it would be better to not @ @jonatack in the commit message. IIRC he'll get a notification each time this commit is included in some bitcoin-fork.",
      "created_at" : "2021-09-03T09:50:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-912411850",
      "id" : 912411850,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5842YkzK",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-03T09:50:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/912411850",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19157360?v=4",
         "events_url" : "https://api.github.com/users/0xB10C/events{/privacy}",
         "followers_url" : "https://api.github.com/users/0xB10C/followers",
         "following_url" : "https://api.github.com/users/0xB10C/following{/other_user}",
         "gists_url" : "https://api.github.com/users/0xB10C/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/0xB10C",
         "id" : 19157360,
         "login" : "0xB10C",
         "node_id" : "MDQ6VXNlcjE5MTU3MzYw",
         "organizations_url" : "https://api.github.com/users/0xB10C/orgs",
         "received_events_url" : "https://api.github.com/users/0xB10C/received_events",
         "repos_url" : "https://api.github.com/users/0xB10C/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/0xB10C/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/0xB10C/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/0xB10C"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I think it would be better to not @ @jonatack in the commit message. IIRC he'll get a notification each time this commit is included in some bitcoin-fork.\r\n\r\nAh right, it even says so in `CONTRIBUTING.md`. I'll change the commit message.",
      "created_at" : "2021-09-03T12:47:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-912511422",
      "id" : 912511422,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5842Y9G-",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-03T12:47:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/912511422",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "The @ is not bothersome until merge, so it can wait until need to retouch.",
      "created_at" : "2021-09-03T12:58:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-912519251",
      "id" : 912519251,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5842Y_BT",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-03T12:58:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/912519251",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   }
]
