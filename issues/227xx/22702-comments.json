[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK\r\n\r\nThe numbers look very promising!\r\n\r\nSeems like this could be one of those rare optimization opportunities actually worth pursuing :)",
      "created_at" : "2021-08-15T18:46:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899094330",
      "id" : 899094330,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841lxc6",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-15T18:46:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899094330",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r689129302"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129302"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "last in first out?",
      "commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "created_at" : "2021-08-15T18:56:43Z",
      "diff_hunk" : "@@ -0,0 +1,356 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a freelist for further use.This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory, the freelist is stored inplace. This typically safes\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a freelist and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The freelist is a simple first-in-last-out linked list, it doesn't reorder elements. So freeing and malloc'ing again",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r689129302",
      "id" : 689129302,
      "line" : 34,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4OTEyOTMwMg==",
      "original_commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "original_line" : 34,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 34,
      "pull_request_review_id" : 730212106,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-15T18:56:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129302",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r689129360"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129360"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "gie -> give",
      "commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "created_at" : "2021-08-15T18:57:28Z",
      "diff_hunk" : "@@ -0,0 +1,356 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a freelist for further use.This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory, the freelist is stored inplace. This typically safes\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a freelist and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The freelist is a simple first-in-last-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as it's chunk size. Note that due to this heuristic we cannot implement an\n+ * `std::pmr::memory_resource` because it does not gie the information about the number of elements.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r689129360",
      "id" : 689129360,
      "line" : 46,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY4OTEyOTM2MA==",
      "original_commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "original_line" : 46,
      "original_position" : 46,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 46,
      "pull_request_review_id" : 730212152,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-15T18:57:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/689129360",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I'm curious what the impact would be on the performance if you allocated N chunks at a time, always, to fill a page.\r\n\r\nE.g., if you want to allocate one node, always allocate something like `aligned_alloc(sysconf(_SC_PAGESIZE), size)` and divide it up into a bunch of pointers for the free list.\r\n\r\nCool properties of doing so: Better cache alignment on items added around the same time, fewer things to keep in the allocated chunks list, if you were to sort the list by pointer (perhaps lazily, when we're not doing anything else) you would get something with good cache alignment again. ",
      "created_at" : "2021-08-15T19:11:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899097140",
      "id" : 899097140,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841lyI0",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-15T19:11:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899097140",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I'm curious what the impact would be on the performance if you allocated N chunks at a time, always, to fill a page.\r\n\r\nI've run the benchmark with `::aligned_alloc(sysconf(_SC_PAGESIZE), ...);` and only allocating a single page, and at least in the benchmark there's no difference:\r\n\r\n|               ns/op |                op/s |    err% |     total | benchmark\r\n|--------------------:|--------------------:|--------:|----------:|:----------\r\n|              140.95 |        7,094,953.03 |    0.2% |      0.08 | `NodeAllocator_StdUnorderedMap`\r\n|              115.57 |        8,652,942.75 |    0.1% |      0.06 | `NodeAllocator_StdUnorderedMapWithNodeAllocator` ::operator new\r\n|              115.33 |        8,670,873.08 |    0.2% |      0.06 | `NodeAllocator_StdUnorderedMapWithNodeAllocator`aligned_alloc",
      "created_at" : "2021-08-16T05:52:41Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899241874",
      "id" : 899241874,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841mVeS",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T05:52:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899241874",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Do you have specific code for that? The changes sounded a bit more complex than just aligning the allocator. Did you divide the allocation into N free list chunks? Or just over-allocate?",
      "created_at" : "2021-08-16T09:19:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899359234",
      "id" : 899359234,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841myIC",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T09:19:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899359234",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> Do you have specific code for that? The changes sounded a bit more complex than just aligning the allocator. Did you divide the allocation into N free list chunks? Or just over-allocate?\r\n\r\n`MemoryResource::AllocateNewBlock` is the only place where I actually malloc a new block that's divided into the chunks. Here I've replaced the `::operator new(num_chunks* m_chunk_size_bytes)` with `::alligned_alloc(sysconf(_SC_PAGESIZE), num_chunks* m_chunk_size_bytes)`. And use `free` in `~MemoryResource`.\r\nI also changed the default allocation size `m_block_size_bytes` from 262144 to `sysconf(_SC_PAGESIZE)`. \r\n\r\nSo for node size of 104 bytes and page size 4096, this should allocate a page-alligned block with 39*104=4056 bytes.",
      "created_at" : "2021-08-16T10:03:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899385299",
      "id" : 899385299,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841m4fT",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T10:03:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899385299",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Some fresh benches in (high dbcache). Continuing to see fairly substantial time/memory improvements with this change.\r\n\r\n![ibd local range 500000 540000](https://user-images.githubusercontent.com/73197/129577300-d73f42aa-8598-4418-9375-2a7c4521701a.png)\r\n\r\n#### commands index\r\n|          bench name           |                                                                                                     command                                                                                                      |\r\n|-------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| ibd.local.range.500000.540000 | `bitcoind -dbcache=10000 -debug=coindb -debug=bench -listen=0 -connect=0 -addnode=127.0.0.1:8888 -prune=9999999 -printtoconsole=0 -assumevalid=000000000000000000176c192f42ad13ab159fdb20198b87e7ba3c001e47b876` |\r\n\r\n\r\n#### #22702 vs. $mergebase (absolute)\r\n|                  bench name                   |  x  |           #22702           |        $mergebase         |\r\n|-----------------------------------------------|----:|----------------------------|---------------------------|\r\n| ibd.local.range.500000.540000.total_secs      |   3 | 2888.4055 (Â± 24.7775)      | 3131.5871 (Â± 4.8045)      |\r\n| ibd.local.range.500000.540000.peak_rss_KiB    |   3 | 5886729.3333 (Â± 3815.6315) | 6352470.6667 (Â± 979.1552) |\r\n| ibd.local.range.500000.540000.cpu_kernel_secs |   3 | 263.5433 (Â± 1.9605)        | 269.2233 (Â± 2.6299)       |\r\n| ibd.local.range.500000.540000.cpu_user_secs   |   3 | 12852.1300 (Â± 15.0661)     | 13134.5300 (Â± 2.9587)     |\r\n\r\n\r\n#### #22702 vs. $mergebase (relative)\r\n|                  bench name                   |  x  | #22702 | $mergebase |\r\n|-----------------------------------------------|----:|-------:|-----------:|\r\n| ibd.local.range.500000.540000.total_secs      |   3 |      1 |      1.084 |\r\n| ibd.local.range.500000.540000.peak_rss_KiB    |   3 |      1 |      1.079 |\r\n| ibd.local.range.500000.540000.cpu_kernel_secs |   3 |      1 |      1.022 |\r\n| ibd.local.range.500000.540000.cpu_user_secs   |   3 |      1 |      1.022 |\r\n\r\n",
      "created_at" : "2021-08-16T14:13:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899545273",
      "id" : 899545273,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841nfi5",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T14:13:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899545273",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks for the benchmark! Good to see its 8.4% faster. I think the only reason the memory is lower is because the `memusage::DynamicUsage` now overestimates the memory requirements of the `std::unordered_map` that uses the node_allocator. I guess I should correct that. Then the memory usage should stay roughly the same (as it should, that's what `-dbcache` is for), but the number of transactions that can be cached will increase.",
      "created_at" : "2021-08-16T17:46:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899698242",
      "id" : 899698242,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841oE5C",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T17:46:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899698242",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> `MemoryResource::AllocateNewBlock` is the only place where I actually malloc a new block that's divided into the chunks. Here I've replaced the `::operator new(num_chunks* m_chunk_size_bytes)` with `::alligned_alloc(sysconf(_SC_PAGESIZE), num_chunks* m_chunk_size_bytes)`. And use `free` in `~MemoryResource`.\r\n> I also changed the default allocation size `m_block_size_bytes` from 262144 to `sysconf(_SC_PAGESIZE)`.\r\n\r\nhmm yeah it's interesting to think through the alignment issues. I think I understand the code a bit better now so it makes sense that most of you allocations are already aligned. One thing that strikes me is that it seems that you have these 104 byte chunks (13 uint64_t s). You might get better properties if you pad them out to the nearest 32/64/128 bytes (memory overhead 24 bytes :( ), because then you'll never have nodes across cache lines. Memory usage is a bit worse though, but cache perfomance may be better this way? https://www.usenix.org/legacy/publications/library/proceedings/als00/2000papers/papers/full_papers/sears/sears_html/index.html for reference.\r\n\r\n",
      "created_at" : "2021-08-16T19:22:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899759585",
      "id" : 899759585,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841oT3h",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T19:22:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899759585",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "might also be interesting to bump the CScript prevector size from 28 to 35 (7 bytes). This would help with the above as well because if we're 104/128 byte aligned we have the capacity & then we'd also save a prevector allocation (which means the vector costs 25 bytes + 34-35 bytes) for a non p2sh segwit v0-v1 output, and also means even more indirection.\r\n\r\nThis might have system impacts very broadly because prevector is a leaky optimization sadly.",
      "created_at" : "2021-08-16T19:29:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-899763888",
      "id" : 899763888,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841oU6w",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-16T19:29:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/899763888",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/886523?v=4",
         "events_url" : "https://api.github.com/users/JeremyRubin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/JeremyRubin/followers",
         "following_url" : "https://api.github.com/users/JeremyRubin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/JeremyRubin",
         "id" : 886523,
         "login" : "JeremyRubin",
         "node_id" : "MDQ6VXNlcjg4NjUyMw==",
         "organizations_url" : "https://api.github.com/users/JeremyRubin/orgs",
         "received_events_url" : "https://api.github.com/users/JeremyRubin/received_events",
         "repos_url" : "https://api.github.com/users/JeremyRubin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/JeremyRubin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/JeremyRubin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r690258262"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690258262"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Tested that `IsMultiple()` can be removed (Debian Clang 13)\r\n\r\n```\r\ntest/node_allocator_tests.cpp:245:16: warning: unused function 'isMultiple' [-Wunused-function]\r\nconstexpr bool isMultiple(size_t a, size_t b)\r\n               ^\r\n1 warning generated.\r\n```\r\n",
      "commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "created_at" : "2021-08-17T10:55:25Z",
      "diff_hunk" : "@@ -0,0 +1,313 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <unordered_map>\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, chunk_size, num_free_chunks, num_blocks) \\\n+    BOOST_CHECK_EQUAL(chunk_size, mr.ChunkSize());                         \\\n+    BOOST_CHECK_EQUAL(num_free_chunks, mr.NumFreeChunks());                \\\n+    BOOST_CHECK_EQUAL(num_blocks, mr.NumBlocks());\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource mr;\n+    void* ptr = mr.Allocate<char>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, node_allocator::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    node_allocator::MemoryResource mr;\n+    Map m(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr});\n+    size_t num_free_chunks = 0;\n+    {\n+        Map a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr});\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_chunks = mr.NumFreeChunks();\n+\n+        // create a copy of the map, destroy the map => now a lot more free chunks should be available\n+        {\n+            Map b = a;\n+        }\n+\n+        BOOST_CHECK(mr.NumFreeChunks() > num_free_chunks);\n+        num_free_chunks = mr.NumFreeChunks();\n+\n+        // creating another copy, and then destroying everything should reuse all the chunks\n+        {\n+            Map b = a;\n+        }\n+        BOOST_CHECK_EQUAL(mr.NumFreeChunks(), num_free_chunks);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(mr.NumFreeChunks(), num_free_chunks);\n+    }\n+    // a is destroyed, still all chunks should stay roughly the same.\n+    BOOST_CHECK(mr.NumFreeChunks() <= num_free_chunks + 5);\n+\n+    m = Map(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr});\n+\n+    // now we got everything free\n+    BOOST_CHECK(mr.NumFreeChunks() > num_free_chunks + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, node_allocator::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    node_allocator::MemoryResource mr_a;\n+    node_allocator::MemoryResource mr_b;\n+\n+    {\n+        Map map_a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_a});\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            Map map_b(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_b});\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(mr_b.NumFreeChunks(), 0);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+        BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+        // but we'll get more free chunks in mr_a\n+        CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free chunks.\n+    CHECK_IN_RANGE(mr_a.NumFreeChunks(), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, node_allocator::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    node_allocator::MemoryResource mr_a;\n+    node_allocator::MemoryResource mr_b;\n+\n+    {\n+        Map map_a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_a});\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            Map map_b(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_b});\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b.\n+        CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+        BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+        // but we'll get more free chunks in mr_a\n+        CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, but since it was moved, no more free chunks.\n+    CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 102U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_swap)\n+{\n+    using Map = std::unordered_map<uint64_t, uint64_t, std::hash<uint64_t>, std::equal_to<uint64_t>, node_allocator::Allocator<std::pair<const uint64_t, uint64_t>>>;\n+\n+    node_allocator::MemoryResource mr_a;\n+    node_allocator::MemoryResource mr_b;\n+\n+    {\n+        Map map_a(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_a});\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            Map map_b(0, Map::hasher{}, Map::key_equal{}, Map::allocator_type{&mr_b});\n+            map_b[123] = 321;\n+\n+            auto alloc_a = map_a.get_allocator();\n+            auto alloc_b = map_b.get_allocator();\n+\n+            std::swap(map_a, map_b);\n+\n+            // maps have swapped, so their allocator have swapped too. No additional allocations have occored!\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK(alloc_a == map_b.get_allocator());\n+            BOOST_CHECK(alloc_b == map_a.get_allocator());\n+        }\n+\n+        // map_b destroyed, so mr_a must have plenty of free chunks now\n+        CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+\n+        // nothing happened to map_a, so mr_b still has no free chunks\n+        BOOST_CHECK_EQUAL(mr_b.NumFreeChunks(), 0);\n+    }\n+\n+    // finally map_a is destroyed, so we got an entry back for mr_b.\n+    CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+    CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+}\n+\n+// some structs that with defined alignment and customizeable size\n+\n+namespace {\n+\n+template <size_t S>\n+struct alignas(1) A1 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(2) A2 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(4) A4 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(8) A8 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(16) A16 {\n+    char data[S];\n+};\n+\n+template <size_t S>\n+struct alignas(32) A32 {\n+    char data[S];\n+};\n+\n+constexpr bool isMultiple(size_t a, size_t b)\n+{\n+    return (a / b) * b == a;\n+}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r690258262",
      "id" : 690258262,
      "line" : 248,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MDI1ODI2Mg==",
      "original_commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "original_line" : 248,
      "original_position" : 248,
      "original_start_line" : null,
      "path" : "src/test/node_allocator_tests.cpp",
      "position" : 248,
      "pull_request_review_id" : 731616678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-17T11:27:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690258262",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r690263859"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690263859"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Perhaps rule of 5 (https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-five, https://www.stroustrup.com/C++11FAQ.html#default)\r\n```diff \r\n     /**\r\n-     * Copying a memory resource is not allowed, it is an immobile object.\r\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\r\n      */\r\n     MemoryResource(const MemoryResource&) = delete;\r\n     MemoryResource& operator=(const MemoryResource&) = delete;\r\n+    MemoryResource(MemoryResource&&) = delete;\r\n+    MemoryResource& operator=(MemoryResource&&) = delete;\r\n```",
      "commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "created_at" : "2021-08-17T11:04:06Z",
      "diff_hunk" : "@@ -0,0 +1,356 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a freelist for further use.This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory, the freelist is stored inplace. This typically safes\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a freelist and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The freelist is a simple first-in-last-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as it's chunk size. Note that due to this heuristic we cannot implement an\n+ * `std::pmr::memory_resource` because it does not gie the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a freelist.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * Inplace linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object and uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying a memory resource is not allowed, it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r690263859",
      "id" : 690263859,
      "line" : 91,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MDI2Mzg1OQ==",
      "original_commit_id" : "3574aeebcbb54df26b7ef27573230c125e96b209",
      "original_line" : 91,
      "original_position" : 91,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 91,
      "pull_request_review_id" : 731616678,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-17T11:27:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/690263859",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I've benchmarked the performance of `CChainState::ConnectBlock` between cde8a991f525b72d3a7ac76e0c83aaa611169f22 (PR) and the mergebase 803ef70fd9f65ef800567ff9456fac525bc3e3c2 (MB) using the [`validation::connect_block`](https://github.com/bitcoin/bitcoin/blob/master/doc/tracing.md#tracepoint-validationblock_connected) tracepoint. The tracepoint reports the time it took to connect each block. This means my results don't include the time it took to download and, AFAIK, not the time it took to persist the block to disk. I didn't look at memory usage. \r\n\r\nI've oriented myself on @jamesob's parameters and synced the blocks 500.000 to 540.000 from a localhost peer three times for the PR and the MB. I used the default dbcache (shouldn't matter for my measurements as cache flushes don't happen while inside `CChainState::ConnectBlock`). I've used an idle workstation with an i5 6500 and an NVME drive. Room and hardware temperature between runs changed which could have impacted performance. A `bpftrace` script to hook into the tracepoint can be found [here](https://gist.github.com/0xB10C/7f9010d44f1d97fbf1c83ec7f98155fd).\r\n\r\nTotal time spent in  `CChainState::ConnectBlock` per run for PR and MB: \r\n| run | 1         | 2     | 3     | \r\n|-----|-----------|-------|-------|\r\n| PR  | **1427s** | 1487s | 1486s | \r\n| MB  | **1577s** | 1670s | 1661s |\r\n\r\n![image](https://user-images.githubusercontent.com/19157360/129805353-5b48c0c1-1184-49c2-800c-196f1eed89c8.png)\r\n(PR run 2 and run 3 are overlapping quite a bit and indistinguishably here)\r\n\r\nMy results confirm that less time is spent in `CChainState::ConnectBlock` with PR compared to MB. A performance improvement between 6% - 10% is likely. \r\n\r\n\r\nTo rule out temperature effects on performance, these measurements could be redone with a properly cooled server/workstation.\r\n\r\n---\r\n\r\n**EDIT:** I did another three runs of PR and MB with calling `pyperf system tune` beforehand as @martinus suggested. PR is still faster.\r\n\r\n| run | 4         | 5     | 6     | \r\n|-----|-----------|-------|-------|\r\n| PR  | 1585s | **1537s** | 1546s | \r\n| MB  | 1647s | 1688s | **1644s** |\r\n\r\n![image](https://user-images.githubusercontent.com/19157360/130277740-548c4070-8dfd-4059-b8eb-acf152a8728f.png)\r\n \r\n\r\n\r\n\r\n",
      "created_at" : "2021-08-17T22:04:46Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-900662089",
      "id" : 900662089,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841rwNJ",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-20T18:32:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/900662089",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19157360?v=4",
         "events_url" : "https://api.github.com/users/0xB10C/events{/privacy}",
         "followers_url" : "https://api.github.com/users/0xB10C/followers",
         "following_url" : "https://api.github.com/users/0xB10C/following{/other_user}",
         "gists_url" : "https://api.github.com/users/0xB10C/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/0xB10C",
         "id" : 19157360,
         "login" : "0xB10C",
         "node_id" : "MDQ6VXNlcjE5MTU3MzYw",
         "organizations_url" : "https://api.github.com/users/0xB10C/orgs",
         "received_events_url" : "https://api.github.com/users/0xB10C/received_events",
         "repos_url" : "https://api.github.com/users/0xB10C/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/0xB10C/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/0xB10C/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/0xB10C"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@JeremyRubin I actually tried to bump it up to 128 byte to see what that does, but I didn't see any major difference. The benchmark got maybe 1% slower, but maybe the benchmark is also not very realistic. I also tried to reduce the size by 8 byte (which can be done by making use of the `Coin`'s padding in `CCoinsCacheEntry`, I might open anothe PR for that), and it got about ~1% faster. I think though that even with no performance benefit the node_allocator is worthwhile because it has lower memory overhead, so we can cache more entries with the same `-dbcache` setting.\r\n\r\n@jonatack Thanks for the review! I'm not sure though how I should best incorporate your changes? Should I copy them and add a `Co-authored-by` in the commit message? (I've never done that)\r\n\r\n@0xB10C Thanks for the benchmark! You might get a bit more stable result with [pyperf](https://pyperf.readthedocs.io/en/latest/): I always use `sudo pyperf system tune` before I run a benchmark which does a few things to make benchmarks much more stable (e.g. locks the CPU to a fixed frequency, disables turbo boost)",
      "created_at" : "2021-08-18T07:03:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-900871568",
      "id" : 900871568,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841sjWQ",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-18T07:03:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/900871568",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> @jonatack Thanks for the review! I'm not sure though how I should best incorporate your changes? Should I copy them and add a `Co-authored-by` in the commit message? (I've never done that)\r\n\r\nThanks! I'd say squash in the changes you want to keep. You can add an empty line followed by `Co-authored-by: Jon Atack <jon@atack.com>` to the bottom of a commit message if you like, but it was just a regular average review :)\r\n",
      "created_at" : "2021-08-18T21:00:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-901426870",
      "id" : 901426870,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841uq62",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-18T21:00:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/901426870",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Bench results with more modest dbcache (800): 6% speedup, 6.7% less memory usage.\r\n\r\n|          bench name           |                                                                                                    command                                                                                                     |\r\n|-------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\r\n| ibd.local.range.500000.540000 | `bitcoind -dbcache=800 -debug=coindb -debug=bench -listen=0 -connect=0 -addnode=127.0.0.1:8888 -prune=9999999 -printtoconsole=0 -assumevalid=000000000000000000176c192f42ad13ab159fdb20198b87e7ba3c001e47b876` |\r\n\r\n|                  bench name                   |  x  |           #22702            |         $mergebase          |\r\n|-----------------------------------------------|----:|-----------------------------|-----------------------------|\r\n| ibd.local.range.500000.540000.total_secs      |   3 | 3519.2667 (Â± 58.0440)       | 3752.9732 (Â± 54.8626)       |\r\n| ibd.local.range.500000.540000.peak_rss_KiB    |   3 | 2282000.0000 (Â± 45539.0428) | 2443188.0000 (Â± 22211.2803) |\r\n| ibd.local.range.500000.540000.cpu_kernel_secs |   3 | 491.2067 (Â± 4.5352)         | 493.7567 (Â± 13.1047)        |\r\n| ibd.local.range.500000.540000.cpu_user_secs   |   3 | 13717.5467 (Â± 15.0752)      | 13957.7867 (Â± 18.7773)      |\r\n\r\n|                  bench name                   |  x  | #22702 | $mergebase |\r\n|-----------------------------------------------|----:|-------:|-----------:|\r\n| ibd.local.range.500000.540000.total_secs      |   3 |      1 |      1.066 |\r\n| ibd.local.range.500000.540000.peak_rss_KiB    |   3 |      1 |      1.071 |\r\n| ibd.local.range.500000.540000.cpu_kernel_secs |   3 |      1 |      1.005 |\r\n| ibd.local.range.500000.540000.cpu_user_secs   |   3 |      1 |      1.018 |",
      "created_at" : "2021-08-19T16:17:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-902047745",
      "id" : 902047745,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841xCgB",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-19T16:17:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902047745",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I've now updated the code with correct memory estimation, and benchmarked it. I had a fully synchronized node, and ran `-reindex-chainstate` from block 0 to 690000. All done on a Intel i7 8700, locked to 3200 MHz. I used this command:\r\n\r\n```sh\r\n/usr/bin/time -v bitcoind -datadir=/run/media/martinus/big/bitcoin/db -dbcache=5000 -assumevalid=00000000000000000002a23d6df20eecec15b21d32c75833cce28f113de888b7 -reindex-chainstate -printtoconsole=0 -stopatheight=690000\r\n```\r\nThe PR ran quite a bit faster than master, 20.8%, with practically the same memory usage. Here some interesting data from `/usr/bin/time`:\r\n\r\n| what | mergebase | #22702 | Change \r\n---|---:|---:|---:\r\nElapsed (wall clock) time (h:mm:ss or m:ss) | 4:06:05 | 3:14:49 | 20.8% lower\r\nMaximum resident set size (kbytes) | 6837496 | 6856104 | 0.27% more\r\nMinor (reclaiming a frame) page faults | 101689566 | 70194069 | 31% fewer\r\nFile system inputs | 693891464 | 687479120 | 0.9% fewer\r\nFile system outputs | 239830024 | 188574064 | 21.4% fewer\r\n\r\nHere are some graphs that I created from parsing the `debug.log` file:\r\n\r\n![Progress in Million Transactions over Time(1)](https://user-images.githubusercontent.com/14386/130218881-c724daa3-f1ab-46e4-848f-a467fe875e4f.png)\r\n\r\n![Size of Cache in MiB over Time](https://user-images.githubusercontent.com/14386/130218975-c04af0ce-d36b-4fd6-9a4d-64b43040650c.png)\r\n\r\n`CCoinsMap` requires currently 104 byte for one node, and `node_allocator` basically uses exactly that (a bit more for house keeping of the allocated blocks but that's practically negigable), and the `std::unordered_map`'s default requires 128 byte (16 byte house keeping, and 8 more byte for 16 byte alignment). So we can cache quite a bit more transactions in the same amount of memory:\r\n\r\n![Size of Cache in Million tx over Time](https://user-images.githubusercontent.com/14386/130219000-5f9674cd-fffb-41c8-aa48-85ce51daca77.png)\r\n\r\nDue to the different allocation behavior (it allocates one big chunk of memory right as the first Coin is added), I also had to update the checks in `validation_flush_tests.cpp`",
      "created_at" : "2021-08-20T17:03:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-902831715",
      "id" : 902831715,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII58410B5j",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-20T17:08:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/902831715",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693212773"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693212773"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This does not sound like a disadvantage when formulated this way?",
      "commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "created_at" : "2021-08-20T20:51:51Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693212773",
      "id" : 693212773,
      "line" : 37,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzIxMjc3Mw==",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 37,
      "original_position" : 37,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 37,
      "pull_request_review_id" : 735378772,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-20T21:27:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693212773",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693215356"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693215356"
         }
      },
      "author_association" : "MEMBER",
      "body" : "\"A contains\" ... what is A?",
      "commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "created_at" : "2021-08-20T20:58:04Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, std::size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSize() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        if (m_chunk_size_bytes == 0) {\n+            return 0;\n+        }\n+        size_t alloc_size = (m_block_size_bytes / m_chunk_size_bytes) * m_chunk_size_bytes;\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to m_block_size_bytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        auto const num_chunks = m_block_size_bytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    //! A single linked list of all data available in the pool. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693215356",
      "id" : 693215356,
      "line" : 267,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzIxNTM1Ng==",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 267,
      "original_position" : 267,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 267,
      "pull_request_review_id" : 735378772,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-20T21:27:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693215356",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693219259"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693219259"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think this comment is incorrect (this is the size of one chunk; blocks are a multiple of that).",
      "commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "created_at" : "2021-08-20T21:07:09Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, std::size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSize() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        if (m_chunk_size_bytes == 0) {\n+            return 0;\n+        }\n+        size_t alloc_size = (m_block_size_bytes / m_chunk_size_bytes) * m_chunk_size_bytes;\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to m_block_size_bytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        auto const num_chunks = m_block_size_bytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    //! A single linked list of all data available in the pool. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! The pool's size for the memory blocks. First call to Allocate() determines the used size.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693219259",
      "id" : 693219259,
      "line" : 270,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzIxOTI1OQ==",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 270,
      "original_position" : 270,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 270,
      "pull_request_review_id" : 735378772,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-20T21:27:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693219259",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693225214"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693225214"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Perhaps add a comment here explaining that the `next` pointer of in-use elements actually doesn't matter until it's deallocated, so it doesn't need initialization here.",
      "commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "created_at" : "2021-08-20T21:21:34Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693225214",
      "id" : 693225214,
      "line" : 168,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzIyNTIxNA==",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 168,
      "original_position" : 168,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 168,
      "pull_request_review_id" : 735378772,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-20T21:27:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693225214",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693308019"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693308019"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "yes I wanted to clarify that the linked list's can become relatively random access pattern into the memory, which can be slower due to lots of cache misses. I'll fix the comment",
      "commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "created_at" : "2021-08-21T05:35:40Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693308019",
      "id" : 693308019,
      "in_reply_to_id" : 693212773,
      "line" : 37,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzMwODAxOQ==",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 37,
      "original_position" : 37,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 37,
      "pull_request_review_id" : 735469428,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-21T05:35:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693308019",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693308135"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693308135"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should be just \"Contains all allocated blocks of memory\"",
      "commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "created_at" : "2021-08-21T05:36:28Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, std::size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSize() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        if (m_chunk_size_bytes == 0) {\n+            return 0;\n+        }\n+        size_t alloc_size = (m_block_size_bytes / m_chunk_size_bytes) * m_chunk_size_bytes;\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to m_block_size_bytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        auto const num_chunks = m_block_size_bytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    //! A single linked list of all data available in the pool. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r693308135",
      "id" : 693308135,
      "in_reply_to_id" : 693215356,
      "line" : 267,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5MzMwODEzNQ==",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 267,
      "original_position" : 267,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 267,
      "pull_request_review_id" : 735469503,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-21T05:36:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/693308135",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Unfortunately Microsofts implementation of unordered_map behaves quite a bit different from libc++ and libstdc++, so the heuristic that I'm using to detect the node size doesn't work. I've added a WIP to the header until I've fixed this. Most likely I'll ditch the heuristic completely, and properly calculate the correct size. I'm already doing that in the tests anyways (except for windows)",
      "created_at" : "2021-08-22T17:28:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-903302726",
      "id" : 903302726,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5841105G",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-22T17:28:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/903302726",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r696103452"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696103452"
         }
      },
      "author_association" : "MEMBER",
      "body" : "As far as I can tell, this can remain `1 << 10` (1024).\r\n\r\nIn both cases, invoking the test with `src/test/test_bitcoin -t validation_flush_tests -l test_suite` prints `CoinsTip usage percentage: 0.997634`\r\n```suggestion\r\n            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, /*max_mempool_size_bytes*/ 1 << 10), // 1024\r\n```",
      "commit_id" : "c6561fd394aab850ac2d8bc6889eaaa274c4abda",
      "created_at" : "2021-08-25T20:50:36Z",
      "diff_hunk" : "@@ -135,7 +143,7 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n         BOOST_CHECK(usage_percentage >= 0.9);\n         BOOST_CHECK(usage_percentage < 1);\n         BOOST_CHECK_EQUAL(\n-            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, 1 << 10),\n+            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, 512),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r696103452",
      "id" : 696103452,
      "line" : 146,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NjEwMzQ1Mg==",
      "original_commit_id" : "c6561fd394aab850ac2d8bc6889eaaa274c4abda",
      "original_line" : 146,
      "original_position" : 67,
      "original_start_line" : null,
      "path" : "src/test/validation_flush_tests.cpp",
      "position" : 67,
      "pull_request_review_id" : 738531236,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-25T21:31:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696103452",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r696124457"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696124457"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```suggestion\r\n            // map_a now uses mr_b, since propagate_on_container_move_assignment is std::true_type\r\n```",
      "commit_id" : "c6561fd394aab850ac2d8bc6889eaaa274c4abda",
      "created_at" : "2021-08-25T21:25:28Z",
      "diff_hunk" : "@@ -0,0 +1,371 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <support/allocators/node_allocator.h>\n+#include <test/util/setup_common.h>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#include <cstddef>\n+#include <list>\n+#include <map>\n+#include <string>\n+#include <unordered_map>\n+\n+BOOST_FIXTURE_TEST_SUITE(node_allocator_tests, BasicTestingSetup)\n+\n+#define CHECK_MEMORY_RESOURCE(mr, chunk_size, num_free_chunks, num_blocks) \\\n+    BOOST_CHECK_EQUAL(chunk_size, mr.ChunkSizeBytes());                    \\\n+    BOOST_CHECK_EQUAL(num_free_chunks, mr.NumFreeChunks());                \\\n+    BOOST_CHECK_EQUAL(num_blocks, mr.NumBlocks());\n+\n+#define CHECK_IN_RANGE(what, lowerInclusive, upperInclusive) \\\n+    BOOST_TEST(what >= lowerInclusive);                      \\\n+    BOOST_TEST(what <= upperInclusive);\n+\n+BOOST_AUTO_TEST_CASE(too_small)\n+{\n+    node_allocator::MemoryResource mr(sizeof(void*));\n+    void* ptr = mr.Allocate<char>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+\n+    // mr is used\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 1, 1);\n+\n+    // void* works too, use freelist\n+    ptr = mr.Allocate<void*>(1);\n+    BOOST_CHECK(ptr != nullptr);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 0, 1);\n+    mr.Deallocate<char>(ptr, 1);\n+    CHECK_MEMORY_RESOURCE(mr, sizeof(void*), 1, 1);\n+}\n+\n+BOOST_AUTO_TEST_CASE(std_unordered_map)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    auto mr = Factory::CreateMemoryResource();\n+    auto m = Factory::CreateContainer(&mr);\n+    size_t num_free_chunks = 0;\n+    {\n+        auto a = Factory::CreateContainer(&mr);\n+\n+        // Allocator compares equal because the same memory resource is used\n+        BOOST_CHECK(a.get_allocator() == m.get_allocator());\n+        for (uint64_t i = 0; i < 1000; ++i) {\n+            a[i] = i;\n+        }\n+\n+        num_free_chunks = mr.NumFreeChunks();\n+\n+        // create a copy of the map, destroy the map => now a lot more free chunks should be available\n+        {\n+            auto b = a;\n+        }\n+\n+        BOOST_CHECK(mr.NumFreeChunks() > num_free_chunks);\n+        num_free_chunks = mr.NumFreeChunks();\n+\n+        // creating another copy, and then destroying everything should reuse all the chunks\n+        {\n+            auto b = a;\n+        }\n+        BOOST_CHECK_EQUAL(mr.NumFreeChunks(), num_free_chunks);\n+\n+        // moving the map should not create new nodes\n+        m = std::move(a);\n+        BOOST_CHECK_EQUAL(mr.NumFreeChunks(), num_free_chunks);\n+    }\n+    // a is destroyed, still all chunks should stay roughly the same.\n+    BOOST_CHECK(mr.NumFreeChunks() <= num_free_chunks + 5);\n+\n+    m = Factory::CreateContainer(&mr);\n+\n+    // now we got everything free\n+    BOOST_CHECK(mr.NumFreeChunks() > num_free_chunks + 50);\n+}\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_assignment)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    auto mr_a = Factory::CreateMemoryResource();\n+    auto mr_b = Factory::CreateMemoryResource();\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+            BOOST_CHECK(map_a.get_allocator() != map_b.get_allocator());\n+            BOOST_CHECK_EQUAL(mr_b.NumFreeChunks(), 0);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            map_b = map_a;\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type\n+            BOOST_CHECK(map_a.get_allocator() == map_b.get_allocator());\n+            CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+            BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+\n+            // map_b was now recreated with data from map_a, using mr_a as the memory resource.\n+        }\n+\n+        // map_b destroyed, should not have any effect on mr_b\n+        CHECK_IN_RANGE(mr_b.NumFreeChunks(), 1U, 2U);\n+        BOOST_CHECK_EQUAL(mr_b.NumBlocks(), 1);\n+        // but we'll get more free chunks in mr_a\n+        CHECK_IN_RANGE(mr_a.NumFreeChunks(), 100U, 101U);\n+    }\n+\n+    // finally map_a is destroyed, getting more free chunks.\n+    CHECK_IN_RANGE(mr_a.NumFreeChunks(), 200U, 202U);\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(different_memoryresource_move)\n+{\n+    using Factory = node_allocator::UnorderedMapFactory<uint64_t, uint64_t>;\n+\n+    auto mr_a = Factory::CreateMemoryResource();\n+    auto mr_b = Factory::CreateMemoryResource();\n+\n+    {\n+        auto map_a = Factory::CreateContainer(&mr_a);\n+        for (int i = 0; i < 100; ++i) {\n+            map_a[i] = i;\n+        }\n+\n+        {\n+            auto map_b = Factory::CreateContainer(&mr_b);\n+            map_b[123] = 321;\n+\n+            map_b = std::move(map_a);\n+\n+            // map_a now uses mr_b, since propagate_on_container_copy_assignment is std::true_type",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r696124457",
      "id" : 696124457,
      "line" : 152,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NjEyNDQ1Nw==",
      "original_commit_id" : "c6561fd394aab850ac2d8bc6889eaaa274c4abda",
      "original_line" : 152,
      "original_position" : 152,
      "original_start_line" : null,
      "path" : "src/test/node_allocator_tests.cpp",
      "position" : 152,
      "pull_request_review_id" : 738531236,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-25T21:31:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696124457",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171063"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171063"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "thanks, I've updated the comment",
      "commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "created_at" : "2021-08-27T05:53:58Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, std::size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSize() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        if (m_chunk_size_bytes == 0) {\n+            return 0;\n+        }\n+        size_t alloc_size = (m_block_size_bytes / m_chunk_size_bytes) * m_chunk_size_bytes;\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to m_block_size_bytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        auto const num_chunks = m_block_size_bytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    //! A single linked list of all data available in the pool. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! The pool's size for the memory blocks. First call to Allocate() determines the used size.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171063",
      "id" : 697171063,
      "in_reply_to_id" : 693219259,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzE3MTA2Mw==",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 270,
      "original_position" : 270,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 740162998,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-27T05:53:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171063",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171107"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171107"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I've updated the comment",
      "commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "created_at" : "2021-08-27T05:54:08Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171107",
      "id" : 697171107,
      "in_reply_to_id" : 693225214,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzE3MTEwNw==",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 158,
      "original_position" : 168,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 740163071,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-27T05:54:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171107",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171287"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171287"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks again, I've squashed your review and rebased",
      "commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "created_at" : "2021-08-27T05:54:40Z",
      "diff_hunk" : "@@ -135,7 +143,7 @@ BOOST_AUTO_TEST_CASE(getcoinscachesizestate)\n         BOOST_CHECK(usage_percentage >= 0.9);\n         BOOST_CHECK(usage_percentage < 1);\n         BOOST_CHECK_EQUAL(\n-            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, 1 << 10),\n+            chainstate.GetCoinsCacheSizeState(MAX_COINS_CACHE_BYTES, 512),",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r697171287",
      "id" : 697171287,
      "in_reply_to_id" : 696103452,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NzE3MTI4Nw==",
      "original_commit_id" : "c6561fd394aab850ac2d8bc6889eaaa274c4abda",
      "original_line" : 146,
      "original_position" : 67,
      "original_start_line" : null,
      "path" : "src/test/validation_flush_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 740163322,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-27T05:54:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/697171287",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I've run the same benchmark as https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-902831715 again, but this time with `-dbcache=10000`, and on my brand new much faster SSD (NVMe Corsair MP400). The results are very similar as before, just both runs are relatively faster. Interestingly, with such a large dbsize the branch never needs to flush the cache, only when finished, while master has to flush once because it got full around the 190 minute mark. That's also why memory usage of the branch is a bit lower here.\r\n\r\n| what | mergebase | #22702 | Change \r\n---|---:|---:|---:\r\nElapsed (wall clock) time (h:mm:ss or m:ss) | 3:29:56 | 2:43:43 | 22.0% faster\r\nMaximum resident set size (kbytes) | 10303716 | 9637256 | 6.4% lower\r\nMinor (reclaiming a frame) page faults | 24088467 | 3836829 | 84% fewer\r\nFile system inputs | 693485000 | 696413568 | 0.4% more\r\nFile system outputs | 109392776 | 81335536 | 25.6% fewer\r\n\r\nAgain, graphs are generated from parsing the `debug.log` files, on an Intel i7 8700 locked to 3.2 GHz:\r\n![Progress in Million Transactions over Time](https://user-images.githubusercontent.com/14386/131080470-18a5a79a-0849-4897-8dee-5eec709d6ab4.png)\r\n![Size of Cache in MiB over Time](https://user-images.githubusercontent.com/14386/131080505-23278cc5-8977-4a73-beec-4f2ece769fae.png)\r\n![Size of Cache in Million tx over Time](https://user-images.githubusercontent.com/14386/131080519-b01abbdb-1300-4acb-aa82-17d83278fdc1.png)\r\n",
      "created_at" : "2021-08-27T06:27:22Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-906958642",
      "id" : 906958642,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5842Dxcy",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-27T06:27:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/906958642",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I've removed `[WIP]` in the title after the code cleanup & fixes, everything should work now as expected on all platforms",
      "created_at" : "2021-08-27T07:46:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-907000522",
      "id" : 907000522,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5842D7rK",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-27T07:46:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/907000522",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r701533891"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/701533891"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "will this be handled correctly in the case of overflow?",
      "commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "created_at" : "2021-09-03T02:00:35Z",
      "diff_hunk" : "@@ -0,0 +1,52 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <coins.h>\n+#include <memusage.h>\n+#include <support/allocators/node_allocator.h>\n+\n+#include <cstring>\n+#include <iostream>\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::Bench& bench, Map& map)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(1);\n+    tx.vin[0].scriptSig = CScript() << OP_2;\n+    tx.vin[0].scriptWitness.stack.push_back({2});\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = CScript() << OP_2 << OP_EQUAL;\n+    tx.vout[0].nValue = 10 * COIN;\n+\n+    COutPoint p{tx.GetHash(), 0};\n+\n+    bench.epochIterations(5000 * 10).run([&] {\n+        // modify hash a bit so we get a new entry in the map\n+        ++p.n;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r701533891",
      "id" : 701533891,
      "line" : 29,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMTUzMzg5MQ==",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/bench/node_allocator.cpp",
      "position" : 29,
      "pull_request_review_id" : 745649234,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-09-03T04:30:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/701533891",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/15256660?v=4",
         "events_url" : "https://api.github.com/users/benthecarman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/benthecarman/followers",
         "following_url" : "https://api.github.com/users/benthecarman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/benthecarman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/benthecarman",
         "id" : 15256660,
         "login" : "benthecarman",
         "node_id" : "MDQ6VXNlcjE1MjU2NjYw",
         "organizations_url" : "https://api.github.com/users/benthecarman/orgs",
         "received_events_url" : "https://api.github.com/users/benthecarman/received_events",
         "repos_url" : "https://api.github.com/users/benthecarman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/benthecarman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/benthecarman"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r701594319"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/701594319"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I think `p.n` cannot overflow here. It is initialized to 0, and since I've specified the number of iterations each measurement will have exactly 50000 iterations. I do this so I can be sure each measurement has exactly the same number of calls to `map.clear();`, which gives more stable benchmark results. Nanobench defaults to 11 measurements, so in total n will reach 550000.",
      "commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "created_at" : "2021-09-03T05:29:14Z",
      "diff_hunk" : "@@ -0,0 +1,52 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <bench/bench.h>\n+#include <coins.h>\n+#include <memusage.h>\n+#include <support/allocators/node_allocator.h>\n+\n+#include <cstring>\n+#include <iostream>\n+#include <unordered_map>\n+\n+template <typename Map>\n+void BenchFillClearMap(benchmark::Bench& bench, Map& map)\n+{\n+    CMutableTransaction tx = CMutableTransaction();\n+    tx.vin.resize(1);\n+    tx.vin[0].scriptSig = CScript() << OP_2;\n+    tx.vin[0].scriptWitness.stack.push_back({2});\n+    tx.vout.resize(1);\n+    tx.vout[0].scriptPubKey = CScript() << OP_2 << OP_EQUAL;\n+    tx.vout[0].nValue = 10 * COIN;\n+\n+    COutPoint p{tx.GetHash(), 0};\n+\n+    bench.epochIterations(5000 * 10).run([&] {\n+        // modify hash a bit so we get a new entry in the map\n+        ++p.n;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r701594319",
      "id" : 701594319,
      "in_reply_to_id" : 701533891,
      "line" : 29,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwMTU5NDMxOQ==",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 29,
      "original_position" : 29,
      "original_start_line" : null,
      "path" : "src/bench/node_allocator.cpp",
      "position" : 29,
      "pull_request_review_id" : 745717791,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-09-03T05:29:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/701594319",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I think it would be better to not @ @jonatack in the commit message. IIRC he'll get a notification each time this commit is included in some bitcoin-fork.",
      "created_at" : "2021-09-03T09:50:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-912411850",
      "id" : 912411850,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5842YkzK",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-03T09:50:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/912411850",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/19157360?v=4",
         "events_url" : "https://api.github.com/users/0xB10C/events{/privacy}",
         "followers_url" : "https://api.github.com/users/0xB10C/followers",
         "following_url" : "https://api.github.com/users/0xB10C/following{/other_user}",
         "gists_url" : "https://api.github.com/users/0xB10C/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/0xB10C",
         "id" : 19157360,
         "login" : "0xB10C",
         "node_id" : "MDQ6VXNlcjE5MTU3MzYw",
         "organizations_url" : "https://api.github.com/users/0xB10C/orgs",
         "received_events_url" : "https://api.github.com/users/0xB10C/received_events",
         "repos_url" : "https://api.github.com/users/0xB10C/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/0xB10C/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/0xB10C/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/0xB10C"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I think it would be better to not @ @jonatack in the commit message. IIRC he'll get a notification each time this commit is included in some bitcoin-fork.\r\n\r\nAh right, it even says so in `CONTRIBUTING.md`. I'll change the commit message.",
      "created_at" : "2021-09-03T12:47:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-912511422",
      "id" : 912511422,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5842Y9G-",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-03T12:47:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/912511422",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "The @ is not bothersome until merge, so it can wait until need to retouch.",
      "created_at" : "2021-09-03T12:58:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-912519251",
      "id" : 912519251,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5842Y_BT",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-03T12:58:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/912519251",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/2415484?v=4",
         "events_url" : "https://api.github.com/users/jonatack/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonatack/followers",
         "following_url" : "https://api.github.com/users/jonatack/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonatack/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonatack",
         "id" : 2415484,
         "login" : "jonatack",
         "node_id" : "MDQ6VXNlcjI0MTU0ODQ=",
         "organizations_url" : "https://api.github.com/users/jonatack/orgs",
         "received_events_url" : "https://api.github.com/users/jonatack/received_events",
         "repos_url" : "https://api.github.com/users/jonatack/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonatack/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonatack/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonatack"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "tACK 952c37a31c39b7acdb5ab2634a354a1c548708a2\r\n\r\nDid IDB on a testnet node, ubuntu 20.04",
      "created_at" : "2021-09-04T00:17:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-912873136",
      "id" : 912873136,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5842aVaw",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-04T00:17:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/912873136",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/15256660?v=4",
         "events_url" : "https://api.github.com/users/benthecarman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/benthecarman/followers",
         "following_url" : "https://api.github.com/users/benthecarman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/benthecarman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/benthecarman",
         "id" : 15256660,
         "login" : "benthecarman",
         "node_id" : "MDQ6VXNlcjE1MjU2NjYw",
         "organizations_url" : "https://api.github.com/users/benthecarman/orgs",
         "received_events_url" : "https://api.github.com/users/benthecarman/received_events",
         "repos_url" : "https://api.github.com/users/benthecarman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/benthecarman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/benthecarman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/benthecarman"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.",
      "created_at" : "2021-09-09T17:28:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-916295394",
      "id" : 916295394,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5842nY7i",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/916295394/reactions"
      },
      "updated_at" : "2021-10-06T20:06:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/916295394",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Given the high potential performance benefit of this PR, it'd be great to see it move forward somehow.\r\n\r\n@martinus: are there any limitations or concerns you have about this? Are there any risks in particular we should be testing for?\r\n\r\n@sipa @ryanofsky @TheBlueMatt: given you're some resident C++/systems experts, are there any concerns you have? Tests you'd like to see?\r\n\r\nI just want to best understand what kind of work we should be doing to assess the suitability of this change. ",
      "created_at" : "2021-10-12T14:17:02Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941055887",
      "id" : 941055887,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5844F1-P",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941055887/reactions"
      },
      "updated_at" : "2021-10-12T14:17:02Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941055887",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "It's been on my list to go through the code in detail.\n\nSo far, my biggest concern is that the object size gets computed incorrectly by a future libstdc++ (or equivalent) change, and we'll silently fall back to old performance.\n\n@martinus What do you think the impact would be from having a list of memory blobs per allocation size? That would alleviate any such concerns, but I'm not sure whether its performance impact might be non-negligible, of if there are other issues with that approach. A pointer to the last-used allocation size's blobs could be cached, perhaps.",
      "created_at" : "2021-10-12T14:30:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941067769",
      "id" : 941067769,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5844F435",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941067769/reactions"
      },
      "updated_at" : "2021-10-12T14:30:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941067769",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> @sipa @ryanofsky @TheBlueMatt: given you're some resident C++/systems experts, are there any concerns you have? Tests you'd like to see?\r\n\r\nNo specific concerns from me. It's just a PR adding a lot of dense code that will take time to read over. This seems like a very worthwhile change if it is speeding up IBD, and it seems less risky than other more invasive performance improvements.\r\n\r\nDumb question, just because the title of this PR is makes me immediately feel stupid: What is  a \"node-based\" container? Just any map container? Maybe a more motivating PR title would be \"Implement node allocator for UTXO cache for faster IBD\". Also it would be good if PR description described the new PR instead of just comparing it to previous PR, since probably some potential reviewers like me are not familiar with the previous PR.",
      "created_at" : "2021-10-12T15:03:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941097068",
      "id" : 941097068,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5844GABs",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941097068/reactions"
      },
      "updated_at" : "2021-10-12T15:03:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941097068",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@ryanofsky I'm not exactly sure where the name \"node based\" comes from, but my interpretation is this: it's an allocator that optimizes the allocation of lots of objects of one specific preset size, without the ability to return individual memory back to the system. Such an allocator is specifically useful for standard library collection types which involve a separately-allocated object (which I guess are called nodes?) for each item (this would apply to things like `std::{,forward_}list`, `std::{,unordered_}{,multi}{set,map}`; I'm unsure about `std::deque`).",
      "created_at" : "2021-10-12T15:14:58Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941108553",
      "id" : 941108553,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5844GC1J",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941108553/reactions"
      },
      "updated_at" : "2021-10-12T15:19:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941108553",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Yeah I don't mean to quibble over the name. I'm sure it's appropriate. Just suggesting to make not make the term seem like assumed knowledge for reviewing the PR. Naively I would think \"separately-allocated object\" would apply to trees and lists but not hash tables so `{,unordered_}` part of this is specifically what's confusing me here. But I should just sit down and read `node_allocator.h`, since the code itself is nicely documented.",
      "created_at" : "2021-10-12T15:24:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941117614",
      "id" : 941117614,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5844GFCu",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941117614/reactions"
      },
      "updated_at" : "2021-10-12T15:24:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941117614",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@ryanofsky Yeah I'm just trying to explain my understanding, not nit about the name. `std::unordered_{multi,}{set}{map}` use a single hashtable with pointers that start singly-linked lists of objects in that bucket, each of which points to the next one. Those objects are potential candidates for optimization by the allocator (the hashtable itself isn't).",
      "created_at" : "2021-10-12T15:27:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941121006",
      "id" : 941121006,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5844GF3u",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941121006/reactions"
      },
      "updated_at" : "2021-10-12T15:28:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941121006",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@jamesob concerning limitations, I can't really think of much... I think the biggest change is that the `MemoryResource` doesn't free memory any more. So once the map reaches a size, memory usage won't decrease even when the map gets smaller. You can see that nicely in this graph: https://user-images.githubusercontent.com/14386/131080505-23278cc5-8977-4a73-beec-4f2ece769fae.png The blue line is mergebase and when map size decreases memory goes down. For this PR the memory stays constant (at a lower level because it needs less memory).\r\n\r\nAnother concern is that on some systems malloc could be exceptionally fast, or implemented differently, so that this `node_allocator` is not actually a performance / memory benefit. \r\n\r\n@sipa concerning incorrectly calculating object sizes, I think this can be covered in unit tests. In the new test `test_chunks_are_used` I'm trying to create `std::unordered_map` with all kind of alignments with and without a `noexcept` hash, and assert if the MemoryResource is actually used. I could also add another test that actually uses `CCoinsMap` to see if the allocator is used.\r\n\r\nAbout having a list of memory blobs per allocation size: I've thought about that, but I've tried to keep the allocator as simple as possible and didn't want to make it more complex. By the way the logic is quite a bit similar to python's pymalloc (which I've discovered after I wrote most of it...): https://www.evanjones.ca/memoryallocator/ Newer versions have multiple pools of different byte sizes, and also the ability to actually free chunks. Of course then the allocator would become much more complex.\r\n\r\n@ryanofsky Node based containers are all containers where for each element they need to allocate data (the actual content + some control structure). For `std::unordered_map` that node usually consists of key+value pair and a pointer. Sometimes hash value is also stored in the node. Only `std::vector`, `std::deque`, `std::array` are not node based. The nodes are a big performance issue because it's always a layer of indirection and requires allocation, but it is necessary so pointers/references to data stays valid even when the container is modified.",
      "created_at" : "2021-10-12T15:29:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941122228",
      "id" : 941122228,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5844GGK0",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941122228/reactions"
      },
      "updated_at" : "2021-10-12T15:29:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941122228",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Makes sense! I didn't know that about those containers.",
      "created_at" : "2021-10-12T15:30:06Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941122988",
      "id" : 941122988,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5844GGWs",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941122988/reactions"
      },
      "updated_at" : "2021-10-12T15:30:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941122988",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@martinus Ah good, the unit tests covering this that way mostly alleviates my concern. I'll review the code.",
      "created_at" : "2021-10-12T15:30:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-941123677",
      "id" : 941123677,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5844GGhd",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 1,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941123677/reactions"
      },
      "updated_at" : "2021-10-12T15:31:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/941123677",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r728671072"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/728671072"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "typo: \"puts p back into the free list **if** it was...\"",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-14T06:27:38Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r728671072",
      "id" : 728671072,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584rbqNg",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 164,
      "original_position" : 164,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 779353334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/728671072/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T08:33:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/728671072",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734648036"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734648036"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\n`m_untouched_memory_end` is always `m_allocated_blocks.back() + alloc_size`. Seems like it would be safer and less confusing to drop this unnecessary variable. Safer to avoid possibility of bugs where object gets into an inconsistent state. Less confusing to need one less variable to understand this.",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-22T15:34:03Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734648036",
      "id" : 734648036,
      "line" : 248,
      "node_id" : "PRRC_kwDOABII584rydbk",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 267,
      "original_position" : 267,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 248,
      "pull_request_review_id" : 787000548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734648036/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-22T22:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734648036",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734663213"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734663213"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nWhy are individual allocations sometimes called \"chunks\" and sometimes called \"nodes\"? Can we drop \"chunk\" terminology and just refer to individual allocations consistently as nodes? \r\n\r\nPersonally I would love to drop the custom chunk/node/block terms entirely, just call the allocator a fixed size allocator,  call the allocations allocations, and call the blocks pools. Just IMO, though.",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-22T15:54:37Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734663213",
      "id" : 734663213,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584ryhIt",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 86,
      "original_position" : 86,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 787000548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734663213/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-22T22:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734663213",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734678036"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734678036"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nStrictly speaking, keeping ChunkNode structs aligned shouldn't be required, because we could `memcpy` them to and from the empty spaces instead of `static_cast`ing them. But I guess not taking the max alignment is unlikely to save any space, if we already need to use the max size anyway? \r\n\r\nIn any case, it would be good to have sentence here to say why this is using ChunkNode alignment, since it seems like ChunkNode alignment shouldn't need to matter in principle.",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-22T16:15:44Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734678036",
      "id" : 734678036,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584rykwU",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 230,
      "original_position" : 230,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 787000548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734678036/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-22T22:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734678036",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734785167"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734785167"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nIt seems like it would be more ideal for chunk_size_bytes to be a compile time constant (template parameter) instead of a runtime constant (class member), since in all cases can be known at compile time, and the fact that it isn't mean that other things like size of a block can't be constant either. Not being able to easily compute size of the block (it requires runtime multiplication and division) I think indirectly led to `m_untouched_memory_end` being added unnecessarily. Not having a compile-time block size also appears to be a reason `m_allocated_blocks` is using `void*` and raw new/deletes instead of safer types like `std::unique_ptr` and `std::array`\r\n\r\nMaking this const would also have more minor benefit of improving clarity by being able to declare useful constants up front and not have things like  `/ m_chunk_size_bytes * m_chunk_size_bytes` various places in the code.",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-22T19:11:34Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734785167",
      "id" : 734785167,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584ry-6P",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 93,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 787000548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734785167/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-22T22:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734785167",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734826521"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734826521"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nThis could go away using std::unique_ptr",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-22T20:30:21Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734826521",
      "id" : 734826521,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584rzJAZ",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 116,
      "original_position" : 116,
      "original_start_line" : 103,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 787000548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734826521/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-10-22T22:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734826521",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734831606"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734831606"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nExposing this method seems pretty dubious. Maybe do `friend class MemoryResourceTester;` instead and move it to test code. My concerns here are verbosity of this header, and temptation for someone to call this inappropriately in some performance counter or log statement. If this should be exposed publicly, maybe it should have a name like `CountFreeChunks` so it doesn't look like an innocuous accessor method.",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-22T20:41:04Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734831606",
      "id" : 734831606,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584rzKP2",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 204,
      "original_position" : 204,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 787000548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734831606/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-22T22:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734831606",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734835564"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734835564"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nSuggestion not for here, but I wouldn't mind some other PR adding simple `CEIL_DIV`, `ROUND_UP` util macros and using them places like this.",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-22T20:49:24Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734835564",
      "id" : 734835564,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584rzLNs",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 234,
      "original_position" : 234,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 787000548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734835564/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-22T22:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734835564",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734838852"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734838852"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nThis should be removed since it's true by definition that `sizeof` returns `char` sized units and `sizeof(char)` is `1`. Size of a char can vary (it is `CHAR_BIT` bits which is usually `8`), but I don't think any code here depends on a particular char size. ",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-22T20:56:20Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734838852",
      "id" : 734838852,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584rzMBE",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 244,
      "original_position" : 244,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 787000548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734838852/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-22T22:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734838852",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734842535"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734842535"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nI think this should be named `MaxBlockSizeBytes` instead of `BlockSizeBytes` since actual block size may be slightly less depending on alignment. Also convention is to use snake case for variable/constant names and camel case for type/function names, so maybe would be good `MAX_BLOCK_SIZE_BYTES` to also make it more obvious this is a compile-time constant.",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-22T21:04:23Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734842535",
      "id" : 734842535,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584rzM6n",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 80,
      "original_position" : 80,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 787000548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734842535/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-22T22:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734842535",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734846594"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734846594"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nThis doesn't doesn't really have anything to do with `MemoryResource`, and I'd think it should be part of the `Allocator` paragraph not the `MemoryResource` one. I'd reshuffle this design section a little bit and put `MemoryResource` paragraph first, `Allocator` paragraph second, and information about determining the node sizes third.",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-22T21:13:50Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734846594",
      "id" : 734846594,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584rzN6C",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 52,
      "original_position" : 52,
      "original_start_line" : 51,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 787000548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734846594/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-10-22T22:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734846594",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734849669"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734849669"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nCurious, when does rebinding happen? Maybe say something about when/if this would happen in a sentence here.",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-22T21:21:34Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource, which\n+ * actually does all the allocation/deallocations. So this class is just a simple wrapper that conforms to the\n+ * required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T>\n+class Allocator\n+{\n+    template <typename U>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y>\n+    friend bool operator==(const Allocator<X>& a, const Allocator<Y>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the memory resource.\n+     */\n+    explicit Allocator(MemoryResource* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734849669",
      "id" : 734849669,
      "line" : 306,
      "node_id" : "PRRC_kwDOABII584rzOqF",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 321,
      "original_position" : 321,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 306,
      "pull_request_review_id" : 787000548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734849669/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-22T22:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734849669",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734854608"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734854608"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nThese construct methods seem sketchy and prone to misuse. Can we drop these? The one place these are called is in `ReallocateCache` and it should be possible to eliminate them there by keeping the existing placement new:\r\n\r\n```c++\r\n::new (&cacheCoinsMemoryResource) MemoryResource{CCoinsMapFactory::CreateMemoryResource()};\r\n::new (&cacheCoins) CCoinsMap{CCoinsMapFactory::CreateContainer(&cacheCoinsMemoryResource)};\r\n```",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-22T21:34:11Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource, which\n+ * actually does all the allocation/deallocations. So this class is just a simple wrapper that conforms to the\n+ * required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T>\n+class Allocator\n+{\n+    template <typename U>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y>\n+    friend bool operator==(const Allocator<X>& a, const Allocator<Y>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the memory resource.\n+     */\n+    explicit Allocator(MemoryResource* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.\n+     */\n+    template <typename U>\n+    Allocator(const Allocator<U>& other) noexcept\n+        : m_memory_resource(other.m_memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Allocates n entries of the given type.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        // Forward all allocations to the memory_resource\n+        return m_memory_resource->Allocate<T>(n);\n+    }\n+\n+\n+    /**\n+     * Deallocates n entries of the given type.\n+     */\n+    void deallocate(T* p, size_t n)\n+    {\n+        m_memory_resource->Deallocate<T>(p, n);\n+    }\n+\n+private:\n+    //! Stateful allocator, where the state is a simple pointer that can be cheaply copied.\n+    MemoryResource* m_memory_resource;\n+};\n+\n+\n+/**\n+ * Since Allocator is stateful, comparison with another one only returns true if it uses the same memory_resource.\n+ */\n+template <typename T, typename U>\n+bool operator==(const Allocator<T>& a, const Allocator<U>& b) noexcept\n+{\n+    // \"Equality of an allocator is determined through the ability of allocating memory with one\n+    // allocator and deallocating it with another.\" - Jonathan MÃ¼ller\n+    // See https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+    //\n+    // For us that is the case when both allocators use the same memory resource.\n+    return a.m_memory_resource == b.m_memory_resource;\n+}\n+\n+template <typename T, typename U>\n+bool operator!=(const Allocator<T>& a, const Allocator<U>& b) noexcept\n+{\n+    return !(a == b);\n+}\n+\n+/**\n+ * Helper to create std::unordered_map which uses the node_allocator.\n+ *\n+ * This calculates the size of the container's internally used node correctly for all supported platforms,\n+ * which is also asserted by the unit tests.\n+ */\n+template <typename Key, typename Value, typename Hash = std::hash<Key>, typename Equals = std::equal_to<Key>>\n+class UnorderedMapFactory\n+{\n+public:\n+    using AllocatorType = Allocator<std::pair<const Key, Value>>;\n+    using ContainerType = std::unordered_map<Key, Value, Hash, Equals, AllocatorType>;\n+    static constexpr size_t NodeSizeBytes = memusage::NodeSize<ContainerType>::Value();\n+\n+    /**\n+     * Create the MemoryResource with correctly calculated ChunkSize.\n+     */\n+    [[nodiscard]] static MemoryResource CreateMemoryResource()\n+    {\n+        return MemoryResource{NodeSizeBytes};\n+    }\n+\n+    /**\n+     * Creates the std::unordered_map container, and asserts that the specified memory_resource is correct.\n+     */\n+    [[nodiscard]] static ContainerType CreateContainer(MemoryResource* memory_resource)\n+    {\n+        assert(memory_resource != nullptr && memory_resource->ChunkSizeBytes() == NodeSizeBytes);\n+        return ContainerType{0, Hash{}, Equals{}, AllocatorType{memory_resource}};\n+    }\n+\n+    /**\n+     * Constructs MemoryResource in the uninitialized storage pointed to by ptr.\n+     */\n+    static void Construct(MemoryResource* ptr)\n+    {\n+        assert(ptr != nullptr);\n+        ::new ((void*)ptr) MemoryResource{NodeSizeBytes};\n+    }\n+\n+    /**\n+     * Constructs the container in the uninitialized storage pointed to by ptr, using the given memory_resource as parameter.\n+     */\n+    static void Construct(ContainerType* ptr, MemoryResource* memory_resource)\n+    {\n+        assert(ptr != nullptr && memory_resource != nullptr && memory_resource->ChunkSizeBytes() == NodeSizeBytes);\n+        ::new ((void*)ptr) ContainerType{0, Hash{}, Equals{}, AllocatorType{memory_resource}};\n+    }\n+};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734854608",
      "id" : 734854608,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584rzP3Q",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 421,
      "original_position" : 421,
      "original_start_line" : 404,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 787000548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734854608/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-10-22T22:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734854608",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734858608"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734858608"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nI think it makes sense to add ReallocateCache cache (though I would be curious if someone knows a reason it wasn't added here initially).\r\n\r\nBut if we are going to add this here I think we should remove the other `ReallocateCache()` call in `validation.h` which is now redundant, and make the `ReallocateCache` method private so it is not uselessly confusing.",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-22T21:44:28Z",
      "diff_hunk" : "@@ -222,6 +222,7 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n bool CCoinsViewCache::Flush() {\n     bool fOk = base->BatchWrite(cacheCoins, hashBlock);\n     cacheCoins.clear();\n+    ReallocateCache();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734858608",
      "id" : 734858608,
      "line" : 225,
      "node_id" : "PRRC_kwDOABII584rzQ1w",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 225,
      "original_position" : 17,
      "original_start_line" : null,
      "path" : "src/coins.cpp",
      "position" : 17,
      "pull_request_review_id" : 787000548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734858608/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-22T22:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734858608",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734861053"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734861053"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In commit \"Add allocator for node based containers\" (952c37a31c39b7acdb5ab2634a354a1c548708a2)\r\n\r\nJust so this information is easily accessible, can you add a comment about how this is tested for accuracy or where the tests can be found?",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-22T21:51:16Z",
      "diff_hunk" : "@@ -148,23 +154,61 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-template<typename X>\n-struct unordered_node : private X\n-{\n-private:\n-    void* ptr;\n+template <typename T>\n+struct NodeSize {\n+};\n+\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734861053",
      "id" : 734861053,
      "line" : 162,
      "node_id" : "PRRC_kwDOABII584rzRb9",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 162,
      "original_position" : 27,
      "original_start_line" : null,
      "path" : "src/memusage.h",
      "position" : 27,
      "pull_request_review_id" : 787000548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 1,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 1,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734861053/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-22T22:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734861053",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734941728"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734941728"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "`ReallocateCache` is now necessary here, because Flush is triggered when memory is full, and with the node_allocator clear() does not free any memory the memory usage would stay constant. It was not necessary before because clear() already deallocated all of the nodes and only kept the memory for the unordered_map's internal indexing array.\r\n\r\nRight! `CoinsTip().ReallocateCache();` in validation.cpp is now unnecessary. Good catch.",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-23T08:20:03Z",
      "diff_hunk" : "@@ -222,6 +222,7 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n bool CCoinsViewCache::Flush() {\n     bool fOk = base->BatchWrite(cacheCoins, hashBlock);\n     cacheCoins.clear();\n+    ReallocateCache();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r734941728",
      "id" : 734941728,
      "in_reply_to_id" : 734858608,
      "line" : 225,
      "node_id" : "PRRC_kwDOABII584rzlIg",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 225,
      "original_position" : 17,
      "original_start_line" : null,
      "path" : "src/coins.cpp",
      "position" : 17,
      "pull_request_review_id" : 779353334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734941728/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T08:33:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/734941728",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thanks a lot for the detailed review @ryanofsky! I'll go through all that and see what I can do",
      "created_at" : "2021-10-23T14:07:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#issuecomment-950158246",
      "id" : 950158246,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22702",
      "node_id" : "IC_kwDOABII5844okOm",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/950158246/reactions"
      },
      "updated_at" : "2021-10-23T14:07:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/950158246",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735096984"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735096984"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I'd prefer to keep that member variable because it is used in `Allocate(size_t n)` which should be really fast. I think it would be a bit slower with additional indirections. Also I currently don't need special handling for when nothing is allocated yet because both pointers are initialized to nullptr",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-24T10:27:17Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735096984",
      "id" : 735096984,
      "in_reply_to_id" : 734648036,
      "line" : 248,
      "node_id" : "PRRC_kwDOABII584r0LCY",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 267,
      "original_position" : 267,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 248,
      "pull_request_review_id" : 779353334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735096984/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T08:33:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735096984",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735146196"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735146196"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The C++ API for allocators is a bit stupid, it actually happens all the time. No allocation actually ever happens with the `std::pair<const Key, Value>` type, the container's rebind to the internal node type, possibly to some control structure, and for unordered_map to the underlying array type. I'll add a comment",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-24T17:15:03Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource, which\n+ * actually does all the allocation/deallocations. So this class is just a simple wrapper that conforms to the\n+ * required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T>\n+class Allocator\n+{\n+    template <typename U>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y>\n+    friend bool operator==(const Allocator<X>& a, const Allocator<Y>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the memory resource.\n+     */\n+    explicit Allocator(MemoryResource* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735146196",
      "id" : 735146196,
      "in_reply_to_id" : 734849669,
      "line" : 306,
      "node_id" : "PRRC_kwDOABII584r0XDU",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 321,
      "original_position" : 321,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 306,
      "pull_request_review_id" : 779353334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735146196/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T08:33:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735146196",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735147340"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735147340"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Right! I'll switch to using `std::unique_ptr<char[]>`.",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-24T17:25:15Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735147340",
      "id" : 735147340,
      "in_reply_to_id" : 734826521,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584r0XVM",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 116,
      "original_position" : 116,
      "original_start_line" : 103,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 779353334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735147340/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-10-26T08:33:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735147340",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735147664"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735147664"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I've tried to make it a template argument before, but couldn't get it to compile. But I've tried it again and figured it out now, the main issue that I missed is that the `Allocator` then needs to have a `struct rebind` for this to work. (this is described in a little footnote here: https://en.cppreference.com/w/cpp/named_req/Allocator#cite_note-2 The rebind is *not* optional because the second template argument will be a `size_t`, and not a template type)",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-24T17:28:34Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735147664",
      "id" : 735147664,
      "in_reply_to_id" : 734785167,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584r0XaQ",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 93,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 779353334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735147664/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T08:33:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735147664",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735279551"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735279551"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Good idea, I didn't think about writing it that way",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-25T06:04:47Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource, which\n+ * actually does all the allocation/deallocations. So this class is just a simple wrapper that conforms to the\n+ * required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T>\n+class Allocator\n+{\n+    template <typename U>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y>\n+    friend bool operator==(const Allocator<X>& a, const Allocator<Y>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the memory resource.\n+     */\n+    explicit Allocator(MemoryResource* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.\n+     */\n+    template <typename U>\n+    Allocator(const Allocator<U>& other) noexcept\n+        : m_memory_resource(other.m_memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Allocates n entries of the given type.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        // Forward all allocations to the memory_resource\n+        return m_memory_resource->Allocate<T>(n);\n+    }\n+\n+\n+    /**\n+     * Deallocates n entries of the given type.\n+     */\n+    void deallocate(T* p, size_t n)\n+    {\n+        m_memory_resource->Deallocate<T>(p, n);\n+    }\n+\n+private:\n+    //! Stateful allocator, where the state is a simple pointer that can be cheaply copied.\n+    MemoryResource* m_memory_resource;\n+};\n+\n+\n+/**\n+ * Since Allocator is stateful, comparison with another one only returns true if it uses the same memory_resource.\n+ */\n+template <typename T, typename U>\n+bool operator==(const Allocator<T>& a, const Allocator<U>& b) noexcept\n+{\n+    // \"Equality of an allocator is determined through the ability of allocating memory with one\n+    // allocator and deallocating it with another.\" - Jonathan MÃ¼ller\n+    // See https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+    //\n+    // For us that is the case when both allocators use the same memory resource.\n+    return a.m_memory_resource == b.m_memory_resource;\n+}\n+\n+template <typename T, typename U>\n+bool operator!=(const Allocator<T>& a, const Allocator<U>& b) noexcept\n+{\n+    return !(a == b);\n+}\n+\n+/**\n+ * Helper to create std::unordered_map which uses the node_allocator.\n+ *\n+ * This calculates the size of the container's internally used node correctly for all supported platforms,\n+ * which is also asserted by the unit tests.\n+ */\n+template <typename Key, typename Value, typename Hash = std::hash<Key>, typename Equals = std::equal_to<Key>>\n+class UnorderedMapFactory\n+{\n+public:\n+    using AllocatorType = Allocator<std::pair<const Key, Value>>;\n+    using ContainerType = std::unordered_map<Key, Value, Hash, Equals, AllocatorType>;\n+    static constexpr size_t NodeSizeBytes = memusage::NodeSize<ContainerType>::Value();\n+\n+    /**\n+     * Create the MemoryResource with correctly calculated ChunkSize.\n+     */\n+    [[nodiscard]] static MemoryResource CreateMemoryResource()\n+    {\n+        return MemoryResource{NodeSizeBytes};\n+    }\n+\n+    /**\n+     * Creates the std::unordered_map container, and asserts that the specified memory_resource is correct.\n+     */\n+    [[nodiscard]] static ContainerType CreateContainer(MemoryResource* memory_resource)\n+    {\n+        assert(memory_resource != nullptr && memory_resource->ChunkSizeBytes() == NodeSizeBytes);\n+        return ContainerType{0, Hash{}, Equals{}, AllocatorType{memory_resource}};\n+    }\n+\n+    /**\n+     * Constructs MemoryResource in the uninitialized storage pointed to by ptr.\n+     */\n+    static void Construct(MemoryResource* ptr)\n+    {\n+        assert(ptr != nullptr);\n+        ::new ((void*)ptr) MemoryResource{NodeSizeBytes};\n+    }\n+\n+    /**\n+     * Constructs the container in the uninitialized storage pointed to by ptr, using the given memory_resource as parameter.\n+     */\n+    static void Construct(ContainerType* ptr, MemoryResource* memory_resource)\n+    {\n+        assert(ptr != nullptr && memory_resource != nullptr && memory_resource->ChunkSizeBytes() == NodeSizeBytes);\n+        ::new ((void*)ptr) ContainerType{0, Hash{}, Equals{}, AllocatorType{memory_resource}};\n+    }\n+};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735279551",
      "id" : 735279551,
      "in_reply_to_id" : 734854608,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584r03m_",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 421,
      "original_position" : 421,
      "original_start_line" : 404,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 779353334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735279551/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-10-26T08:33:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735279551",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735298577"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735298577"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I prefer to keep the alignment here, as far as I remember some systems can produce very slow code when using memcpy without the alignment requirement. It shouldn't matter for x86 though. I'll add a comment",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-25T06:45:04Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r735298577",
      "id" : 735298577,
      "in_reply_to_id" : 734678036,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584r08QR",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 230,
      "original_position" : 230,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 779353334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735298577/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T08:33:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/735298577",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736176745"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736176745"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "When refactoring to use compile time `NODE_SIZE_BYTES` (renamed to `ALLOCATION_SIZE_BYTES`) I can now calculate the correct blocksize right here.",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-26T06:00:08Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736176745",
      "id" : 736176745,
      "in_reply_to_id" : 734842535,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584r4Spp",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 80,
      "original_position" : 80,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 779353334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736176745/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T08:33:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736176745",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736177958"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736177958"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I also wasn't really sure what terms to use. I'll try to clean that up.",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-26T06:02:44Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736177958",
      "id" : 736177958,
      "in_reply_to_id" : 734663213,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584r4S8m",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 86,
      "original_position" : 86,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 779353334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736177958/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T08:33:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736177958",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736178494"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736178494"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "That's a good idea, then I can move `NumFreeChunks` and `NumBlocks` to the test class because it shouldn't be needed anywhere else",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-26T06:03:57Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736178494",
      "id" : 736178494,
      "in_reply_to_id" : 734831606,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584r4TE-",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 204,
      "original_position" : 204,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 779353334,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736178494/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T08:33:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736178494",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736298809"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736298809"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "fixed in 89c62017f2a099de5353579b08f79037805ca70f",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-26T08:46:35Z",
      "diff_hunk" : "@@ -0,0 +1,399 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no control structure is required for each node memory; the free list is stored in-place. This typically saves\n+ *   about 8 bytes per node.\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements. So freeing and malloc'ing again\n+ *   can have an advantageous access pattern which leads to less cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator` compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Since there is\n+ * unfortunately no way to determine the size of nodes that we want to optimize for in advance, MemoryResource uses\n+ * a simple heuristic: We assume the first call to Allocate with 1 element is for the node, and upon that first call the\n+ * MemoryResource is configured to use that as its chunk size. Note that due to this heuristic we cannot implement a\n+ * `std::pmr::memory_resource` because it does not give the information about the number of elements.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *     https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block. Whenever a node is given back\n+ *   with Deallocate(), it is put into a free list.\n+ */\n+class MemoryResource\n+{\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified block size for allocations.\n+     * Actually the real block size can be a bit smaller, it will be the largest multiple of chunk size\n+     * that fits into the block.\n+     */\n+    explicit MemoryResource(size_t block_size_byte) : m_block_size_bytes(block_size_byte) {}\n+\n+    MemoryResource() = default;\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        Clear();\n+    }\n+\n+    /**\n+     * Clears all allocated blocks.\n+     *\n+     * Memory is freed regardless if its still in use, so use with care! E.g. only after a call to clear() to the underlying container.\n+     */\n+    void Clear()\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+        m_free_chunks = nullptr;\n+        m_allocated_blocks.clear();\n+        m_chunk_size_bytes = 0U;\n+        m_untouched_memory_iterator = nullptr;\n+        m_untouched_memory_end = nullptr;\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 the memory blocks are used to give out memory. The first call with n==1\n+     * decides the chunk size.\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        // only use pool when a single element is allocated\n+        if (m_chunk_size_bytes == 0 && n == 1) {\n+            // first call to Allocate with n==1 determines chunk size\n+            m_chunk_size_bytes = required_chunk_size;\n+        }\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up front, for several reasons\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory\n+        auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, std::size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSize() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        if (m_chunk_size_bytes == 0) {\n+            return 0;\n+        }\n+        size_t alloc_size = (m_block_size_bytes / m_chunk_size_bytes) * m_chunk_size_bytes;\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to m_block_size_bytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        auto const num_chunks = m_block_size_bytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    //! A single linked list of all data available in the pool. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736298809",
      "id" : 736298809,
      "in_reply_to_id" : 693215356,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584r4wc5",
      "original_commit_id" : "6fa1a72e7dd9ff1e99c6e2ad0531619d119045f9",
      "original_line" : 257,
      "original_position" : 267,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 789052548,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736298809/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T08:46:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736298809",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736299928"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736299928"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done in 89c62017f2a099de5353579b08f79037805ca70f",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-26T08:47:48Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736299928",
      "id" : 736299928,
      "in_reply_to_id" : 734826521,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584r4wuY",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 116,
      "original_position" : 116,
      "original_start_line" : 103,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 789054076,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736299928/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-10-26T08:47:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736299928",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736300228"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300228"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in 89c62017f2a099de5353579b08f79037805ca70f",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-26T08:48:06Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736300228",
      "id" : 736300228,
      "in_reply_to_id" : 734785167,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584r4wzE",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 93,
      "original_position" : 93,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 789054455,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300228/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T08:48:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300228",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736300410"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300410"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in 89c62017f2a099de5353579b08f79037805ca70f",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-26T08:48:18Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736300410",
      "id" : 736300410,
      "in_reply_to_id" : 734831606,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584r4w16",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 204,
      "original_position" : 204,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 789054714,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300410/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T08:48:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300410",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736300724"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300724"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in 89c62017f2a099de5353579b08f79037805ca70f",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-26T08:48:35Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736300724",
      "id" : 736300724,
      "in_reply_to_id" : 734838852,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584r4w60",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 244,
      "original_position" : 244,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 789055038,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300724/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T08:48:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300724",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736300998"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300998"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in 89c62017f2a099de5353579b08f79037805ca70f",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-26T08:48:51Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736300998",
      "id" : 736300998,
      "in_reply_to_id" : 734842535,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584r4w_G",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 80,
      "original_position" : 80,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 789055353,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300998/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T08:48:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736300998",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736301223"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301223"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "reshuffled in 89c62017f2a099de5353579b08f79037805ca70f",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-26T08:49:07Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736301223",
      "id" : 736301223,
      "in_reply_to_id" : 734846594,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584r4xCn",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 52,
      "original_position" : 52,
      "original_start_line" : 51,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 789055687,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301223/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-10-26T08:49:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301223",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736301409"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301409"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "comment added in 89c62017f2a099de5353579b08f79037805ca70f",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-26T08:49:18Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource, which\n+ * actually does all the allocation/deallocations. So this class is just a simple wrapper that conforms to the\n+ * required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T>\n+class Allocator\n+{\n+    template <typename U>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y>\n+    friend bool operator==(const Allocator<X>& a, const Allocator<Y>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the memory resource.\n+     */\n+    explicit Allocator(MemoryResource* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736301409",
      "id" : 736301409,
      "in_reply_to_id" : 734849669,
      "line" : 306,
      "node_id" : "PRRC_kwDOABII584r4xFh",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 321,
      "original_position" : 321,
      "original_start_line" : null,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : 306,
      "pull_request_review_id" : 789055899,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301409/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T08:49:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301409",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736301727"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301727"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "done in 89c62017f2a099de5353579b08f79037805ca70f",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-26T08:49:39Z",
      "diff_hunk" : "@@ -0,0 +1,425 @@\n+// Copyright (c) 2019-2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_NODE_ALLOCATOR_H\n+\n+#include <memusage.h>\n+\n+#include <new>\n+#include <type_traits>\n+#include <unordered_map>\n+#include <utility>\n+#include <vector>\n+\n+/**\n+ * @brief Efficient allocator for node-based containers.\n+ *\n+ * The combination of Allocator and MemoryResource can be used as an optimization for node-based containers\n+ * that experience heavy load.\n+ *\n+ * ## Behavior\n+ *\n+ * MemoryResource mallocs blocks of memory and uses these to carve out memory for the nodes. Nodes that are\n+ * destroyed by the Allocator are actually put back into a free list for further use. This behavior has two main advantages:\n+ *\n+ * - Memory: no malloc control structure is required for each node memory; the free list is stored in-place. This typically\n+ *   saves about 16 bytes per node.\n+ *\n+ * - Performance: much fewer calls to malloc/free. Accessing / putting back entries are O(1) with low constant overhead.\n+ *\n+ * There's no free lunch, so there are also disadvantages:\n+ *\n+ * - It is necessary to know the exact size of the container internally used nodes beforehand, but there is no\n+ *   standard way to get this.\n+ *\n+ * - Memory that's been used for nodes is always put back into a free list and never given back to the system. Memory\n+ *   is only freed when the MemoryResource is destructed.\n+ *\n+ * - The free list is a simple last-in-first-out linked list, it doesn't reorder elements based on proximity. So freeing\n+ *   and malloc'ing again can become a random access pattern which can lead to more cache misses.\n+ *\n+ * ## Design & Implementation\n+ *\n+ * Allocator is a cheaply copyable, `std::allocator`-compatible type used for the containers. Similar to\n+ * `std::pmr::polymorphic_allocator`, it holds a pointer to a memory resource.\n+ *\n+ * MemoryResource is an immobile object that actually allocates, holds and manages chunks of memory. Currently it is only\n+ * able provide optimized alloc/free for a single fixed node size which is given in the constructor. Only allocations that match this\n+ * size will be provided from the preallocated blocks of memory; all other requests simply use ::operator new().\n+ * To get the correct node size in all cases it is unfortunately necessary to have a look at the various implementations of\n+ * std::unordered_map. There is currently no standard way of getting the node size programmatically.\n+ *\n+ * Node size is determined by memusage::NodeSize and verified to work in various alignment scenarios in\n+ * `node_allocator_tests/test_chunks_are_used`.\n+ *\n+ * ## Further Links\n+ *\n+ * @see CppCon 2017: Bob Steagall âHow to Write a Custom Allocatorâ https://www.youtube.com/watch?v=kSWfushlvB8\n+ * @see C++Now 2018: Arthur O'Dwyer âAn Allocator is a Handle to a Heapâ https://www.youtube.com/watch?v=0MdSJsCTRkY\n+ * @see AllocatorAwareContainer: Introduction and pitfalls of propagate_on_container_XXX defaults\n+ *      https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+ */\n+namespace node_allocator {\n+\n+/**\n+ * Actually holds and provides memory to an allocator. MemoryResource is an immobile object. It stores a number of memory blocks\n+ * (the pool) which are used to quickly give out memory of a fixed chunk size. The class is purposely kept very simple. It only\n+ * knows about \"Chunks\" and \"Blocks\".\n+ *\n+ * - Block: MemoryResource allocates one memory block at a time. These blocks are kept around until the memory resource is destroyed.\n+ *\n+ * - Chunks: Node-based containers allocate one node at a time. Whenever that happens, the MemoryResource's Allocate() gives out\n+ *   one chunk of memory. These chunks are carved out from a previously allocated memory block, or from a free list if it contains entries.\n+ *   Whenever a node is given back with Deallocate(), it is put into that free list.\n+ */\n+class MemoryResource\n+{\n+    //! Size in bytes to allocate per block, currently hardcoded to 256 KiB.\n+    static constexpr size_t BlockSizeBytes = 262144;\n+\n+public:\n+    /**\n+     * In-place linked list of the allocation chunks, used for the free list.\n+     */\n+    struct ChunkNode {\n+        void* next;\n+    };\n+\n+    /**\n+     * Construct a new Memory Resource object that uses the specified chunk size to optimize for.\n+     */\n+    explicit MemoryResource(size_t chunk_size_bytes) : m_chunk_size_bytes(chunk_size_bytes) {}\n+\n+    /**\n+     * Copying/moving a memory resource is not allowed; it is an immobile object.\n+     */\n+    MemoryResource(const MemoryResource&) = delete;\n+    MemoryResource& operator=(const MemoryResource&) = delete;\n+    MemoryResource(MemoryResource&&) = delete;\n+    MemoryResource& operator=(MemoryResource&&) = delete;\n+\n+    /**\n+     * Deallocates all allocated blocks.\n+     *\n+     * There's no Clear() method on purpose, because it would be dangerous. E.g. when calling clear() on\n+     * an unordered_map, it is not certain that all allocated chunks are given back to the MemoryResource.\n+     * Microsoft's STL still uses a control structure that might have the same size as the nodes, and therefore\n+     * needs to be kept around until the map is actually destroyed.\n+     */\n+    ~MemoryResource() noexcept\n+    {\n+        for (auto* block : m_allocated_blocks) {\n+            ::operator delete(block);\n+        }\n+    }\n+\n+    /**\n+     * Allocates memory for n times T. Only when n==1 and T's size matches m_chunk_size_bytes\n+     * the chunking mechanism is used. Otherwise, the allocation is forwarded to ::operator new().\n+     *\n+     * @tparam T Object to allocate memory for.\n+     * @param n Number of objects to allocate for\n+     */\n+    template <typename T>\n+    [[nodiscard]] T* Allocate(size_t n)\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes != required_chunk_size || n != 1) {\n+            // pool is not used so forward to operator new.\n+            return static_cast<T*>(::operator new(n * sizeof(T)));\n+        }\n+\n+        // chunk size is correct, so we can actually use the pool's block data\n+\n+        if (m_free_chunks) {\n+            // we've already got data in the free list, unlink one element\n+            auto old_head = m_free_chunks;\n+            m_free_chunks = static_cast<ChunkNode*>(m_free_chunks)->next;\n+            return static_cast<T*>(old_head);\n+        }\n+\n+        // free list is empty: get one chunk from allocated block memory.\n+        // It makes sense to not create the fully linked list of an allocated block up-front, for several reasons.\n+        // On the one hand, the latency is higher when we need to iterate and update pointers for the whole block at once.\n+        // More importantly, most systems lazily allocate data. So when we allocate a big block of memory the memory for a page\n+        // is only actually made available to the program when it is first touched. So when we allocate a big block and only use\n+        // very little memory from it, the total memory usage is lower than what has been malloc'ed.\n+        if (m_untouched_memory_iterator == m_untouched_memory_end) {\n+            // slow path, only happens when a new block needs to be allocated\n+            AllocateNewBlock();\n+        }\n+\n+        // peel off one chunk from the untouched memory. The next pointer of in-use elements doesn't matter until it is\n+        // deallocated, only then it is used to form the free list.\n+        const auto tmp = m_untouched_memory_iterator;\n+        m_untouched_memory_iterator = static_cast<char*>(tmp) + m_chunk_size_bytes;\n+        return static_cast<T*>(tmp);\n+    }\n+\n+    /**\n+     * Puts p back into the free list f it was actually allocated from the memory block.\n+     * Otherwise, simply call ::operator delete(p).\n+     */\n+    template <typename T>\n+    void Deallocate(void* p, size_t n) noexcept\n+    {\n+        // assign to a constexpr variable to force constexpr evaluation\n+        static constexpr auto required_chunk_size_bytes = CalcRequiredChunkSizeBytes<T>();\n+\n+        if (m_chunk_size_bytes == required_chunk_size_bytes && n == 1) {\n+            // put it into the linked list\n+            const auto node = static_cast<ChunkNode*>(p);\n+            node->next = m_free_chunks;\n+            m_free_chunks = node;\n+        } else {\n+            // allocation didn't happen with the pool\n+            ::operator delete(p);\n+        }\n+    }\n+\n+    /**\n+     * Actual size in bytes that is used for one chunk (node allocation)\n+     */\n+    [[nodiscard]] size_t ChunkSizeBytes() const noexcept\n+    {\n+        return m_chunk_size_bytes;\n+    }\n+\n+    /**\n+     * Calculates bytes allocated by the memory resource.\n+     */\n+    [[nodiscard]] size_t DynamicMemoryUsage() const noexcept\n+    {\n+        const size_t alloc_size{(BlockSizeBytes / m_chunk_size_bytes) * m_chunk_size_bytes};\n+        return memusage::MallocUsage(alloc_size) * m_allocated_blocks.size() + memusage::DynamicUsage(m_allocated_blocks);\n+    }\n+\n+    /**\n+     * Counts number of free entries in the free list. This is an O(n) operation. Mostly for debugging / logging / testing.\n+     */\n+    [[nodiscard]] size_t NumFreeChunks() const noexcept\n+    {\n+        size_t length = 0;\n+        auto node = m_free_chunks;\n+        while (node) {\n+            node = static_cast<ChunkNode const*>(node)->next;\n+            ++length;\n+        }\n+        return length;\n+    }\n+\n+    /**\n+     * Number of memory blocks that have been allocated\n+     */\n+    [[nodiscard]] size_t NumBlocks() const noexcept\n+    {\n+        return m_allocated_blocks.size();\n+    }\n+\n+    /**\n+     * Calculates the required chunk size for the given type.\n+     * The memory block needs to be correctly aligned and large enough to hold both T and ChunkNode.\n+     */\n+    template <typename T>\n+    [[nodiscard]] static constexpr size_t CalcRequiredChunkSizeBytes() noexcept\n+    {\n+        const auto alignment_max = std::max(std::alignment_of_v<T>, std::alignment_of_v<ChunkNode>);\n+        const auto size_max = std::max(sizeof(T), sizeof(ChunkNode));\n+\n+        // find closest multiple of alignment_max that holds size_max\n+        return ((size_max + alignment_max - 1U) / alignment_max) * alignment_max;\n+    }\n+\n+private:\n+    /**\n+     * Allocate one full memory block which is used to carve out chunks.\n+     * The block size is the multiple of m_chunk_size_bytes that comes closest to BlockSizeBytes.\n+     */\n+    void AllocateNewBlock()\n+    {\n+        static_assert(sizeof(char) == 1U);\n+\n+        const auto num_chunks = BlockSizeBytes / m_chunk_size_bytes;\n+        m_untouched_memory_iterator = ::operator new(num_chunks* m_chunk_size_bytes);\n+        m_untouched_memory_end = static_cast<char*>(m_untouched_memory_iterator) + num_chunks * m_chunk_size_bytes;\n+        m_allocated_blocks.push_back(m_untouched_memory_iterator);\n+    }\n+\n+    /**\n+     * The MemoryResource's size for the memory chunks that it can give out.\n+     */\n+    size_t const m_chunk_size_bytes;\n+\n+    //! A contains all allocated blocks of memory, used to free the data in the destructor.\n+    std::vector<void*> m_allocated_blocks{};\n+\n+    //! A single linked list of all data available in the MemoryResource. This list is used for allocations of single elements.\n+    void* m_free_chunks = nullptr;\n+\n+    //! Points to the beginning of available memory for carving out chunks.\n+    void* m_untouched_memory_iterator = nullptr;\n+\n+    //! Points to the end of available memory for carving out chunks.\n+    void* m_untouched_memory_end = nullptr;\n+};\n+\n+\n+/**\n+ * Allocator that's usable for node-based containers like std::unordered_map or std::list.\n+ *\n+ * The allocator is stateful, and can be cheaply copied. Its state is an immobile MemoryResource, which\n+ * actually does all the allocation/deallocations. So this class is just a simple wrapper that conforms to the\n+ * required STL interface to be usable for the node-based containers.\n+ */\n+template <typename T>\n+class Allocator\n+{\n+    template <typename U>\n+    friend class Allocator;\n+\n+    template <typename X, typename Y>\n+    friend bool operator==(const Allocator<X>& a, const Allocator<Y>& b) noexcept;\n+\n+public:\n+    using value_type = T;\n+\n+    /**\n+     * The allocator is stateful so we can't use the compile time `is_always_equal` optimization and have to use the runtime operator==.\n+     */\n+    using is_always_equal = std::false_type;\n+\n+    /**\n+     * Move assignment should be a fast operation. In the case of a = std::move(b), we want\n+     * a to be able to use b's allocator, otherwise all elements would have to be recreated with a's old allocator.\n+     */\n+    using propagate_on_container_move_assignment = std::true_type;\n+\n+    /**\n+     * Swapping two containers with unequal allocators who are *not* propagated is undefined\n+     * behavior. Unfortunately this is the default! Obviously, we don't want that.\n+     */\n+    using propagate_on_container_swap = std::true_type; // to avoid the undefined behavior\n+\n+    /**\n+     * Move and swap have to propagate the allocator, so for consistency we do the same for copy assignment.\n+     */\n+    using propagate_on_container_copy_assignment = std::true_type;\n+\n+    /**\n+     * Construct a new Allocator object which will delegate all allocations/deallocations to the memory resource.\n+     */\n+    explicit Allocator(MemoryResource* memory_resource) noexcept\n+        : m_memory_resource(memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Conversion constructor for rebinding. All Allocators use the same memory_resource.\n+     */\n+    template <typename U>\n+    Allocator(const Allocator<U>& other) noexcept\n+        : m_memory_resource(other.m_memory_resource)\n+    {\n+    }\n+\n+    /**\n+     * Allocates n entries of the given type.\n+     */\n+    T* allocate(size_t n)\n+    {\n+        // Forward all allocations to the memory_resource\n+        return m_memory_resource->Allocate<T>(n);\n+    }\n+\n+\n+    /**\n+     * Deallocates n entries of the given type.\n+     */\n+    void deallocate(T* p, size_t n)\n+    {\n+        m_memory_resource->Deallocate<T>(p, n);\n+    }\n+\n+private:\n+    //! Stateful allocator, where the state is a simple pointer that can be cheaply copied.\n+    MemoryResource* m_memory_resource;\n+};\n+\n+\n+/**\n+ * Since Allocator is stateful, comparison with another one only returns true if it uses the same memory_resource.\n+ */\n+template <typename T, typename U>\n+bool operator==(const Allocator<T>& a, const Allocator<U>& b) noexcept\n+{\n+    // \"Equality of an allocator is determined through the ability of allocating memory with one\n+    // allocator and deallocating it with another.\" - Jonathan MÃ¼ller\n+    // See https://www.foonathan.net/2015/10/allocatorawarecontainer-propagation-pitfalls/\n+    //\n+    // For us that is the case when both allocators use the same memory resource.\n+    return a.m_memory_resource == b.m_memory_resource;\n+}\n+\n+template <typename T, typename U>\n+bool operator!=(const Allocator<T>& a, const Allocator<U>& b) noexcept\n+{\n+    return !(a == b);\n+}\n+\n+/**\n+ * Helper to create std::unordered_map which uses the node_allocator.\n+ *\n+ * This calculates the size of the container's internally used node correctly for all supported platforms,\n+ * which is also asserted by the unit tests.\n+ */\n+template <typename Key, typename Value, typename Hash = std::hash<Key>, typename Equals = std::equal_to<Key>>\n+class UnorderedMapFactory\n+{\n+public:\n+    using AllocatorType = Allocator<std::pair<const Key, Value>>;\n+    using ContainerType = std::unordered_map<Key, Value, Hash, Equals, AllocatorType>;\n+    static constexpr size_t NodeSizeBytes = memusage::NodeSize<ContainerType>::Value();\n+\n+    /**\n+     * Create the MemoryResource with correctly calculated ChunkSize.\n+     */\n+    [[nodiscard]] static MemoryResource CreateMemoryResource()\n+    {\n+        return MemoryResource{NodeSizeBytes};\n+    }\n+\n+    /**\n+     * Creates the std::unordered_map container, and asserts that the specified memory_resource is correct.\n+     */\n+    [[nodiscard]] static ContainerType CreateContainer(MemoryResource* memory_resource)\n+    {\n+        assert(memory_resource != nullptr && memory_resource->ChunkSizeBytes() == NodeSizeBytes);\n+        return ContainerType{0, Hash{}, Equals{}, AllocatorType{memory_resource}};\n+    }\n+\n+    /**\n+     * Constructs MemoryResource in the uninitialized storage pointed to by ptr.\n+     */\n+    static void Construct(MemoryResource* ptr)\n+    {\n+        assert(ptr != nullptr);\n+        ::new ((void*)ptr) MemoryResource{NodeSizeBytes};\n+    }\n+\n+    /**\n+     * Constructs the container in the uninitialized storage pointed to by ptr, using the given memory_resource as parameter.\n+     */\n+    static void Construct(ContainerType* ptr, MemoryResource* memory_resource)\n+    {\n+        assert(ptr != nullptr && memory_resource != nullptr && memory_resource->ChunkSizeBytes() == NodeSizeBytes);\n+        ::new ((void*)ptr) ContainerType{0, Hash{}, Equals{}, AllocatorType{memory_resource}};\n+    }\n+};",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736301727",
      "id" : 736301727,
      "in_reply_to_id" : 734854608,
      "line" : null,
      "node_id" : "PRRC_kwDOABII584r4xKf",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 421,
      "original_position" : 421,
      "original_start_line" : 404,
      "path" : "src/support/allocators/node_allocator.h",
      "position" : null,
      "pull_request_review_id" : 789056337,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301727/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2021-10-26T08:49:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736301727",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736304047"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736304047"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done that in a separate commit in 1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "commit_id" : "1e4a65b21c70ee745a8ae02c3af109f4f5e16422",
      "created_at" : "2021-10-26T08:52:12Z",
      "diff_hunk" : "@@ -222,6 +222,7 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n bool CCoinsViewCache::Flush() {\n     bool fOk = base->BatchWrite(cacheCoins, hashBlock);\n     cacheCoins.clear();\n+    ReallocateCache();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736304047",
      "id" : 736304047,
      "in_reply_to_id" : 734858608,
      "line" : 225,
      "node_id" : "PRRC_kwDOABII584r4xuv",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 225,
      "original_position" : 17,
      "original_start_line" : null,
      "path" : "src/coins.cpp",
      "position" : 17,
      "pull_request_review_id" : 789059441,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736304047/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T08:52:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736304047",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736401678"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736401678"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Added in a91b603 ",
      "commit_id" : "a91b6032f037ab1a26ac4baa761e809fbfeb1bdd",
      "created_at" : "2021-10-26T10:51:22Z",
      "diff_hunk" : "@@ -148,23 +154,61 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-template<typename X>\n-struct unordered_node : private X\n-{\n-private:\n-    void* ptr;\n+template <typename T>\n+struct NodeSize {\n+};\n+\n+template <typename Key, typename V, typename Hash, typename Equals, typename Allocator>\n+struct NodeSize<std::unordered_map<Key, V, Hash, Equals, Allocator>> {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22702#discussion_r736401678",
      "id" : 736401678,
      "in_reply_to_id" : 734861053,
      "line" : 165,
      "node_id" : "PRRC_kwDOABII584r5JkO",
      "original_commit_id" : "952c37a31c39b7acdb5ab2634a354a1c548708a2",
      "original_line" : 162,
      "original_position" : 27,
      "original_start_line" : null,
      "path" : "src/memusage.h",
      "position" : 30,
      "pull_request_review_id" : 789190496,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/22702",
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736401678/reactions"
      },
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-10-26T10:51:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/736401678",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   }
]
