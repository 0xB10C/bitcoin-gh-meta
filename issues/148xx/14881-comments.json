[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239370263"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239370263"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could move these declarations to the test file, so that production code does not have access to the declarations.\r\n\r\nWould benefit from `EXCLUSIVE_LOCKS_REQUIRED` on `AddTimeDataAlgorithm` - which if I'm not mistaken could be applied to the body of the method rather than the declaration.",
      "commit_id" : "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "created_at" : "2018-12-06T08:56:23Z",
      "diff_hunk" : "@@ -75,4 +76,8 @@ int64_t GetTimeOffset();\n int64_t GetAdjustedTime();\n void AddTimeData(const CNetAddr& ip, int64_t nTime);\n \n+/** Functions to enable testing the contract for AddTimeData */\n+int CountOffsetSamples();\n+void AddTimeDataAlgorithm(const CNetAddr& ip, const int64_t nOffsetSample, std::set<CNetAddr>& knownSet, CMedianFilter<int64_t>& offsetFilter, int64_t& offset);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239370263",
      "id" : 239370263,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzOTM3MDI2Mw==",
      "original_commit_id" : "c4cd6dabde865558c98dc50de64dbaf6228eff09",
      "original_position" : 14,
      "path" : "src/timedata.h",
      "position" : 14,
      "pull_request_review_id" : 182134528,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881",
      "updated_at" : "2018-12-06T21:09:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239370263",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/5470?v=4",
         "events_url" : "https://api.github.com/users/Empact/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Empact/followers",
         "following_url" : "https://api.github.com/users/Empact/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Empact/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Empact",
         "id" : 5470,
         "login" : "Empact",
         "node_id" : "MDQ6VXNlcjU0NzA=",
         "organizations_url" : "https://api.github.com/users/Empact/orgs",
         "received_events_url" : "https://api.github.com/users/Empact/received_events",
         "repos_url" : "https://api.github.com/users/Empact/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Empact/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Empact/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Empact"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239602774"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239602774"
         }
      },
      "author_association" : "NONE",
      "body" : "Hi Empact.\r\n\r\nThank you for the feedback, but I prefer to keep modifications to a minimum. Apart from this, I am a newbie with this code and not really proficient with C/C++, which is actually why I am focusing on unit testing in the first place. Functions added are either read only or do not modify the runtime data. That is why I did this in the first place. \r\n\r\nFirst priority here is to dig out the contract and make it testable the way it is now. I consider this as a prerequisite for any subsequent changes.\r\n\r\nIf you have any hints, then please be more explicit, as I partly understand your approach, but do not really know how to implement it in a safe manner.",
      "commit_id" : "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "created_at" : "2018-12-06T20:28:34Z",
      "diff_hunk" : "@@ -75,4 +76,8 @@ int64_t GetTimeOffset();\n int64_t GetAdjustedTime();\n void AddTimeData(const CNetAddr& ip, int64_t nTime);\n \n+/** Functions to enable testing the contract for AddTimeData */\n+int CountOffsetSamples();\n+void AddTimeDataAlgorithm(const CNetAddr& ip, const int64_t nOffsetSample, std::set<CNetAddr>& knownSet, CMedianFilter<int64_t>& offsetFilter, int64_t& offset);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239602774",
      "id" : 239602774,
      "in_reply_to_id" : 239370263,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzOTYwMjc3NA==",
      "original_commit_id" : "c4cd6dabde865558c98dc50de64dbaf6228eff09",
      "original_position" : 14,
      "path" : "src/timedata.h",
      "position" : 14,
      "pull_request_review_id" : 182433176,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881",
      "updated_at" : "2018-12-06T21:09:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239602774",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1525975?v=4",
         "events_url" : "https://api.github.com/users/mmachicao/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mmachicao/followers",
         "following_url" : "https://api.github.com/users/mmachicao/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mmachicao/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mmachicao",
         "id" : 1525975,
         "login" : "mmachicao",
         "node_id" : "MDQ6VXNlcjE1MjU5NzU=",
         "organizations_url" : "https://api.github.com/users/mmachicao/orgs",
         "received_events_url" : "https://api.github.com/users/mmachicao/received_events",
         "repos_url" : "https://api.github.com/users/mmachicao/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mmachicao/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mmachicao/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mmachicao"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239816019"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239816019"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You could include `compat.h` instead.",
      "commit_id" : "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "created_at" : "2018-12-07T13:59:23Z",
      "diff_hunk" : "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n //\n #include <netaddress.h>\n+#include <arpa/inet.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239816019",
      "id" : 239816019,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzOTgxNjAxOQ==",
      "original_commit_id" : "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "original_position" : 4,
      "path" : "src/test/timedata_tests.cpp",
      "position" : 6,
      "pull_request_review_id" : 182703446,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881",
      "updated_at" : "2018-12-07T13:59:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239816019",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/11154118?v=4",
         "events_url" : "https://api.github.com/users/ken2812221/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ken2812221/followers",
         "following_url" : "https://api.github.com/users/ken2812221/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ken2812221/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ken2812221",
         "id" : 11154118,
         "login" : "ken2812221",
         "node_id" : "MDQ6VXNlcjExMTU0MTE4",
         "organizations_url" : "https://api.github.com/users/ken2812221/orgs",
         "received_events_url" : "https://api.github.com/users/ken2812221/received_events",
         "repos_url" : "https://api.github.com/users/ken2812221/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ken2812221/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ken2812221/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ken2812221"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239935051"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239935051"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`address` should be const ref?",
      "commit_id" : "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "created_at" : "2018-12-07T20:19:56Z",
      "diff_hunk" : "@@ -34,4 +36,209 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+\n+CNetAddr utilBuildAddress(std::string address);\n+\n+void utilPreconditionIsAtLeastFiveEntriesRequired(std::string baseip, int basevalue);\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataComputeOffsetWhenSampleCountIsUneven)\n+{\n+    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 200); // precondition 1: at least 5 entries required to compute any offset\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+\n+    if ((CountOffsetSamples() % 2) == 1) { // precondition 2: start with an even number of samples\n+        AddTimeData(utilBuildAddress(\"1.1.1.210\"), 210);\n+    }\n+\n+    BOOST_CHECK(CountOffsetSamples() % 2 == 0);\n+\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(utilBuildAddress(\"1.1.1.211\"), 211);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n+    BOOST_CHECK(GetTimeOffset() != offset);               // and new offset was computed\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataDoNotComputeOffsetWhenSampleCountIsEven)\n+{\n+    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 100); // precondition 1: at least 5 entries required to compute any offset\n+\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+    if (CountOffsetSamples() % 2 == 0) { // precondition 2: start with an uneven number of samples\n+        AddTimeData(utilBuildAddress(\"1.1.1.110\"), 110);\n+    }\n+\n+    BOOST_CHECK(CountOffsetSamples() % 2 == 1);\n+\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(utilBuildAddress(\"1.1.1.111\"), 111);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n+    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);           //new offset was not computed\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataIgnoreSampleWithDuplicateIP)\n+{\n+    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 300); // precondition 1: at least 5 entries required to compute any offset\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+\n+    AddTimeData(utilBuildAddress(\"1.1.1.310\"), 310);\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(utilBuildAddress(\"1.1.1.310\"), 311);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples); // sample was ignored\n+    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);       //new offset was not computed\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsWithinBounds)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : 10 , init value: 0\n+\n+\n+    for (int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all within bounds\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(utilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+    }\n+\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+\n+    BOOST_CHECK_EQUAL(offset, offsetFilter.median());\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 5);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsOutsideBounds)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+    for (int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all outside bounds\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << 1 + sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(utilBuildAddress(ip), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset);\n+    } // sorted filter: 0 x x x  -- x is outside the boundaries\n+\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n+\n+    // offset is computed only when number of entries is uneven\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.5\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 (x) x x  -- median (x)\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.6\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 x x x\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.7\"), 1, knownSet, offsetFilter, offset);                               // sorted filter : 0 1 1 (1) x x x x -- median (1)\n+    BOOST_CHECK_EQUAL(offset, 1);                                                                                       // flip to 1\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.8\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 x x x x x\n+    BOOST_CHECK_EQUAL(offset, 1);\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.9\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 (x) x x x x x -- median (x)\n+    BOOST_CHECK_EQUAL(offset, 0);                                                                                       // flip back to zero\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 9);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmAtLeastFiveSamplesToComputeOffset)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.1\"), 1, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.2\"), 2, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.3\"), 3, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.4\"), 4, knownSet, offsetFilter, offset); // this is the fifth entry\n+    BOOST_CHECK_EQUAL(offset, 2);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmIgnoresSamplesBeyondInternalLimit)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+\n+    for (int sample = 1; sample < limit; sample++) { // precondition: limit samples\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(utilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+    }\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), limit);\n+\n+    int64_t pre = offset;\n+    int size = offsetFilter.size();\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+\n+    BOOST_CHECK_EQUAL(offset, pre);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), size);\n+}\n+\n+\n+CNetAddr utilBuildAddress(std::string address)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239935051",
      "id" : 239935051,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzOTkzNTA1MQ==",
      "original_commit_id" : "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "original_position" : 201,
      "path" : "src/test/timedata_tests.cpp",
      "position" : 201,
      "pull_request_review_id" : 182858668,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881",
      "updated_at" : "2018-12-07T20:19:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239935051",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239935388"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239935388"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here: `baseip` should be const ref?",
      "commit_id" : "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "created_at" : "2018-12-07T20:21:10Z",
      "diff_hunk" : "@@ -34,4 +36,209 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+\n+CNetAddr utilBuildAddress(std::string address);\n+\n+void utilPreconditionIsAtLeastFiveEntriesRequired(std::string baseip, int basevalue);\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataComputeOffsetWhenSampleCountIsUneven)\n+{\n+    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 200); // precondition 1: at least 5 entries required to compute any offset\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+\n+    if ((CountOffsetSamples() % 2) == 1) { // precondition 2: start with an even number of samples\n+        AddTimeData(utilBuildAddress(\"1.1.1.210\"), 210);\n+    }\n+\n+    BOOST_CHECK(CountOffsetSamples() % 2 == 0);\n+\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(utilBuildAddress(\"1.1.1.211\"), 211);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n+    BOOST_CHECK(GetTimeOffset() != offset);               // and new offset was computed\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataDoNotComputeOffsetWhenSampleCountIsEven)\n+{\n+    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 100); // precondition 1: at least 5 entries required to compute any offset\n+\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+    if (CountOffsetSamples() % 2 == 0) { // precondition 2: start with an uneven number of samples\n+        AddTimeData(utilBuildAddress(\"1.1.1.110\"), 110);\n+    }\n+\n+    BOOST_CHECK(CountOffsetSamples() % 2 == 1);\n+\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(utilBuildAddress(\"1.1.1.111\"), 111);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n+    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);           //new offset was not computed\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataIgnoreSampleWithDuplicateIP)\n+{\n+    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 300); // precondition 1: at least 5 entries required to compute any offset\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+\n+    AddTimeData(utilBuildAddress(\"1.1.1.310\"), 310);\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(utilBuildAddress(\"1.1.1.310\"), 311);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples); // sample was ignored\n+    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);       //new offset was not computed\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsWithinBounds)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : 10 , init value: 0\n+\n+\n+    for (int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all within bounds\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(utilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+    }\n+\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+\n+    BOOST_CHECK_EQUAL(offset, offsetFilter.median());\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 5);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsOutsideBounds)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+    for (int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all outside bounds\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << 1 + sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(utilBuildAddress(ip), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset);\n+    } // sorted filter: 0 x x x  -- x is outside the boundaries\n+\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n+\n+    // offset is computed only when number of entries is uneven\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.5\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 (x) x x  -- median (x)\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.6\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 x x x\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.7\"), 1, knownSet, offsetFilter, offset);                               // sorted filter : 0 1 1 (1) x x x x -- median (1)\n+    BOOST_CHECK_EQUAL(offset, 1);                                                                                       // flip to 1\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.8\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 x x x x x\n+    BOOST_CHECK_EQUAL(offset, 1);\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.9\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 (x) x x x x x -- median (x)\n+    BOOST_CHECK_EQUAL(offset, 0);                                                                                       // flip back to zero\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 9);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmAtLeastFiveSamplesToComputeOffset)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.1\"), 1, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.2\"), 2, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.3\"), 3, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.4\"), 4, knownSet, offsetFilter, offset); // this is the fifth entry\n+    BOOST_CHECK_EQUAL(offset, 2);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmIgnoresSamplesBeyondInternalLimit)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+\n+    for (int sample = 1; sample < limit; sample++) { // precondition: limit samples\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(utilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+    }\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), limit);\n+\n+    int64_t pre = offset;\n+    int size = offsetFilter.size();\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+\n+    BOOST_CHECK_EQUAL(offset, pre);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), size);\n+}\n+\n+\n+CNetAddr utilBuildAddress(std::string address)\n+{\n+    struct sockaddr_in sa;\n+    inet_pton(AF_INET, address.c_str(), &(sa.sin_addr));\n+    CNetAddr addr = CNetAddr(sa.sin_addr);\n+    return addr;\n+}\n+\n+\n+void utilPreconditionIsAtLeastFiveEntriesRequired(std::string baseip, int basevalue)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239935388",
      "id" : 239935388,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzOTkzNTM4OA==",
      "original_commit_id" : "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "original_position" : 210,
      "path" : "src/test/timedata_tests.cpp",
      "position" : 210,
      "pull_request_review_id" : 182859059,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881",
      "updated_at" : "2018-12-07T20:21:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239935388",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239935482"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239935482"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The call to `c_str` is not needed here. The function takes `std::string`.",
      "commit_id" : "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "created_at" : "2018-12-07T20:21:33Z",
      "diff_hunk" : "@@ -34,4 +36,209 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+\n+CNetAddr utilBuildAddress(std::string address);\n+\n+void utilPreconditionIsAtLeastFiveEntriesRequired(std::string baseip, int basevalue);\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataComputeOffsetWhenSampleCountIsUneven)\n+{\n+    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 200); // precondition 1: at least 5 entries required to compute any offset\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+\n+    if ((CountOffsetSamples() % 2) == 1) { // precondition 2: start with an even number of samples\n+        AddTimeData(utilBuildAddress(\"1.1.1.210\"), 210);\n+    }\n+\n+    BOOST_CHECK(CountOffsetSamples() % 2 == 0);\n+\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(utilBuildAddress(\"1.1.1.211\"), 211);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n+    BOOST_CHECK(GetTimeOffset() != offset);               // and new offset was computed\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataDoNotComputeOffsetWhenSampleCountIsEven)\n+{\n+    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 100); // precondition 1: at least 5 entries required to compute any offset\n+\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+    if (CountOffsetSamples() % 2 == 0) { // precondition 2: start with an uneven number of samples\n+        AddTimeData(utilBuildAddress(\"1.1.1.110\"), 110);\n+    }\n+\n+    BOOST_CHECK(CountOffsetSamples() % 2 == 1);\n+\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(utilBuildAddress(\"1.1.1.111\"), 111);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples + 1); // sample was added\n+    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);           //new offset was not computed\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataIgnoreSampleWithDuplicateIP)\n+{\n+    utilPreconditionIsAtLeastFiveEntriesRequired(\"1.1.1.\", 300); // precondition 1: at least 5 entries required to compute any offset\n+    BOOST_CHECK(CountOffsetSamples() >= 5);\n+\n+\n+    AddTimeData(utilBuildAddress(\"1.1.1.310\"), 310);\n+\n+    int64_t offset = GetTimeOffset();\n+    int samples = CountOffsetSamples();\n+    AddTimeData(utilBuildAddress(\"1.1.1.310\"), 311);\n+\n+    BOOST_CHECK_EQUAL(CountOffsetSamples(), samples); // sample was ignored\n+    BOOST_CHECK_EQUAL(GetTimeOffset(), offset);       //new offset was not computed\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsWithinBounds)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : 10 , init value: 0\n+\n+\n+    for (int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all within bounds\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(utilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+    }\n+\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+\n+    BOOST_CHECK_EQUAL(offset, offsetFilter.median());\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 5);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmMedianIsOutsideBounds)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+    for (int sample = 1; sample < 4; sample++) { // precondition: 4 samples, all outside bounds\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << 1 + sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(utilBuildAddress(ip), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset);\n+    } // sorted filter: 0 x x x  -- x is outside the boundaries\n+\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 4);\n+\n+    // offset is computed only when number of entries is uneven\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.5\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 (x) x x  -- median (x)\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.6\"), 1, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 x x x\n+    BOOST_CHECK_EQUAL(offset, 0);\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.7\"), 1, knownSet, offsetFilter, offset);                               // sorted filter : 0 1 1 (1) x x x x -- median (1)\n+    BOOST_CHECK_EQUAL(offset, 1);                                                                                       // flip to 1\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.8\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 x x x x x\n+    BOOST_CHECK_EQUAL(offset, 1);\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.9\"), 2 * DEFAULT_MAX_TIME_ADJUSTMENT, knownSet, offsetFilter, offset); // sorted filter : 0 1 1 1 (x) x x x x x -- median (x)\n+    BOOST_CHECK_EQUAL(offset, 0);                                                                                       // flip back to zero\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), 9);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmAtLeastFiveSamplesToComputeOffset)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.1\"), 1, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.2\"), 2, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.3\"), 3, knownSet, offsetFilter, offset);\n+    BOOST_CHECK_EQUAL(offset, 0);\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.4\"), 4, knownSet, offsetFilter, offset); // this is the fifth entry\n+    BOOST_CHECK_EQUAL(offset, 2);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_AddTimeDataAlgorithmIgnoresSamplesBeyondInternalLimit)\n+{\n+    int limit = 10;\n+    int64_t offset = 0;\n+    std::set<CNetAddr> knownSet;\n+    CMedianFilter<int64_t> offsetFilter(limit, 0); // max size : limit , init value: 0\n+\n+\n+    for (int sample = 1; sample < limit; sample++) { // precondition: limit samples\n+        std::stringstream stream;\n+        stream << \"1.1.1.\" << sample;\n+        std::string ip = stream.str();\n+        AddTimeDataAlgorithm(utilBuildAddress(ip), sample, knownSet, offsetFilter, offset);\n+    }\n+\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), limit);\n+\n+    int64_t pre = offset;\n+    int size = offsetFilter.size();\n+\n+    AddTimeDataAlgorithm(utilBuildAddress(\"1.1.1.200\"), 200, knownSet, offsetFilter, offset);\n+\n+    BOOST_CHECK_EQUAL(offset, pre);\n+    BOOST_CHECK_EQUAL(offsetFilter.size(), size);\n+}\n+\n+\n+CNetAddr utilBuildAddress(std::string address)\n+{\n+    struct sockaddr_in sa;\n+    inet_pton(AF_INET, address.c_str(), &(sa.sin_addr));\n+    CNetAddr addr = CNetAddr(sa.sin_addr);\n+    return addr;\n+}\n+\n+\n+void utilPreconditionIsAtLeastFiveEntriesRequired(std::string baseip, int basevalue)\n+{\n+    for (int i = CountOffsetSamples(); i < 5; i++) { // precondition 1: at least 5 entries required to compute any offset\n+        int val = basevalue + i;\n+        std::stringstream stream;\n+        stream << baseip << val;\n+        std::string ip = stream.str();\n+        AddTimeData(utilBuildAddress(ip.c_str()), val);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239935482",
      "id" : 239935482,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzOTkzNTQ4Mg==",
      "original_commit_id" : "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "original_position" : 217,
      "path" : "src/test/timedata_tests.cpp",
      "position" : 217,
      "pull_request_review_id" : 182859203,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881",
      "updated_at" : "2018-12-07T20:22:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239935482",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239936121"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239936121"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could be dropped if `utilBuildAddress` was defined up here instead?",
      "commit_id" : "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "created_at" : "2018-12-07T20:24:21Z",
      "diff_hunk" : "@@ -34,4 +36,209 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+\n+CNetAddr utilBuildAddress(std::string address);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239936121",
      "id" : 239936121,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzOTkzNjEyMQ==",
      "original_commit_id" : "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "original_position" : 32,
      "path" : "src/test/timedata_tests.cpp",
      "position" : 32,
      "pull_request_review_id" : 182860029,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881",
      "updated_at" : "2018-12-07T20:24:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239936121",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239936239"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239936239"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here. Move definition of `utilPreconditionIsAtLeastFiveEntriesRequired` here instead.",
      "commit_id" : "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "created_at" : "2018-12-07T20:24:52Z",
      "diff_hunk" : "@@ -34,4 +36,209 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+\n+CNetAddr utilBuildAddress(std::string address);\n+\n+void utilPreconditionIsAtLeastFiveEntriesRequired(std::string baseip, int basevalue);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239936239",
      "id" : 239936239,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzOTkzNjIzOQ==",
      "original_commit_id" : "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "original_position" : 34,
      "path" : "src/test/timedata_tests.cpp",
      "position" : 34,
      "pull_request_review_id" : 182860178,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881",
      "updated_at" : "2018-12-07T20:24:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239936239",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239936426"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239936426"
         }
      },
      "author_association" : "MEMBER",
      "body" : "See style guide for the function naming guidelines. Apply to all functions in this PR.",
      "commit_id" : "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "created_at" : "2018-12-07T20:25:45Z",
      "diff_hunk" : "@@ -34,4 +36,209 @@ BOOST_AUTO_TEST_CASE(util_MedianFilter)\n     BOOST_CHECK_EQUAL(filter.median(), 7);\n }\n \n+BOOST_AUTO_TEST_CASE(util_MedianFilterShallNotGrowBeyondSize)\n+{\n+    CMedianFilter<int> filter(2, 15);\n+\n+    BOOST_CHECK_EQUAL(filter.size(), 1); // 15\n+\n+    filter.input(100); // 15 100\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+\n+    filter.input(10); // 100 10\n+    BOOST_CHECK_EQUAL(filter.size(), 2);\n+    BOOST_CHECK_EQUAL(filter.sorted()[0], 10);\n+    BOOST_CHECK_EQUAL(filter.sorted()[1], 100);\n+}\n+\n+\n+CNetAddr utilBuildAddress(std::string address);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14881#discussion_r239936426",
      "id" : 239936426,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzOTkzNjQyNg==",
      "original_commit_id" : "305ebd25db4dfbe742ca693e4160dafaff2e8acd",
      "original_position" : 32,
      "path" : "src/test/timedata_tests.cpp",
      "position" : 32,
      "pull_request_review_id" : 182860468,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14881",
      "updated_at" : "2018-12-07T20:25:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/239936426",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   }
]
