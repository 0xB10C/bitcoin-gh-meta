[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14898#discussion_r240008984"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14898"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240008984"
         }
      },
      "author_association" : "NONE",
      "body" : "There are more categories than just `send` and `receive`. See https://github.com/bitcoin/bitcoin/pull/14653",
      "commit_id" : "0796ebfdf9982129bcefa72aa00b3a492ae40697",
      "created_at" : "2018-12-08T16:14:40Z",
      "diff_hunk" : "@@ -1500,6 +1500,267 @@ UniValue listtransactions(const JSONRPCRequest& request)\n     return ret;\n }\n \n+/**\n+ * List transactions version two based on the given criteria.\n+ *\n+ * @param  locked_chain\n+ * @param  pwallet        The wallet.\n+ * @param  wtx            The wallet transaction.\n+ * @param  nMinDepth      The minimum confirmation depth.\n+ * @param  fLong          Whether to include the JSON version of the transaction.\n+ * @param  ret            The UniValue into which the result is stored.\n+ * @param  filter_ismine  The \"is mine\" filter flags.\n+ * @param  filter_label   Optional label string to filter incoming transactions.\n+ * @param  afterOutPoint Start adding after this coin\n+ * @param  pRemaining    Adds new entries until this is zero\n+ *\n+ * Searches for afterOutPoint, When found, sets afterOutPoint to null\n+ * So after its found, starts adding remaining coins until pRemaining == 0\n+ * Returns true only if all elements has processed\n+ */\n+static bool ListTransactions2(interfaces::Chain::Lock& locked_chain, CWallet* const pwallet, const CWalletTx& wtx, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter_ismine, const std::string* filter_label, COutPoint& afterOutPoint, int* pRemaining)\n+{\n+    CAmount nFee;\n+    std::list<COutputEntry> listReceived;\n+    std::list<COutputEntry> listSent;\n+\n+    wtx.GetAmounts(listReceived, listSent, nFee, filter_ismine);\n+\n+    bool involvesWatchonly = wtx.IsFromMe(ISMINE_WATCH_ONLY);\n+    bool searchAfterOutPoint = !afterOutPoint.IsNull();\n+    bool afterHashEqual = searchAfterOutPoint && afterOutPoint.hash == wtx.GetHash();\n+    \n+    // Sent\n+    if (!filter_label)\n+    {\n+        for (const COutputEntry& s : listSent)\n+        {\n+            UniValue entry(UniValue::VOBJ);\n+            if (searchAfterOutPoint) {\n+                if (afterHashEqual && (int)afterOutPoint.n == s.vout) {\n+                    afterOutPoint.SetNull();\n+                    searchAfterOutPoint = false;\n+                }\n+                continue;\n+            }\n+            // check for remaining when new entry exists\n+            if ((*pRemaining) == 0) {\n+                return false;\n+            }\n+            (*pRemaining)--;\n+            if (involvesWatchonly || (::IsMine(*pwallet, s.destination) & ISMINE_WATCH_ONLY)) {\n+                entry.pushKV(\"involvesWatchonly\", true);\n+            }\n+            MaybePushAddress(entry, s.destination);\n+            entry.pushKV(\"category\", \"send\");\n+            entry.pushKV(\"amount\", ValueFromAmount(-s.amount));\n+            if (pwallet->mapAddressBook.count(s.destination)) {\n+                entry.pushKV(\"label\", pwallet->mapAddressBook[s.destination].name);\n+            }\n+            entry.pushKV(\"vout\", s.vout);\n+            entry.pushKV(\"fee\", ValueFromAmount(-nFee));\n+            if (fLong)\n+                WalletTxToJSON(pwallet->chain(), locked_chain, wtx, entry);\n+            entry.pushKV(\"abandoned\", wtx.isAbandoned());\n+            ret.push_back(entry);\n+        }\n+    }\n+\n+    // Received\n+    if (listReceived.size() > 0 && wtx.GetDepthInMainChain(locked_chain) >= nMinDepth)\n+    {\n+        for (const COutputEntry& r : listReceived)\n+        {\n+            std::string label;\n+            if (pwallet->mapAddressBook.count(r.destination)) {\n+                label = pwallet->mapAddressBook[r.destination].name;\n+            }\n+            if (filter_label && label != *filter_label) {\n+                continue;\n+            }\n+            if (searchAfterOutPoint) {\n+                if (afterHashEqual && (int)afterOutPoint.n == r.vout) {\n+                    afterOutPoint.SetNull();\n+                    searchAfterOutPoint = false;\n+                }\n+                continue;\n+            }\n+            // check for remaining when new entry exists\n+            if ((*pRemaining) == 0) {\n+                return false;\n+            }\n+            (*pRemaining)--;\n+            UniValue entry(UniValue::VOBJ);\n+            if (involvesWatchonly || (::IsMine(*pwallet, r.destination) & ISMINE_WATCH_ONLY)) {\n+                entry.pushKV(\"involvesWatchonly\", true);\n+            }\n+            MaybePushAddress(entry, r.destination);\n+            if (wtx.IsCoinBase())\n+            {\n+                if (wtx.GetDepthInMainChain(locked_chain) < 1)\n+                    entry.pushKV(\"category\", \"orphan\");\n+                else if (wtx.IsImmatureCoinBase(locked_chain))\n+                    entry.pushKV(\"category\", \"immature\");\n+                else\n+                    entry.pushKV(\"category\", \"generate\");\n+            }\n+            else\n+            {\n+                entry.pushKV(\"category\", \"receive\");\n+            }\n+            entry.pushKV(\"amount\", ValueFromAmount(r.amount));\n+            if (pwallet->mapAddressBook.count(r.destination)) {\n+                entry.pushKV(\"label\", label);\n+            }\n+            entry.pushKV(\"vout\", r.vout);\n+            if (fLong)\n+                WalletTxToJSON(pwallet->chain(), locked_chain, wtx, entry);\n+            ret.push_back(entry);\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+UniValue listtransactions2(const JSONRPCRequest& request)\n+{\n+    std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);\n+    CWallet* const pwallet = wallet.get();\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    std::string help_text =\n+      \"listtransactions2 (label count nextpagepointer include_watchonly)\\n\"\n+            \"\\nIf a label name is provided, this will return only incoming transactions paying to addresses with the specified label.\\n\"\n+            \"\\nReturns up to 'count' most recent transactions from tip of entries or nextpagepointer (exclusive).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"label\\\"    (string, optional) If set, should be a valid label name to return only incoming transactions\\n\"\n+            \"              with the specified label, or \\\"*\\\" to disable filtering and return all transactions.\\n\"\n+            \"2. count             (numeric, optional, default=10) The number of transactions to return\\n\"\n+            \"3. nextpagepointer         (string, optional, default=null) Continue the existing listing by passing last known txid:vout.\\n\"\n+            \"5. include_watchonly (bool, optional, default=false) Include transactions to watch-only addresses (see 'importaddress')\\n\"\n+            \"\\nResult:\\n\"\n+            \"[\\n\"\n+            \"  {\\n\"\n+            \"    \\\"address\\\":\\\"address\\\",    (string) The bitcoin address of the transaction.\\n\"\n+            \"    \\\"category\\\":\\\"send|receive\\\", (string) The transaction category.\\n\"",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14898#discussion_r240008984",
      "id" : 240008984,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MDAwODk4NA==",
      "original_commit_id" : "0796ebfdf9982129bcefa72aa00b3a492ae40697",
      "original_position" : 149,
      "path" : "src/wallet/rpcwallet.cpp",
      "position" : 149,
      "pull_request_review_id" : 182948632,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14898",
      "updated_at" : "2018-12-08T16:14:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/240008984",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/237213?v=4",
         "events_url" : "https://api.github.com/users/andrewtoth/events{/privacy}",
         "followers_url" : "https://api.github.com/users/andrewtoth/followers",
         "following_url" : "https://api.github.com/users/andrewtoth/following{/other_user}",
         "gists_url" : "https://api.github.com/users/andrewtoth/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/andrewtoth",
         "id" : 237213,
         "login" : "andrewtoth",
         "node_id" : "MDQ6VXNlcjIzNzIxMw==",
         "organizations_url" : "https://api.github.com/users/andrewtoth/orgs",
         "received_events_url" : "https://api.github.com/users/andrewtoth/received_events",
         "repos_url" : "https://api.github.com/users/andrewtoth/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/andrewtoth/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/andrewtoth/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/andrewtoth"
      }
   }
]
