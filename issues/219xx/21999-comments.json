[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21999#discussion_r636278997"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21999"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/636278997"
         }
      },
      "author_association" : "NONE",
      "body" : "It looks like this should be:\r\n```suggestion        \r\n                .format(n_tx_to_mine)\r\n```",
      "commit_id" : "a02da6d8c0d4951111df7b035388f01dbe526d0a",
      "created_at" : "2021-05-20T16:47:41Z",
      "diff_hunk" : "@@ -38,86 +35,52 @@ def transaction_graph_test(self, size, n_tx_to_mine=None, start_input_txid='', e\n         More details: https://en.wikipedia.org/wiki/Tournament_(graph_theory)\n         \"\"\"\n \n-        if not start_input_txid:\n-            start_input_txid = self.nodes[0].getblock(self.nodes[0].getblockhash(1))['tx'][0]\n-\n-        if not end_address:\n-            end_address = self.nodes[0].getnewaddress()\n-\n-        first_block_hash = ''\n-        tx_id = []\n-        tx_size = []\n+        node = self.nodes[0]\n+        self.wallet = MiniWallet(node)\n         self.log.info('Creating {} transactions...'.format(size))\n-        for i in range(0, size):\n-            self.log.debug('Preparing transaction #{}...'.format(i))\n-            # Prepare inputs.\n-            if i == 0:\n-                inputs = [{'txid': start_input_txid, 'vout': 0}]\n-                inputs_value = self.nodes[0].gettxout(start_input_txid, 0)['value']\n-            else:\n-                inputs = []\n-                inputs_value = 0\n-                for j, tx in enumerate(tx_id[0:i]):\n-                    # Transaction tx[K] is a child of each of previous transactions tx[0]..tx[K-1] at their output K-1.\n-                    vout = i - j - 1\n-                    inputs.append({'txid': tx_id[j], 'vout': vout})\n-                    inputs_value += self.nodes[0].gettxout(tx, vout)['value']\n-\n-            self.log.debug('inputs={}'.format(inputs))\n-            self.log.debug('inputs_value={}'.format(inputs_value))\n-\n-            # Prepare outputs.\n-            tx_count = i + 1\n-            if tx_count < size:\n-                # Transaction tx[K] is an ancestor of each of subsequent transactions tx[K+1]..tx[N-1].\n-                n_outputs = size - tx_count\n-                output_value = ((inputs_value - fee) / Decimal(n_outputs)).quantize(Decimal('0.00000001'))\n-                outputs = {}\n-                for _ in range(n_outputs):\n-                    outputs[self.nodes[0].getnewaddress()] = output_value\n-            else:\n-                output_value = (inputs_value - fee).quantize(Decimal('0.00000001'))\n-                outputs = {end_address: output_value}\n-\n-            self.log.debug('output_value={}'.format(output_value))\n-            self.log.debug('outputs={}'.format(outputs))\n-\n-            # Create a new transaction.\n-            unsigned_raw_tx = self.nodes[0].createrawtransaction(inputs, outputs)\n-            signed_raw_tx = self.nodes[0].signrawtransactionwithwallet(unsigned_raw_tx)\n-            tx_id.append(self.nodes[0].sendrawtransaction(signed_raw_tx['hex']))\n-            tx_size.append(self.nodes[0].getrawmempool(True)[tx_id[-1]]['vsize'])\n-\n-            if tx_count in n_tx_to_mine:\n-                # The created transactions are mined into blocks by batches.\n-                self.log.info('The batch of {} transactions has been accepted into the mempool.'.format(len(self.nodes[0].getrawmempool())))\n-                block_hash = self.nodes[0].generate(1)[0]\n-                if not first_block_hash:\n-                    first_block_hash = block_hash\n-                assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        self.wallet.generate(1)\n+        node.generate(size)\n+        txs = []\n+        block_ids = []\n+        tx_size = []\n+        for i in range(size):\n+            txs.append(self.wallet.send_self_transfer(from_node=node))\n+            tx_size.append(96)\n+            if (i+1) % n_tx_to_mine == 0:\n+                self.log.info('The batch of {} transactions has been accepted into the mempool.'\n+                .format(len(node.getrawmempool())))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21999#discussion_r636278997",
      "id" : 636278997,
      "line" : 51,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjI3ODk5Nw==",
      "original_commit_id" : "b7c6eea86154320520fa6766c4a87f6ad4c1b899",
      "original_line" : 51,
      "original_position" : 98,
      "original_start_line" : null,
      "path" : "test/functional/mempool_updatefromblock.py",
      "position" : 98,
      "pull_request_review_id" : 664624908,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21999",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-20T17:16:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/636278997",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/41220998?v=4",
         "events_url" : "https://api.github.com/users/DariusParvin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DariusParvin/followers",
         "following_url" : "https://api.github.com/users/DariusParvin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DariusParvin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DariusParvin",
         "id" : 41220998,
         "login" : "DariusParvin",
         "node_id" : "MDQ6VXNlcjQxMjIwOTk4",
         "organizations_url" : "https://api.github.com/users/DariusParvin/orgs",
         "received_events_url" : "https://api.github.com/users/DariusParvin/received_events",
         "repos_url" : "https://api.github.com/users/DariusParvin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DariusParvin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DariusParvin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DariusParvin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21999#discussion_r636281765"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21999"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/636281765"
         }
      },
      "author_association" : "NONE",
      "body" : "is this useful to have in the log?",
      "commit_id" : "a02da6d8c0d4951111df7b035388f01dbe526d0a",
      "created_at" : "2021-05-20T16:51:39Z",
      "diff_hunk" : "@@ -38,86 +35,52 @@ def transaction_graph_test(self, size, n_tx_to_mine=None, start_input_txid='', e\n         More details: https://en.wikipedia.org/wiki/Tournament_(graph_theory)\n         \"\"\"\n \n-        if not start_input_txid:\n-            start_input_txid = self.nodes[0].getblock(self.nodes[0].getblockhash(1))['tx'][0]\n-\n-        if not end_address:\n-            end_address = self.nodes[0].getnewaddress()\n-\n-        first_block_hash = ''\n-        tx_id = []\n-        tx_size = []\n+        node = self.nodes[0]\n+        self.wallet = MiniWallet(node)\n         self.log.info('Creating {} transactions...'.format(size))\n-        for i in range(0, size):\n-            self.log.debug('Preparing transaction #{}...'.format(i))\n-            # Prepare inputs.\n-            if i == 0:\n-                inputs = [{'txid': start_input_txid, 'vout': 0}]\n-                inputs_value = self.nodes[0].gettxout(start_input_txid, 0)['value']\n-            else:\n-                inputs = []\n-                inputs_value = 0\n-                for j, tx in enumerate(tx_id[0:i]):\n-                    # Transaction tx[K] is a child of each of previous transactions tx[0]..tx[K-1] at their output K-1.\n-                    vout = i - j - 1\n-                    inputs.append({'txid': tx_id[j], 'vout': vout})\n-                    inputs_value += self.nodes[0].gettxout(tx, vout)['value']\n-\n-            self.log.debug('inputs={}'.format(inputs))\n-            self.log.debug('inputs_value={}'.format(inputs_value))\n-\n-            # Prepare outputs.\n-            tx_count = i + 1\n-            if tx_count < size:\n-                # Transaction tx[K] is an ancestor of each of subsequent transactions tx[K+1]..tx[N-1].\n-                n_outputs = size - tx_count\n-                output_value = ((inputs_value - fee) / Decimal(n_outputs)).quantize(Decimal('0.00000001'))\n-                outputs = {}\n-                for _ in range(n_outputs):\n-                    outputs[self.nodes[0].getnewaddress()] = output_value\n-            else:\n-                output_value = (inputs_value - fee).quantize(Decimal('0.00000001'))\n-                outputs = {end_address: output_value}\n-\n-            self.log.debug('output_value={}'.format(output_value))\n-            self.log.debug('outputs={}'.format(outputs))\n-\n-            # Create a new transaction.\n-            unsigned_raw_tx = self.nodes[0].createrawtransaction(inputs, outputs)\n-            signed_raw_tx = self.nodes[0].signrawtransactionwithwallet(unsigned_raw_tx)\n-            tx_id.append(self.nodes[0].sendrawtransaction(signed_raw_tx['hex']))\n-            tx_size.append(self.nodes[0].getrawmempool(True)[tx_id[-1]]['vsize'])\n-\n-            if tx_count in n_tx_to_mine:\n-                # The created transactions are mined into blocks by batches.\n-                self.log.info('The batch of {} transactions has been accepted into the mempool.'.format(len(self.nodes[0].getrawmempool())))\n-                block_hash = self.nodes[0].generate(1)[0]\n-                if not first_block_hash:\n-                    first_block_hash = block_hash\n-                assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        self.wallet.generate(1)\n+        node.generate(size)\n+        txs = []\n+        block_ids = []\n+        tx_size = []\n+        for i in range(size):\n+            txs.append(self.wallet.send_self_transfer(from_node=node))\n+            tx_size.append(96)\n+            if (i+1) % n_tx_to_mine == 0:\n+                self.log.info('The batch of {} transactions has been accepted into the mempool.'\n+                .format(len(node.getrawmempool())))\n+                block_ids.append(self.wallet.generate(1)[0])\n+                assert_equal(len(node.getrawmempool()), 0)\n                 self.log.info('All of the transactions from the current batch have been mined into a block.')\n-            elif tx_count == size:\n-                # At the end all of the mined blocks are invalidated, and all of the created\n-                # transactions should be re-added from disconnected blocks to the mempool.\n-                self.log.info('The last batch of {} transactions has been accepted into the mempool.'.format(len(self.nodes[0].getrawmempool())))\n-                start = time.time()\n-                self.nodes[0].invalidateblock(first_block_hash)\n-                end = time.time()\n-                assert_equal(len(self.nodes[0].getrawmempool()), size)\n-                self.log.info('All of the recently mined transactions have been re-added into the mempool in {} seconds.'.format(end - start))\n+                self.log.info('{}'.format(block_ids))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21999#discussion_r636281765",
      "id" : 636281765,
      "line" : 55,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjI4MTc2NQ==",
      "original_commit_id" : "b7c6eea86154320520fa6766c4a87f6ad4c1b899",
      "original_line" : 55,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "test/functional/mempool_updatefromblock.py",
      "position" : 111,
      "pull_request_review_id" : 664624908,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21999",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-20T17:16:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/636281765",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/41220998?v=4",
         "events_url" : "https://api.github.com/users/DariusParvin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DariusParvin/followers",
         "following_url" : "https://api.github.com/users/DariusParvin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DariusParvin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DariusParvin",
         "id" : 41220998,
         "login" : "DariusParvin",
         "node_id" : "MDQ6VXNlcjQxMjIwOTk4",
         "organizations_url" : "https://api.github.com/users/DariusParvin/orgs",
         "received_events_url" : "https://api.github.com/users/DariusParvin/received_events",
         "repos_url" : "https://api.github.com/users/DariusParvin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DariusParvin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DariusParvin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DariusParvin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21999#discussion_r636285450"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21999"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/636285450"
         }
      },
      "author_association" : "NONE",
      "body" : "'Block height' is probably misleading. Should this say something like?\r\n```suggestion\r\n                self.log.info('Number of recently mined blocks: {}'.format(math.ceil(i / n_tx_to_mine)))\r\n```\r\nbut also is this useful to have? Without this we won't need to `import math` ",
      "commit_id" : "a02da6d8c0d4951111df7b035388f01dbe526d0a",
      "created_at" : "2021-05-20T16:56:44Z",
      "diff_hunk" : "@@ -38,86 +35,52 @@ def transaction_graph_test(self, size, n_tx_to_mine=None, start_input_txid='', e\n         More details: https://en.wikipedia.org/wiki/Tournament_(graph_theory)\n         \"\"\"\n \n-        if not start_input_txid:\n-            start_input_txid = self.nodes[0].getblock(self.nodes[0].getblockhash(1))['tx'][0]\n-\n-        if not end_address:\n-            end_address = self.nodes[0].getnewaddress()\n-\n-        first_block_hash = ''\n-        tx_id = []\n-        tx_size = []\n+        node = self.nodes[0]\n+        self.wallet = MiniWallet(node)\n         self.log.info('Creating {} transactions...'.format(size))\n-        for i in range(0, size):\n-            self.log.debug('Preparing transaction #{}...'.format(i))\n-            # Prepare inputs.\n-            if i == 0:\n-                inputs = [{'txid': start_input_txid, 'vout': 0}]\n-                inputs_value = self.nodes[0].gettxout(start_input_txid, 0)['value']\n-            else:\n-                inputs = []\n-                inputs_value = 0\n-                for j, tx in enumerate(tx_id[0:i]):\n-                    # Transaction tx[K] is a child of each of previous transactions tx[0]..tx[K-1] at their output K-1.\n-                    vout = i - j - 1\n-                    inputs.append({'txid': tx_id[j], 'vout': vout})\n-                    inputs_value += self.nodes[0].gettxout(tx, vout)['value']\n-\n-            self.log.debug('inputs={}'.format(inputs))\n-            self.log.debug('inputs_value={}'.format(inputs_value))\n-\n-            # Prepare outputs.\n-            tx_count = i + 1\n-            if tx_count < size:\n-                # Transaction tx[K] is an ancestor of each of subsequent transactions tx[K+1]..tx[N-1].\n-                n_outputs = size - tx_count\n-                output_value = ((inputs_value - fee) / Decimal(n_outputs)).quantize(Decimal('0.00000001'))\n-                outputs = {}\n-                for _ in range(n_outputs):\n-                    outputs[self.nodes[0].getnewaddress()] = output_value\n-            else:\n-                output_value = (inputs_value - fee).quantize(Decimal('0.00000001'))\n-                outputs = {end_address: output_value}\n-\n-            self.log.debug('output_value={}'.format(output_value))\n-            self.log.debug('outputs={}'.format(outputs))\n-\n-            # Create a new transaction.\n-            unsigned_raw_tx = self.nodes[0].createrawtransaction(inputs, outputs)\n-            signed_raw_tx = self.nodes[0].signrawtransactionwithwallet(unsigned_raw_tx)\n-            tx_id.append(self.nodes[0].sendrawtransaction(signed_raw_tx['hex']))\n-            tx_size.append(self.nodes[0].getrawmempool(True)[tx_id[-1]]['vsize'])\n-\n-            if tx_count in n_tx_to_mine:\n-                # The created transactions are mined into blocks by batches.\n-                self.log.info('The batch of {} transactions has been accepted into the mempool.'.format(len(self.nodes[0].getrawmempool())))\n-                block_hash = self.nodes[0].generate(1)[0]\n-                if not first_block_hash:\n-                    first_block_hash = block_hash\n-                assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        self.wallet.generate(1)\n+        node.generate(size)\n+        txs = []\n+        block_ids = []\n+        tx_size = []\n+        for i in range(size):\n+            txs.append(self.wallet.send_self_transfer(from_node=node))\n+            tx_size.append(96)\n+            if (i+1) % n_tx_to_mine == 0:\n+                self.log.info('The batch of {} transactions has been accepted into the mempool.'\n+                .format(len(node.getrawmempool())))\n+                block_ids.append(self.wallet.generate(1)[0])\n+                assert_equal(len(node.getrawmempool()), 0)\n                 self.log.info('All of the transactions from the current batch have been mined into a block.')\n-            elif tx_count == size:\n-                # At the end all of the mined blocks are invalidated, and all of the created\n-                # transactions should be re-added from disconnected blocks to the mempool.\n-                self.log.info('The last batch of {} transactions has been accepted into the mempool.'.format(len(self.nodes[0].getrawmempool())))\n-                start = time.time()\n-                self.nodes[0].invalidateblock(first_block_hash)\n-                end = time.time()\n-                assert_equal(len(self.nodes[0].getrawmempool()), size)\n-                self.log.info('All of the recently mined transactions have been re-added into the mempool in {} seconds.'.format(end - start))\n+                self.log.info('{}'.format(block_ids))\n+                self.log.info('Block height: {}'.format(math.ceil(i / n_tx_to_mine)))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21999#discussion_r636285450",
      "id" : 636285450,
      "line" : 56,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjI4NTQ1MA==",
      "original_commit_id" : "b7c6eea86154320520fa6766c4a87f6ad4c1b899",
      "original_line" : 56,
      "original_position" : 112,
      "original_start_line" : null,
      "path" : "test/functional/mempool_updatefromblock.py",
      "position" : 112,
      "pull_request_review_id" : 664624908,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21999",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-20T17:16:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/636285450",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/41220998?v=4",
         "events_url" : "https://api.github.com/users/DariusParvin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DariusParvin/followers",
         "following_url" : "https://api.github.com/users/DariusParvin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DariusParvin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DariusParvin",
         "id" : 41220998,
         "login" : "DariusParvin",
         "node_id" : "MDQ6VXNlcjQxMjIwOTk4",
         "organizations_url" : "https://api.github.com/users/DariusParvin/orgs",
         "received_events_url" : "https://api.github.com/users/DariusParvin/received_events",
         "repos_url" : "https://api.github.com/users/DariusParvin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DariusParvin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DariusParvin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DariusParvin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21999#discussion_r636298155"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21999"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/636298155"
         }
      },
      "author_association" : "NONE",
      "body" : "`scan_blocks` is slightly quicker than `generate`, so instead we can use\r\n```suggestion\r\n        self.wallet.scan_blocks(start=76, num=1)\r\n```\r\n(76 is the first block where the coinbase is mined to the miniwallet address)",
      "commit_id" : "a02da6d8c0d4951111df7b035388f01dbe526d0a",
      "created_at" : "2021-05-20T17:09:03Z",
      "diff_hunk" : "@@ -38,86 +35,52 @@ def transaction_graph_test(self, size, n_tx_to_mine=None, start_input_txid='', e\n         More details: https://en.wikipedia.org/wiki/Tournament_(graph_theory)\n         \"\"\"\n \n-        if not start_input_txid:\n-            start_input_txid = self.nodes[0].getblock(self.nodes[0].getblockhash(1))['tx'][0]\n-\n-        if not end_address:\n-            end_address = self.nodes[0].getnewaddress()\n-\n-        first_block_hash = ''\n-        tx_id = []\n-        tx_size = []\n+        node = self.nodes[0]\n+        self.wallet = MiniWallet(node)\n         self.log.info('Creating {} transactions...'.format(size))\n-        for i in range(0, size):\n-            self.log.debug('Preparing transaction #{}...'.format(i))\n-            # Prepare inputs.\n-            if i == 0:\n-                inputs = [{'txid': start_input_txid, 'vout': 0}]\n-                inputs_value = self.nodes[0].gettxout(start_input_txid, 0)['value']\n-            else:\n-                inputs = []\n-                inputs_value = 0\n-                for j, tx in enumerate(tx_id[0:i]):\n-                    # Transaction tx[K] is a child of each of previous transactions tx[0]..tx[K-1] at their output K-1.\n-                    vout = i - j - 1\n-                    inputs.append({'txid': tx_id[j], 'vout': vout})\n-                    inputs_value += self.nodes[0].gettxout(tx, vout)['value']\n-\n-            self.log.debug('inputs={}'.format(inputs))\n-            self.log.debug('inputs_value={}'.format(inputs_value))\n-\n-            # Prepare outputs.\n-            tx_count = i + 1\n-            if tx_count < size:\n-                # Transaction tx[K] is an ancestor of each of subsequent transactions tx[K+1]..tx[N-1].\n-                n_outputs = size - tx_count\n-                output_value = ((inputs_value - fee) / Decimal(n_outputs)).quantize(Decimal('0.00000001'))\n-                outputs = {}\n-                for _ in range(n_outputs):\n-                    outputs[self.nodes[0].getnewaddress()] = output_value\n-            else:\n-                output_value = (inputs_value - fee).quantize(Decimal('0.00000001'))\n-                outputs = {end_address: output_value}\n-\n-            self.log.debug('output_value={}'.format(output_value))\n-            self.log.debug('outputs={}'.format(outputs))\n-\n-            # Create a new transaction.\n-            unsigned_raw_tx = self.nodes[0].createrawtransaction(inputs, outputs)\n-            signed_raw_tx = self.nodes[0].signrawtransactionwithwallet(unsigned_raw_tx)\n-            tx_id.append(self.nodes[0].sendrawtransaction(signed_raw_tx['hex']))\n-            tx_size.append(self.nodes[0].getrawmempool(True)[tx_id[-1]]['vsize'])\n-\n-            if tx_count in n_tx_to_mine:\n-                # The created transactions are mined into blocks by batches.\n-                self.log.info('The batch of {} transactions has been accepted into the mempool.'.format(len(self.nodes[0].getrawmempool())))\n-                block_hash = self.nodes[0].generate(1)[0]\n-                if not first_block_hash:\n-                    first_block_hash = block_hash\n-                assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        self.wallet.generate(1)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21999#discussion_r636298155",
      "id" : 636298155,
      "line" : 41,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjI5ODE1NQ==",
      "original_commit_id" : "a02da6d8c0d4951111df7b035388f01dbe526d0a",
      "original_line" : 41,
      "original_position" : 88,
      "original_start_line" : null,
      "path" : "test/functional/mempool_updatefromblock.py",
      "position" : 88,
      "pull_request_review_id" : 664624908,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21999",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-20T17:16:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/636298155",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/41220998?v=4",
         "events_url" : "https://api.github.com/users/DariusParvin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DariusParvin/followers",
         "following_url" : "https://api.github.com/users/DariusParvin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DariusParvin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DariusParvin",
         "id" : 41220998,
         "login" : "DariusParvin",
         "node_id" : "MDQ6VXNlcjQxMjIwOTk4",
         "organizations_url" : "https://api.github.com/users/DariusParvin/orgs",
         "received_events_url" : "https://api.github.com/users/DariusParvin/received_events",
         "repos_url" : "https://api.github.com/users/DariusParvin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DariusParvin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DariusParvin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DariusParvin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21999#discussion_r636302051"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21999"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/636302051"
         }
      },
      "author_association" : "NONE",
      "body" : "Would it be useful to have this in the line above?\r\n```suggestion                \r\n                assert_equal(len(node.getrawmempool()), n_tx_to_mine)\r\n```",
      "commit_id" : "a02da6d8c0d4951111df7b035388f01dbe526d0a",
      "created_at" : "2021-05-20T17:12:08Z",
      "diff_hunk" : "@@ -38,86 +35,52 @@ def transaction_graph_test(self, size, n_tx_to_mine=None, start_input_txid='', e\n         More details: https://en.wikipedia.org/wiki/Tournament_(graph_theory)\n         \"\"\"\n \n-        if not start_input_txid:\n-            start_input_txid = self.nodes[0].getblock(self.nodes[0].getblockhash(1))['tx'][0]\n-\n-        if not end_address:\n-            end_address = self.nodes[0].getnewaddress()\n-\n-        first_block_hash = ''\n-        tx_id = []\n-        tx_size = []\n+        node = self.nodes[0]\n+        self.wallet = MiniWallet(node)\n         self.log.info('Creating {} transactions...'.format(size))\n-        for i in range(0, size):\n-            self.log.debug('Preparing transaction #{}...'.format(i))\n-            # Prepare inputs.\n-            if i == 0:\n-                inputs = [{'txid': start_input_txid, 'vout': 0}]\n-                inputs_value = self.nodes[0].gettxout(start_input_txid, 0)['value']\n-            else:\n-                inputs = []\n-                inputs_value = 0\n-                for j, tx in enumerate(tx_id[0:i]):\n-                    # Transaction tx[K] is a child of each of previous transactions tx[0]..tx[K-1] at their output K-1.\n-                    vout = i - j - 1\n-                    inputs.append({'txid': tx_id[j], 'vout': vout})\n-                    inputs_value += self.nodes[0].gettxout(tx, vout)['value']\n-\n-            self.log.debug('inputs={}'.format(inputs))\n-            self.log.debug('inputs_value={}'.format(inputs_value))\n-\n-            # Prepare outputs.\n-            tx_count = i + 1\n-            if tx_count < size:\n-                # Transaction tx[K] is an ancestor of each of subsequent transactions tx[K+1]..tx[N-1].\n-                n_outputs = size - tx_count\n-                output_value = ((inputs_value - fee) / Decimal(n_outputs)).quantize(Decimal('0.00000001'))\n-                outputs = {}\n-                for _ in range(n_outputs):\n-                    outputs[self.nodes[0].getnewaddress()] = output_value\n-            else:\n-                output_value = (inputs_value - fee).quantize(Decimal('0.00000001'))\n-                outputs = {end_address: output_value}\n-\n-            self.log.debug('output_value={}'.format(output_value))\n-            self.log.debug('outputs={}'.format(outputs))\n-\n-            # Create a new transaction.\n-            unsigned_raw_tx = self.nodes[0].createrawtransaction(inputs, outputs)\n-            signed_raw_tx = self.nodes[0].signrawtransactionwithwallet(unsigned_raw_tx)\n-            tx_id.append(self.nodes[0].sendrawtransaction(signed_raw_tx['hex']))\n-            tx_size.append(self.nodes[0].getrawmempool(True)[tx_id[-1]]['vsize'])\n-\n-            if tx_count in n_tx_to_mine:\n-                # The created transactions are mined into blocks by batches.\n-                self.log.info('The batch of {} transactions has been accepted into the mempool.'.format(len(self.nodes[0].getrawmempool())))\n-                block_hash = self.nodes[0].generate(1)[0]\n-                if not first_block_hash:\n-                    first_block_hash = block_hash\n-                assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        self.wallet.generate(1)\n+        node.generate(size)\n+        txs = []\n+        block_ids = []\n+        tx_size = []\n+        for i in range(size):\n+            txs.append(self.wallet.send_self_transfer(from_node=node))\n+            tx_size.append(96)\n+            if (i+1) % n_tx_to_mine == 0:\n+                self.log.info('The batch of {} transactions has been accepted into the mempool.'",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21999#discussion_r636302051",
      "id" : 636302051,
      "line" : 50,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjMwMjA1MQ==",
      "original_commit_id" : "a02da6d8c0d4951111df7b035388f01dbe526d0a",
      "original_line" : 50,
      "original_position" : 97,
      "original_start_line" : null,
      "path" : "test/functional/mempool_updatefromblock.py",
      "position" : 97,
      "pull_request_review_id" : 664624908,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21999",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-20T17:16:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/636302051",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/41220998?v=4",
         "events_url" : "https://api.github.com/users/DariusParvin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DariusParvin/followers",
         "following_url" : "https://api.github.com/users/DariusParvin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DariusParvin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DariusParvin",
         "id" : 41220998,
         "login" : "DariusParvin",
         "node_id" : "MDQ6VXNlcjQxMjIwOTk4",
         "organizations_url" : "https://api.github.com/users/DariusParvin/orgs",
         "received_events_url" : "https://api.github.com/users/DariusParvin/received_events",
         "repos_url" : "https://api.github.com/users/DariusParvin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DariusParvin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DariusParvin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DariusParvin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21999#discussion_r636304223"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21999"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/636304223"
         }
      },
      "author_association" : "NONE",
      "body" : "I'm curious if there's any advantage to incrementing k manually rather than using `enumerate`? Otherwise `enumerate` seems more concise.\r\n```suggestion\r\n        for k, tx in enumerate(txs):\r\n```",
      "commit_id" : "a02da6d8c0d4951111df7b035388f01dbe526d0a",
      "created_at" : "2021-05-20T17:15:20Z",
      "diff_hunk" : "@@ -38,86 +35,52 @@ def transaction_graph_test(self, size, n_tx_to_mine=None, start_input_txid='', e\n         More details: https://en.wikipedia.org/wiki/Tournament_(graph_theory)\n         \"\"\"\n \n-        if not start_input_txid:\n-            start_input_txid = self.nodes[0].getblock(self.nodes[0].getblockhash(1))['tx'][0]\n-\n-        if not end_address:\n-            end_address = self.nodes[0].getnewaddress()\n-\n-        first_block_hash = ''\n-        tx_id = []\n-        tx_size = []\n+        node = self.nodes[0]\n+        self.wallet = MiniWallet(node)\n         self.log.info('Creating {} transactions...'.format(size))\n-        for i in range(0, size):\n-            self.log.debug('Preparing transaction #{}...'.format(i))\n-            # Prepare inputs.\n-            if i == 0:\n-                inputs = [{'txid': start_input_txid, 'vout': 0}]\n-                inputs_value = self.nodes[0].gettxout(start_input_txid, 0)['value']\n-            else:\n-                inputs = []\n-                inputs_value = 0\n-                for j, tx in enumerate(tx_id[0:i]):\n-                    # Transaction tx[K] is a child of each of previous transactions tx[0]..tx[K-1] at their output K-1.\n-                    vout = i - j - 1\n-                    inputs.append({'txid': tx_id[j], 'vout': vout})\n-                    inputs_value += self.nodes[0].gettxout(tx, vout)['value']\n-\n-            self.log.debug('inputs={}'.format(inputs))\n-            self.log.debug('inputs_value={}'.format(inputs_value))\n-\n-            # Prepare outputs.\n-            tx_count = i + 1\n-            if tx_count < size:\n-                # Transaction tx[K] is an ancestor of each of subsequent transactions tx[K+1]..tx[N-1].\n-                n_outputs = size - tx_count\n-                output_value = ((inputs_value - fee) / Decimal(n_outputs)).quantize(Decimal('0.00000001'))\n-                outputs = {}\n-                for _ in range(n_outputs):\n-                    outputs[self.nodes[0].getnewaddress()] = output_value\n-            else:\n-                output_value = (inputs_value - fee).quantize(Decimal('0.00000001'))\n-                outputs = {end_address: output_value}\n-\n-            self.log.debug('output_value={}'.format(output_value))\n-            self.log.debug('outputs={}'.format(outputs))\n-\n-            # Create a new transaction.\n-            unsigned_raw_tx = self.nodes[0].createrawtransaction(inputs, outputs)\n-            signed_raw_tx = self.nodes[0].signrawtransactionwithwallet(unsigned_raw_tx)\n-            tx_id.append(self.nodes[0].sendrawtransaction(signed_raw_tx['hex']))\n-            tx_size.append(self.nodes[0].getrawmempool(True)[tx_id[-1]]['vsize'])\n-\n-            if tx_count in n_tx_to_mine:\n-                # The created transactions are mined into blocks by batches.\n-                self.log.info('The batch of {} transactions has been accepted into the mempool.'.format(len(self.nodes[0].getrawmempool())))\n-                block_hash = self.nodes[0].generate(1)[0]\n-                if not first_block_hash:\n-                    first_block_hash = block_hash\n-                assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        self.wallet.generate(1)\n+        node.generate(size)\n+        txs = []\n+        block_ids = []\n+        tx_size = []\n+        for i in range(size):\n+            txs.append(self.wallet.send_self_transfer(from_node=node))\n+            tx_size.append(96)\n+            if (i+1) % n_tx_to_mine == 0:\n+                self.log.info('The batch of {} transactions has been accepted into the mempool.'\n+                .format(len(node.getrawmempool())))\n+                block_ids.append(self.wallet.generate(1)[0])\n+                assert_equal(len(node.getrawmempool()), 0)\n                 self.log.info('All of the transactions from the current batch have been mined into a block.')\n-            elif tx_count == size:\n-                # At the end all of the mined blocks are invalidated, and all of the created\n-                # transactions should be re-added from disconnected blocks to the mempool.\n-                self.log.info('The last batch of {} transactions has been accepted into the mempool.'.format(len(self.nodes[0].getrawmempool())))\n-                start = time.time()\n-                self.nodes[0].invalidateblock(first_block_hash)\n-                end = time.time()\n-                assert_equal(len(self.nodes[0].getrawmempool()), size)\n-                self.log.info('All of the recently mined transactions have been re-added into the mempool in {} seconds.'.format(end - start))\n+                self.log.info('{}'.format(block_ids))\n+                self.log.info('Block height: {}'.format(math.ceil(i / n_tx_to_mine)))\n+\n+        self.log.info('Mempool size pre-invalidation: {}'.format(len(node.getrawmempool())))\n+        assert_equal(len(node.getrawmempool()), 0)\n+        # Invalidate the first block to send the transactions back to the mempool.\n+        start = time.time()\n+        node.invalidateblock(block_ids[0])\n+        end = time.time()\n+        self.log.info('Mempool size post-invalidation: {}'.format(len(node.getrawmempool())))\n+        assert_equal(len(self.nodes[0].getrawmempool()), size)\n+        self.log.info('All of the recently mined transactions have been re-added into the mempool in {} seconds.'\n+        .format(end - start))\n \n         self.log.info('Checking descendants/ancestors properties of all of the in-mempool transactions...')\n-        for k, tx in enumerate(tx_id):\n+        k = 0\n+        for tx in txs:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21999#discussion_r636304223",
      "id" : 636304223,
      "line" : 71,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjMwNDIyMw==",
      "original_commit_id" : "a02da6d8c0d4951111df7b035388f01dbe526d0a",
      "original_line" : 71,
      "original_position" : 128,
      "original_start_line" : null,
      "path" : "test/functional/mempool_updatefromblock.py",
      "position" : 128,
      "pull_request_review_id" : 664624908,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21999",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-20T17:16:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/636304223",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/41220998?v=4",
         "events_url" : "https://api.github.com/users/DariusParvin/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DariusParvin/followers",
         "following_url" : "https://api.github.com/users/DariusParvin/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DariusParvin/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DariusParvin",
         "id" : 41220998,
         "login" : "DariusParvin",
         "node_id" : "MDQ6VXNlcjQxMjIwOTk4",
         "organizations_url" : "https://api.github.com/users/DariusParvin/orgs",
         "received_events_url" : "https://api.github.com/users/DariusParvin/received_events",
         "repos_url" : "https://api.github.com/users/DariusParvin/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DariusParvin/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DariusParvin/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DariusParvin"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21999#discussion_r636310625"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21999"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/636310625"
         }
      },
      "author_association" : "NONE",
      "body" : "Nice catch! Yes will update. ",
      "commit_id" : "a02da6d8c0d4951111df7b035388f01dbe526d0a",
      "created_at" : "2021-05-20T17:24:57Z",
      "diff_hunk" : "@@ -38,86 +35,52 @@ def transaction_graph_test(self, size, n_tx_to_mine=None, start_input_txid='', e\n         More details: https://en.wikipedia.org/wiki/Tournament_(graph_theory)\n         \"\"\"\n \n-        if not start_input_txid:\n-            start_input_txid = self.nodes[0].getblock(self.nodes[0].getblockhash(1))['tx'][0]\n-\n-        if not end_address:\n-            end_address = self.nodes[0].getnewaddress()\n-\n-        first_block_hash = ''\n-        tx_id = []\n-        tx_size = []\n+        node = self.nodes[0]\n+        self.wallet = MiniWallet(node)\n         self.log.info('Creating {} transactions...'.format(size))\n-        for i in range(0, size):\n-            self.log.debug('Preparing transaction #{}...'.format(i))\n-            # Prepare inputs.\n-            if i == 0:\n-                inputs = [{'txid': start_input_txid, 'vout': 0}]\n-                inputs_value = self.nodes[0].gettxout(start_input_txid, 0)['value']\n-            else:\n-                inputs = []\n-                inputs_value = 0\n-                for j, tx in enumerate(tx_id[0:i]):\n-                    # Transaction tx[K] is a child of each of previous transactions tx[0]..tx[K-1] at their output K-1.\n-                    vout = i - j - 1\n-                    inputs.append({'txid': tx_id[j], 'vout': vout})\n-                    inputs_value += self.nodes[0].gettxout(tx, vout)['value']\n-\n-            self.log.debug('inputs={}'.format(inputs))\n-            self.log.debug('inputs_value={}'.format(inputs_value))\n-\n-            # Prepare outputs.\n-            tx_count = i + 1\n-            if tx_count < size:\n-                # Transaction tx[K] is an ancestor of each of subsequent transactions tx[K+1]..tx[N-1].\n-                n_outputs = size - tx_count\n-                output_value = ((inputs_value - fee) / Decimal(n_outputs)).quantize(Decimal('0.00000001'))\n-                outputs = {}\n-                for _ in range(n_outputs):\n-                    outputs[self.nodes[0].getnewaddress()] = output_value\n-            else:\n-                output_value = (inputs_value - fee).quantize(Decimal('0.00000001'))\n-                outputs = {end_address: output_value}\n-\n-            self.log.debug('output_value={}'.format(output_value))\n-            self.log.debug('outputs={}'.format(outputs))\n-\n-            # Create a new transaction.\n-            unsigned_raw_tx = self.nodes[0].createrawtransaction(inputs, outputs)\n-            signed_raw_tx = self.nodes[0].signrawtransactionwithwallet(unsigned_raw_tx)\n-            tx_id.append(self.nodes[0].sendrawtransaction(signed_raw_tx['hex']))\n-            tx_size.append(self.nodes[0].getrawmempool(True)[tx_id[-1]]['vsize'])\n-\n-            if tx_count in n_tx_to_mine:\n-                # The created transactions are mined into blocks by batches.\n-                self.log.info('The batch of {} transactions has been accepted into the mempool.'.format(len(self.nodes[0].getrawmempool())))\n-                block_hash = self.nodes[0].generate(1)[0]\n-                if not first_block_hash:\n-                    first_block_hash = block_hash\n-                assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        self.wallet.generate(1)\n+        node.generate(size)\n+        txs = []\n+        block_ids = []\n+        tx_size = []\n+        for i in range(size):\n+            txs.append(self.wallet.send_self_transfer(from_node=node))\n+            tx_size.append(96)\n+            if (i+1) % n_tx_to_mine == 0:\n+                self.log.info('The batch of {} transactions has been accepted into the mempool.'\n+                .format(len(node.getrawmempool())))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21999#discussion_r636310625",
      "id" : 636310625,
      "in_reply_to_id" : 636278997,
      "line" : 51,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjMxMDYyNQ==",
      "original_commit_id" : "b7c6eea86154320520fa6766c4a87f6ad4c1b899",
      "original_line" : 51,
      "original_position" : 98,
      "original_start_line" : null,
      "path" : "test/functional/mempool_updatefromblock.py",
      "position" : 98,
      "pull_request_review_id" : 664669323,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21999",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-20T17:24:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/636310625",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/13033037?v=4",
         "events_url" : "https://api.github.com/users/reemuru/events{/privacy}",
         "followers_url" : "https://api.github.com/users/reemuru/followers",
         "following_url" : "https://api.github.com/users/reemuru/following{/other_user}",
         "gists_url" : "https://api.github.com/users/reemuru/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/reemuru",
         "id" : 13033037,
         "login" : "reemuru",
         "node_id" : "MDQ6VXNlcjEzMDMzMDM3",
         "organizations_url" : "https://api.github.com/users/reemuru/orgs",
         "received_events_url" : "https://api.github.com/users/reemuru/received_events",
         "repos_url" : "https://api.github.com/users/reemuru/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/reemuru/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/reemuru/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/reemuru"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/21999#discussion_r636311404"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21999"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/636311404"
         }
      },
      "author_association" : "NONE",
      "body" : "I think I was using this for debugging and set to info by mistake. Should remove this to reduce clutter on the console for sure.",
      "commit_id" : "a02da6d8c0d4951111df7b035388f01dbe526d0a",
      "created_at" : "2021-05-20T17:26:07Z",
      "diff_hunk" : "@@ -38,86 +35,52 @@ def transaction_graph_test(self, size, n_tx_to_mine=None, start_input_txid='', e\n         More details: https://en.wikipedia.org/wiki/Tournament_(graph_theory)\n         \"\"\"\n \n-        if not start_input_txid:\n-            start_input_txid = self.nodes[0].getblock(self.nodes[0].getblockhash(1))['tx'][0]\n-\n-        if not end_address:\n-            end_address = self.nodes[0].getnewaddress()\n-\n-        first_block_hash = ''\n-        tx_id = []\n-        tx_size = []\n+        node = self.nodes[0]\n+        self.wallet = MiniWallet(node)\n         self.log.info('Creating {} transactions...'.format(size))\n-        for i in range(0, size):\n-            self.log.debug('Preparing transaction #{}...'.format(i))\n-            # Prepare inputs.\n-            if i == 0:\n-                inputs = [{'txid': start_input_txid, 'vout': 0}]\n-                inputs_value = self.nodes[0].gettxout(start_input_txid, 0)['value']\n-            else:\n-                inputs = []\n-                inputs_value = 0\n-                for j, tx in enumerate(tx_id[0:i]):\n-                    # Transaction tx[K] is a child of each of previous transactions tx[0]..tx[K-1] at their output K-1.\n-                    vout = i - j - 1\n-                    inputs.append({'txid': tx_id[j], 'vout': vout})\n-                    inputs_value += self.nodes[0].gettxout(tx, vout)['value']\n-\n-            self.log.debug('inputs={}'.format(inputs))\n-            self.log.debug('inputs_value={}'.format(inputs_value))\n-\n-            # Prepare outputs.\n-            tx_count = i + 1\n-            if tx_count < size:\n-                # Transaction tx[K] is an ancestor of each of subsequent transactions tx[K+1]..tx[N-1].\n-                n_outputs = size - tx_count\n-                output_value = ((inputs_value - fee) / Decimal(n_outputs)).quantize(Decimal('0.00000001'))\n-                outputs = {}\n-                for _ in range(n_outputs):\n-                    outputs[self.nodes[0].getnewaddress()] = output_value\n-            else:\n-                output_value = (inputs_value - fee).quantize(Decimal('0.00000001'))\n-                outputs = {end_address: output_value}\n-\n-            self.log.debug('output_value={}'.format(output_value))\n-            self.log.debug('outputs={}'.format(outputs))\n-\n-            # Create a new transaction.\n-            unsigned_raw_tx = self.nodes[0].createrawtransaction(inputs, outputs)\n-            signed_raw_tx = self.nodes[0].signrawtransactionwithwallet(unsigned_raw_tx)\n-            tx_id.append(self.nodes[0].sendrawtransaction(signed_raw_tx['hex']))\n-            tx_size.append(self.nodes[0].getrawmempool(True)[tx_id[-1]]['vsize'])\n-\n-            if tx_count in n_tx_to_mine:\n-                # The created transactions are mined into blocks by batches.\n-                self.log.info('The batch of {} transactions has been accepted into the mempool.'.format(len(self.nodes[0].getrawmempool())))\n-                block_hash = self.nodes[0].generate(1)[0]\n-                if not first_block_hash:\n-                    first_block_hash = block_hash\n-                assert_equal(len(self.nodes[0].getrawmempool()), 0)\n+        self.wallet.generate(1)\n+        node.generate(size)\n+        txs = []\n+        block_ids = []\n+        tx_size = []\n+        for i in range(size):\n+            txs.append(self.wallet.send_self_transfer(from_node=node))\n+            tx_size.append(96)\n+            if (i+1) % n_tx_to_mine == 0:\n+                self.log.info('The batch of {} transactions has been accepted into the mempool.'\n+                .format(len(node.getrawmempool())))\n+                block_ids.append(self.wallet.generate(1)[0])\n+                assert_equal(len(node.getrawmempool()), 0)\n                 self.log.info('All of the transactions from the current batch have been mined into a block.')\n-            elif tx_count == size:\n-                # At the end all of the mined blocks are invalidated, and all of the created\n-                # transactions should be re-added from disconnected blocks to the mempool.\n-                self.log.info('The last batch of {} transactions has been accepted into the mempool.'.format(len(self.nodes[0].getrawmempool())))\n-                start = time.time()\n-                self.nodes[0].invalidateblock(first_block_hash)\n-                end = time.time()\n-                assert_equal(len(self.nodes[0].getrawmempool()), size)\n-                self.log.info('All of the recently mined transactions have been re-added into the mempool in {} seconds.'.format(end - start))\n+                self.log.info('{}'.format(block_ids))",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/21999#discussion_r636311404",
      "id" : 636311404,
      "in_reply_to_id" : 636281765,
      "line" : 55,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNjMxMTQwNA==",
      "original_commit_id" : "b7c6eea86154320520fa6766c4a87f6ad4c1b899",
      "original_line" : 55,
      "original_position" : 111,
      "original_start_line" : null,
      "path" : "test/functional/mempool_updatefromblock.py",
      "position" : 111,
      "pull_request_review_id" : 664670413,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/21999",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-05-20T17:26:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/636311404",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/13033037?v=4",
         "events_url" : "https://api.github.com/users/reemuru/events{/privacy}",
         "followers_url" : "https://api.github.com/users/reemuru/followers",
         "following_url" : "https://api.github.com/users/reemuru/following{/other_user}",
         "gists_url" : "https://api.github.com/users/reemuru/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/reemuru",
         "id" : 13033037,
         "login" : "reemuru",
         "node_id" : "MDQ6VXNlcjEzMDMzMDM3",
         "organizations_url" : "https://api.github.com/users/reemuru/orgs",
         "received_events_url" : "https://api.github.com/users/reemuru/received_events",
         "repos_url" : "https://api.github.com/users/reemuru/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/reemuru/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/reemuru/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/reemuru"
      }
   }
]
