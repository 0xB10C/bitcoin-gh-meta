[
   {
      "body" : "Concept ACK!   I'm glad that you're working on this. I think it's the right approach.\r\nThe other advantage is that right now, IIRC, once the ulimit maximum of locked pages is reached, no more data will be locked... silent... and the massive locked page inflation makes it easy to hit any reasonable limit quickly.",
      "created_at" : "2016-09-18T09:23:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247836948",
      "id" : 247836948,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T09:23:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247836948",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "There is no\r\n```\r\nstatic inline std::pair<std::string,UniValue> Pair(const char *, size_t)\r\n```\r\n",
      "created_at" : "2016-09-18T09:50:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247838140",
      "id" : 247838140,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T09:50:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247838140",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "> The other advantage is that right now, IIRC, once the ulimit maximum of locked pages is reached, no more data will be locked... silent... and the massive locked page inflation makes it easy to hit any reasonable limit quickly.\r\n\r\nIndeed. I've also been thinking about heartbleed-like attacks. Currently key data is scattered all around the heap and stack, with this approach it is consolidated in a few places which are separate from the normal heap where e.g. network buffers are allocated.\r\n\r\nIt would help even more if the secret data is separated with a 'moat' of unmapped pages from the normal heap, so that a large read can't get there.\r\n\r\nI've done nothing special to accomplish this at the moment, though, apart from trying to use the OS page allocation directly. Which reminds me that on POSIX I should probably be using `mmap` not `posix_memalign` which may just grab the memory from the heap.\r\n\r\n> static inline std::pair<std::string,UniValue> Pair(const char *, size_t)\r\n\r\nGah, that needs a silly cast to uint64_t (I guess this error comes up on 32-bit platforms?).\r\n",
      "created_at" : "2016-09-18T10:22:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247839585",
      "id" : 247839585,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T10:25:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247839585",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79303352"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79303352"
         }
      },
      "body" : "`_allocator` here please.",
      "commit_id" : "386e1f2c2bb89960ceeeabf86de501dceaa43d64",
      "created_at" : "2016-09-18T11:04:53Z",
      "diff_hunk" : "@@ -0,0 +1,354 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"support/lockedpool.h\"\n+#include \"support/cleanse.h\"\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#ifdef WIN32\n+#ifdef _WIN32_WINNT\n+#undef _WIN32_WINNT\n+#endif\n+#define _WIN32_WINNT 0x0501\n+#define WIN32_LEAN_AND_MEAN 1\n+#ifndef NOMINMAX\n+#define NOMINMAX\n+#endif\n+#include <windows.h>\n+#else\n+#include <sys/mman.h>\n+#include <limits.h> // for PAGESIZE\n+#include <unistd.h> // for sysconf\n+#endif\n+\n+LockedPoolManager* LockedPoolManager::_instance = NULL;\n+boost::once_flag LockedPoolManager::init_flag = BOOST_ONCE_INIT;\n+\n+/*******************************************************************************/\n+// Utilities\n+//\n+/** Align up to power of 2 */\n+static inline size_t align_up(size_t x, size_t align)\n+{\n+    return (x + align - 1) & ~(align - 1);\n+}\n+\n+/*******************************************************************************/\n+// Implementation: Arena\n+\n+Arena::Arena(void *base, size_t size, size_t alignment_in):\n+    alignment(alignment_in)\n+{\n+    chunks.emplace(reinterpret_cast<uintptr_t>(base), Chunk(size, 0));\n+}\n+\n+Arena::~Arena()\n+{\n+}\n+\n+void* Arena::alloc(size_t size)\n+{\n+    /* Round to next multiple of alignment */\n+    size = (size + alignment - 1) & ~(alignment-1);\n+\n+    /* Don't handle zero-sized chunks */\n+    if (size == 0)\n+        return nullptr;\n+\n+    for (auto& chunk: chunks)\n+    {\n+        if (!(chunk.second.flags & ChunkFlags::INUSE) && size <= chunk.second.size)\n+        {\n+            uintptr_t base = chunk.first;\n+            size_t leftover = chunk.second.size - size;\n+            if (leftover > 0) // Split chunk\n+            {\n+                chunks.emplace(base + size, Chunk(leftover, 0));\n+                chunk.second.size = size;\n+            }\n+            chunk.second.flags |= ChunkFlags::INUSE;\n+            return reinterpret_cast<void*>(base);\n+        }\n+    }\n+    return nullptr;\n+}\n+\n+void Arena::free(void *ptr)\n+{\n+    /* Freeing the NULL pointer is OK. */\n+    if (ptr == nullptr)\n+        return;\n+    auto i = chunks.find(reinterpret_cast<uintptr_t>(ptr));\n+    if (i == chunks.end() || !(i->second.flags & ChunkFlags::INUSE))\n+        throw std::runtime_error(\"Arena: invalid or double free\");\n+\n+    i->second.flags &= ~ChunkFlags::INUSE;\n+\n+    if (i != chunks.begin()) // Absorb into previous chunk if exists and free\n+    {\n+        auto prev = i;\n+        --prev;\n+        if (!(prev->second.flags & ChunkFlags::INUSE))\n+        {\n+            // Absorb current chunk size into previous chunk.\n+            prev->second.size += i->second.size;\n+            // Erase current chunk. Erasing does not invalidate current iterators for a map.\n+            chunks.erase(i);\n+            // From here on, the previous chunk is our current chunk.\n+            i = prev;\n+        }\n+    }\n+    auto next = i;\n+    ++next;\n+    if (next != chunks.end()) // Absorb next chunk if exists and free\n+    {\n+        if (!(next->second.flags & ChunkFlags::INUSE))\n+        {\n+            // Absurb next chunk size into current chunk\n+            i->second.size += next->second.size;\n+            // Erase next chunk.\n+            chunks.erase(next);\n+        }\n+    }\n+}\n+\n+Arena::Stats Arena::stats() const\n+{\n+    Arena::Stats r;\n+    r.used = r.free = r.total = 0;\n+    for (const auto& chunk: chunks)\n+    {\n+        if (chunk.second.flags & ChunkFlags::INUSE)\n+            r.used += chunk.second.size;\n+        else\n+            r.free += chunk.second.size;\n+        r.total += chunk.second.size;\n+    }\n+    return r;\n+}\n+\n+#ifdef ARENA_DEBUG\n+void Arena::walk() const\n+{\n+    for (const auto& chunk: chunks)\n+    {\n+        std::cout <<\n+            \"0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.first <<\n+            \" 0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.second.size <<\n+            \" 0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.second.flags << std::endl;\n+    }\n+    std::cout << std::endl;\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: Win32LockedPageAllocator\n+\n+#ifdef WIN32\n+/** LockedPageAllocator specialized for Windows.\n+ */\n+class Win32LockedPageAllocator: public LockedPageAllocator\n+{\n+public:\n+    Win32LockedPageAllocator();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess);\n+    void FreeLocked(void* addr, size_t len);\n+private:\n+    size_t page_size;\n+}\n+\n+Win32LockedPageAllocator::Win32LockedPageAllocator()\n+{\n+    // Determine system page size in bytes\n+    SYSTEM_INFO sSysInfo;\n+    GetSystemInfo(&sSysInfo);\n+    page_size = sSysInfo.dwPageSize;\n+}\n+void *Win32LockedPageAllocator::AllocateLocked(size_t len, bool *lockingSuccess)\n+{\n+    len = align_up(len, page_size);\n+    void *addr = VirtualAlloc(nullptr, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n+    if (addr) {\n+        // VirtualLock is used to attempt to keep keying material out of swap Note\n+        // that it does not provide this as a guarantee, but, in practice, memory\n+        // that has been VirtualLock'd almost never gets written to the pagefile\n+        // except in rare circumstances where memory is extremely low.\n+        *lockingSuccess = VirtualLock(const_cast<void*>(addr), len) != 0;\n+    }\n+    return addr;\n+}\n+void Win32LockedPageAllocator::FreeLocked(const void* addr, size_t len)\n+{\n+    len = align_up(len, page_size);\n+    memory_cleanse(addr, len);\n+    VirtualUnlock(const_cast<void*>(addr), len);\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: PosixLockedPageAllocator\n+\n+#ifndef WIN32\n+/** LockedPageAllocator specialized for OSes that don't try to be\n+ * special snowflakes.\n+ */\n+class PosixLockedPageAllocator: public LockedPageAllocator\n+{\n+public:\n+    PosixLockedPageAllocator();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess);\n+    void FreeLocked(void* addr, size_t len);\n+private:\n+    size_t page_size;\n+};\n+\n+PosixLockedPageAllocator::PosixLockedPageAllocator()\n+{\n+    // Determine system page size in bytes\n+#if defined(PAGESIZE) // defined in limits.h\n+    page_size = PAGESIZE;\n+#else                   // assume some POSIX OS\n+    page_size = sysconf(_SC_PAGESIZE);\n+#endif\n+}\n+void *PosixLockedPageAllocator::AllocateLocked(size_t len, bool *lockingSuccess)\n+{\n+    void *addr;\n+    len = align_up(len, page_size);\n+    addr = mmap(nullptr, len, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n+    if (addr) {\n+        *lockingSuccess = mlock(addr, len) == 0;\n+    }\n+    return addr;\n+}\n+void PosixLockedPageAllocator::FreeLocked(void* addr, size_t len)\n+{\n+    len = align_up(len, page_size);\n+    memory_cleanse(addr, len);\n+    munlock(addr, len);\n+    munmap(addr, len);\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: LockedPool\n+\n+LockedPool::LockedPool(std::unique_ptr<LockedPageAllocator> allocator, LockingFailed_Callback lf_cb_in):\n+    allocator(std::move(allocator)), lf_cb(lf_cb_in), cumulative_bytes_locked(0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79303352",
      "id" : 79303352,
      "original_commit_id" : "2d603c97df474abd09d4f8c0fdb3e8e70e2a2f52",
      "original_position" : 241,
      "path" : "src/support/lockedpool.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-18T11:10:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79303352",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79303409"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79303409"
         }
      },
      "body" : "As you use `x` down in for cycles, please change this.",
      "commit_id" : "386e1f2c2bb89960ceeeabf86de501dceaa43d64",
      "created_at" : "2016-09-18T11:07:36Z",
      "diff_hunk" : "@@ -11,110 +11,210 @@\n \n BOOST_FIXTURE_TEST_SUITE(allocator_tests, BasicTestingSetup)\n \n-// Dummy memory page locker for platform independent tests\n-static const void *last_lock_addr, *last_unlock_addr;\n-static size_t last_lock_len, last_unlock_len;\n-class TestLocker\n+BOOST_AUTO_TEST_CASE(arena_tests)\n {\n-public:\n-    bool Lock(const void *addr, size_t len)\n+    // Fake memory base address for testing\n+    // without actually using memory.\n+    void *synth_base = reinterpret_cast<void*>(0x08000000);\n+    const size_t synth_size = 1024*1024;\n+    Arena b(synth_base, synth_size, 16);\n+    void *x = b.alloc(1000);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79303409",
      "id" : 79303409,
      "original_commit_id" : "2d603c97df474abd09d4f8c0fdb3e8e70e2a2f52",
      "original_position" : 17,
      "path" : "src/test/allocator_tests.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-18T11:10:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79303409",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79303418"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79303418"
         }
      },
      "body" : "I'm using `_in` as convention in this file, but yes it shouldn't shadow here.",
      "commit_id" : "386e1f2c2bb89960ceeeabf86de501dceaa43d64",
      "created_at" : "2016-09-18T11:08:05Z",
      "diff_hunk" : "@@ -0,0 +1,354 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"support/lockedpool.h\"\n+#include \"support/cleanse.h\"\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#ifdef WIN32\n+#ifdef _WIN32_WINNT\n+#undef _WIN32_WINNT\n+#endif\n+#define _WIN32_WINNT 0x0501\n+#define WIN32_LEAN_AND_MEAN 1\n+#ifndef NOMINMAX\n+#define NOMINMAX\n+#endif\n+#include <windows.h>\n+#else\n+#include <sys/mman.h>\n+#include <limits.h> // for PAGESIZE\n+#include <unistd.h> // for sysconf\n+#endif\n+\n+LockedPoolManager* LockedPoolManager::_instance = NULL;\n+boost::once_flag LockedPoolManager::init_flag = BOOST_ONCE_INIT;\n+\n+/*******************************************************************************/\n+// Utilities\n+//\n+/** Align up to power of 2 */\n+static inline size_t align_up(size_t x, size_t align)\n+{\n+    return (x + align - 1) & ~(align - 1);\n+}\n+\n+/*******************************************************************************/\n+// Implementation: Arena\n+\n+Arena::Arena(void *base, size_t size, size_t alignment_in):\n+    alignment(alignment_in)\n+{\n+    chunks.emplace(reinterpret_cast<uintptr_t>(base), Chunk(size, 0));\n+}\n+\n+Arena::~Arena()\n+{\n+}\n+\n+void* Arena::alloc(size_t size)\n+{\n+    /* Round to next multiple of alignment */\n+    size = (size + alignment - 1) & ~(alignment-1);\n+\n+    /* Don't handle zero-sized chunks */\n+    if (size == 0)\n+        return nullptr;\n+\n+    for (auto& chunk: chunks)\n+    {\n+        if (!(chunk.second.flags & ChunkFlags::INUSE) && size <= chunk.second.size)\n+        {\n+            uintptr_t base = chunk.first;\n+            size_t leftover = chunk.second.size - size;\n+            if (leftover > 0) // Split chunk\n+            {\n+                chunks.emplace(base + size, Chunk(leftover, 0));\n+                chunk.second.size = size;\n+            }\n+            chunk.second.flags |= ChunkFlags::INUSE;\n+            return reinterpret_cast<void*>(base);\n+        }\n+    }\n+    return nullptr;\n+}\n+\n+void Arena::free(void *ptr)\n+{\n+    /* Freeing the NULL pointer is OK. */\n+    if (ptr == nullptr)\n+        return;\n+    auto i = chunks.find(reinterpret_cast<uintptr_t>(ptr));\n+    if (i == chunks.end() || !(i->second.flags & ChunkFlags::INUSE))\n+        throw std::runtime_error(\"Arena: invalid or double free\");\n+\n+    i->second.flags &= ~ChunkFlags::INUSE;\n+\n+    if (i != chunks.begin()) // Absorb into previous chunk if exists and free\n+    {\n+        auto prev = i;\n+        --prev;\n+        if (!(prev->second.flags & ChunkFlags::INUSE))\n+        {\n+            // Absorb current chunk size into previous chunk.\n+            prev->second.size += i->second.size;\n+            // Erase current chunk. Erasing does not invalidate current iterators for a map.\n+            chunks.erase(i);\n+            // From here on, the previous chunk is our current chunk.\n+            i = prev;\n+        }\n+    }\n+    auto next = i;\n+    ++next;\n+    if (next != chunks.end()) // Absorb next chunk if exists and free\n+    {\n+        if (!(next->second.flags & ChunkFlags::INUSE))\n+        {\n+            // Absurb next chunk size into current chunk\n+            i->second.size += next->second.size;\n+            // Erase next chunk.\n+            chunks.erase(next);\n+        }\n+    }\n+}\n+\n+Arena::Stats Arena::stats() const\n+{\n+    Arena::Stats r;\n+    r.used = r.free = r.total = 0;\n+    for (const auto& chunk: chunks)\n+    {\n+        if (chunk.second.flags & ChunkFlags::INUSE)\n+            r.used += chunk.second.size;\n+        else\n+            r.free += chunk.second.size;\n+        r.total += chunk.second.size;\n+    }\n+    return r;\n+}\n+\n+#ifdef ARENA_DEBUG\n+void Arena::walk() const\n+{\n+    for (const auto& chunk: chunks)\n+    {\n+        std::cout <<\n+            \"0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.first <<\n+            \" 0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.second.size <<\n+            \" 0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.second.flags << std::endl;\n+    }\n+    std::cout << std::endl;\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: Win32LockedPageAllocator\n+\n+#ifdef WIN32\n+/** LockedPageAllocator specialized for Windows.\n+ */\n+class Win32LockedPageAllocator: public LockedPageAllocator\n+{\n+public:\n+    Win32LockedPageAllocator();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess);\n+    void FreeLocked(void* addr, size_t len);\n+private:\n+    size_t page_size;\n+}\n+\n+Win32LockedPageAllocator::Win32LockedPageAllocator()\n+{\n+    // Determine system page size in bytes\n+    SYSTEM_INFO sSysInfo;\n+    GetSystemInfo(&sSysInfo);\n+    page_size = sSysInfo.dwPageSize;\n+}\n+void *Win32LockedPageAllocator::AllocateLocked(size_t len, bool *lockingSuccess)\n+{\n+    len = align_up(len, page_size);\n+    void *addr = VirtualAlloc(nullptr, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n+    if (addr) {\n+        // VirtualLock is used to attempt to keep keying material out of swap Note\n+        // that it does not provide this as a guarantee, but, in practice, memory\n+        // that has been VirtualLock'd almost never gets written to the pagefile\n+        // except in rare circumstances where memory is extremely low.\n+        *lockingSuccess = VirtualLock(const_cast<void*>(addr), len) != 0;\n+    }\n+    return addr;\n+}\n+void Win32LockedPageAllocator::FreeLocked(const void* addr, size_t len)\n+{\n+    len = align_up(len, page_size);\n+    memory_cleanse(addr, len);\n+    VirtualUnlock(const_cast<void*>(addr), len);\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: PosixLockedPageAllocator\n+\n+#ifndef WIN32\n+/** LockedPageAllocator specialized for OSes that don't try to be\n+ * special snowflakes.\n+ */\n+class PosixLockedPageAllocator: public LockedPageAllocator\n+{\n+public:\n+    PosixLockedPageAllocator();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess);\n+    void FreeLocked(void* addr, size_t len);\n+private:\n+    size_t page_size;\n+};\n+\n+PosixLockedPageAllocator::PosixLockedPageAllocator()\n+{\n+    // Determine system page size in bytes\n+#if defined(PAGESIZE) // defined in limits.h\n+    page_size = PAGESIZE;\n+#else                   // assume some POSIX OS\n+    page_size = sysconf(_SC_PAGESIZE);\n+#endif\n+}\n+void *PosixLockedPageAllocator::AllocateLocked(size_t len, bool *lockingSuccess)\n+{\n+    void *addr;\n+    len = align_up(len, page_size);\n+    addr = mmap(nullptr, len, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n+    if (addr) {\n+        *lockingSuccess = mlock(addr, len) == 0;\n+    }\n+    return addr;\n+}\n+void PosixLockedPageAllocator::FreeLocked(void* addr, size_t len)\n+{\n+    len = align_up(len, page_size);\n+    memory_cleanse(addr, len);\n+    munlock(addr, len);\n+    munmap(addr, len);\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: LockedPool\n+\n+LockedPool::LockedPool(std::unique_ptr<LockedPageAllocator> allocator, LockingFailed_Callback lf_cb_in):\n+    allocator(std::move(allocator)), lf_cb(lf_cb_in), cumulative_bytes_locked(0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79303418",
      "id" : 79303418,
      "original_commit_id" : "2d603c97df474abd09d4f8c0fdb3e8e70e2a2f52",
      "original_position" : 241,
      "path" : "src/support/lockedpool.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-18T11:10:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79303418",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "@paveljanik Ok, I've made your variable naming changes. But let's please discuss higher-level concerns first before bombarding nits in code that may be thrown away anyway.",
      "created_at" : "2016-09-18T11:10:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247841551",
      "id" : 247841551,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T11:10:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247841551",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "The higher level is already wrote by @gmaxwell, no need to repeat it.\r\n\r\nWith `ulimit -l` being unlimited, RPC returns:\r\n```\r\n{\r\n  \"locked\": {\r\n    \"used\": 200608,\r\n    \"free\": 61536,\r\n    \"total\": 262144,\r\n    \"locked\": 262144\r\n  }\r\n}\r\n```\r\n\r\nAfter `ulimit -l 128`, the result is:\r\n\r\n```\r\n{\r\n  \"locked\": {\r\n    \"used\": 200608,\r\n    \"free\": 61536,\r\n    \"total\": 262144,\r\n    \"locked\": 0\r\n  }\r\n}\r\n```\r\n\r\nNo memory locked at all? Or when we jump out of the limit, you do not lock anything?\r\n\r\nHmm, arena is 256k min. Will try with lower arena size.\r\n\r\nChanged arenasize to 128k and:\r\n\r\n```\r\n{\r\n  \"locked\": {\r\n    \"used\": 200608,\r\n    \"free\": 61536,\r\n    \"total\": 262144,\r\n    \"locked\": 131072\r\n  }\r\n}\r\n```\r\nGood!",
      "created_at" : "2016-09-18T12:00:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247843668",
      "id" : 247843668,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T12:16:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247843668",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79304140"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79304140"
         }
      },
      "body" : "New file, new convention? Welcome to Bitcoin Core...\r\n\r\n*Edit*: There is no need to markup irony ;-)",
      "commit_id" : "386e1f2c2bb89960ceeeabf86de501dceaa43d64",
      "created_at" : "2016-09-18T12:00:39Z",
      "diff_hunk" : "@@ -0,0 +1,354 @@\n+// Copyright (c) 2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"support/lockedpool.h\"\n+#include \"support/cleanse.h\"\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#ifdef WIN32\n+#ifdef _WIN32_WINNT\n+#undef _WIN32_WINNT\n+#endif\n+#define _WIN32_WINNT 0x0501\n+#define WIN32_LEAN_AND_MEAN 1\n+#ifndef NOMINMAX\n+#define NOMINMAX\n+#endif\n+#include <windows.h>\n+#else\n+#include <sys/mman.h>\n+#include <limits.h> // for PAGESIZE\n+#include <unistd.h> // for sysconf\n+#endif\n+\n+LockedPoolManager* LockedPoolManager::_instance = NULL;\n+boost::once_flag LockedPoolManager::init_flag = BOOST_ONCE_INIT;\n+\n+/*******************************************************************************/\n+// Utilities\n+//\n+/** Align up to power of 2 */\n+static inline size_t align_up(size_t x, size_t align)\n+{\n+    return (x + align - 1) & ~(align - 1);\n+}\n+\n+/*******************************************************************************/\n+// Implementation: Arena\n+\n+Arena::Arena(void *base, size_t size, size_t alignment_in):\n+    alignment(alignment_in)\n+{\n+    chunks.emplace(reinterpret_cast<uintptr_t>(base), Chunk(size, 0));\n+}\n+\n+Arena::~Arena()\n+{\n+}\n+\n+void* Arena::alloc(size_t size)\n+{\n+    /* Round to next multiple of alignment */\n+    size = (size + alignment - 1) & ~(alignment-1);\n+\n+    /* Don't handle zero-sized chunks */\n+    if (size == 0)\n+        return nullptr;\n+\n+    for (auto& chunk: chunks)\n+    {\n+        if (!(chunk.second.flags & ChunkFlags::INUSE) && size <= chunk.second.size)\n+        {\n+            uintptr_t base = chunk.first;\n+            size_t leftover = chunk.second.size - size;\n+            if (leftover > 0) // Split chunk\n+            {\n+                chunks.emplace(base + size, Chunk(leftover, 0));\n+                chunk.second.size = size;\n+            }\n+            chunk.second.flags |= ChunkFlags::INUSE;\n+            return reinterpret_cast<void*>(base);\n+        }\n+    }\n+    return nullptr;\n+}\n+\n+void Arena::free(void *ptr)\n+{\n+    /* Freeing the NULL pointer is OK. */\n+    if (ptr == nullptr)\n+        return;\n+    auto i = chunks.find(reinterpret_cast<uintptr_t>(ptr));\n+    if (i == chunks.end() || !(i->second.flags & ChunkFlags::INUSE))\n+        throw std::runtime_error(\"Arena: invalid or double free\");\n+\n+    i->second.flags &= ~ChunkFlags::INUSE;\n+\n+    if (i != chunks.begin()) // Absorb into previous chunk if exists and free\n+    {\n+        auto prev = i;\n+        --prev;\n+        if (!(prev->second.flags & ChunkFlags::INUSE))\n+        {\n+            // Absorb current chunk size into previous chunk.\n+            prev->second.size += i->second.size;\n+            // Erase current chunk. Erasing does not invalidate current iterators for a map.\n+            chunks.erase(i);\n+            // From here on, the previous chunk is our current chunk.\n+            i = prev;\n+        }\n+    }\n+    auto next = i;\n+    ++next;\n+    if (next != chunks.end()) // Absorb next chunk if exists and free\n+    {\n+        if (!(next->second.flags & ChunkFlags::INUSE))\n+        {\n+            // Absurb next chunk size into current chunk\n+            i->second.size += next->second.size;\n+            // Erase next chunk.\n+            chunks.erase(next);\n+        }\n+    }\n+}\n+\n+Arena::Stats Arena::stats() const\n+{\n+    Arena::Stats r;\n+    r.used = r.free = r.total = 0;\n+    for (const auto& chunk: chunks)\n+    {\n+        if (chunk.second.flags & ChunkFlags::INUSE)\n+            r.used += chunk.second.size;\n+        else\n+            r.free += chunk.second.size;\n+        r.total += chunk.second.size;\n+    }\n+    return r;\n+}\n+\n+#ifdef ARENA_DEBUG\n+void Arena::walk() const\n+{\n+    for (const auto& chunk: chunks)\n+    {\n+        std::cout <<\n+            \"0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.first <<\n+            \" 0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.second.size <<\n+            \" 0x\" << std::hex << std::setw(16) << std::setfill('0') << chunk.second.flags << std::endl;\n+    }\n+    std::cout << std::endl;\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: Win32LockedPageAllocator\n+\n+#ifdef WIN32\n+/** LockedPageAllocator specialized for Windows.\n+ */\n+class Win32LockedPageAllocator: public LockedPageAllocator\n+{\n+public:\n+    Win32LockedPageAllocator();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess);\n+    void FreeLocked(void* addr, size_t len);\n+private:\n+    size_t page_size;\n+}\n+\n+Win32LockedPageAllocator::Win32LockedPageAllocator()\n+{\n+    // Determine system page size in bytes\n+    SYSTEM_INFO sSysInfo;\n+    GetSystemInfo(&sSysInfo);\n+    page_size = sSysInfo.dwPageSize;\n+}\n+void *Win32LockedPageAllocator::AllocateLocked(size_t len, bool *lockingSuccess)\n+{\n+    len = align_up(len, page_size);\n+    void *addr = VirtualAlloc(nullptr, len, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);\n+    if (addr) {\n+        // VirtualLock is used to attempt to keep keying material out of swap Note\n+        // that it does not provide this as a guarantee, but, in practice, memory\n+        // that has been VirtualLock'd almost never gets written to the pagefile\n+        // except in rare circumstances where memory is extremely low.\n+        *lockingSuccess = VirtualLock(const_cast<void*>(addr), len) != 0;\n+    }\n+    return addr;\n+}\n+void Win32LockedPageAllocator::FreeLocked(const void* addr, size_t len)\n+{\n+    len = align_up(len, page_size);\n+    memory_cleanse(addr, len);\n+    VirtualUnlock(const_cast<void*>(addr), len);\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: PosixLockedPageAllocator\n+\n+#ifndef WIN32\n+/** LockedPageAllocator specialized for OSes that don't try to be\n+ * special snowflakes.\n+ */\n+class PosixLockedPageAllocator: public LockedPageAllocator\n+{\n+public:\n+    PosixLockedPageAllocator();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess);\n+    void FreeLocked(void* addr, size_t len);\n+private:\n+    size_t page_size;\n+};\n+\n+PosixLockedPageAllocator::PosixLockedPageAllocator()\n+{\n+    // Determine system page size in bytes\n+#if defined(PAGESIZE) // defined in limits.h\n+    page_size = PAGESIZE;\n+#else                   // assume some POSIX OS\n+    page_size = sysconf(_SC_PAGESIZE);\n+#endif\n+}\n+void *PosixLockedPageAllocator::AllocateLocked(size_t len, bool *lockingSuccess)\n+{\n+    void *addr;\n+    len = align_up(len, page_size);\n+    addr = mmap(nullptr, len, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n+    if (addr) {\n+        *lockingSuccess = mlock(addr, len) == 0;\n+    }\n+    return addr;\n+}\n+void PosixLockedPageAllocator::FreeLocked(void* addr, size_t len)\n+{\n+    len = align_up(len, page_size);\n+    memory_cleanse(addr, len);\n+    munlock(addr, len);\n+    munmap(addr, len);\n+}\n+#endif\n+\n+/*******************************************************************************/\n+// Implementation: LockedPool\n+\n+LockedPool::LockedPool(std::unique_ptr<LockedPageAllocator> allocator, LockingFailed_Callback lf_cb_in):\n+    allocator(std::move(allocator)), lf_cb(lf_cb_in), cumulative_bytes_locked(0)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#discussion_r79304140",
      "id" : 79304140,
      "original_commit_id" : "2d603c97df474abd09d4f8c0fdb3e8e70e2a2f52",
      "original_position" : 241,
      "path" : "src/support/lockedpool.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/8753",
      "updated_at" : "2016-09-18T12:01:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/79304140",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "The default `ulimit -l` values can bring a lot of fun here... OS X unlimited, SUSE Linux 64k etc.",
      "created_at" : "2016-09-18T12:19:29Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/8753#issuecomment-247844473",
      "id" : 247844473,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/8753",
      "updated_at" : "2016-09-18T12:19:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/247844473",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   }
]
