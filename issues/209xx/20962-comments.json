[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nNo conflicts as of last run.",
      "created_at" : "2021-01-24T23:59:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#issuecomment-766463849",
      "id" : 766463849,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20962",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2NjQ2Mzg0OQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-24T19:40:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/766463849",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-01-26T09:06:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#issuecomment-767404737",
      "id" : 767404737,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20962",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2NzQwNDczNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-26T09:06:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/767404737",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased",
      "created_at" : "2021-01-29T08:47:43Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#issuecomment-769666976",
      "id" : 769666976,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20962",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDc2OTY2Njk3Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-01-29T08:47:43Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/769666976",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/178464?v=4",
         "events_url" : "https://api.github.com/users/jonasschnelli/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jonasschnelli/followers",
         "following_url" : "https://api.github.com/users/jonasschnelli/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jonasschnelli",
         "id" : 178464,
         "login" : "jonasschnelli",
         "node_id" : "MDQ6VXNlcjE3ODQ2NA==",
         "organizations_url" : "https://api.github.com/users/jonasschnelli/orgs",
         "received_events_url" : "https://api.github.com/users/jonasschnelli/received_events",
         "repos_url" : "https://api.github.com/users/jonasschnelli/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jonasschnelli/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jonasschnelli"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@sipa @jonasschnelli Is there a reason why this PR has stalled?",
      "created_at" : "2021-05-23T17:36:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#issuecomment-846598517",
      "id" : 846598517,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20962",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg0NjU5ODUxNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-05-23T17:36:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/846598517",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6443210?v=4",
         "events_url" : "https://api.github.com/users/PastaPastaPasta/events{/privacy}",
         "followers_url" : "https://api.github.com/users/PastaPastaPasta/followers",
         "following_url" : "https://api.github.com/users/PastaPastaPasta/following{/other_user}",
         "gists_url" : "https://api.github.com/users/PastaPastaPasta/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/PastaPastaPasta",
         "id" : 6443210,
         "login" : "PastaPastaPasta",
         "node_id" : "MDQ6VXNlcjY0NDMyMTA=",
         "organizations_url" : "https://api.github.com/users/PastaPastaPasta/orgs",
         "received_events_url" : "https://api.github.com/users/PastaPastaPasta/received_events",
         "repos_url" : "https://api.github.com/users/PastaPastaPasta/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/PastaPastaPasta/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/PastaPastaPasta/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/PastaPastaPasta"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659021347"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659021347"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should this be `K_2`?",
      "commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "created_at" : "2021-06-25T20:32:30Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659021347",
      "id" : 659021347,
      "line" : 76,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTAyMTM0Nw==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 76,
      "original_position" : 125,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : 125,
      "pull_request_review_id" : 693173094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-28T18:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659021347",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659066917"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659066917"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "(nit): \"AEAD state changes (can't be called multiple times)\" -> \"AAD keystream will advance. As a result, DecryptLength() cannot be called multiple times to get the same result. The caller must cache the result for re-use.\"",
      "commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "created_at" : "2021-06-25T22:29:19Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same\n+* re-key rules.\n+*\n+*\n+* ==== Packet Handling ====\n+*\n+* When receiving a packet, the length must be decrypted first. When 3 bytes of\n+* ciphertext length have been received, they MUST be decrypted.\n+*\n+* Once the entire packet has been received, the MAC MUST be checked before\n+* decryption. A per-packet Poly1305 key is generated as described above and the\n+* MAC tag is calculated using Poly1305 with this key over the ciphertext of the\n+* packet length and the payload together. The calculated MAC is then compared in\n+* constant time with the one appended to the packet and the packet decrypted\n+* using ChaCha20 as described above (with K_2, the packet sequence number as\n+* nonce and a starting block counter of 1).\n+*\n+* Detection of an invalid MAC MUST lead to immediate connection termination.\n+*\n+* To send a packet, first encode the 3 byte length and encrypt it using the\n+* ChaCha20 stream keyed with K_1 as described above. Encrypt the packet payload\n+* (using the ChaCha20 stream keyed with K_2) and append it to the encrypted\n+* length. Finally, calculate a MAC tag and append it.\n+*/\n+\n+const int KEYSTREAM_SIZE = 4096;\n+\n+class ChaCha20ReKey4096 {\n+private:\n+    ChaCha20 m_ctx;\n+    uint64_t m_seqnr{0};\n+    size_t m_keystream_pos{0};\n+    unsigned char m_keystream[KEYSTREAM_SIZE] = {0};\n+public:\n+    ~ChaCha20ReKey4096();\n+    void SetKey(const unsigned char* key, size_t keylen);\n+    void Crypt(const unsigned char* input, unsigned char* output, size_t bytes);\n+};\n \n class ChaCha20Poly1305AEAD\n {\n private:\n-    ChaCha20 m_chacha_main;                                      // payload and poly1305 key-derivation cipher instance\n-    ChaCha20 m_chacha_header;                                    // AAD cipher instance (encrypted length)\n-    unsigned char m_aad_keystream_buffer[CHACHA20_ROUND_OUTPUT]; // aad keystream cache\n-    uint64_t m_cached_aad_seqnr;                                 // aad keystream cache hint\n+    ChaCha20ReKey4096 m_chacha_main;                                      // payload and poly1305 key-derivation cipher instance\n+    ChaCha20ReKey4096 m_chacha_header;                                    // AAD cipher instance (encrypted length)\n \n public:\n     ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len);\n \n     explicit ChaCha20Poly1305AEAD(const ChaCha20Poly1305AEAD&) = delete;\n \n     /** Encrypts/decrypts a packet\n-        seqnr_payload, the message sequence number\n-        seqnr_aad, the messages AAD sequence number which allows reuse of the AAD keystream\n-        aad_pos, position to use in the AAD keystream to encrypt the AAD\n         dest, output buffer, must be of a size equal or larger then CHACHA20_POLY1305_AEAD_AAD_LEN + payload (+ POLY1305_TAG_LEN in encryption) bytes\n         destlen, length of the destination buffer\n         src, the AAD+payload to encrypt or the AAD+payload+MAC to decrypt\n         src_len, the length of the source buffer\n         is_encrypt, set to true if we encrypt (creates and appends the MAC instead of verifying it)\n         */\n-    bool Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int aad_pos, unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);\n+    bool Crypt(unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);\n \n-    /** decrypts the 3 bytes AAD data and decodes it into a uint32_t field */\n-    bool GetLength(uint32_t* len24_out, uint64_t seqnr_aad, int aad_pos, const uint8_t* ciphertext);\n+    /** decrypts the 3 bytes AAD data (the packet length) and decodes it into a uint32_t field\n+        the ciphertext will not be manipulated but the AEAD state changes (can't be called multiple times)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659066917",
      "id" : 659066917,
      "line" : 136,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTA2NjkxNw==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 136,
      "original_position" : 195,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : 195,
      "pull_request_review_id" : 693173094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-28T18:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659066917",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659072624"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659072624"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "nit: `[[nodiscard]]` ?\r\n\r\nAlso, can we add to the comments: \"Returns true if encipher succeeds. Upon failure, the data at `dest` should not be used\"",
      "commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "created_at" : "2021-06-25T22:49:13Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same\n+* re-key rules.\n+*\n+*\n+* ==== Packet Handling ====\n+*\n+* When receiving a packet, the length must be decrypted first. When 3 bytes of\n+* ciphertext length have been received, they MUST be decrypted.\n+*\n+* Once the entire packet has been received, the MAC MUST be checked before\n+* decryption. A per-packet Poly1305 key is generated as described above and the\n+* MAC tag is calculated using Poly1305 with this key over the ciphertext of the\n+* packet length and the payload together. The calculated MAC is then compared in\n+* constant time with the one appended to the packet and the packet decrypted\n+* using ChaCha20 as described above (with K_2, the packet sequence number as\n+* nonce and a starting block counter of 1).\n+*\n+* Detection of an invalid MAC MUST lead to immediate connection termination.\n+*\n+* To send a packet, first encode the 3 byte length and encrypt it using the\n+* ChaCha20 stream keyed with K_1 as described above. Encrypt the packet payload\n+* (using the ChaCha20 stream keyed with K_2) and append it to the encrypted\n+* length. Finally, calculate a MAC tag and append it.\n+*/\n+\n+const int KEYSTREAM_SIZE = 4096;\n+\n+class ChaCha20ReKey4096 {\n+private:\n+    ChaCha20 m_ctx;\n+    uint64_t m_seqnr{0};\n+    size_t m_keystream_pos{0};\n+    unsigned char m_keystream[KEYSTREAM_SIZE] = {0};\n+public:\n+    ~ChaCha20ReKey4096();\n+    void SetKey(const unsigned char* key, size_t keylen);\n+    void Crypt(const unsigned char* input, unsigned char* output, size_t bytes);\n+};\n \n class ChaCha20Poly1305AEAD\n {\n private:\n-    ChaCha20 m_chacha_main;                                      // payload and poly1305 key-derivation cipher instance\n-    ChaCha20 m_chacha_header;                                    // AAD cipher instance (encrypted length)\n-    unsigned char m_aad_keystream_buffer[CHACHA20_ROUND_OUTPUT]; // aad keystream cache\n-    uint64_t m_cached_aad_seqnr;                                 // aad keystream cache hint\n+    ChaCha20ReKey4096 m_chacha_main;                                      // payload and poly1305 key-derivation cipher instance\n+    ChaCha20ReKey4096 m_chacha_header;                                    // AAD cipher instance (encrypted length)\n \n public:\n     ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len);\n \n     explicit ChaCha20Poly1305AEAD(const ChaCha20Poly1305AEAD&) = delete;\n \n     /** Encrypts/decrypts a packet\n-        seqnr_payload, the message sequence number\n-        seqnr_aad, the messages AAD sequence number which allows reuse of the AAD keystream\n-        aad_pos, position to use in the AAD keystream to encrypt the AAD\n         dest, output buffer, must be of a size equal or larger then CHACHA20_POLY1305_AEAD_AAD_LEN + payload (+ POLY1305_TAG_LEN in encryption) bytes\n         destlen, length of the destination buffer\n         src, the AAD+payload to encrypt or the AAD+payload+MAC to decrypt\n         src_len, the length of the source buffer\n         is_encrypt, set to true if we encrypt (creates and appends the MAC instead of verifying it)\n         */\n-    bool Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int aad_pos, unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);\n+    bool Crypt(unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659072624",
      "id" : 659072624,
      "line" : 133,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTA3MjYyNA==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 133,
      "original_position" : 190,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : 190,
      "pull_request_review_id" : 693173094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-28T18:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659072624",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659072639"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659072639"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Could this function signature be `[[nodiscard]] uint32_t DecryptLength(const uint8_t* ciphertext)` ? I'm curious why we return value using the pointer argument ?",
      "commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "created_at" : "2021-06-25T22:49:19Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same\n+* re-key rules.\n+*\n+*\n+* ==== Packet Handling ====\n+*\n+* When receiving a packet, the length must be decrypted first. When 3 bytes of\n+* ciphertext length have been received, they MUST be decrypted.\n+*\n+* Once the entire packet has been received, the MAC MUST be checked before\n+* decryption. A per-packet Poly1305 key is generated as described above and the\n+* MAC tag is calculated using Poly1305 with this key over the ciphertext of the\n+* packet length and the payload together. The calculated MAC is then compared in\n+* constant time with the one appended to the packet and the packet decrypted\n+* using ChaCha20 as described above (with K_2, the packet sequence number as\n+* nonce and a starting block counter of 1).\n+*\n+* Detection of an invalid MAC MUST lead to immediate connection termination.\n+*\n+* To send a packet, first encode the 3 byte length and encrypt it using the\n+* ChaCha20 stream keyed with K_1 as described above. Encrypt the packet payload\n+* (using the ChaCha20 stream keyed with K_2) and append it to the encrypted\n+* length. Finally, calculate a MAC tag and append it.\n+*/\n+\n+const int KEYSTREAM_SIZE = 4096;\n+\n+class ChaCha20ReKey4096 {\n+private:\n+    ChaCha20 m_ctx;\n+    uint64_t m_seqnr{0};\n+    size_t m_keystream_pos{0};\n+    unsigned char m_keystream[KEYSTREAM_SIZE] = {0};\n+public:\n+    ~ChaCha20ReKey4096();\n+    void SetKey(const unsigned char* key, size_t keylen);\n+    void Crypt(const unsigned char* input, unsigned char* output, size_t bytes);\n+};\n \n class ChaCha20Poly1305AEAD\n {\n private:\n-    ChaCha20 m_chacha_main;                                      // payload and poly1305 key-derivation cipher instance\n-    ChaCha20 m_chacha_header;                                    // AAD cipher instance (encrypted length)\n-    unsigned char m_aad_keystream_buffer[CHACHA20_ROUND_OUTPUT]; // aad keystream cache\n-    uint64_t m_cached_aad_seqnr;                                 // aad keystream cache hint\n+    ChaCha20ReKey4096 m_chacha_main;                                      // payload and poly1305 key-derivation cipher instance\n+    ChaCha20ReKey4096 m_chacha_header;                                    // AAD cipher instance (encrypted length)\n \n public:\n     ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len);\n \n     explicit ChaCha20Poly1305AEAD(const ChaCha20Poly1305AEAD&) = delete;\n \n     /** Encrypts/decrypts a packet\n-        seqnr_payload, the message sequence number\n-        seqnr_aad, the messages AAD sequence number which allows reuse of the AAD keystream\n-        aad_pos, position to use in the AAD keystream to encrypt the AAD\n         dest, output buffer, must be of a size equal or larger then CHACHA20_POLY1305_AEAD_AAD_LEN + payload (+ POLY1305_TAG_LEN in encryption) bytes\n         destlen, length of the destination buffer\n         src, the AAD+payload to encrypt or the AAD+payload+MAC to decrypt\n         src_len, the length of the source buffer\n         is_encrypt, set to true if we encrypt (creates and appends the MAC instead of verifying it)\n         */\n-    bool Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int aad_pos, unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);\n+    bool Crypt(unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);\n \n-    /** decrypts the 3 bytes AAD data and decodes it into a uint32_t field */\n-    bool GetLength(uint32_t* len24_out, uint64_t seqnr_aad, int aad_pos, const uint8_t* ciphertext);\n+    /** decrypts the 3 bytes AAD data (the packet length) and decodes it into a uint32_t field\n+        the ciphertext will not be manipulated but the AEAD state changes (can't be called multiple times)\n+        Ciphertext needs to stay encrypted due to the MAC check that will follow (requires encrypted length)\n+        */\n+    bool DecryptLength(uint32_t* len24_out, const uint8_t* ciphertext);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659072639",
      "id" : 659072639,
      "line" : 139,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTA3MjYzOQ==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 139,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : 198,
      "pull_request_review_id" : 693173094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-28T18:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659072639",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659089284"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659089284"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Would it make sense for this to be done in a constructor since this class implements re-keying internally and ideally, the user should not call this function more than once on an instance?",
      "commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "created_at" : "2021-06-26T00:07:58Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same\n+* re-key rules.\n+*\n+*\n+* ==== Packet Handling ====\n+*\n+* When receiving a packet, the length must be decrypted first. When 3 bytes of\n+* ciphertext length have been received, they MUST be decrypted.\n+*\n+* Once the entire packet has been received, the MAC MUST be checked before\n+* decryption. A per-packet Poly1305 key is generated as described above and the\n+* MAC tag is calculated using Poly1305 with this key over the ciphertext of the\n+* packet length and the payload together. The calculated MAC is then compared in\n+* constant time with the one appended to the packet and the packet decrypted\n+* using ChaCha20 as described above (with K_2, the packet sequence number as\n+* nonce and a starting block counter of 1).\n+*\n+* Detection of an invalid MAC MUST lead to immediate connection termination.\n+*\n+* To send a packet, first encode the 3 byte length and encrypt it using the\n+* ChaCha20 stream keyed with K_1 as described above. Encrypt the packet payload\n+* (using the ChaCha20 stream keyed with K_2) and append it to the encrypted\n+* length. Finally, calculate a MAC tag and append it.\n+*/\n+\n+const int KEYSTREAM_SIZE = 4096;\n+\n+class ChaCha20ReKey4096 {\n+private:\n+    ChaCha20 m_ctx;\n+    uint64_t m_seqnr{0};\n+    size_t m_keystream_pos{0};\n+    unsigned char m_keystream[KEYSTREAM_SIZE] = {0};\n+public:\n+    ~ChaCha20ReKey4096();\n+    void SetKey(const unsigned char* key, size_t keylen);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659089284",
      "id" : 659089284,
      "line" : 111,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTA4OTI4NA==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 111,
      "original_position" : 160,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : 160,
      "pull_request_review_id" : 693173094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-28T18:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659089284",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659123550"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659123550"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "To make sure I am understanding this correctly (did try it in godbolt): \r\n\r\n`ReadLE32(&m_keystream[m_keystream_pos])` will interpret 4 bytes starting at `m_keystream_pos` as a little endian encoded `uint32_t`. This means the LSB of the `uint32_t` will be the byte at `m_keystream[m_keystream_pos]`. The XOR with unsigned char will only use this LSB. Perhaps this was done for batching but not needed right now?\r\n\r\nI applied the patch below and `crypto_tests/chacha20_poly1305_aead_testvector` passed.\r\n\r\n```diff\r\ndiff --git a/src/crypto/chacha_poly_aead.cpp b/src/crypto/chacha_poly_aead.cpp\r\nindex bf261df55..139168fd7 100644\r\n--- a/src/crypto/chacha_poly_aead.cpp\r\n+++ b/src/crypto/chacha_poly_aead.cpp\r\n@@ -46,8 +46,7 @@ void ChaCha20ReKey4096::Crypt(const unsigned char* input, unsigned char* output,\r\n \r\n     // TODO: speedup with a block approach (rather then looping over every byte)\r\n     while (bytes > message_pos) {\r\n-        output[message_pos] = input[message_pos] ^ ReadLE32(&m_keystream[m_keystream_pos]);\r\n-        m_keystream_pos++;\r\n+        output[message_pos] = input[message_pos] ^ m_keystream[m_keystream_pos++];\r\n         message_pos++;\r\n         if (m_keystream_pos == KEYSTREAM_SIZE-CHACHA20_POLY1305_AEAD_KEY_LEN) {\r\n             // we reached the end of the keystream\r\n```",
      "commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "created_at" : "2021-06-26T05:40:07Z",
      "diff_hunk" : "@@ -27,19 +28,52 @@ int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n \n #endif // TIMINGSAFE_BCMP\n \n+void ChaCha20ReKey4096::SetKey(const unsigned char* key, size_t keylen) {\n+    assert(keylen == 32);\n+    m_ctx.SetKey(key, keylen);\n+\n+    // set initial sequence number\n+    m_seqnr = 0;\n+    m_ctx.SetIV(m_seqnr);\n+\n+    // precompute first chunk of keystream\n+    m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+    m_keystream_pos = 0;\n+}\n+\n+void ChaCha20ReKey4096::Crypt(const unsigned char* input, unsigned char* output, size_t bytes) {\n+    size_t message_pos = 0;\n+\n+    // TODO: speedup with a block approach (rather then looping over every byte)\n+    while (bytes > message_pos) {\n+        output[message_pos] = input[message_pos] ^ ReadLE32(&m_keystream[m_keystream_pos]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659123550",
      "id" : 659123550,
      "line" : 49,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTEyMzU1MA==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 49,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.cpp",
      "position" : 30,
      "pull_request_review_id" : 693173094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-28T18:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659123550",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659123909"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659123909"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Could we leave a comment here that `SetKey()` also sets the counter and IV to zero?",
      "commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "created_at" : "2021-06-26T05:44:24Z",
      "diff_hunk" : "@@ -27,19 +28,52 @@ int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n \n #endif // TIMINGSAFE_BCMP\n \n+void ChaCha20ReKey4096::SetKey(const unsigned char* key, size_t keylen) {\n+    assert(keylen == 32);\n+    m_ctx.SetKey(key, keylen);\n+\n+    // set initial sequence number\n+    m_seqnr = 0;\n+    m_ctx.SetIV(m_seqnr);\n+\n+    // precompute first chunk of keystream\n+    m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+    m_keystream_pos = 0;\n+}\n+\n+void ChaCha20ReKey4096::Crypt(const unsigned char* input, unsigned char* output, size_t bytes) {\n+    size_t message_pos = 0;\n+\n+    // TODO: speedup with a block approach (rather then looping over every byte)\n+    while (bytes > message_pos) {\n+        output[message_pos] = input[message_pos] ^ ReadLE32(&m_keystream[m_keystream_pos]);\n+        m_keystream_pos++;\n+        message_pos++;\n+        if (m_keystream_pos == KEYSTREAM_SIZE-CHACHA20_POLY1305_AEAD_KEY_LEN) {\n+            // we reached the end of the keystream\n+            // rekey with the remaining and last 32 bytes and precompute the next 4096 bytes\n+            m_ctx.SetKey(&m_keystream[m_keystream_pos], CHACHA20_POLY1305_AEAD_KEY_LEN);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659123909",
      "id" : 659123909,
      "line" : 55,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTEyMzkwOQ==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 55,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.cpp",
      "position" : 36,
      "pull_request_review_id" : 693173094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-28T18:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659123909",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659124563"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659124563"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Would it be useful to completely hide the details of the encrypted length from the user of this class? \r\n\r\nThat way, for encryption:\r\n`src=plaintext; dest=encrypted length + ciphertext + MAC`\r\n\r\nfor decryption:\r\n`src=encrypted length + ciphertext + MAC; dest=plaintext`\r\n\r\nThis would:\r\n- Eliminate the awkwardness around the user of this class accidentally calling `DecryptLength` multiple times.\r\n- Eliminate the possibility that the user of this class forgets to terminate the connection if the decrypted length does not match the length of the payload.\r\n\r\nOr perhaps I am missing a reason the user of the class might need to know the decrypted length.",
      "commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "created_at" : "2021-06-26T05:51:55Z",
      "diff_hunk" : "@@ -27,19 +28,52 @@ int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n \n #endif // TIMINGSAFE_BCMP\n \n+void ChaCha20ReKey4096::SetKey(const unsigned char* key, size_t keylen) {\n+    assert(keylen == 32);\n+    m_ctx.SetKey(key, keylen);\n+\n+    // set initial sequence number\n+    m_seqnr = 0;\n+    m_ctx.SetIV(m_seqnr);\n+\n+    // precompute first chunk of keystream\n+    m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+    m_keystream_pos = 0;\n+}\n+\n+void ChaCha20ReKey4096::Crypt(const unsigned char* input, unsigned char* output, size_t bytes) {\n+    size_t message_pos = 0;\n+\n+    // TODO: speedup with a block approach (rather then looping over every byte)\n+    while (bytes > message_pos) {\n+        output[message_pos] = input[message_pos] ^ ReadLE32(&m_keystream[m_keystream_pos]);\n+        m_keystream_pos++;\n+        message_pos++;\n+        if (m_keystream_pos == KEYSTREAM_SIZE-CHACHA20_POLY1305_AEAD_KEY_LEN) {\n+            // we reached the end of the keystream\n+            // rekey with the remaining and last 32 bytes and precompute the next 4096 bytes\n+            m_ctx.SetKey(&m_keystream[m_keystream_pos], CHACHA20_POLY1305_AEAD_KEY_LEN);\n+            m_ctx.SetIV(++m_seqnr);\n+            m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+            // reset keystream position\n+            m_keystream_pos = 0;\n+        }\n+    }\n+}\n+\n+ChaCha20ReKey4096::~ChaCha20ReKey4096() {\n+    memory_cleanse(m_keystream, KEYSTREAM_SIZE);\n+}\n+\n ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len)\n {\n     assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n     assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n     m_chacha_main.SetKey(K_1, CHACHA20_POLY1305_AEAD_KEY_LEN);\n     m_chacha_header.SetKey(K_2, CHACHA20_POLY1305_AEAD_KEY_LEN);\n-\n-    // set the cached sequence number to uint64 max which hints for an unset cache.\n-    // we can't hit uint64 max since the rekey rule (which resets the sequence number) is 1GB\n-    m_cached_aad_seqnr = std::numeric_limits<uint64_t>::max();\n }\n \n-bool ChaCha20Poly1305AEAD::Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int aad_pos, unsigned char* dest, size_t dest_len /* length of the output buffer for sanity checks */, const unsigned char* src, size_t src_len, bool is_encrypt)\n+bool ChaCha20Poly1305AEAD::Crypt(unsigned char* dest, size_t dest_len /* length of the output buffer for sanity checks */, const unsigned char* src, size_t src_len, bool is_encrypt)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659124563",
      "id" : 659124563,
      "line" : 76,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTEyNDU2Mw==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 76,
      "original_position" : 62,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.cpp",
      "position" : 62,
      "pull_request_review_id" : 693173094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-28T18:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659124563",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659125693"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659125693"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "should this be \"the length has already been decrypted\"?",
      "commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "created_at" : "2021-06-26T06:01:59Z",
      "diff_hunk" : "@@ -52,18 +86,24 @@ bool ChaCha20Poly1305AEAD::Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int\n \n     unsigned char expected_tag[POLY1305_TAGLEN], poly_key[POLY1305_KEYLEN];\n     memset(poly_key, 0, sizeof(poly_key));\n-    m_chacha_main.SetIV(seqnr_payload);\n \n-    // block counter 0 for the poly1305 key\n-    // use lower 32bytes for the poly1305 key\n-    // (throws away 32 unused bytes (upper 32) from this ChaCha20 round)\n-    m_chacha_main.Seek(0);\n-    m_chacha_main.Crypt(poly_key, poly_key, sizeof(poly_key));\n+    // 1. AAD (the encrypted packet length), use the header-keystream\n+    if (is_encrypt) {\n+        m_chacha_header.Crypt(src, dest, 3);\n+    } else {\n+        // we must use ChaCha20Poly1305AEAD::DecryptLength before calling ChaCha20Poly1305AEAD::Crypt\n+        // thus the length has already been encrypted, avoid doing it again and messing up the keystream position",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659125693",
      "id" : 659125693,
      "line" : 95,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTEyNTY5Mw==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 95,
      "original_position" : 82,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.cpp",
      "position" : 82,
      "pull_request_review_id" : 693173094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-28T18:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659125693",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659179980"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659179980"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "(nit): \"IV of 0 and a block counter of 0 and a sequence number 0 as IV\" -> \"sequence number 0 as IV and a block counter of 0\"",
      "commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "created_at" : "2021-06-26T15:22:14Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659179980",
      "id" : 659179980,
      "line" : 60,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTE3OTk4MA==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 60,
      "original_position" : 109,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : 109,
      "pull_request_review_id" : 693173094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-28T18:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659179980",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659180419"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659180419"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In #18242, I see that the bytes are accessible as a `Span` and `Span::size()` seems available. Would it be useful to say something like: \"If the decrypted length does not match the payload length, the connection MUST be immediately terminated?\" \r\n\r\nAt first I thought that is implicitly delegated to the MAC, but we don't seem to confirm that the length is correct when encrypting either.",
      "commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "created_at" : "2021-06-26T15:27:30Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same\n+* re-key rules.\n+*\n+*\n+* ==== Packet Handling ====\n+*\n+* When receiving a packet, the length must be decrypted first. When 3 bytes of\n+* ciphertext length have been received, they MUST be decrypted.\n+*",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659180419",
      "id" : 659180419,
      "line" : 84,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTE4MDQxOQ==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 84,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : 133,
      "pull_request_review_id" : 693173094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-28T18:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659180419",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659180737"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659180737"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "(nit): \"Finally, calculate a MAC tag and append it.\" -> \"Finally, calculate a MAC tag(using poly1305 key from stream keyed with K_1) and append it.\"",
      "commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "created_at" : "2021-06-26T15:30:22Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same\n+* re-key rules.\n+*\n+*\n+* ==== Packet Handling ====\n+*\n+* When receiving a packet, the length must be decrypted first. When 3 bytes of\n+* ciphertext length have been received, they MUST be decrypted.\n+*\n+* Once the entire packet has been received, the MAC MUST be checked before\n+* decryption. A per-packet Poly1305 key is generated as described above and the\n+* MAC tag is calculated using Poly1305 with this key over the ciphertext of the\n+* packet length and the payload together. The calculated MAC is then compared in\n+* constant time with the one appended to the packet and the packet decrypted\n+* using ChaCha20 as described above (with K_2, the packet sequence number as\n+* nonce and a starting block counter of 1).\n+*\n+* Detection of an invalid MAC MUST lead to immediate connection termination.\n+*\n+* To send a packet, first encode the 3 byte length and encrypt it using the\n+* ChaCha20 stream keyed with K_1 as described above. Encrypt the packet payload\n+* (using the ChaCha20 stream keyed with K_2) and append it to the encrypted\n+* length. Finally, calculate a MAC tag and append it.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659180737",
      "id" : 659180737,
      "line" : 98,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTE4MDczNw==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 98,
      "original_position" : 147,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : 147,
      "pull_request_review_id" : 693173094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-28T18:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659180737",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659181005"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659181005"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "should \"(with K_2, the packet sequence number as nonce and a starting block counter of 1)\" now be just \"(using stream keyed with K_2)\"? IIUC, the block counter could be anything in `[0, 7]` (since 8 * 512 = 4096), right?",
      "commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "created_at" : "2021-06-26T15:32:54Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same\n+* re-key rules.\n+*\n+*\n+* ==== Packet Handling ====\n+*\n+* When receiving a packet, the length must be decrypted first. When 3 bytes of\n+* ciphertext length have been received, they MUST be decrypted.\n+*\n+* Once the entire packet has been received, the MAC MUST be checked before\n+* decryption. A per-packet Poly1305 key is generated as described above and the\n+* MAC tag is calculated using Poly1305 with this key over the ciphertext of the\n+* packet length and the payload together. The calculated MAC is then compared in\n+* constant time with the one appended to the packet and the packet decrypted\n+* using ChaCha20 as described above (with K_2, the packet sequence number as",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r659181005",
      "id" : 659181005,
      "line" : 90,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY1OTE4MTAwNQ==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 90,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : 139,
      "pull_request_review_id" : 693173094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-28T18:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/659181005",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r660004965"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/660004965"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This line implies that the decrypted length is len(AAD) + len(payload). I interpreted, [this](https://gist.github.com/jonasschnelli/c530ea8421b8d0e80c51486325587c52#v2-messages-structure) to mean that the decrypted length is the length of the ciphertext of the payload alone.\r\n\r\nIf this is intentional, can we make it clearer in the BIP? IIUC, typically, in other protocols, the length in the preamble is the length of the payload that follows. Did we want to do it that way?",
      "commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "created_at" : "2021-06-28T18:01:16Z",
      "diff_hunk" : "@@ -629,56 +616,27 @@ static void TestChaCha20Poly1305AEAD(bool must_succeed, unsigned int expected_aa\n     BOOST_CHECK_EQUAL(expected_ciphertext_and_mac.size(), ciphertext_buf.size());\n     BOOST_CHECK(memcmp(ciphertext_buf.data(), expected_ciphertext_and_mac.data(), ciphertext_buf.size()) == 0);\n \n-    // manually construct the AAD keystream\n-    cmp_ctx.SetIV(seqnr_aad);\n-    cmp_ctx.Seek(0);\n-    cmp_ctx.Keystream(cmp_ctx_buffer.data(), 64);\n-    BOOST_CHECK(memcmp(expected_aad_keystream.data(), cmp_ctx_buffer.data(), expected_aad_keystream.size()) == 0);\n-    // crypt the 3 length bytes and compare the length\n-    uint32_t len_cmp = 0;\n-    len_cmp = (ciphertext_buf[0] ^ cmp_ctx_buffer[aad_pos + 0]) |\n-              (ciphertext_buf[1] ^ cmp_ctx_buffer[aad_pos + 1]) << 8 |\n-              (ciphertext_buf[2] ^ cmp_ctx_buffer[aad_pos + 2]) << 16;\n-    BOOST_CHECK_EQUAL(len_cmp, expected_aad_length);\n-\n-    // encrypt / decrypt 1000 packets\n+    BOOST_CHECK(aead_in.DecryptLength(&out_len, ciphertext_buf.data()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r660004965",
      "id" : 660004965,
      "line" : 619,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY2MDAwNDk2NQ==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 619,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "src/test/crypto_tests.cpp",
      "position" : 59,
      "pull_request_review_id" : 693173094,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-06-28T18:11:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/660004965",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->\nð This pull request conflicts with the target branch and [needs rebase](https://github.com/bitcoin/bitcoin/blob/master/CONTRIBUTING.md#rebasing-changes).\n\n<sub>Want to unsubscribe from rebase notifications on this pull request? Just convert this pull request to a \"draft\".</sub>",
      "created_at" : "2021-08-19T03:18:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#issuecomment-901577870",
      "id" : 901577870,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20962",
      "node_id" : "IC_kwDOABII5841vPyO",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-19T03:18:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/901577870",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694251569"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694251569"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "1a868b11b04f6701f0b739d4e039ea1e343de233",
      "created_at" : "2021-08-23T19:32:06Z",
      "diff_hunk" : "@@ -27,19 +28,52 @@ int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n \n #endif // TIMINGSAFE_BCMP\n \n+void ChaCha20ReKey4096::SetKey(const unsigned char* key, size_t keylen) {\n+    assert(keylen == 32);\n+    m_ctx.SetKey(key, keylen);\n+\n+    // set initial sequence number\n+    m_seqnr = 0;\n+    m_ctx.SetIV(m_seqnr);\n+\n+    // precompute first chunk of keystream\n+    m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+    m_keystream_pos = 0;\n+}\n+\n+void ChaCha20ReKey4096::Crypt(const unsigned char* input, unsigned char* output, size_t bytes) {\n+    size_t message_pos = 0;\n+\n+    // TODO: speedup with a block approach (rather then looping over every byte)\n+    while (bytes > message_pos) {\n+        output[message_pos] = input[message_pos] ^ ReadLE32(&m_keystream[m_keystream_pos]);\n+        m_keystream_pos++;\n+        message_pos++;\n+        if (m_keystream_pos == KEYSTREAM_SIZE-CHACHA20_POLY1305_AEAD_KEY_LEN) {\n+            // we reached the end of the keystream\n+            // rekey with the remaining and last 32 bytes and precompute the next 4096 bytes\n+            m_ctx.SetKey(&m_keystream[m_keystream_pos], CHACHA20_POLY1305_AEAD_KEY_LEN);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694251569",
      "id" : 694251569,
      "in_reply_to_id" : 659123909,
      "line" : 57,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDI1MTU2OQ==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 57,
      "original_position" : 36,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.cpp",
      "position" : 41,
      "pull_request_review_id" : 736492544,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-23T19:32:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694251569",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694252767"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694252767"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Or perhaps I am missing a reason the user of the class might need to know the decrypted length.\r\n\r\nI was missing the reason: Tried to do this and realized that the interface for `TransportDeserializer` actually requires the client of this class to be aware of the length because the bytes come in as a stream. ",
      "commit_id" : "1a868b11b04f6701f0b739d4e039ea1e343de233",
      "created_at" : "2021-08-23T19:33:59Z",
      "diff_hunk" : "@@ -27,19 +28,52 @@ int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n \n #endif // TIMINGSAFE_BCMP\n \n+void ChaCha20ReKey4096::SetKey(const unsigned char* key, size_t keylen) {\n+    assert(keylen == 32);\n+    m_ctx.SetKey(key, keylen);\n+\n+    // set initial sequence number\n+    m_seqnr = 0;\n+    m_ctx.SetIV(m_seqnr);\n+\n+    // precompute first chunk of keystream\n+    m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+    m_keystream_pos = 0;\n+}\n+\n+void ChaCha20ReKey4096::Crypt(const unsigned char* input, unsigned char* output, size_t bytes) {\n+    size_t message_pos = 0;\n+\n+    // TODO: speedup with a block approach (rather then looping over every byte)\n+    while (bytes > message_pos) {\n+        output[message_pos] = input[message_pos] ^ ReadLE32(&m_keystream[m_keystream_pos]);\n+        m_keystream_pos++;\n+        message_pos++;\n+        if (m_keystream_pos == KEYSTREAM_SIZE-CHACHA20_POLY1305_AEAD_KEY_LEN) {\n+            // we reached the end of the keystream\n+            // rekey with the remaining and last 32 bytes and precompute the next 4096 bytes\n+            m_ctx.SetKey(&m_keystream[m_keystream_pos], CHACHA20_POLY1305_AEAD_KEY_LEN);\n+            m_ctx.SetIV(++m_seqnr);\n+            m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+            // reset keystream position\n+            m_keystream_pos = 0;\n+        }\n+    }\n+}\n+\n+ChaCha20ReKey4096::~ChaCha20ReKey4096() {\n+    memory_cleanse(m_keystream, KEYSTREAM_SIZE);\n+}\n+\n ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len)\n {\n     assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n     assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n     m_chacha_main.SetKey(K_1, CHACHA20_POLY1305_AEAD_KEY_LEN);\n     m_chacha_header.SetKey(K_2, CHACHA20_POLY1305_AEAD_KEY_LEN);\n-\n-    // set the cached sequence number to uint64 max which hints for an unset cache.\n-    // we can't hit uint64 max since the rekey rule (which resets the sequence number) is 1GB\n-    m_cached_aad_seqnr = std::numeric_limits<uint64_t>::max();\n }\n \n-bool ChaCha20Poly1305AEAD::Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int aad_pos, unsigned char* dest, size_t dest_len /* length of the output buffer for sanity checks */, const unsigned char* src, size_t src_len, bool is_encrypt)\n+bool ChaCha20Poly1305AEAD::Crypt(unsigned char* dest, size_t dest_len /* length of the output buffer for sanity checks */, const unsigned char* src, size_t src_len, bool is_encrypt)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694252767",
      "id" : 694252767,
      "in_reply_to_id" : 659124563,
      "line" : 82,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDI1Mjc2Nw==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 82,
      "original_position" : 62,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.cpp",
      "position" : 72,
      "pull_request_review_id" : 736494013,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-23T19:33:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694252767",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694255045"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694255045"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Thinking through this more, I realized that:\r\n- Sender errors in encrypted length cannot be corrected since the bytes for multiple p2p messages are in a single TCP stream. Such sender errors are protocol errors.\r\n- MITM errors/attacks will be caught by the MAC check.\r\n",
      "commit_id" : "1a868b11b04f6701f0b739d4e039ea1e343de233",
      "created_at" : "2021-08-23T19:37:20Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same\n+* re-key rules.\n+*\n+*\n+* ==== Packet Handling ====\n+*\n+* When receiving a packet, the length must be decrypted first. When 3 bytes of\n+* ciphertext length have been received, they MUST be decrypted.\n+*",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694255045",
      "id" : 694255045,
      "in_reply_to_id" : 659180419,
      "line" : 84,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDI1NTA0NQ==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 84,
      "original_position" : 133,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : 133,
      "pull_request_review_id" : 736496703,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-23T19:37:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694255045",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694255584"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694255584"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "1a868b11b04f6701f0b739d4e039ea1e343de233",
      "created_at" : "2021-08-23T19:38:14Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694255584",
      "id" : 694255584,
      "in_reply_to_id" : 659021347,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDI1NTU4NA==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 76,
      "original_position" : 125,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : null,
      "pull_request_review_id" : 736497369,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-23T19:38:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694255584",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694255829"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694255829"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "1a868b11b04f6701f0b739d4e039ea1e343de233",
      "created_at" : "2021-08-23T19:38:37Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same\n+* re-key rules.\n+*\n+*\n+* ==== Packet Handling ====\n+*\n+* When receiving a packet, the length must be decrypted first. When 3 bytes of\n+* ciphertext length have been received, they MUST be decrypted.\n+*\n+* Once the entire packet has been received, the MAC MUST be checked before\n+* decryption. A per-packet Poly1305 key is generated as described above and the\n+* MAC tag is calculated using Poly1305 with this key over the ciphertext of the\n+* packet length and the payload together. The calculated MAC is then compared in\n+* constant time with the one appended to the packet and the packet decrypted\n+* using ChaCha20 as described above (with K_2, the packet sequence number as\n+* nonce and a starting block counter of 1).\n+*\n+* Detection of an invalid MAC MUST lead to immediate connection termination.\n+*\n+* To send a packet, first encode the 3 byte length and encrypt it using the\n+* ChaCha20 stream keyed with K_1 as described above. Encrypt the packet payload\n+* (using the ChaCha20 stream keyed with K_2) and append it to the encrypted\n+* length. Finally, calculate a MAC tag and append it.\n+*/\n+\n+const int KEYSTREAM_SIZE = 4096;\n+\n+class ChaCha20ReKey4096 {\n+private:\n+    ChaCha20 m_ctx;\n+    uint64_t m_seqnr{0};\n+    size_t m_keystream_pos{0};\n+    unsigned char m_keystream[KEYSTREAM_SIZE] = {0};\n+public:\n+    ~ChaCha20ReKey4096();\n+    void SetKey(const unsigned char* key, size_t keylen);\n+    void Crypt(const unsigned char* input, unsigned char* output, size_t bytes);\n+};\n \n class ChaCha20Poly1305AEAD\n {\n private:\n-    ChaCha20 m_chacha_main;                                      // payload and poly1305 key-derivation cipher instance\n-    ChaCha20 m_chacha_header;                                    // AAD cipher instance (encrypted length)\n-    unsigned char m_aad_keystream_buffer[CHACHA20_ROUND_OUTPUT]; // aad keystream cache\n-    uint64_t m_cached_aad_seqnr;                                 // aad keystream cache hint\n+    ChaCha20ReKey4096 m_chacha_main;                                      // payload and poly1305 key-derivation cipher instance\n+    ChaCha20ReKey4096 m_chacha_header;                                    // AAD cipher instance (encrypted length)\n \n public:\n     ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len);\n \n     explicit ChaCha20Poly1305AEAD(const ChaCha20Poly1305AEAD&) = delete;\n \n     /** Encrypts/decrypts a packet\n-        seqnr_payload, the message sequence number\n-        seqnr_aad, the messages AAD sequence number which allows reuse of the AAD keystream\n-        aad_pos, position to use in the AAD keystream to encrypt the AAD\n         dest, output buffer, must be of a size equal or larger then CHACHA20_POLY1305_AEAD_AAD_LEN + payload (+ POLY1305_TAG_LEN in encryption) bytes\n         destlen, length of the destination buffer\n         src, the AAD+payload to encrypt or the AAD+payload+MAC to decrypt\n         src_len, the length of the source buffer\n         is_encrypt, set to true if we encrypt (creates and appends the MAC instead of verifying it)\n         */\n-    bool Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int aad_pos, unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);\n+    bool Crypt(unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);\n \n-    /** decrypts the 3 bytes AAD data and decodes it into a uint32_t field */\n-    bool GetLength(uint32_t* len24_out, uint64_t seqnr_aad, int aad_pos, const uint8_t* ciphertext);\n+    /** decrypts the 3 bytes AAD data (the packet length) and decodes it into a uint32_t field\n+        the ciphertext will not be manipulated but the AEAD state changes (can't be called multiple times)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694255829",
      "id" : 694255829,
      "in_reply_to_id" : 659066917,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDI1NTgyOQ==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 136,
      "original_position" : 195,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : null,
      "pull_request_review_id" : 736497647,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-23T19:38:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694255829",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694255914"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694255914"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "1a868b11b04f6701f0b739d4e039ea1e343de233",
      "created_at" : "2021-08-23T19:38:45Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same\n+* re-key rules.\n+*\n+*\n+* ==== Packet Handling ====\n+*\n+* When receiving a packet, the length must be decrypted first. When 3 bytes of\n+* ciphertext length have been received, they MUST be decrypted.\n+*\n+* Once the entire packet has been received, the MAC MUST be checked before\n+* decryption. A per-packet Poly1305 key is generated as described above and the\n+* MAC tag is calculated using Poly1305 with this key over the ciphertext of the\n+* packet length and the payload together. The calculated MAC is then compared in\n+* constant time with the one appended to the packet and the packet decrypted\n+* using ChaCha20 as described above (with K_2, the packet sequence number as\n+* nonce and a starting block counter of 1).\n+*\n+* Detection of an invalid MAC MUST lead to immediate connection termination.\n+*\n+* To send a packet, first encode the 3 byte length and encrypt it using the\n+* ChaCha20 stream keyed with K_1 as described above. Encrypt the packet payload\n+* (using the ChaCha20 stream keyed with K_2) and append it to the encrypted\n+* length. Finally, calculate a MAC tag and append it.\n+*/\n+\n+const int KEYSTREAM_SIZE = 4096;\n+\n+class ChaCha20ReKey4096 {\n+private:\n+    ChaCha20 m_ctx;\n+    uint64_t m_seqnr{0};\n+    size_t m_keystream_pos{0};\n+    unsigned char m_keystream[KEYSTREAM_SIZE] = {0};\n+public:\n+    ~ChaCha20ReKey4096();\n+    void SetKey(const unsigned char* key, size_t keylen);\n+    void Crypt(const unsigned char* input, unsigned char* output, size_t bytes);\n+};\n \n class ChaCha20Poly1305AEAD\n {\n private:\n-    ChaCha20 m_chacha_main;                                      // payload and poly1305 key-derivation cipher instance\n-    ChaCha20 m_chacha_header;                                    // AAD cipher instance (encrypted length)\n-    unsigned char m_aad_keystream_buffer[CHACHA20_ROUND_OUTPUT]; // aad keystream cache\n-    uint64_t m_cached_aad_seqnr;                                 // aad keystream cache hint\n+    ChaCha20ReKey4096 m_chacha_main;                                      // payload and poly1305 key-derivation cipher instance\n+    ChaCha20ReKey4096 m_chacha_header;                                    // AAD cipher instance (encrypted length)\n \n public:\n     ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len);\n \n     explicit ChaCha20Poly1305AEAD(const ChaCha20Poly1305AEAD&) = delete;\n \n     /** Encrypts/decrypts a packet\n-        seqnr_payload, the message sequence number\n-        seqnr_aad, the messages AAD sequence number which allows reuse of the AAD keystream\n-        aad_pos, position to use in the AAD keystream to encrypt the AAD\n         dest, output buffer, must be of a size equal or larger then CHACHA20_POLY1305_AEAD_AAD_LEN + payload (+ POLY1305_TAG_LEN in encryption) bytes\n         destlen, length of the destination buffer\n         src, the AAD+payload to encrypt or the AAD+payload+MAC to decrypt\n         src_len, the length of the source buffer\n         is_encrypt, set to true if we encrypt (creates and appends the MAC instead of verifying it)\n         */\n-    bool Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int aad_pos, unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);\n+    bool Crypt(unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694255914",
      "id" : 694255914,
      "in_reply_to_id" : 659072624,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDI1NTkxNA==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 133,
      "original_position" : 190,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : null,
      "pull_request_review_id" : 736497751,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-23T19:38:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694255914",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694255961"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694255961"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "1a868b11b04f6701f0b739d4e039ea1e343de233",
      "created_at" : "2021-08-23T19:38:52Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same\n+* re-key rules.\n+*\n+*\n+* ==== Packet Handling ====\n+*\n+* When receiving a packet, the length must be decrypted first. When 3 bytes of\n+* ciphertext length have been received, they MUST be decrypted.\n+*\n+* Once the entire packet has been received, the MAC MUST be checked before\n+* decryption. A per-packet Poly1305 key is generated as described above and the\n+* MAC tag is calculated using Poly1305 with this key over the ciphertext of the\n+* packet length and the payload together. The calculated MAC is then compared in\n+* constant time with the one appended to the packet and the packet decrypted\n+* using ChaCha20 as described above (with K_2, the packet sequence number as\n+* nonce and a starting block counter of 1).\n+*\n+* Detection of an invalid MAC MUST lead to immediate connection termination.\n+*\n+* To send a packet, first encode the 3 byte length and encrypt it using the\n+* ChaCha20 stream keyed with K_1 as described above. Encrypt the packet payload\n+* (using the ChaCha20 stream keyed with K_2) and append it to the encrypted\n+* length. Finally, calculate a MAC tag and append it.\n+*/\n+\n+const int KEYSTREAM_SIZE = 4096;\n+\n+class ChaCha20ReKey4096 {\n+private:\n+    ChaCha20 m_ctx;\n+    uint64_t m_seqnr{0};\n+    size_t m_keystream_pos{0};\n+    unsigned char m_keystream[KEYSTREAM_SIZE] = {0};\n+public:\n+    ~ChaCha20ReKey4096();\n+    void SetKey(const unsigned char* key, size_t keylen);\n+    void Crypt(const unsigned char* input, unsigned char* output, size_t bytes);\n+};\n \n class ChaCha20Poly1305AEAD\n {\n private:\n-    ChaCha20 m_chacha_main;                                      // payload and poly1305 key-derivation cipher instance\n-    ChaCha20 m_chacha_header;                                    // AAD cipher instance (encrypted length)\n-    unsigned char m_aad_keystream_buffer[CHACHA20_ROUND_OUTPUT]; // aad keystream cache\n-    uint64_t m_cached_aad_seqnr;                                 // aad keystream cache hint\n+    ChaCha20ReKey4096 m_chacha_main;                                      // payload and poly1305 key-derivation cipher instance\n+    ChaCha20ReKey4096 m_chacha_header;                                    // AAD cipher instance (encrypted length)\n \n public:\n     ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len);\n \n     explicit ChaCha20Poly1305AEAD(const ChaCha20Poly1305AEAD&) = delete;\n \n     /** Encrypts/decrypts a packet\n-        seqnr_payload, the message sequence number\n-        seqnr_aad, the messages AAD sequence number which allows reuse of the AAD keystream\n-        aad_pos, position to use in the AAD keystream to encrypt the AAD\n         dest, output buffer, must be of a size equal or larger then CHACHA20_POLY1305_AEAD_AAD_LEN + payload (+ POLY1305_TAG_LEN in encryption) bytes\n         destlen, length of the destination buffer\n         src, the AAD+payload to encrypt or the AAD+payload+MAC to decrypt\n         src_len, the length of the source buffer\n         is_encrypt, set to true if we encrypt (creates and appends the MAC instead of verifying it)\n         */\n-    bool Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int aad_pos, unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);\n+    bool Crypt(unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);\n \n-    /** decrypts the 3 bytes AAD data and decodes it into a uint32_t field */\n-    bool GetLength(uint32_t* len24_out, uint64_t seqnr_aad, int aad_pos, const uint8_t* ciphertext);\n+    /** decrypts the 3 bytes AAD data (the packet length) and decodes it into a uint32_t field\n+        the ciphertext will not be manipulated but the AEAD state changes (can't be called multiple times)\n+        Ciphertext needs to stay encrypted due to the MAC check that will follow (requires encrypted length)\n+        */\n+    bool DecryptLength(uint32_t* len24_out, const uint8_t* ciphertext);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694255961",
      "id" : 694255961,
      "in_reply_to_id" : 659072639,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDI1NTk2MQ==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 139,
      "original_position" : 198,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : null,
      "pull_request_review_id" : 736497826,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-23T19:38:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694255961",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694256303"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694256303"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "1a868b11b04f6701f0b739d4e039ea1e343de233",
      "created_at" : "2021-08-23T19:39:27Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same\n+* re-key rules.\n+*\n+*\n+* ==== Packet Handling ====\n+*\n+* When receiving a packet, the length must be decrypted first. When 3 bytes of\n+* ciphertext length have been received, they MUST be decrypted.\n+*\n+* Once the entire packet has been received, the MAC MUST be checked before\n+* decryption. A per-packet Poly1305 key is generated as described above and the\n+* MAC tag is calculated using Poly1305 with this key over the ciphertext of the\n+* packet length and the payload together. The calculated MAC is then compared in\n+* constant time with the one appended to the packet and the packet decrypted\n+* using ChaCha20 as described above (with K_2, the packet sequence number as\n+* nonce and a starting block counter of 1).\n+*\n+* Detection of an invalid MAC MUST lead to immediate connection termination.\n+*\n+* To send a packet, first encode the 3 byte length and encrypt it using the\n+* ChaCha20 stream keyed with K_1 as described above. Encrypt the packet payload\n+* (using the ChaCha20 stream keyed with K_2) and append it to the encrypted\n+* length. Finally, calculate a MAC tag and append it.\n+*/\n+\n+const int KEYSTREAM_SIZE = 4096;\n+\n+class ChaCha20ReKey4096 {\n+private:\n+    ChaCha20 m_ctx;\n+    uint64_t m_seqnr{0};\n+    size_t m_keystream_pos{0};\n+    unsigned char m_keystream[KEYSTREAM_SIZE] = {0};\n+public:\n+    ~ChaCha20ReKey4096();\n+    void SetKey(const unsigned char* key, size_t keylen);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694256303",
      "id" : 694256303,
      "in_reply_to_id" : 659089284,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDI1NjMwMw==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 111,
      "original_position" : 160,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : null,
      "pull_request_review_id" : 736498251,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-23T19:39:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694256303",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694256461"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694256461"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "1a868b11b04f6701f0b739d4e039ea1e343de233",
      "created_at" : "2021-08-23T19:39:44Z",
      "diff_hunk" : "@@ -27,19 +28,52 @@ int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n \n #endif // TIMINGSAFE_BCMP\n \n+void ChaCha20ReKey4096::SetKey(const unsigned char* key, size_t keylen) {\n+    assert(keylen == 32);\n+    m_ctx.SetKey(key, keylen);\n+\n+    // set initial sequence number\n+    m_seqnr = 0;\n+    m_ctx.SetIV(m_seqnr);\n+\n+    // precompute first chunk of keystream\n+    m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+    m_keystream_pos = 0;\n+}\n+\n+void ChaCha20ReKey4096::Crypt(const unsigned char* input, unsigned char* output, size_t bytes) {\n+    size_t message_pos = 0;\n+\n+    // TODO: speedup with a block approach (rather then looping over every byte)\n+    while (bytes > message_pos) {\n+        output[message_pos] = input[message_pos] ^ ReadLE32(&m_keystream[m_keystream_pos]);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694256461",
      "id" : 694256461,
      "in_reply_to_id" : 659123550,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDI1NjQ2MQ==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 49,
      "original_position" : 30,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.cpp",
      "position" : null,
      "pull_request_review_id" : 736498448,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-23T19:39:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694256461",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694256688"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694256688"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "1a868b11b04f6701f0b739d4e039ea1e343de233",
      "created_at" : "2021-08-23T19:40:06Z",
      "diff_hunk" : "@@ -52,18 +86,24 @@ bool ChaCha20Poly1305AEAD::Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int\n \n     unsigned char expected_tag[POLY1305_TAGLEN], poly_key[POLY1305_KEYLEN];\n     memset(poly_key, 0, sizeof(poly_key));\n-    m_chacha_main.SetIV(seqnr_payload);\n \n-    // block counter 0 for the poly1305 key\n-    // use lower 32bytes for the poly1305 key\n-    // (throws away 32 unused bytes (upper 32) from this ChaCha20 round)\n-    m_chacha_main.Seek(0);\n-    m_chacha_main.Crypt(poly_key, poly_key, sizeof(poly_key));\n+    // 1. AAD (the encrypted packet length), use the header-keystream\n+    if (is_encrypt) {\n+        m_chacha_header.Crypt(src, dest, 3);\n+    } else {\n+        // we must use ChaCha20Poly1305AEAD::DecryptLength before calling ChaCha20Poly1305AEAD::Crypt\n+        // thus the length has already been encrypted, avoid doing it again and messing up the keystream position",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694256688",
      "id" : 694256688,
      "in_reply_to_id" : 659125693,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDI1NjY4OA==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 95,
      "original_position" : 82,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.cpp",
      "position" : null,
      "pull_request_review_id" : 736498726,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-23T19:40:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694256688",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694256838"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694256838"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "1a868b11b04f6701f0b739d4e039ea1e343de233",
      "created_at" : "2021-08-23T19:40:21Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694256838",
      "id" : 694256838,
      "in_reply_to_id" : 659179980,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDI1NjgzOA==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 60,
      "original_position" : 109,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : null,
      "pull_request_review_id" : 736498917,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-23T19:40:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694256838",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694257137"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694257137"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "1a868b11b04f6701f0b739d4e039ea1e343de233",
      "created_at" : "2021-08-23T19:40:52Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same\n+* re-key rules.\n+*\n+*\n+* ==== Packet Handling ====\n+*\n+* When receiving a packet, the length must be decrypted first. When 3 bytes of\n+* ciphertext length have been received, they MUST be decrypted.\n+*\n+* Once the entire packet has been received, the MAC MUST be checked before\n+* decryption. A per-packet Poly1305 key is generated as described above and the\n+* MAC tag is calculated using Poly1305 with this key over the ciphertext of the\n+* packet length and the payload together. The calculated MAC is then compared in\n+* constant time with the one appended to the packet and the packet decrypted\n+* using ChaCha20 as described above (with K_2, the packet sequence number as\n+* nonce and a starting block counter of 1).\n+*\n+* Detection of an invalid MAC MUST lead to immediate connection termination.\n+*\n+* To send a packet, first encode the 3 byte length and encrypt it using the\n+* ChaCha20 stream keyed with K_1 as described above. Encrypt the packet payload\n+* (using the ChaCha20 stream keyed with K_2) and append it to the encrypted\n+* length. Finally, calculate a MAC tag and append it.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694257137",
      "id" : 694257137,
      "in_reply_to_id" : 659180737,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDI1NzEzNw==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 98,
      "original_position" : 147,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : null,
      "pull_request_review_id" : 736499289,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-23T19:40:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694257137",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694257391"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694257391"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "1a868b11b04f6701f0b739d4e039ea1e343de233",
      "created_at" : "2021-08-23T19:41:18Z",
      "diff_hunk" : "@@ -36,111 +37,106 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  *\n  * ==== Detailed Construction ====\n  *\n- * The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n- * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n- * instances of chacha20.\n- *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n- *\n- * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n- *\n- * ==== Packet Handling ====\n- *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n- *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n- *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n- *\n- * Once the entire packet has been received, the MAC MUST be checked before\n- * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n- * packet length and the payload together. The calculated MAC is then compared in\n- * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n- *\n- * Detection of an invalid MAC MUST lead to immediate connection termination.\n- *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n- */\n+The chacha20-poly1305@bitcoin cipher requires two 256 bits of key material as\n+* output from the key exchange. Each key (K_1 and K_2) are used by two separate\n+* instances of chacha20.\n+*\n+* The instance keyed by K_1 is a stream cipher that is used for the per-message\n+* metadata, specifically for the poly1305 authentication key as well as for the\n+* length encryption. The second instance, keyed by K_2, is used to encrypt the\n+* entire payload.\n+*\n+* Two separate cipher instances are used here so as to keep the packet lengths\n+* confidential (best effort; for passive observing) but not create an oracle for\n+* the packet payload cipher by decrypting and using the packet length prior to\n+* checking the MAC. By using an independently-keyed cipher instance to encrypt\n+* the length, an active attacker seeking to exploit the packet input handling as\n+* a decryption oracle can learn nothing about the payload contents or its MAC\n+* (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+* can still obtain the message length (ex. active ciphertext bit flipping or\n+* traffic shemantics analysis)\n+*\n+* The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+* keyed with K_1 and K_2 and IV of 0 and a block counter of 0 and a sequence\n+* number 0 as IV. After encrypting 4064 bytes, the following 32 bytes are used to\n+* re-key the ChaCha20 context.\n+*\n+* Byte-level forward security is possible by precomputing 4096 bytes of stream\n+* output, caching it, resetting the key to the final 32 bytes of the output, and\n+* then wiping the remaining 4064 bytes of cached data as it gets used.\n+*\n+* For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+* K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+* generate a Poly1305 key.\n+*\n+* If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+* 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+* incrementing the sequence number + 1 and set is as IV (little endian encoding).\n+*\n+* For the payload, use the ChaCha20 stream keyed with K_1 and apply the same\n+* re-key rules.\n+*\n+*\n+* ==== Packet Handling ====\n+*\n+* When receiving a packet, the length must be decrypted first. When 3 bytes of\n+* ciphertext length have been received, they MUST be decrypted.\n+*\n+* Once the entire packet has been received, the MAC MUST be checked before\n+* decryption. A per-packet Poly1305 key is generated as described above and the\n+* MAC tag is calculated using Poly1305 with this key over the ciphertext of the\n+* packet length and the payload together. The calculated MAC is then compared in\n+* constant time with the one appended to the packet and the packet decrypted\n+* using ChaCha20 as described above (with K_2, the packet sequence number as",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694257391",
      "id" : 694257391,
      "in_reply_to_id" : 659181005,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDI1NzM5MQ==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 90,
      "original_position" : 139,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : null,
      "pull_request_review_id" : 736499604,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-23T19:41:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694257391",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694258297"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694258297"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The BIP, the unit test and the bench test have been updated to be consistently clear that the encrypted length is `len(ciphertext_payload)` and not `len(ciphertext_payload + ciphertext_aad)`",
      "commit_id" : "1a868b11b04f6701f0b739d4e039ea1e343de233",
      "created_at" : "2021-08-23T19:42:54Z",
      "diff_hunk" : "@@ -629,56 +616,27 @@ static void TestChaCha20Poly1305AEAD(bool must_succeed, unsigned int expected_aa\n     BOOST_CHECK_EQUAL(expected_ciphertext_and_mac.size(), ciphertext_buf.size());\n     BOOST_CHECK(memcmp(ciphertext_buf.data(), expected_ciphertext_and_mac.data(), ciphertext_buf.size()) == 0);\n \n-    // manually construct the AAD keystream\n-    cmp_ctx.SetIV(seqnr_aad);\n-    cmp_ctx.Seek(0);\n-    cmp_ctx.Keystream(cmp_ctx_buffer.data(), 64);\n-    BOOST_CHECK(memcmp(expected_aad_keystream.data(), cmp_ctx_buffer.data(), expected_aad_keystream.size()) == 0);\n-    // crypt the 3 length bytes and compare the length\n-    uint32_t len_cmp = 0;\n-    len_cmp = (ciphertext_buf[0] ^ cmp_ctx_buffer[aad_pos + 0]) |\n-              (ciphertext_buf[1] ^ cmp_ctx_buffer[aad_pos + 1]) << 8 |\n-              (ciphertext_buf[2] ^ cmp_ctx_buffer[aad_pos + 2]) << 16;\n-    BOOST_CHECK_EQUAL(len_cmp, expected_aad_length);\n-\n-    // encrypt / decrypt 1000 packets\n+    BOOST_CHECK(aead_in.DecryptLength(&out_len, ciphertext_buf.data()));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r694258297",
      "id" : 694258297,
      "in_reply_to_id" : 660004965,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NDI1ODI5Nw==",
      "original_commit_id" : "c22f607b62af59969b9378d4cd8ed72b866dec11",
      "original_line" : 619,
      "original_position" : 59,
      "original_start_line" : null,
      "path" : "src/test/crypto_tests.cpp",
      "position" : null,
      "pull_request_review_id" : 736500815,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-23T19:42:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/694258297",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "I will be taking on this PR. Rebased with master. Addressed my own comments. Ready for further review.",
      "created_at" : "2021-08-23T20:39:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#issuecomment-904108753",
      "id" : 904108753,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20962",
      "node_id" : "IC_kwDOABII584145rR",
      "performed_via_github_app" : null,
      "updated_at" : "2021-08-23T20:39:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/904108753",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r696008360"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696008360"
         }
      },
      "author_association" : "NONE",
      "body" : "`AAD_PACKAGES_PER_ROUND` is defined but not used anywhere. Couldn't we remove it?",
      "commit_id" : "424e0100fbea0ac8106b25a9b23698f2c2cd7a4f",
      "created_at" : "2021-08-25T18:23:49Z",
      "diff_hunk" : "@@ -6,6 +6,7 @@\n #define BITCOIN_CRYPTO_CHACHA_POLY_AEAD_H\n \n #include <crypto/chacha20.h>\n+#include <crypto/poly1305.h>\n \n #include <cmath>\n ",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r696008360",
      "id" : 696008360,
      "line" : 12,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NjAwODM2MA==",
      "original_commit_id" : "424e0100fbea0ac8106b25a9b23698f2c2cd7a4f",
      "original_line" : 12,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : 7,
      "pull_request_review_id" : 738693637,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-25T19:14:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696008360",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r696015556"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696015556"
         }
      },
      "author_association" : "NONE",
      "body" : "Since we're already initialising `m_seqnr` with 0 in the class definition of `ChaCha20Forward4064`, https://github.com/bitcoin/bitcoin/blob/424e0100fbea0ac8106b25a9b23698f2c2cd7a4f/src/crypto/chacha_poly_aead.h#L107  Couldn't we remove this line from the constructor?",
      "commit_id" : "424e0100fbea0ac8106b25a9b23698f2c2cd7a4f",
      "created_at" : "2021-08-25T18:33:58Z",
      "diff_hunk" : "@@ -27,20 +28,58 @@ int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n \n #endif // TIMINGSAFE_BCMP\n \n-ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len)\n+ChaCha20Forward4064::ChaCha20Forward4064(const unsigned char* key, size_t keylen)\n {\n-    assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n-    assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    assert(keylen == 32);\n+    m_ctx.SetKey(key, keylen);\n+\n+    // set initial sequence number\n+    m_seqnr = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r696015556",
      "id" : 696015556,
      "line" : 37,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NjAxNTU1Ng==",
      "original_commit_id" : "424e0100fbea0ac8106b25a9b23698f2c2cd7a4f",
      "original_line" : 37,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.cpp",
      "position" : 21,
      "pull_request_review_id" : 738693637,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-25T19:14:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696015556",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r696016509"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696016509"
         }
      },
      "author_association" : "NONE",
      "body" : "Since we're already initialising `m_keystream_pos` with 0 in the class definition of `ChaCha20Forward4064`, https://github.com/bitcoin/bitcoin/blob/424e0100fbea0ac8106b25a9b23698f2c2cd7a4f/src/crypto/chacha_poly_aead.h#L108 Couldn't we remove this line from the constructor?",
      "commit_id" : "424e0100fbea0ac8106b25a9b23698f2c2cd7a4f",
      "created_at" : "2021-08-25T18:35:28Z",
      "diff_hunk" : "@@ -27,20 +28,58 @@ int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n \n #endif // TIMINGSAFE_BCMP\n \n-ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len)\n+ChaCha20Forward4064::ChaCha20Forward4064(const unsigned char* key, size_t keylen)\n {\n-    assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n-    assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    assert(keylen == 32);\n+    m_ctx.SetKey(key, keylen);\n+\n+    // set initial sequence number\n+    m_seqnr = 0;\n+    m_ctx.SetIV(m_seqnr);\n+\n+    // precompute first chunk of keystream\n+    m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+    m_keystream_pos = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r696016509",
      "id" : 696016509,
      "line" : 42,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NjAxNjUwOQ==",
      "original_commit_id" : "424e0100fbea0ac8106b25a9b23698f2c2cd7a4f",
      "original_line" : 42,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.cpp",
      "position" : 26,
      "pull_request_review_id" : 738693637,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-08-25T19:14:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696016509",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r696022694"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696022694"
         }
      },
      "author_association" : "NONE",
      "body" : "We are checking whether the key length is 32 on this line https://github.com/bitcoin/bitcoin/blob/424e0100fbea0ac8106b25a9b23698f2c2cd7a4f/src/crypto/chacha_poly_aead.cpp#L33 when the constructors of `m_chacha_header` and `m_chacha_main` get called. So couldn't we remove these 2 lines?",
      "commit_id" : "424e0100fbea0ac8106b25a9b23698f2c2cd7a4f",
      "created_at" : "2021-08-25T18:44:41Z",
      "diff_hunk" : "@@ -27,20 +28,58 @@ int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n \n #endif // TIMINGSAFE_BCMP\n \n-ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len)\n+ChaCha20Forward4064::ChaCha20Forward4064(const unsigned char* key, size_t keylen)\n {\n-    assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n-    assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    assert(keylen == 32);\n+    m_ctx.SetKey(key, keylen);\n+\n+    // set initial sequence number\n+    m_seqnr = 0;\n+    m_ctx.SetIV(m_seqnr);\n+\n+    // precompute first chunk of keystream\n+    m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+    m_keystream_pos = 0;\n+}\n+\n+void ChaCha20Forward4064::Crypt(const unsigned char* input, unsigned char* output, size_t bytes)\n+{\n+    size_t message_pos = 0;\n+\n+    // TODO: speedup with a block approach (rather then looping over every byte)\n+    while (bytes > message_pos) {\n+        output[message_pos] = input[message_pos] ^ m_keystream[m_keystream_pos];\n+        m_keystream_pos++;\n+        message_pos++;\n+        if (m_keystream_pos == KEYSTREAM_SIZE - CHACHA20_POLY1305_AEAD_KEY_LEN) {\n+            // we reached the end of the keystream\n+            // rekey with the remaining and last 32 bytes and precompute the next 4096 bytes\n+            m_ctx.SetKey(&m_keystream[m_keystream_pos], CHACHA20_POLY1305_AEAD_KEY_LEN);\n+\n+            // m_ctx.SetKey() sets both IV and counter to zero, but we need the IV to increment.\n+            m_ctx.SetIV(++m_seqnr);\n+            m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+            // reset keystream position\n+            m_keystream_pos = 0;\n+        }\n+    }\n+}\n \n-    m_chacha_header.SetKey(K_1, CHACHA20_POLY1305_AEAD_KEY_LEN);\n-    m_chacha_main.SetKey(K_2, CHACHA20_POLY1305_AEAD_KEY_LEN);\n+ChaCha20Forward4064::~ChaCha20Forward4064()\n+{\n+    memory_cleanse(m_keystream, KEYSTREAM_SIZE);\n+}\n \n-    // set the cached sequence number to uint64 max which hints for an unset cache.\n-    // we can't hit uint64 max since the rekey rule (which resets the sequence number) is 1GB\n-    m_cached_aad_seqnr = std::numeric_limits<uint64_t>::max();\n+ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1,\n+                                           size_t K_1_len,\n+                                           const unsigned char* K_2,\n+                                           size_t K_2_len) : m_chacha_header(K_1, CHACHA20_POLY1305_AEAD_KEY_LEN), m_chacha_main(K_2, CHACHA20_POLY1305_AEAD_KEY_LEN)\n+{\n+    assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r696022694",
      "id" : 696022694,
      "line" : 79,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDY5NjAyMjY5NA==",
      "original_commit_id" : "424e0100fbea0ac8106b25a9b23698f2c2cd7a4f",
      "original_line" : 79,
      "original_position" : 68,
      "original_start_line" : 78,
      "path" : "src/crypto/chacha_poly_aead.cpp",
      "position" : 68,
      "pull_request_review_id" : 738693637,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : 78,
      "start_side" : "RIGHT",
      "updated_at" : "2021-08-25T19:14:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/696022694",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/44024636?v=4",
         "events_url" : "https://api.github.com/users/stratospher/events{/privacy}",
         "followers_url" : "https://api.github.com/users/stratospher/followers",
         "following_url" : "https://api.github.com/users/stratospher/following{/other_user}",
         "gists_url" : "https://api.github.com/users/stratospher/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/stratospher",
         "id" : 44024636,
         "login" : "stratospher",
         "node_id" : "MDQ6VXNlcjQ0MDI0NjM2",
         "organizations_url" : "https://api.github.com/users/stratospher/orgs",
         "received_events_url" : "https://api.github.com/users/stratospher/received_events",
         "repos_url" : "https://api.github.com/users/stratospher/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/stratospher/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/stratospher/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/stratospher"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r706917217"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/706917217"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Good catch. Fixed.",
      "commit_id" : "8a9daf57ed7e9f1b3ce2524ff6a5797293bfa9de",
      "created_at" : "2021-09-12T21:47:09Z",
      "diff_hunk" : "@@ -6,6 +6,7 @@\n #define BITCOIN_CRYPTO_CHACHA_POLY_AEAD_H\n \n #include <crypto/chacha20.h>\n+#include <crypto/poly1305.h>\n \n #include <cmath>\n ",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r706917217",
      "id" : 706917217,
      "in_reply_to_id" : 696008360,
      "line" : 12,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjkxNzIxNw==",
      "original_commit_id" : "424e0100fbea0ac8106b25a9b23698f2c2cd7a4f",
      "original_line" : 12,
      "original_position" : 7,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.h",
      "position" : 7,
      "pull_request_review_id" : 752218440,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-09-12T21:47:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/706917217",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r706917227"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/706917227"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "8a9daf57ed7e9f1b3ce2524ff6a5797293bfa9de",
      "created_at" : "2021-09-12T21:47:15Z",
      "diff_hunk" : "@@ -27,20 +28,58 @@ int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n \n #endif // TIMINGSAFE_BCMP\n \n-ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len)\n+ChaCha20Forward4064::ChaCha20Forward4064(const unsigned char* key, size_t keylen)\n {\n-    assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n-    assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    assert(keylen == 32);\n+    m_ctx.SetKey(key, keylen);\n+\n+    // set initial sequence number\n+    m_seqnr = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r706917227",
      "id" : 706917227,
      "in_reply_to_id" : 696015556,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjkxNzIyNw==",
      "original_commit_id" : "424e0100fbea0ac8106b25a9b23698f2c2cd7a4f",
      "original_line" : 37,
      "original_position" : 21,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.cpp",
      "position" : null,
      "pull_request_review_id" : 752218448,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-09-12T21:47:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/706917227",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r706917252"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/706917252"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Done.",
      "commit_id" : "8a9daf57ed7e9f1b3ce2524ff6a5797293bfa9de",
      "created_at" : "2021-09-12T21:47:30Z",
      "diff_hunk" : "@@ -27,20 +28,58 @@ int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n \n #endif // TIMINGSAFE_BCMP\n \n-ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len)\n+ChaCha20Forward4064::ChaCha20Forward4064(const unsigned char* key, size_t keylen)\n {\n-    assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n-    assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    assert(keylen == 32);\n+    m_ctx.SetKey(key, keylen);\n+\n+    // set initial sequence number\n+    m_seqnr = 0;\n+    m_ctx.SetIV(m_seqnr);\n+\n+    // precompute first chunk of keystream\n+    m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+    m_keystream_pos = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r706917252",
      "id" : 706917252,
      "in_reply_to_id" : 696016509,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjkxNzI1Mg==",
      "original_commit_id" : "424e0100fbea0ac8106b25a9b23698f2c2cd7a4f",
      "original_line" : 42,
      "original_position" : 26,
      "original_start_line" : null,
      "path" : "src/crypto/chacha_poly_aead.cpp",
      "position" : null,
      "pull_request_review_id" : 752218464,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2021-09-12T21:47:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/706917252",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r706917333"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/706917333"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I find these asserts clarifying and afaict, C++ asserts are optimized away in release builds so it's not slowing anything down. Leaving these in here for now.",
      "commit_id" : "8a9daf57ed7e9f1b3ce2524ff6a5797293bfa9de",
      "created_at" : "2021-09-12T21:48:21Z",
      "diff_hunk" : "@@ -27,20 +28,58 @@ int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n \n #endif // TIMINGSAFE_BCMP\n \n-ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len)\n+ChaCha20Forward4064::ChaCha20Forward4064(const unsigned char* key, size_t keylen)\n {\n-    assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n-    assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    assert(keylen == 32);\n+    m_ctx.SetKey(key, keylen);\n+\n+    // set initial sequence number\n+    m_seqnr = 0;\n+    m_ctx.SetIV(m_seqnr);\n+\n+    // precompute first chunk of keystream\n+    m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+    m_keystream_pos = 0;\n+}\n+\n+void ChaCha20Forward4064::Crypt(const unsigned char* input, unsigned char* output, size_t bytes)\n+{\n+    size_t message_pos = 0;\n+\n+    // TODO: speedup with a block approach (rather then looping over every byte)\n+    while (bytes > message_pos) {\n+        output[message_pos] = input[message_pos] ^ m_keystream[m_keystream_pos];\n+        m_keystream_pos++;\n+        message_pos++;\n+        if (m_keystream_pos == KEYSTREAM_SIZE - CHACHA20_POLY1305_AEAD_KEY_LEN) {\n+            // we reached the end of the keystream\n+            // rekey with the remaining and last 32 bytes and precompute the next 4096 bytes\n+            m_ctx.SetKey(&m_keystream[m_keystream_pos], CHACHA20_POLY1305_AEAD_KEY_LEN);\n+\n+            // m_ctx.SetKey() sets both IV and counter to zero, but we need the IV to increment.\n+            m_ctx.SetIV(++m_seqnr);\n+            m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+            // reset keystream position\n+            m_keystream_pos = 0;\n+        }\n+    }\n+}\n \n-    m_chacha_header.SetKey(K_1, CHACHA20_POLY1305_AEAD_KEY_LEN);\n-    m_chacha_main.SetKey(K_2, CHACHA20_POLY1305_AEAD_KEY_LEN);\n+ChaCha20Forward4064::~ChaCha20Forward4064()\n+{\n+    memory_cleanse(m_keystream, KEYSTREAM_SIZE);\n+}\n \n-    // set the cached sequence number to uint64 max which hints for an unset cache.\n-    // we can't hit uint64 max since the rekey rule (which resets the sequence number) is 1GB\n-    m_cached_aad_seqnr = std::numeric_limits<uint64_t>::max();\n+ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1,\n+                                           size_t K_1_len,\n+                                           const unsigned char* K_2,\n+                                           size_t K_2_len) : m_chacha_header(K_1, CHACHA20_POLY1305_AEAD_KEY_LEN), m_chacha_main(K_2, CHACHA20_POLY1305_AEAD_KEY_LEN)\n+{\n+    assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r706917333",
      "id" : 706917333,
      "in_reply_to_id" : 696022694,
      "line" : 77,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDcwNjkxNzMzMw==",
      "original_commit_id" : "424e0100fbea0ac8106b25a9b23698f2c2cd7a4f",
      "original_line" : 77,
      "original_position" : 68,
      "original_start_line" : 78,
      "path" : "src/crypto/chacha_poly_aead.cpp",
      "position" : 66,
      "pull_request_review_id" : 752218529,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : 76,
      "start_side" : "RIGHT",
      "updated_at" : "2021-09-12T21:48:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/706917333",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Comments from @stratospher addressed. Ready for further review.",
      "created_at" : "2021-09-12T21:48:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#issuecomment-917716402",
      "id" : 917716402,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20962",
      "node_id" : "IC_kwDOABII5842sz2y",
      "performed_via_github_app" : null,
      "updated_at" : "2021-09-12T21:48:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/917716402",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r710606026"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/710606026"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Update: Turns out this was mistaken. assert() is not optimized away in optimized Bitcoin Core builds.",
      "commit_id" : "8a9daf57ed7e9f1b3ce2524ff6a5797293bfa9de",
      "created_at" : "2021-09-17T00:27:34Z",
      "diff_hunk" : "@@ -27,20 +28,58 @@ int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n \n #endif // TIMINGSAFE_BCMP\n \n-ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len)\n+ChaCha20Forward4064::ChaCha20Forward4064(const unsigned char* key, size_t keylen)\n {\n-    assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n-    assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    assert(keylen == 32);\n+    m_ctx.SetKey(key, keylen);\n+\n+    // set initial sequence number\n+    m_seqnr = 0;\n+    m_ctx.SetIV(m_seqnr);\n+\n+    // precompute first chunk of keystream\n+    m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+    m_keystream_pos = 0;\n+}\n+\n+void ChaCha20Forward4064::Crypt(const unsigned char* input, unsigned char* output, size_t bytes)\n+{\n+    size_t message_pos = 0;\n+\n+    // TODO: speedup with a block approach (rather then looping over every byte)\n+    while (bytes > message_pos) {\n+        output[message_pos] = input[message_pos] ^ m_keystream[m_keystream_pos];\n+        m_keystream_pos++;\n+        message_pos++;\n+        if (m_keystream_pos == KEYSTREAM_SIZE - CHACHA20_POLY1305_AEAD_KEY_LEN) {\n+            // we reached the end of the keystream\n+            // rekey with the remaining and last 32 bytes and precompute the next 4096 bytes\n+            m_ctx.SetKey(&m_keystream[m_keystream_pos], CHACHA20_POLY1305_AEAD_KEY_LEN);\n+\n+            // m_ctx.SetKey() sets both IV and counter to zero, but we need the IV to increment.\n+            m_ctx.SetIV(++m_seqnr);\n+            m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+            // reset keystream position\n+            m_keystream_pos = 0;\n+        }\n+    }\n+}\n \n-    m_chacha_header.SetKey(K_1, CHACHA20_POLY1305_AEAD_KEY_LEN);\n-    m_chacha_main.SetKey(K_2, CHACHA20_POLY1305_AEAD_KEY_LEN);\n+ChaCha20Forward4064::~ChaCha20Forward4064()\n+{\n+    memory_cleanse(m_keystream, KEYSTREAM_SIZE);\n+}\n \n-    // set the cached sequence number to uint64 max which hints for an unset cache.\n-    // we can't hit uint64 max since the rekey rule (which resets the sequence number) is 1GB\n-    m_cached_aad_seqnr = std::numeric_limits<uint64_t>::max();\n+ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1,\n+                                           size_t K_1_len,\n+                                           const unsigned char* K_2,\n+                                           size_t K_2_len) : m_chacha_header(K_1, CHACHA20_POLY1305_AEAD_KEY_LEN), m_chacha_main(K_2, CHACHA20_POLY1305_AEAD_KEY_LEN)\n+{\n+    assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#discussion_r710606026",
      "id" : 710606026,
      "in_reply_to_id" : 696022694,
      "line" : 77,
      "node_id" : "PRRC_kwDOABII584qWvzK",
      "original_commit_id" : "424e0100fbea0ac8106b25a9b23698f2c2cd7a4f",
      "original_line" : 77,
      "original_position" : 68,
      "original_start_line" : 78,
      "path" : "src/crypto/chacha_poly_aead.cpp",
      "position" : 66,
      "pull_request_review_id" : 756952958,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/20962",
      "side" : "RIGHT",
      "start_line" : 76,
      "start_side" : "RIGHT",
      "updated_at" : "2021-09-17T00:27:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/710606026",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Addressed https://github.com/bitcoin/bitcoin/pull/23233#discussion_r725442331 - ready for further review",
      "created_at" : "2021-10-10T04:52:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/20962#issuecomment-939406631",
      "id" : 939406631,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/20962",
      "node_id" : "IC_kwDOABII5843_jUn",
      "performed_via_github_app" : null,
      "reactions" : {
         "+1" : 0,
         "-1" : 0,
         "confused" : 0,
         "eyes" : 0,
         "heart" : 0,
         "hooray" : 0,
         "laugh" : 0,
         "rocket" : 0,
         "total_count" : 0,
         "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/939406631/reactions"
      },
      "updated_at" : "2021-10-10T04:52:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/939406631",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   }
]
