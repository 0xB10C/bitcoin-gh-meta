[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11824#discussion_r154814580"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11824"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/154814580"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Should this be parameterized? Or at least a configurable constant?\r\nIs there any advantage to tweaking it?",
      "commit_id" : "3113573c847c76943c065b72d3e7a9edc643fed1",
      "created_at" : "2017-12-05T00:16:39Z",
      "diff_hunk" : "@@ -2467,12 +2468,23 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n     // far from a guarantee. Things in the P2P/RPC will often end up calling\n     // us in the middle of ProcessNewBlock - do not assume pblock is set\n     // sanely for performance or correctness!\n+    AssertLockNotHeld(cs_main);\n \n     CBlockIndex *pindexMostWork = nullptr;\n     CBlockIndex *pindexNewTip = nullptr;\n     int nStopAtHeight = gArgs.GetArg(\"-stopatheight\", DEFAULT_STOPATHEIGHT);\n     do {\n         boost::this_thread::interruption_point();\n+\n+        if (GetMainSignals().CallbacksPending() > 10) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11824#discussion_r154814580",
      "id" : 154814580,
      "original_commit_id" : "151b17da19c10324f8405038e19329310bad2467",
      "original_position" : 20,
      "path" : "src/validation.cpp",
      "position" : 20,
      "pull_request_review_id" : 81034310,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11824",
      "updated_at" : "2017-12-05T04:32:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/154814580",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/413395?v=4",
         "events_url" : "https://api.github.com/users/dcousens/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dcousens/followers",
         "following_url" : "https://api.github.com/users/dcousens/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dcousens/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dcousens",
         "id" : 413395,
         "login" : "dcousens",
         "organizations_url" : "https://api.github.com/users/dcousens/orgs",
         "received_events_url" : "https://api.github.com/users/dcousens/received_events",
         "repos_url" : "https://api.github.com/users/dcousens/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dcousens/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dcousens/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dcousens"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11824#discussion_r154814746"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11824"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/154814746"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "During normal (read: non-IBD/reindex) usage, this should virtually never reach 10. During IBD/reindex, your memory is probably better speint in more dbcache than storing blocks you recently connected to eventually give to your wallet. I dont think more knobs is helpful here.",
      "commit_id" : "3113573c847c76943c065b72d3e7a9edc643fed1",
      "created_at" : "2017-12-05T00:17:45Z",
      "diff_hunk" : "@@ -2467,12 +2468,23 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n     // far from a guarantee. Things in the P2P/RPC will often end up calling\n     // us in the middle of ProcessNewBlock - do not assume pblock is set\n     // sanely for performance or correctness!\n+    AssertLockNotHeld(cs_main);\n \n     CBlockIndex *pindexMostWork = nullptr;\n     CBlockIndex *pindexNewTip = nullptr;\n     int nStopAtHeight = gArgs.GetArg(\"-stopatheight\", DEFAULT_STOPATHEIGHT);\n     do {\n         boost::this_thread::interruption_point();\n+\n+        if (GetMainSignals().CallbacksPending() > 10) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11824#discussion_r154814746",
      "id" : 154814746,
      "in_reply_to_id" : 154814580,
      "original_commit_id" : "151b17da19c10324f8405038e19329310bad2467",
      "original_position" : 20,
      "path" : "src/validation.cpp",
      "position" : 20,
      "pull_request_review_id" : 81034486,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11824",
      "updated_at" : "2017-12-05T01:52:39Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/154814746",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11824#discussion_r154841745"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11824"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/154841745"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It seems to me that this expects to see transactions first and then blocks. But can't a `getdata` message have the types in any order?",
      "commit_id" : "3113573c847c76943c065b72d3e7a9edc643fed1",
      "created_at" : "2017-12-05T03:58:38Z",
      "diff_hunk" : "@@ -1032,170 +1040,183 @@ static void RelayAddress(const CAddress& addr, bool fReachable, CConnman* connma\n     connman->ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n }\n \n+// returns true if we need to call ActivateBestChain before responding\n+bool static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensusParams, const CInv& inv, CConnman* connman, const std::atomic<bool>& interruptMsgProc, bool best_chain_active)\n+{\n+    bool send = false;\n+    std::shared_ptr<const CBlock> a_recent_block;\n+    std::shared_ptr<const CBlockHeaderAndShortTxIDs> a_recent_compact_block;\n+    bool fWitnessesPresentInARecentCompactBlock;\n+    {\n+        LOCK(cs_most_recent_block);\n+        a_recent_block = most_recent_block;\n+        a_recent_compact_block = most_recent_compact_block;\n+        fWitnessesPresentInARecentCompactBlock = fWitnessesPresentInMostRecentCompactBlock;\n+    }\n+\n+    LOCK(cs_main);\n+    BlockMap::iterator mi = mapBlockIndex.find(inv.hash);\n+    if (mi != mapBlockIndex.end())\n+    {\n+        if (mi->second->nChainTx && !mi->second->IsValid(BLOCK_VALID_SCRIPTS) &&\n+                mi->second->IsValid(BLOCK_VALID_TREE)) {\n+            // If we have the block and all of its parents, but have not yet validated it,\n+            // we might be in the middle of connecting it (ie in the unlock of cs_main\n+            // before ActivateBestChain but after AcceptBlock).\n+            // In this case, we need to run ActivateBestChain prior to checking the relay\n+            // conditions below.\n+            return true;\n+        }\n+        send = BlockRequestAllowed(mi->second, consensusParams);\n+        if (!send) {\n+            LogPrintf(\"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom->GetId());\n+        }\n+    }\n+    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n+    // disconnect node in case we have reached the outbound limit for serving historical blocks\n+    // never disconnect whitelisted nodes\n+    if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n+    {\n+        LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n+\n+        //disconnect node\n+        pfrom->fDisconnect = true;\n+        send = false;\n+    }\n+    // Pruned nodes may have deleted the block, so check whether\n+    // it's available before trying to send.\n+    if (send && (mi->second->nStatus & BLOCK_HAVE_DATA))\n+    {\n+        std::shared_ptr<const CBlock> pblock;\n+        if (a_recent_block && a_recent_block->GetHash() == (*mi).second->GetBlockHash()) {\n+            pblock = a_recent_block;\n+        } else {\n+            // Send block from disk\n+            std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();\n+            if (!ReadBlockFromDisk(*pblockRead, (*mi).second, consensusParams))\n+                assert(!\"cannot load block from disk\");\n+            pblock = pblockRead;\n+        }\n+        if (inv.type == MSG_BLOCK)\n+            connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n+        else if (inv.type == MSG_WITNESS_BLOCK)\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n+        else if (inv.type == MSG_FILTERED_BLOCK)\n+        {\n+            bool sendMerkleBlock = false;\n+            CMerkleBlock merkleBlock;\n+            {\n+                LOCK(pfrom->cs_filter);\n+                if (pfrom->pfilter) {\n+                    sendMerkleBlock = true;\n+                    merkleBlock = CMerkleBlock(*pblock, *pfrom->pfilter);\n+                }\n+            }\n+            if (sendMerkleBlock) {\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n+                // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n+                // This avoids hurting performance by pointlessly requiring a round-trip\n+                // Note that there is currently no way for a node to request any single transactions we didn't send here -\n+                // they must either disconnect and retry or request the full block.\n+                // Thus, the protocol spec specified allows for us to provide duplicate txn here,\n+                // however we MUST always provide at least what the remote peer needs\n+                typedef std::pair<unsigned int, uint256> PairType;\n+                for (PairType& pair : merkleBlock.vMatchedTxn)\n+                    connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n+            }\n+            // else\n+                // no response\n+        }\n+        else if (inv.type == MSG_CMPCT_BLOCK)\n+        {\n+            // If a peer is asking for old blocks, we're almost guaranteed\n+            // they won't have a useful mempool to match against a compact block,\n+            // and we don't feel like constructing the object for them, so\n+            // instead we respond with the full, non-compact block.\n+            bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;\n+            int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n+            if (CanDirectFetch(consensusParams) && mi->second->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {\n+                if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == mi->second->GetBlockHash()) {\n+                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n+                } else {\n+                    CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n+                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                }\n+            } else {\n+                connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n+            }\n+        }\n+\n+        // Trigger the peer node to send a getblocks request for the next batch of inventory\n+        if (inv.hash == pfrom->hashContinue)\n+        {\n+            // Bypass PushInventory, this must send even if redundant,\n+            // and we want it right after the last block so they don't\n+            // wait for other stuff first.\n+            std::vector<CInv> vInv;\n+            vInv.push_back(CInv(MSG_BLOCK, chainActive.Tip()->GetBlockHash()));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n+            pfrom->hashContinue.SetNull();\n+        }\n+    }\n+\n+    return false;\n+}\n+\n void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n+    AssertLockNotHeld(cs_main);\n+\n     std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n     std::vector<CInv> vNotFound;\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n-    LOCK(cs_main);\n-\n-    while (it != pfrom->vRecvGetData.end()) {\n-        // Don't bother if send buffer is too full to respond anyway\n-        if (pfrom->fPauseSend)\n-            break;\n+    {\n+        LOCK(cs_main);\n \n-        const CInv &inv = *it;\n-        {\n+        while (it != pfrom->vRecvGetData.end() && (it->type == MSG_TX || it->type == MSG_WITNESS_TX)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11824#discussion_r154841745",
      "id" : 154841745,
      "original_commit_id" : "3113573c847c76943c065b72d3e7a9edc643fed1",
      "original_position" : 244,
      "path" : "src/net_processing.cpp",
      "position" : 244,
      "pull_request_review_id" : 81064613,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11824",
      "updated_at" : "2017-12-05T04:01:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/154841745",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11824#discussion_r154842507"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11824"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/154842507"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "No, we are allowed to (in fact always have) not finish the full queue before returning, and we do for blocks (always did). A peer shouldn't be able to make us spin giving them 100 blocks before processing any other peers' requests.",
      "commit_id" : "3113573c847c76943c065b72d3e7a9edc643fed1",
      "created_at" : "2017-12-05T04:05:07Z",
      "diff_hunk" : "@@ -1032,170 +1040,183 @@ static void RelayAddress(const CAddress& addr, bool fReachable, CConnman* connma\n     connman->ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n }\n \n+// returns true if we need to call ActivateBestChain before responding\n+bool static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensusParams, const CInv& inv, CConnman* connman, const std::atomic<bool>& interruptMsgProc, bool best_chain_active)\n+{\n+    bool send = false;\n+    std::shared_ptr<const CBlock> a_recent_block;\n+    std::shared_ptr<const CBlockHeaderAndShortTxIDs> a_recent_compact_block;\n+    bool fWitnessesPresentInARecentCompactBlock;\n+    {\n+        LOCK(cs_most_recent_block);\n+        a_recent_block = most_recent_block;\n+        a_recent_compact_block = most_recent_compact_block;\n+        fWitnessesPresentInARecentCompactBlock = fWitnessesPresentInMostRecentCompactBlock;\n+    }\n+\n+    LOCK(cs_main);\n+    BlockMap::iterator mi = mapBlockIndex.find(inv.hash);\n+    if (mi != mapBlockIndex.end())\n+    {\n+        if (mi->second->nChainTx && !mi->second->IsValid(BLOCK_VALID_SCRIPTS) &&\n+                mi->second->IsValid(BLOCK_VALID_TREE)) {\n+            // If we have the block and all of its parents, but have not yet validated it,\n+            // we might be in the middle of connecting it (ie in the unlock of cs_main\n+            // before ActivateBestChain but after AcceptBlock).\n+            // In this case, we need to run ActivateBestChain prior to checking the relay\n+            // conditions below.\n+            return true;\n+        }\n+        send = BlockRequestAllowed(mi->second, consensusParams);\n+        if (!send) {\n+            LogPrintf(\"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom->GetId());\n+        }\n+    }\n+    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n+    // disconnect node in case we have reached the outbound limit for serving historical blocks\n+    // never disconnect whitelisted nodes\n+    if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n+    {\n+        LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n+\n+        //disconnect node\n+        pfrom->fDisconnect = true;\n+        send = false;\n+    }\n+    // Pruned nodes may have deleted the block, so check whether\n+    // it's available before trying to send.\n+    if (send && (mi->second->nStatus & BLOCK_HAVE_DATA))\n+    {\n+        std::shared_ptr<const CBlock> pblock;\n+        if (a_recent_block && a_recent_block->GetHash() == (*mi).second->GetBlockHash()) {\n+            pblock = a_recent_block;\n+        } else {\n+            // Send block from disk\n+            std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();\n+            if (!ReadBlockFromDisk(*pblockRead, (*mi).second, consensusParams))\n+                assert(!\"cannot load block from disk\");\n+            pblock = pblockRead;\n+        }\n+        if (inv.type == MSG_BLOCK)\n+            connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n+        else if (inv.type == MSG_WITNESS_BLOCK)\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n+        else if (inv.type == MSG_FILTERED_BLOCK)\n+        {\n+            bool sendMerkleBlock = false;\n+            CMerkleBlock merkleBlock;\n+            {\n+                LOCK(pfrom->cs_filter);\n+                if (pfrom->pfilter) {\n+                    sendMerkleBlock = true;\n+                    merkleBlock = CMerkleBlock(*pblock, *pfrom->pfilter);\n+                }\n+            }\n+            if (sendMerkleBlock) {\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n+                // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n+                // This avoids hurting performance by pointlessly requiring a round-trip\n+                // Note that there is currently no way for a node to request any single transactions we didn't send here -\n+                // they must either disconnect and retry or request the full block.\n+                // Thus, the protocol spec specified allows for us to provide duplicate txn here,\n+                // however we MUST always provide at least what the remote peer needs\n+                typedef std::pair<unsigned int, uint256> PairType;\n+                for (PairType& pair : merkleBlock.vMatchedTxn)\n+                    connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n+            }\n+            // else\n+                // no response\n+        }\n+        else if (inv.type == MSG_CMPCT_BLOCK)\n+        {\n+            // If a peer is asking for old blocks, we're almost guaranteed\n+            // they won't have a useful mempool to match against a compact block,\n+            // and we don't feel like constructing the object for them, so\n+            // instead we respond with the full, non-compact block.\n+            bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;\n+            int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n+            if (CanDirectFetch(consensusParams) && mi->second->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {\n+                if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == mi->second->GetBlockHash()) {\n+                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n+                } else {\n+                    CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n+                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                }\n+            } else {\n+                connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n+            }\n+        }\n+\n+        // Trigger the peer node to send a getblocks request for the next batch of inventory\n+        if (inv.hash == pfrom->hashContinue)\n+        {\n+            // Bypass PushInventory, this must send even if redundant,\n+            // and we want it right after the last block so they don't\n+            // wait for other stuff first.\n+            std::vector<CInv> vInv;\n+            vInv.push_back(CInv(MSG_BLOCK, chainActive.Tip()->GetBlockHash()));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n+            pfrom->hashContinue.SetNull();\n+        }\n+    }\n+\n+    return false;\n+}\n+\n void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n+    AssertLockNotHeld(cs_main);\n+\n     std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n     std::vector<CInv> vNotFound;\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n-    LOCK(cs_main);\n-\n-    while (it != pfrom->vRecvGetData.end()) {\n-        // Don't bother if send buffer is too full to respond anyway\n-        if (pfrom->fPauseSend)\n-            break;\n+    {\n+        LOCK(cs_main);\n \n-        const CInv &inv = *it;\n-        {\n+        while (it != pfrom->vRecvGetData.end() && (it->type == MSG_TX || it->type == MSG_WITNESS_TX)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11824#discussion_r154842507",
      "id" : 154842507,
      "in_reply_to_id" : 154841745,
      "original_commit_id" : "3113573c847c76943c065b72d3e7a9edc643fed1",
      "original_position" : 244,
      "path" : "src/net_processing.cpp",
      "position" : 244,
      "pull_request_review_id" : 81065477,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11824",
      "updated_at" : "2017-12-05T04:05:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/154842507",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "tACK 3113573c847c76943c065b72d3e7a9edc643fed1",
      "created_at" : "2017-12-05T04:18:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11824#issuecomment-349190738",
      "id" : 349190738,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11824",
      "updated_at" : "2017-12-05T04:18:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/349190738",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/11824#discussion_r154843830"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11824"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/154843830"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Ok, I see now. I didn't see the break for when the type was a block.",
      "commit_id" : "3113573c847c76943c065b72d3e7a9edc643fed1",
      "created_at" : "2017-12-05T04:19:14Z",
      "diff_hunk" : "@@ -1032,170 +1040,183 @@ static void RelayAddress(const CAddress& addr, bool fReachable, CConnman* connma\n     connman->ForEachNodeThen(std::move(sortfunc), std::move(pushfunc));\n }\n \n+// returns true if we need to call ActivateBestChain before responding\n+bool static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensusParams, const CInv& inv, CConnman* connman, const std::atomic<bool>& interruptMsgProc, bool best_chain_active)\n+{\n+    bool send = false;\n+    std::shared_ptr<const CBlock> a_recent_block;\n+    std::shared_ptr<const CBlockHeaderAndShortTxIDs> a_recent_compact_block;\n+    bool fWitnessesPresentInARecentCompactBlock;\n+    {\n+        LOCK(cs_most_recent_block);\n+        a_recent_block = most_recent_block;\n+        a_recent_compact_block = most_recent_compact_block;\n+        fWitnessesPresentInARecentCompactBlock = fWitnessesPresentInMostRecentCompactBlock;\n+    }\n+\n+    LOCK(cs_main);\n+    BlockMap::iterator mi = mapBlockIndex.find(inv.hash);\n+    if (mi != mapBlockIndex.end())\n+    {\n+        if (mi->second->nChainTx && !mi->second->IsValid(BLOCK_VALID_SCRIPTS) &&\n+                mi->second->IsValid(BLOCK_VALID_TREE)) {\n+            // If we have the block and all of its parents, but have not yet validated it,\n+            // we might be in the middle of connecting it (ie in the unlock of cs_main\n+            // before ActivateBestChain but after AcceptBlock).\n+            // In this case, we need to run ActivateBestChain prior to checking the relay\n+            // conditions below.\n+            return true;\n+        }\n+        send = BlockRequestAllowed(mi->second, consensusParams);\n+        if (!send) {\n+            LogPrintf(\"%s: ignoring request from peer=%i for old block that isn't in the main chain\\n\", __func__, pfrom->GetId());\n+        }\n+    }\n+    const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n+    // disconnect node in case we have reached the outbound limit for serving historical blocks\n+    // never disconnect whitelisted nodes\n+    if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n+    {\n+        LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n+\n+        //disconnect node\n+        pfrom->fDisconnect = true;\n+        send = false;\n+    }\n+    // Pruned nodes may have deleted the block, so check whether\n+    // it's available before trying to send.\n+    if (send && (mi->second->nStatus & BLOCK_HAVE_DATA))\n+    {\n+        std::shared_ptr<const CBlock> pblock;\n+        if (a_recent_block && a_recent_block->GetHash() == (*mi).second->GetBlockHash()) {\n+            pblock = a_recent_block;\n+        } else {\n+            // Send block from disk\n+            std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();\n+            if (!ReadBlockFromDisk(*pblockRead, (*mi).second, consensusParams))\n+                assert(!\"cannot load block from disk\");\n+            pblock = pblockRead;\n+        }\n+        if (inv.type == MSG_BLOCK)\n+            connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n+        else if (inv.type == MSG_WITNESS_BLOCK)\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n+        else if (inv.type == MSG_FILTERED_BLOCK)\n+        {\n+            bool sendMerkleBlock = false;\n+            CMerkleBlock merkleBlock;\n+            {\n+                LOCK(pfrom->cs_filter);\n+                if (pfrom->pfilter) {\n+                    sendMerkleBlock = true;\n+                    merkleBlock = CMerkleBlock(*pblock, *pfrom->pfilter);\n+                }\n+            }\n+            if (sendMerkleBlock) {\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::MERKLEBLOCK, merkleBlock));\n+                // CMerkleBlock just contains hashes, so also push any transactions in the block the client did not see\n+                // This avoids hurting performance by pointlessly requiring a round-trip\n+                // Note that there is currently no way for a node to request any single transactions we didn't send here -\n+                // they must either disconnect and retry or request the full block.\n+                // Thus, the protocol spec specified allows for us to provide duplicate txn here,\n+                // however we MUST always provide at least what the remote peer needs\n+                typedef std::pair<unsigned int, uint256> PairType;\n+                for (PairType& pair : merkleBlock.vMatchedTxn)\n+                    connman->PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n+            }\n+            // else\n+                // no response\n+        }\n+        else if (inv.type == MSG_CMPCT_BLOCK)\n+        {\n+            // If a peer is asking for old blocks, we're almost guaranteed\n+            // they won't have a useful mempool to match against a compact block,\n+            // and we don't feel like constructing the object for them, so\n+            // instead we respond with the full, non-compact block.\n+            bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;\n+            int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n+            if (CanDirectFetch(consensusParams) && mi->second->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {\n+                if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == mi->second->GetBlockHash()) {\n+                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n+                } else {\n+                    CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n+                    connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                }\n+            } else {\n+                connman->PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n+            }\n+        }\n+\n+        // Trigger the peer node to send a getblocks request for the next batch of inventory\n+        if (inv.hash == pfrom->hashContinue)\n+        {\n+            // Bypass PushInventory, this must send even if redundant,\n+            // and we want it right after the last block so they don't\n+            // wait for other stuff first.\n+            std::vector<CInv> vInv;\n+            vInv.push_back(CInv(MSG_BLOCK, chainActive.Tip()->GetBlockHash()));\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::INV, vInv));\n+            pfrom->hashContinue.SetNull();\n+        }\n+    }\n+\n+    return false;\n+}\n+\n void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParams, CConnman* connman, const std::atomic<bool>& interruptMsgProc)\n {\n+    AssertLockNotHeld(cs_main);\n+\n     std::deque<CInv>::iterator it = pfrom->vRecvGetData.begin();\n     std::vector<CInv> vNotFound;\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n-    LOCK(cs_main);\n-\n-    while (it != pfrom->vRecvGetData.end()) {\n-        // Don't bother if send buffer is too full to respond anyway\n-        if (pfrom->fPauseSend)\n-            break;\n+    {\n+        LOCK(cs_main);\n \n-        const CInv &inv = *it;\n-        {\n+        while (it != pfrom->vRecvGetData.end() && (it->type == MSG_TX || it->type == MSG_WITNESS_TX)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11824#discussion_r154843830",
      "id" : 154843830,
      "in_reply_to_id" : 154841745,
      "original_commit_id" : "3113573c847c76943c065b72d3e7a9edc643fed1",
      "original_position" : 244,
      "path" : "src/net_processing.cpp",
      "position" : 244,
      "pull_request_review_id" : 81066823,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/11824",
      "updated_at" : "2017-12-05T04:19:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/154843830",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "tACK https://github.com/bitcoin/bitcoin/pull/11824/commits/3113573c847c76943c065b72d3e7a9edc643fed1\r\n\r\nI've been running `-reindex` for over twelve hours and haven't seen an OOM:\r\n```\r\njob@ali:~$ sudo egrep \"Kill.*bitcoind\" /var/log/syslog || echo \"cool\"\r\ncool\r\n```",
      "created_at" : "2017-12-05T17:54:33Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11824#issuecomment-349386105",
      "id" : 349386105,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11824",
      "updated_at" : "2017-12-05T17:54:33Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/349386105",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Just hit another OOM, but also realized I was on an outdated version of this branch (HEAD was `151b17da1 Block ActivateBestChain to empty validationinterface queue`). @TheBlueMatt do you recall what changed between `151b17da1` and current HEAD and if it would explain the difference between another OOM or not?\r\n\r\nIn any case, I'm pulling down the tip of this branch and starting another -reindex.",
      "created_at" : "2017-12-05T22:25:16Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11824#issuecomment-349462251",
      "id" : 349462251,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11824",
      "updated_at" : "2017-12-05T22:25:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/349462251",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@jamesob No, the only differences there were in test_bitcoin.cpp, so that should have had no affect.",
      "created_at" : "2017-12-05T22:27:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11824#issuecomment-349462871",
      "id" : 349462871,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11824",
      "updated_at" : "2017-12-05T22:27:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/349462871",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I haven't seen any OOMs and my node is almost fully reindexed. Granted it did go down sometime last night as it ran out of disk space. It's been running for ~6 hours now and was running for ~14 hours before then.",
      "created_at" : "2017-12-05T22:38:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11824#issuecomment-349465237",
      "id" : 349465237,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11824",
      "updated_at" : "2017-12-05T22:38:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/349465237",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Well this definitely fixes *a* bug...just did a reindex to 150k with 0.15, 0.15.1 master and this branch, peak memory usage on this branch and 0.15 and 0.15.1 were all about the same, master was 3x higher...I'll look more into our memory footprint and see what else is hiding.",
      "created_at" : "2017-12-05T23:25:56Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/11824#issuecomment-349475729",
      "id" : 349475729,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/11824",
      "updated_at" : "2017-12-05T23:25:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/349475729",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/649246?v=4",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   }
]
