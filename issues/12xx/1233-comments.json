[
   {
      "body" : "For the record, cblockstore's download times from local nodes comes in reliably under master, but only by a very tiny margin.  This, on the other hand, comes in around 20% lower on tmpfs chain sync.",
      "created_at" : "2012-05-10T01:36:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#issuecomment-5616222",
      "id" : 5616222,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/1233",
      "updated_at" : "2012-05-10T01:36:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/5616222",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r812384"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/812384"
         }
      },
      "body" : "oh.. not IsInitialBlockDownload() again...",
      "commit_id" : "1e2aff6a68b40a31d4833b256245bbbad0ad38c2",
      "created_at" : "2012-05-12T14:18:56Z",
      "diff_hunk" : "@@ -2124,26 +2137,29 @@ Value getmemorypool(const Array& params, bool fHelp)\n             \"  \\\"bits\\\" : compressed target of next block\\n\"\n             \"If [data] is specified, tries to solve the block and returns true if it was successful.\");\n \n+    if (!pblockstore->HasFullBlocks())\n+        throw JSONRPCError(-18, \"Bitcoin does not have full blocks for transaction verification...\");\n+\n     if (params.size() == 0)\n     {\n         if (vNodes.empty())\n             throw JSONRPCError(-9, \"Bitcoin is not connected!\");\n \n-        if (IsInitialBlockDownload())\n+        if (pblockstore->IsInitialBlockDownload())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r812384",
      "id" : 812384,
      "original_commit_id" : "c37ab81ce1480a0881be408e5bc94e0f68af55cb",
      "original_position" : 223,
      "path" : "src/bitcoinrpc.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233",
      "updated_at" : "2012-06-28T17:47:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/812384",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r812390"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/812390"
         }
      },
      "body" : "Could comment out this line too, since the height is mentioned in debug.log just few lines before this line.",
      "commit_id" : "1e2aff6a68b40a31d4833b256245bbbad0ad38c2",
      "created_at" : "2012-05-12T14:22:28Z",
      "diff_hunk" : "@@ -463,8 +506,8 @@ bool AppInit2(int argc, char* argv[])\n     printf(\"Done loading\\n\");\n \n     //// debug print\n-    printf(\"mapBlockIndex.size() = %d\\n\",   mapBlockIndex.size());\n-    printf(\"nBestHeight = %d\\n\",            nBestHeight);\n+    //printf(\"mapBlockIndex.size() = %d\\n\",   mapBlockIndex.size());\n+    printf(\"BestBlockHeight = %d\\n\",        pblockstore->GetBestBlockIndex()->nHeight);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r812390",
      "id" : 812390,
      "original_commit_id" : "c37ab81ce1480a0881be408e5bc94e0f68af55cb",
      "original_position" : 137,
      "path" : "src/init.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233",
      "updated_at" : "2012-06-28T17:47:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/812390",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r812392"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/812392"
         }
      },
      "body" : "has all this code really changed, or is this diff a bit of a mess?",
      "commit_id" : "1e2aff6a68b40a31d4833b256245bbbad0ad38c2",
      "created_at" : "2012-05-12T14:24:32Z",
      "diff_hunk" : "@@ -2229,960 +2168,112 @@ bool CAlert::ProcessAlert()\n //\n \n \n-bool static AlreadyHave(CTxDB& txdb, const CInv& inv)\n+bool CBlockStore::NeedInv(const CInv* pinv)\n {\n-    switch (inv.type)\n     {\n-    case MSG_TX:\n+        LOCK(cs_main);\n+        switch (pinv->type)\n         {\n-        bool txInMap = false;\n+        case MSG_TX:\n             {\n-            LOCK(mempool.cs);\n-            txInMap = (mempool.exists(inv.hash));\n+            if (pblockstore->IsInitialBlockDownload())\n+                return false;\n+\n+            bool txNotInMap = false;\n+                {\n+                LOCK(mempool.cs);\n+                txNotInMap = !(mempool.exists(pinv->hash));\n+                }\n+\n+            if (pblockstore->HasFullBlocks())\n+            {\n+                CTxDB txdb(\"r\");\n+                return txNotInMap &&\n+                       !mapOrphanTransactions.count(pinv->hash) &&\n+                       !txdb.ContainsTx(pinv->hash);\n+            }\n+            else\n+                return txNotInMap &&\n+                       !mapOrphanTransactions.count(pinv->hash);\n             }\n-        return txInMap ||\n-               mapOrphanTransactions.count(inv.hash) ||\n-               txdb.ContainsTx(inv.hash);\n+        case MSG_BLOCK:\n+            if (mapOrphanBlocks.count(pinv->hash))\n+                AskForBlocks(GetOrphanRoot(mapOrphanBlocks[pinv->hash]), pinv->hash);\n+            return !mapBlockIndex.count(pinv->hash) &&\n+                   !mapOrphanBlocks.count(pinv->hash);\n         }\n-\n-    case MSG_BLOCK:\n-        return mapBlockIndex.count(inv.hash) ||\n-               mapOrphanBlocks.count(inv.hash);\n     }\n-    // Don't know what it is, just say we already got one\n-    return true;\n+    // Don't know what it is, guess we don't need one\n+    return false;\n }\n \n \n \n \n-// The message start string is designed to be unlikely to occur in normal data.\n-// The characters are rarely used upper ascii, not valid as UTF-8, and produce\n-// a large 4-byte int at any alignment.\n-unsigned char pchMessageStart[4] = { 0xf9, 0xbe, 0xb4, 0xd9 };\n \n \n-bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n-{\n-    static map<CService, vector<unsigned char> > mapReuseKey;\n-    RandAddSeedPerfmon();\n-    if (fDebug) {\n-        printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n-        printf(\"received: %s (%d bytes)\\n\", strCommand.c_str(), vRecv.size());\n-    }\n-    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n-    {\n-        printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n-        return true;\n-    }\n \n \n \n+//////////////////////////////////////////////////////////////////////////////\n+//\n+// BitcoinMiner\n+//\n \n+int static FormatHashBlocks(void* pbuffer, unsigned int len)\n+{\n+    unsigned char* pdata = (unsigned char*)pbuffer;\n+    unsigned int blocks = 1 + ((len + 8) / 64);\n+    unsigned char* pend = pdata + 64 * blocks;\n+    memset(pdata + len, 0, 64 * blocks - len);\n+    pdata[len] = 0x80;\n+    unsigned int bits = len * 8;\n+    pend[-1] = (bits >> 0) & 0xff;\n+    pend[-2] = (bits >> 8) & 0xff;\n+    pend[-3] = (bits >> 16) & 0xff;\n+    pend[-4] = (bits >> 24) & 0xff;\n+    return blocks;\n+}\n \n-    if (strCommand == \"version\")\n-    {\n-        // Each connection can only send one version message\n-        if (pfrom->nVersion != 0)\n-        {\n-            pfrom->Misbehaving(1);\n-            return false;\n-        }\n+static const unsigned int pSHA256InitState[8] =\n+{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n \n-        int64 nTime;\n-        CAddress addrMe;\n-        CAddress addrFrom;\n-        uint64 nNonce = 1;\n-        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n-        if (pfrom->nVersion < MIN_PROTO_VERSION)\n-        {\n-            // Since February 20, 2012, the protocol is initiated at version 209,\n-            // and earlier versions are no longer supported\n-            printf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n-            pfrom->fDisconnect = true;\n-            return false;\n-        }\n+void SHA256Transform(void* pstate, void* pinput, const void* pinit)\n+{\n+    SHA256_CTX ctx;\n+    unsigned char data[64];\n \n-        if (pfrom->nVersion == 10300)\n-            pfrom->nVersion = 300;\n-        if (!vRecv.empty())\n-            vRecv >> addrFrom >> nNonce;\n-        if (!vRecv.empty())\n-            vRecv >> pfrom->strSubVer;\n-        if (!vRecv.empty())\n-            vRecv >> pfrom->nStartingHeight;\n+    SHA256_Init(&ctx);\n \n-        if (pfrom->fInbound && addrMe.IsRoutable())\n-        {\n-            pfrom->addrLocal = addrMe;\n-            SeenLocal(addrMe);\n-        }\n+    for (int i = 0; i < 16; i++)\n+        ((uint32_t*)data)[i] = ByteReverse(((uint32_t*)pinput)[i]);\n \n-        // Disconnect if we connected to ourself\n-        if (nNonce == nLocalHostNonce && nNonce > 1)\n-        {\n-            printf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString().c_str());\n-            pfrom->fDisconnect = true;\n-            return true;\n-        }\n+    for (int i = 0; i < 8; i++)\n+        ctx.h[i] = ((uint32_t*)pinit)[i];\n \n-        // Be shy and don't send version until we hear\n-        if (pfrom->fInbound)\n-            pfrom->PushVersion();\n+    SHA256_Update(&ctx, data, sizeof(data));\n+    for (int i = 0; i < 8; i++) \n+        ((uint32_t*)pstate)[i] = ctx.h[i];\n+}\n \n-        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n-\n-        AddTimeData(pfrom->addr, nTime);\n-\n-        // Change version\n-        pfrom->PushMessage(\"verack\");\n-        pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n-\n-        if (!pfrom->fInbound)\n-        {\n-            // Advertise our address\n-            if (!fNoListen && !fUseProxy && !IsInitialBlockDownload())\n-            {\n-                CAddress addr = GetLocalAddress(&pfrom->addr);\n-                if (addr.IsRoutable())\n-                    pfrom->PushAddress(addr);\n-            }\n-\n-            // Get recent addresses\n-            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || addrman.size() < 1000)\n-            {\n-                pfrom->PushMessage(\"getaddr\");\n-                pfrom->fGetAddr = true;\n-            }\n-            addrman.Good(pfrom->addr);\n-        } else {\n-            if (((CNetAddr)pfrom->addr) == (CNetAddr)addrFrom)\n-            {\n-                addrman.Add(addrFrom, addrFrom);\n-                addrman.Good(addrFrom);\n-            }\n-        }\n-\n-        // Ask the first connected node for block updates\n-        static int nAskedForBlocks = 0;\n-        if (!pfrom->fClient && !pfrom->fOneShot &&\n-            (pfrom->nVersion < NOBLKS_VERSION_START ||\n-             pfrom->nVersion >= NOBLKS_VERSION_END) &&\n-             (nAskedForBlocks < 1 || vNodes.size() <= 1))\n-        {\n-            nAskedForBlocks++;\n-            pfrom->PushGetBlocks(pindexBest, uint256(0));\n-        }\n-\n-        // Relay alerts\n-        {\n-            LOCK(cs_mapAlerts);\n-            BOOST_FOREACH(PAIRTYPE(const uint256, CAlert)& item, mapAlerts)\n-                item.second.RelayTo(pfrom);\n-        }\n-\n-        pfrom->fSuccessfullyConnected = true;\n-\n-        printf(\"version message: version %d, blocks=%d\\n\", pfrom->nVersion, pfrom->nStartingHeight);\n-\n-        cPeerBlockCounts.input(pfrom->nStartingHeight);\n-    }\n-\n-\n-    else if (pfrom->nVersion == 0)\n-    {\n-        // Must have a version message before anything else\n-        pfrom->Misbehaving(1);\n-        return false;\n-    }\n-\n-\n-    else if (strCommand == \"verack\")\n-    {\n-        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n-    }\n-\n-\n-    else if (strCommand == \"addr\")\n-    {\n-        vector<CAddress> vAddr;\n-        vRecv >> vAddr;\n-\n-        // Don't want addr from older versions unless seeding\n-        if (pfrom->nVersion < CADDR_TIME_VERSION && addrman.size() > 1000)\n-            return true;\n-        if (vAddr.size() > 1000)\n-        {\n-            pfrom->Misbehaving(20);\n-            return error(\"message addr size() = %d\", vAddr.size());\n-        }\n-\n-        // Store the new addresses\n-        int64 nNow = GetAdjustedTime();\n-        int64 nSince = nNow - 10 * 60;\n-        BOOST_FOREACH(CAddress& addr, vAddr)\n-        {\n-            if (fShutdown)\n-                return true;\n-            // ignore IPv6 for now, since it isn't implemented anyway\n-            if (!addr.IsIPv4())\n-                continue;\n-            if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n-                addr.nTime = nNow - 5 * 24 * 60 * 60;\n-            pfrom->AddAddressKnown(addr);\n-            if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n-            {\n-                // Relay to a limited number of other nodes\n-                {\n-                    LOCK(cs_vNodes);\n-                    // Use deterministic randomness to send to the same nodes for 24 hours\n-                    // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n-                    static uint256 hashSalt;\n-                    if (hashSalt == 0)\n-                        RAND_bytes((unsigned char*)&hashSalt, sizeof(hashSalt));\n-                    int64 hashAddr = addr.GetHash();\n-                    uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((GetTime()+hashAddr)/(24*60*60));\n-                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n-                    multimap<uint256, CNode*> mapMix;\n-                    BOOST_FOREACH(CNode* pnode, vNodes)\n-                    {\n-                        if (pnode->nVersion < CADDR_TIME_VERSION)\n-                            continue;\n-                        unsigned int nPointer;\n-                        memcpy(&nPointer, &pnode, sizeof(nPointer));\n-                        uint256 hashKey = hashRand ^ nPointer;\n-                        hashKey = Hash(BEGIN(hashKey), END(hashKey));\n-                        mapMix.insert(make_pair(hashKey, pnode));\n-                    }\n-                    int nRelayNodes = 2;\n-                    for (multimap<uint256, CNode*>::iterator mi = mapMix.begin(); mi != mapMix.end() && nRelayNodes-- > 0; ++mi)\n-                        ((*mi).second)->PushAddress(addr);\n-                }\n-            }\n-        }\n-        addrman.Add(vAddr, pfrom->addr, 2 * 60 * 60);\n-        if (vAddr.size() < 1000)\n-            pfrom->fGetAddr = false;\n-        if (pfrom->fOneShot)\n-            pfrom->fDisconnect = true;\n-    }\n-\n-\n-    else if (strCommand == \"inv\")\n-    {\n-        vector<CInv> vInv;\n-        vRecv >> vInv;\n-        if (vInv.size() > 50000)\n-        {\n-            pfrom->Misbehaving(20);\n-            return error(\"message inv size() = %d\", vInv.size());\n-        }\n-\n-        // find last block in inv vector\n-        unsigned int nLastBlock = (unsigned int)(-1);\n-        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {\n-            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK)\n-                nLastBlock = vInv.size() - 1 - nInv;\n-        }\n-        CTxDB txdb(\"r\");\n-        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n-        {\n-            const CInv &inv = vInv[nInv];\n-\n-            if (fShutdown)\n-                return true;\n-            pfrom->AddInventoryKnown(inv);\n-\n-            bool fAlreadyHave = AlreadyHave(txdb, inv);\n-            if (fDebug)\n-                printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fAlreadyHave ? \"have\" : \"new\");\n-\n-            // Always request the last block in an inv bundle (even if we already have it), as it is the\n-            // trigger for the other side to send further invs. If we are stuck on a (very long) side chain,\n-            // this is necessary to connect earlier received orphan blocks to the chain again.\n-            if (fAlreadyHave && nInv == nLastBlock) {\n-                // bypass mapAskFor, and send request directly; it must go through.\n-                std::vector<CInv> vGetData(1,inv);\n-                pfrom->PushMessage(\"getdata\", vGetData);\n-            }\n-\n-            if (!fAlreadyHave)\n-                pfrom->AskFor(inv);\n-            else if (inv.type == MSG_BLOCK && mapOrphanBlocks.count(inv.hash))\n-                pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(mapOrphanBlocks[inv.hash]));\n-\n-            // Track requests for our stuff\n-            Inventory(inv.hash);\n-        }\n-    }\n-\n-",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r812392",
      "id" : 812392,
      "original_commit_id" : "c37ab81ce1480a0881be408e5bc94e0f68af55cb",
      "original_position" : 1334,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233",
      "updated_at" : "2012-06-28T17:47:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/812392",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r812394"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/812394"
         }
      },
      "body" : "goodness... it's all moved from main.cpp...  this'll break quite a few other pulls I suspect...",
      "commit_id" : "1e2aff6a68b40a31d4833b256245bbbad0ad38c2",
      "created_at" : "2012-05-12T14:26:26Z",
      "diff_hunk" : "@@ -148,3 +161,808 @@ void CInv::print() const\n     printf(\"CInv(%s)\\n\", ToString().c_str());\n }\n \n+// Return maximum amount of blocks that other nodes claim to have\n+int GetNumBlocksOfPeers()\n+{\n+    return std::max(cPeerBlockCounts.median(), Checkpoints::GetTotalBlocksEstimate());\n+}\n+\n+\n+\n+// The message start string is designed to be unlikely to occur in normal data.\n+// The characters are rarely used upper ascii, not valid as UTF-8, and produce\n+// a large 4-byte int at any alignment.\n+unsigned char pchMessageStart[4] = { 0xf9, 0xbe, 0xb4, 0xd9 };\n+\n+\n+bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n+{\n+    static map<CService, vector<unsigned char> > mapReuseKey;\n+    RandAddSeedPerfmon();\n+    if (fDebug) {\n+        printf(\"%s \", DateTimeStrFormat(\"%x %H:%M:%S\", GetTime()).c_str());\n+        printf(\"received: %s (%d bytes)\\n\", strCommand.c_str(), vRecv.size());\n+    }\n+    if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n+    {\n+        printf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n+        return true;\n+    }\n+\n+\n+\n+\n+\n+    if (strCommand == \"version\")\n+    {\n+        // Each connection can only send one version message\n+        if (pfrom->nVersion != 0)\n+        {\n+            pfrom->Misbehaving(1);\n+            return false;\n+        }\n+\n+        int64 nTime;\n+        CAddress addrMe;\n+        CAddress addrFrom;\n+        uint64 nNonce = 1;\n+        vRecv >> pfrom->nVersion >> pfrom->nServices >> nTime >> addrMe;\n+        if (pfrom->nVersion < MIN_PROTO_VERSION)\n+        {\n+            // Since February 20, 2012, the protocol is initiated at version 209,\n+            // and earlier versions are no longer supported\n+            printf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString().c_str(), pfrom->nVersion);\n+            pfrom->fDisconnect = true;\n+            return false;\n+        }\n+\n+        if (pfrom->nVersion == 10300)\n+            pfrom->nVersion = 300;\n+        if (!vRecv.empty())\n+            vRecv >> addrFrom >> nNonce;\n+        if (!vRecv.empty())\n+            vRecv >> pfrom->strSubVer;\n+        if (!vRecv.empty())\n+            vRecv >> pfrom->nStartingHeight;\n+\n+        if (pfrom->fInbound && addrMe.IsRoutable())\n+        {\n+            pfrom->addrLocal = addrMe;\n+            SeenLocal(addrMe);\n+        }\n+\n+        // Disconnect if we connected to ourself\n+        if (nNonce == nLocalHostNonce && nNonce > 1)\n+        {\n+            printf(\"connected to self at %s, disconnecting\\n\", pfrom->addr.ToString().c_str());\n+            pfrom->fDisconnect = true;\n+            return true;\n+        }\n+\n+        // Be shy and don't send version until we hear\n+        if (pfrom->fInbound)\n+            pfrom->PushVersion();\n+\n+        pfrom->fClient = !(pfrom->nServices & NODE_NETWORK);\n+\n+        AddTimeData(pfrom->addr, nTime);\n+\n+        // Change version\n+        pfrom->PushMessage(\"verack\");\n+        pfrom->vSend.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n+\n+        if (!pfrom->fInbound)\n+        {\n+            // Advertise our address\n+            if (!fNoListen && !fUseProxy && !pblockstore->IsInitialBlockDownload())\n+            {\n+                CAddress addr = GetLocalAddress(&pfrom->addr);\n+                if (addr.IsRoutable())\n+                    pfrom->PushAddress(addr);\n+            }\n+\n+            // Get recent addresses\n+            if (pfrom->fOneShot || pfrom->nVersion >= CADDR_TIME_VERSION || addrman.size() < 1000)\n+            {\n+                pfrom->PushMessage(\"getaddr\");\n+                pfrom->fGetAddr = true;\n+            }\n+            addrman.Good(pfrom->addr);\n+        } else {\n+            if (((CNetAddr)pfrom->addr) == (CNetAddr)addrFrom)\n+            {\n+                addrman.Add(addrFrom, addrFrom);\n+                addrman.Good(addrFrom);\n+            }\n+        }\n+\n+        // Ask the first connected node for block updates\n+        static int nAskedForBlocks = 0;\n+        if (!pfrom->fClient && !pfrom->fOneShot &&\n+            (pfrom->nVersion < NOBLKS_VERSION_START ||\n+             pfrom->nVersion >= NOBLKS_VERSION_END) &&\n+            (nAskedForBlocks < 1 || vNodes.size() <= 1))\n+        {\n+            nAskedForBlocks++;\n+            pfrom->PushGetBlocks(pblockstore->GetBestBlockIndex(), uint256(0));\n+        }\n+\n+        // Relay alerts\n+        pblockstore->RelayAlerts(pfrom);\n+\n+        pfrom->fSuccessfullyConnected = true;\n+\n+        printf(\"version message: version %d, blocks=%d\\n\", pfrom->nVersion, pfrom->nStartingHeight);\n+\n+        cPeerBlockCounts.input(pfrom->nStartingHeight);\n+    }\n+\n+\n+    else if (pfrom->nVersion == 0)\n+    {\n+        // Must have a version message before anything else\n+        pfrom->Misbehaving(1);\n+        return false;\n+    }\n+\n+\n+    else if (strCommand == \"verack\")\n+    {\n+        pfrom->vRecv.SetVersion(min(pfrom->nVersion, PROTOCOL_VERSION));\n+    }\n+\n+\n+    else if (strCommand == \"addr\")\n+    {\n+        vector<CAddress> vAddr;\n+        vRecv >> vAddr;\n+\n+        // Don't want addr from older versions unless seeding\n+        if (pfrom->nVersion < CADDR_TIME_VERSION && addrman.size() > 1000)\n+            return true;\n+        if (vAddr.size() > 1000)\n+        {\n+            pfrom->Misbehaving(20);\n+            return error(\"message addr size() = %d\", vAddr.size());\n+        }\n+\n+        // Store the new addresses\n+        int64 nNow = GetAdjustedTime();\n+        int64 nSince = nNow - 10 * 60;\n+        BOOST_FOREACH(CAddress& addr, vAddr)\n+        {\n+            if (fShutdown)\n+                return true;\n+            // ignore IPv6 for now, since it isn't implemented anyway\n+            if (!addr.IsIPv4())\n+                continue;\n+            if (addr.nTime <= 100000000 || addr.nTime > nNow + 10 * 60)\n+                addr.nTime = nNow - 5 * 24 * 60 * 60;\n+            pfrom->AddAddressKnown(addr);\n+            if (addr.nTime > nSince && !pfrom->fGetAddr && vAddr.size() <= 10 && addr.IsRoutable())\n+            {\n+                // Relay to a limited number of other nodes\n+                {\n+                    LOCK(cs_vNodes);\n+                    // Use deterministic randomness to send to the same nodes for 24 hours\n+                    // at a time so the setAddrKnowns of the chosen nodes prevent repeats\n+                    static uint256 hashSalt;\n+                    if (hashSalt == 0)\n+                        RAND_bytes((unsigned char*)&hashSalt, sizeof(hashSalt));\n+                    int64 hashAddr = addr.GetHash();\n+                    uint256 hashRand = hashSalt ^ (hashAddr<<32) ^ ((GetTime()+hashAddr)/(24*60*60));\n+                    hashRand = Hash(BEGIN(hashRand), END(hashRand));\n+                    multimap<uint256, CNode*> mapMix;\n+                    BOOST_FOREACH(CNode* pnode, vNodes)\n+                    {\n+                        if (pnode->nVersion < CADDR_TIME_VERSION)\n+                            continue;\n+                        unsigned int nPointer;\n+                        memcpy(&nPointer, &pnode, sizeof(nPointer));\n+                        uint256 hashKey = hashRand ^ nPointer;\n+                        hashKey = Hash(BEGIN(hashKey), END(hashKey));\n+                        mapMix.insert(make_pair(hashKey, pnode));\n+                    }\n+                    int nRelayNodes = 2;\n+                    for (multimap<uint256, CNode*>::iterator mi = mapMix.begin(); mi != mapMix.end() && nRelayNodes-- > 0; ++mi)\n+                        ((*mi).second)->PushAddress(addr);\n+                }\n+            }\n+        }\n+        addrman.Add(vAddr, pfrom->addr, 2 * 60 * 60);\n+        if (vAddr.size() < 1000)\n+            pfrom->fGetAddr = false;\n+        if (pfrom->fOneShot)\n+            pfrom->fDisconnect = true;\n+    }\n+\n+\n+    else if (strCommand == \"inv\")\n+    {\n+        vector<CInv> vInv;\n+        vRecv >> vInv;\n+        if (vInv.size() > 50000)\n+        {\n+            pfrom->Misbehaving(20);\n+            return error(\"message inv size() = %d\", vInv.size());\n+        }\n+\n+        // find last block in inv vector\n+        unsigned int nLastBlock = (unsigned int)(-1);\n+        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++) {\n+            if (vInv[vInv.size() - 1 - nInv].type == MSG_BLOCK)\n+                nLastBlock = vInv.size() - 1 - nInv;\n+        }\n+        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n+        {\n+            const CInv &inv = vInv[nInv];\n+\n+            if (fShutdown)\n+                return true;\n+            pfrom->AddInventoryKnown(inv);\n+\n+            bool fNeedInv = pblockstore->NeedInv(&inv);\n+            if (fDebug)\n+                printf(\"  got inventory: %s  %s\\n\", inv.ToString().c_str(), fNeedInv ? \"need\" : \"don't need\");\n+\n+            // Always request the last block in an inv bundle (even if we already have it), as it is the\n+            // trigger for the other side to send further invs. If we are stuck on a (very long) side chain,\n+            // this is necessary to connect earlier received orphan blocks to the chain again.\n+            if (!fNeedInv && nInv == nLastBlock) {\n+                // bypass mapAskFor, and send request directly; it must go through.\n+                std::vector<CInv> vGetData(1,inv);\n+                pfrom->PushMessage(\"getdata\", vGetData);\n+            }\n+\n+            if (fNeedInv)\n+                pfrom->AskFor(inv);\n+\n+            // Track requests for our stuff\n+            pblockstore->Relayed(inv.hash);\n+        }\n+    }\n+\n+",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r812394",
      "id" : 812394,
      "original_commit_id" : "c37ab81ce1480a0881be408e5bc94e0f68af55cb",
      "original_position" : 338,
      "path" : "src/protocol.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233",
      "updated_at" : "2012-06-28T17:47:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/812394",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "body" : "can this pull request be done in such a way that there isn't so much of a diff output? Did so much code need to move from main.cpp to protocol.cpp, for example?",
      "created_at" : "2012-05-12T14:28:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#issuecomment-5668865",
      "id" : 5668865,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/1233",
      "updated_at" : "2012-05-12T14:28:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/5668865",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "body" : "Note that this pull is based on #771, which has radically different design goals.  This pull is fairly small on its own.\nRe: the move from main -> protocol.  One of the primary design goals of #771 is to remove the number of globals we export from main, especially the block index/chain storage stuff.  As a part of this, the net code in main.cpp really no longer belongs there, and was moved to protocol.cpp.",
      "created_at" : "2012-05-12T16:51:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#issuecomment-5669958",
      "id" : 5669958,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/1233",
      "updated_at" : "2012-05-12T16:51:17Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/5669958",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "I think those are very sensible design goals.\n\nThat said, in that case we should definitely pull #771 first, to prevent unrelated changes being merged into one pull request. Github seems to almost lock up when I try to view the diff.\n",
      "created_at" : "2012-05-13T07:58:14Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#issuecomment-5674672",
      "id" : 5674672,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/1233",
      "updated_at" : "2012-05-13T07:58:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/5674672",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/126646?v=3",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "body" : "Ah, ok. Well, I'd certainly find the diffs easier to view if they were kept small. Probably would be better therefore to base this commit from a post-#771 commit then, in order not to effectively include that commit in its entirety within this commit, then it can be reviewed without having to manually save the files and manually diff them.",
      "created_at" : "2012-05-14T18:09:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#issuecomment-5697411",
      "id" : 5697411,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/1233",
      "updated_at" : "2012-05-14T18:10:14Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/5697411",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "body" : "Github always shows total diffs from master, so the only reasonable way to do it is to just base on #711, pulling in its huge diff...however, you can always compare the commit list to #711 and view the diffs of individual commits.",
      "created_at" : "2012-05-14T18:19:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#issuecomment-5697644",
      "id" : 5697644,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/1233",
      "updated_at" : "2012-05-14T18:19:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/5697644",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "@TheBlueMatt, do you mean within github? I'm not sure how to do that. Could you provide a URL, perhaps?",
      "created_at" : "2012-05-14T18:21:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#issuecomment-5697689",
      "id" : 5697689,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/1233",
      "updated_at" : "2012-05-14T18:21:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/5697689",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "body" : "You have to manually compare the list of commits, and then you can just open each commit from the commits list in the pull...if you feel like doing some URL hacking, you will notice git style ...s in diff URLs which you can replace manually using any branch like:\nhttps://github.com/TheBlueMatt/bitcoin/compare/cblockstore...parallelcheck",
      "created_at" : "2012-05-14T18:26:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#issuecomment-5697960",
      "id" : 5697960,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/1233",
      "updated_at" : "2012-05-14T18:26:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/5697960",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "Rebased onto #1429",
      "created_at" : "2012-06-06T23:57:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#issuecomment-6165915",
      "id" : 6165915,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/1233",
      "updated_at" : "2012-06-06T23:57:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/6165915",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r989834"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989834"
         }
      },
      "body" : "Why make this line longer than it already was?",
      "commit_id" : "1e2aff6a68b40a31d4833b256245bbbad0ad38c2",
      "created_at" : "2012-06-14T23:28:41Z",
      "diff_hunk" : "@@ -1724,135 +1711,152 @@ bool CBlock::CheckBlock() const\n     return true;\n }\n \n-bool CBlock::AcceptBlock()\n+bool CBlockStore::AcceptBlock(CBlock& block)\n {\n     // Check for duplicate\n-    uint256 hash = GetHash();\n+    uint256 hash = block.GetHash();\n     if (mapBlockIndex.count(hash))\n         return error(\"AcceptBlock() : block already in mapBlockIndex\");\n \n     // Get prev block index\n-    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n+    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n     if (mi == mapBlockIndex.end())\n-        return DoS(10, error(\"AcceptBlock() : prev block not found\"));\n+        return block.DoS(10, error(\"AcceptBlock() : prev block not found\"));\n     CBlockIndex* pindexPrev = (*mi).second;\n     int nHeight = pindexPrev->nHeight+1;\n \n     // Check proof of work\n-    if (nBits != GetNextWorkRequired(pindexPrev, this))\n-        return DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n+    if (block.nBits != GetNextWorkRequired(pindexPrev, &block))\n+        return block.DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n \n     // Check timestamp against prev\n-    if (GetBlockTime() <= pindexPrev->GetMedianTimePast())\n+    if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n         return error(\"AcceptBlock() : block's timestamp is too early\");\n \n     // Check that all transactions are finalized\n-    BOOST_FOREACH(const CTransaction& tx, vtx)\n-        if (!tx.IsFinal(nHeight, GetBlockTime()))\n-            return DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n+    BOOST_FOREACH(const CTransaction& tx, block.vtx)\n+        if (!tx.IsFinal(nHeight, block.GetBlockTime()))\n+            return block.DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n \n     // Check that the block chain matches the known block chain up to a checkpoint\n     if (!Checkpoints::CheckBlock(nHeight, hash))\n-        return DoS(100, error(\"AcceptBlock() : rejected by checkpoint lockin at %d\", nHeight));\n+        return block.DoS(100, error(\"AcceptBlock() : rejected by checkpoint lockin at %d\", nHeight));\n \n     // Write block to history file\n-    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n+    if (!CheckDiskSpace(GetSerializeSize(block, SER_DISK, CLIENT_VERSION)))\n         return error(\"AcceptBlock() : out of disk space\");\n     unsigned int nFile = -1;\n     unsigned int nBlockPos = 0;\n-    if (!WriteToDisk(nFile, nBlockPos))\n+    if (!block.WriteToDisk(nFile, nBlockPos))\n         return error(\"AcceptBlock() : WriteToDisk failed\");\n-    if (!AddToBlockIndex(nFile, nBlockPos))\n+    if (!AddToBlockIndex(block, nFile, nBlockPos))\n         return error(\"AcceptBlock() : AddToBlockIndex failed\");\n \n-    // Relay inventory, but don't relay old inventory during initial block download\n-    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n-    if (hashBestChain == hash)\n-    {\n-        LOCK(cs_vNodes);\n-        BOOST_FOREACH(CNode* pnode, vNodes)\n-            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n-                pnode->PushInventory(CInv(MSG_BLOCK, hash));\n-    }\n-\n     return true;\n }\n \n-bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n+bool CBlockStore::EmitBlock(CBlock& block, bool fBlocking, CNode* pNodeDoS)\n {\n     // Check for duplicate\n-    uint256 hash = pblock->GetHash();\n-    if (mapBlockIndex.count(hash))\n-        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n-    if (mapOrphanBlocks.count(hash))\n-        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n+    uint256 hash = block.GetHash();\n+    {\n+        LOCK(cs_setBlocksSeen);\n+        if (setBlocksSeen.count(hash) > 0)\n+            return error(\"CHub::EmitBlock() : already seen block %s\", hash.ToString().substr(0,20).c_str());\n+    }\n \n     // Preliminary checks\n-    if (!pblock->CheckBlock())\n-        return error(\"ProcessBlock() : CheckBlock FAILED\");\n+    if (!block.CheckBlock())\n+    {\n+        if (block.nDoS && pNodeDoS)\n+            CallbackDoS(pNodeDoS, block.nDoS);\n+        return error(\"CBlockStore::EmitBlock() : CheckBlock FAILED\");\n+    }\n \n-    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n-    if (pcheckpoint && pblock->hashPrevBlock != hashBestChain)\n+    const CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint();\n+    if (pcheckpoint && block.hashPrevBlock != hashBestChain)\n     {\n         // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n-        int64 deltaTime = pblock->GetBlockTime() - pcheckpoint->nTime;\n+        int64 deltaTime = block.GetBlockTime() - pcheckpoint->nTime;\n         if (deltaTime < 0)\n         {\n-            if (pfrom)\n-                pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with timestamp before last checkpoint\");\n+            if (pNodeDoS) CallbackDoS(pNodeDoS, 100);\n+            return block.DoS(100, error(\"CBlockStore::EmitBlock() : block with timestamp before last checkpoint\"));\n         }\n         CBigNum bnNewBlock;\n-        bnNewBlock.SetCompact(pblock->nBits);\n+        bnNewBlock.SetCompact(block.nBits);\n         CBigNum bnRequired;\n         bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n         if (bnNewBlock > bnRequired)\n         {\n-            if (pfrom)\n-                pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with too little proof-of-work\");\n+            if (pNodeDoS) CallbackDoS(pNodeDoS, 100);\n+            return block.DoS(100, error(\"CBlockStore::EmitBlock() : block with too little proof-of-work\"));\n         }\n     }\n \n+    {\n+        LOCK(cs_setBlocksSeen);\n+        setBlocksSeen.insert(hash);\n+    }\n+\n+    if (fBlocking)\n+        return FinishEmitBlock(block, pNodeDoS);\n+    else\n+        SubmitCallbackFinishEmitBlock(block, pNodeDoS);\n+\n+    return true;\n+}\n+\n+bool CBlockStore::FinishEmitBlock(CBlock& block, CNode* pNodeDoS)\n+{\n+    uint256 hash = block.GetHash();\n+\n+    LOCK(cs_main);\n \n     // If don't already have its previous block, shunt it off to holding area until we get it\n-    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n+    if (!mapBlockIndex.count(block.hashPrevBlock))\n     {\n-        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n-        CBlock* pblock2 = new CBlock(*pblock);\n-        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n-        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n+        printf(\"CBlockStore::FinishEmitBlock: ORPHAN BLOCK, prev=%s\\n\", block.hashPrevBlock.ToString().substr(0,20).c_str());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r989834",
      "id" : 989834,
      "original_commit_id" : "669a5d4c9e49fb3027ec7110664faa42615698bc",
      "original_position" : 785,
      "path" : "src/main.cpp",
      "position" : 782,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233",
      "updated_at" : "2012-06-28T17:47:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989834",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r989842"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989842"
         }
      },
      "body" : "Not sure why this line is being changed....",
      "commit_id" : "1e2aff6a68b40a31d4833b256245bbbad0ad38c2",
      "created_at" : "2012-06-14T23:29:55Z",
      "diff_hunk" : "@@ -1724,135 +1711,152 @@ bool CBlock::CheckBlock() const\n     return true;\n }\n \n-bool CBlock::AcceptBlock()\n+bool CBlockStore::AcceptBlock(CBlock& block)\n {\n     // Check for duplicate\n-    uint256 hash = GetHash();\n+    uint256 hash = block.GetHash();\n     if (mapBlockIndex.count(hash))\n         return error(\"AcceptBlock() : block already in mapBlockIndex\");\n \n     // Get prev block index\n-    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n+    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n     if (mi == mapBlockIndex.end())\n-        return DoS(10, error(\"AcceptBlock() : prev block not found\"));\n+        return block.DoS(10, error(\"AcceptBlock() : prev block not found\"));\n     CBlockIndex* pindexPrev = (*mi).second;\n     int nHeight = pindexPrev->nHeight+1;\n \n     // Check proof of work\n-    if (nBits != GetNextWorkRequired(pindexPrev, this))\n-        return DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n+    if (block.nBits != GetNextWorkRequired(pindexPrev, &block))\n+        return block.DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n \n     // Check timestamp against prev\n-    if (GetBlockTime() <= pindexPrev->GetMedianTimePast())\n+    if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n         return error(\"AcceptBlock() : block's timestamp is too early\");\n \n     // Check that all transactions are finalized\n-    BOOST_FOREACH(const CTransaction& tx, vtx)\n-        if (!tx.IsFinal(nHeight, GetBlockTime()))\n-            return DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n+    BOOST_FOREACH(const CTransaction& tx, block.vtx)\n+        if (!tx.IsFinal(nHeight, block.GetBlockTime()))\n+            return block.DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n \n     // Check that the block chain matches the known block chain up to a checkpoint\n     if (!Checkpoints::CheckBlock(nHeight, hash))\n-        return DoS(100, error(\"AcceptBlock() : rejected by checkpoint lockin at %d\", nHeight));\n+        return block.DoS(100, error(\"AcceptBlock() : rejected by checkpoint lockin at %d\", nHeight));\n \n     // Write block to history file\n-    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n+    if (!CheckDiskSpace(GetSerializeSize(block, SER_DISK, CLIENT_VERSION)))\n         return error(\"AcceptBlock() : out of disk space\");\n     unsigned int nFile = -1;\n     unsigned int nBlockPos = 0;\n-    if (!WriteToDisk(nFile, nBlockPos))\n+    if (!block.WriteToDisk(nFile, nBlockPos))\n         return error(\"AcceptBlock() : WriteToDisk failed\");\n-    if (!AddToBlockIndex(nFile, nBlockPos))\n+    if (!AddToBlockIndex(block, nFile, nBlockPos))\n         return error(\"AcceptBlock() : AddToBlockIndex failed\");\n \n-    // Relay inventory, but don't relay old inventory during initial block download\n-    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n-    if (hashBestChain == hash)\n-    {\n-        LOCK(cs_vNodes);\n-        BOOST_FOREACH(CNode* pnode, vNodes)\n-            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n-                pnode->PushInventory(CInv(MSG_BLOCK, hash));\n-    }\n-\n     return true;\n }\n \n-bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n+bool CBlockStore::EmitBlock(CBlock& block, bool fBlocking, CNode* pNodeDoS)\n {\n     // Check for duplicate\n-    uint256 hash = pblock->GetHash();\n-    if (mapBlockIndex.count(hash))\n-        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n-    if (mapOrphanBlocks.count(hash))\n-        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n+    uint256 hash = block.GetHash();\n+    {\n+        LOCK(cs_setBlocksSeen);\n+        if (setBlocksSeen.count(hash) > 0)\n+            return error(\"CHub::EmitBlock() : already seen block %s\", hash.ToString().substr(0,20).c_str());\n+    }\n \n     // Preliminary checks\n-    if (!pblock->CheckBlock())\n-        return error(\"ProcessBlock() : CheckBlock FAILED\");\n+    if (!block.CheckBlock())\n+    {\n+        if (block.nDoS && pNodeDoS)\n+            CallbackDoS(pNodeDoS, block.nDoS);\n+        return error(\"CBlockStore::EmitBlock() : CheckBlock FAILED\");\n+    }\n \n-    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n-    if (pcheckpoint && pblock->hashPrevBlock != hashBestChain)\n+    const CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint();\n+    if (pcheckpoint && block.hashPrevBlock != hashBestChain)\n     {\n         // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n-        int64 deltaTime = pblock->GetBlockTime() - pcheckpoint->nTime;\n+        int64 deltaTime = block.GetBlockTime() - pcheckpoint->nTime;\n         if (deltaTime < 0)\n         {\n-            if (pfrom)\n-                pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with timestamp before last checkpoint\");\n+            if (pNodeDoS) CallbackDoS(pNodeDoS, 100);\n+            return block.DoS(100, error(\"CBlockStore::EmitBlock() : block with timestamp before last checkpoint\"));\n         }\n         CBigNum bnNewBlock;\n-        bnNewBlock.SetCompact(pblock->nBits);\n+        bnNewBlock.SetCompact(block.nBits);\n         CBigNum bnRequired;\n         bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n         if (bnNewBlock > bnRequired)\n         {\n-            if (pfrom)\n-                pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with too little proof-of-work\");\n+            if (pNodeDoS) CallbackDoS(pNodeDoS, 100);\n+            return block.DoS(100, error(\"CBlockStore::EmitBlock() : block with too little proof-of-work\"));\n         }\n     }\n \n+    {\n+        LOCK(cs_setBlocksSeen);\n+        setBlocksSeen.insert(hash);\n+    }\n+\n+    if (fBlocking)\n+        return FinishEmitBlock(block, pNodeDoS);\n+    else\n+        SubmitCallbackFinishEmitBlock(block, pNodeDoS);\n+\n+    return true;\n+}\n+\n+bool CBlockStore::FinishEmitBlock(CBlock& block, CNode* pNodeDoS)\n+{\n+    uint256 hash = block.GetHash();\n+\n+    LOCK(cs_main);\n \n     // If don't already have its previous block, shunt it off to holding area until we get it\n-    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n+    if (!mapBlockIndex.count(block.hashPrevBlock))\n     {\n-        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n-        CBlock* pblock2 = new CBlock(*pblock);\n-        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n-        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n+        printf(\"CBlockStore::FinishEmitBlock: ORPHAN BLOCK, prev=%s\\n\", block.hashPrevBlock.ToString().substr(0,20).c_str());\n+        CBlock* pblock = new CBlock(block);\n+        mapOrphanBlocks.insert(make_pair(hash, pblock));\n+        mapOrphanBlocksByPrev.insert(make_pair(pblock->hashPrevBlock, pblock));\n \n         // Ask this guy to fill in what we're missing\n-        if (pfrom)\n-            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n+        CallbackAskForBlocks(GetOrphanRoot(pblock), hash);\n         return true;\n     }\n \n     // Store to disk\n-    if (!pblock->AcceptBlock())\n-        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n+    if (!AcceptBlock(block))\n+    {\n+        if (block.nDoS && pNodeDoS)\n+            CallbackDoS(pNodeDoS, block.nDoS);\n+        return error(\"CBlockStore::FinishEmitBlock() : AcceptBlock FAILED\");\n+    }\n \n     // Recursively process any orphan blocks that depended on this one\n-    vector<uint256> vWorkQueue;\n-    vWorkQueue.push_back(hash);\n-    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n+    queue<uint256> qWorkQueue;\n+    qWorkQueue.push(hash);\n+    while (!qWorkQueue.empty())\n     {\n-        uint256 hashPrev = vWorkQueue[i];\n+        uint256 hashPrev = qWorkQueue.front();\n+        qWorkQueue.pop();\n         for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n              mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n              ++mi)\n         {\n             CBlock* pblockOrphan = (*mi).second;\n-            if (pblockOrphan->AcceptBlock())\n-                vWorkQueue.push_back(pblockOrphan->GetHash());\n-            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n+            uint256 hashOrphan = pblockOrphan->GetHash();\n+            if (AcceptBlock(*pblockOrphan))\n+                qWorkQueue.push(hashOrphan);\n+            mapOrphanBlocks.erase(hashOrphan);\n             delete pblockOrphan;\n         }\n         mapOrphanBlocksByPrev.erase(hashPrev);\n     }\n \n-    printf(\"ProcessBlock: ACCEPTED\\n\");\n+    printf(\"CBlockStore::FinishEmitBlock: ACCEPTED\\n\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r989842",
      "id" : 989842,
      "original_commit_id" : "669a5d4c9e49fb3027ec7110664faa42615698bc",
      "original_position" : 836,
      "path" : "src/main.cpp",
      "position" : 833,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233",
      "updated_at" : "2012-06-28T17:47:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989842",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r989853"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989853"
         }
      },
      "body" : "why 5?",
      "commit_id" : "1e2aff6a68b40a31d4833b256245bbbad0ad38c2",
      "created_at" : "2012-06-14T23:31:06Z",
      "diff_hunk" : "@@ -2551,6 +2696,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     printf(\"force request: %s\\n\", inv.ToString().c_str());\n             }\n \n+            if (inv.type == MSG_BLOCK)\n+                nBlockCount++;\n+\n+            // Don't set hashLastInvLastBlock if we are getting a hashContinue inv\n+            if (nInv == nLastBlock && nBlockCount > 5)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r989853",
      "id" : 989853,
      "original_commit_id" : "669a5d4c9e49fb3027ec7110664faa42615698bc",
      "original_position" : 1188,
      "path" : "src/main.cpp",
      "position" : 1297,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233",
      "updated_at" : "2012-06-28T17:47:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989853",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r989857"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989857"
         }
      },
      "body" : "Because the name of the function it is in, is being renamed.",
      "commit_id" : "1e2aff6a68b40a31d4833b256245bbbad0ad38c2",
      "created_at" : "2012-06-14T23:31:57Z",
      "diff_hunk" : "@@ -1724,135 +1711,152 @@ bool CBlock::CheckBlock() const\n     return true;\n }\n \n-bool CBlock::AcceptBlock()\n+bool CBlockStore::AcceptBlock(CBlock& block)\n {\n     // Check for duplicate\n-    uint256 hash = GetHash();\n+    uint256 hash = block.GetHash();\n     if (mapBlockIndex.count(hash))\n         return error(\"AcceptBlock() : block already in mapBlockIndex\");\n \n     // Get prev block index\n-    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n+    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n     if (mi == mapBlockIndex.end())\n-        return DoS(10, error(\"AcceptBlock() : prev block not found\"));\n+        return block.DoS(10, error(\"AcceptBlock() : prev block not found\"));\n     CBlockIndex* pindexPrev = (*mi).second;\n     int nHeight = pindexPrev->nHeight+1;\n \n     // Check proof of work\n-    if (nBits != GetNextWorkRequired(pindexPrev, this))\n-        return DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n+    if (block.nBits != GetNextWorkRequired(pindexPrev, &block))\n+        return block.DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n \n     // Check timestamp against prev\n-    if (GetBlockTime() <= pindexPrev->GetMedianTimePast())\n+    if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n         return error(\"AcceptBlock() : block's timestamp is too early\");\n \n     // Check that all transactions are finalized\n-    BOOST_FOREACH(const CTransaction& tx, vtx)\n-        if (!tx.IsFinal(nHeight, GetBlockTime()))\n-            return DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n+    BOOST_FOREACH(const CTransaction& tx, block.vtx)\n+        if (!tx.IsFinal(nHeight, block.GetBlockTime()))\n+            return block.DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n \n     // Check that the block chain matches the known block chain up to a checkpoint\n     if (!Checkpoints::CheckBlock(nHeight, hash))\n-        return DoS(100, error(\"AcceptBlock() : rejected by checkpoint lockin at %d\", nHeight));\n+        return block.DoS(100, error(\"AcceptBlock() : rejected by checkpoint lockin at %d\", nHeight));\n \n     // Write block to history file\n-    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n+    if (!CheckDiskSpace(GetSerializeSize(block, SER_DISK, CLIENT_VERSION)))\n         return error(\"AcceptBlock() : out of disk space\");\n     unsigned int nFile = -1;\n     unsigned int nBlockPos = 0;\n-    if (!WriteToDisk(nFile, nBlockPos))\n+    if (!block.WriteToDisk(nFile, nBlockPos))\n         return error(\"AcceptBlock() : WriteToDisk failed\");\n-    if (!AddToBlockIndex(nFile, nBlockPos))\n+    if (!AddToBlockIndex(block, nFile, nBlockPos))\n         return error(\"AcceptBlock() : AddToBlockIndex failed\");\n \n-    // Relay inventory, but don't relay old inventory during initial block download\n-    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n-    if (hashBestChain == hash)\n-    {\n-        LOCK(cs_vNodes);\n-        BOOST_FOREACH(CNode* pnode, vNodes)\n-            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n-                pnode->PushInventory(CInv(MSG_BLOCK, hash));\n-    }\n-\n     return true;\n }\n \n-bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n+bool CBlockStore::EmitBlock(CBlock& block, bool fBlocking, CNode* pNodeDoS)\n {\n     // Check for duplicate\n-    uint256 hash = pblock->GetHash();\n-    if (mapBlockIndex.count(hash))\n-        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n-    if (mapOrphanBlocks.count(hash))\n-        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n+    uint256 hash = block.GetHash();\n+    {\n+        LOCK(cs_setBlocksSeen);\n+        if (setBlocksSeen.count(hash) > 0)\n+            return error(\"CHub::EmitBlock() : already seen block %s\", hash.ToString().substr(0,20).c_str());\n+    }\n \n     // Preliminary checks\n-    if (!pblock->CheckBlock())\n-        return error(\"ProcessBlock() : CheckBlock FAILED\");\n+    if (!block.CheckBlock())\n+    {\n+        if (block.nDoS && pNodeDoS)\n+            CallbackDoS(pNodeDoS, block.nDoS);\n+        return error(\"CBlockStore::EmitBlock() : CheckBlock FAILED\");\n+    }\n \n-    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n-    if (pcheckpoint && pblock->hashPrevBlock != hashBestChain)\n+    const CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint();\n+    if (pcheckpoint && block.hashPrevBlock != hashBestChain)\n     {\n         // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n-        int64 deltaTime = pblock->GetBlockTime() - pcheckpoint->nTime;\n+        int64 deltaTime = block.GetBlockTime() - pcheckpoint->nTime;\n         if (deltaTime < 0)\n         {\n-            if (pfrom)\n-                pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with timestamp before last checkpoint\");\n+            if (pNodeDoS) CallbackDoS(pNodeDoS, 100);\n+            return block.DoS(100, error(\"CBlockStore::EmitBlock() : block with timestamp before last checkpoint\"));\n         }\n         CBigNum bnNewBlock;\n-        bnNewBlock.SetCompact(pblock->nBits);\n+        bnNewBlock.SetCompact(block.nBits);\n         CBigNum bnRequired;\n         bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n         if (bnNewBlock > bnRequired)\n         {\n-            if (pfrom)\n-                pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with too little proof-of-work\");\n+            if (pNodeDoS) CallbackDoS(pNodeDoS, 100);\n+            return block.DoS(100, error(\"CBlockStore::EmitBlock() : block with too little proof-of-work\"));\n         }\n     }\n \n+    {\n+        LOCK(cs_setBlocksSeen);\n+        setBlocksSeen.insert(hash);\n+    }\n+\n+    if (fBlocking)\n+        return FinishEmitBlock(block, pNodeDoS);\n+    else\n+        SubmitCallbackFinishEmitBlock(block, pNodeDoS);\n+\n+    return true;\n+}\n+\n+bool CBlockStore::FinishEmitBlock(CBlock& block, CNode* pNodeDoS)\n+{\n+    uint256 hash = block.GetHash();\n+\n+    LOCK(cs_main);\n \n     // If don't already have its previous block, shunt it off to holding area until we get it\n-    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n+    if (!mapBlockIndex.count(block.hashPrevBlock))\n     {\n-        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n-        CBlock* pblock2 = new CBlock(*pblock);\n-        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n-        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n+        printf(\"CBlockStore::FinishEmitBlock: ORPHAN BLOCK, prev=%s\\n\", block.hashPrevBlock.ToString().substr(0,20).c_str());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r989857",
      "id" : 989857,
      "original_commit_id" : "669a5d4c9e49fb3027ec7110664faa42615698bc",
      "original_position" : 785,
      "path" : "src/main.cpp",
      "position" : 782,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233",
      "updated_at" : "2012-06-28T17:47:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989857",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/548488?v=3",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r989870"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989870"
         }
      },
      "body" : "won't inv.hash work here?",
      "commit_id" : "1e2aff6a68b40a31d4833b256245bbbad0ad38c2",
      "created_at" : "2012-06-14T23:33:58Z",
      "diff_hunk" : "@@ -2767,14 +2869,24 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         CInv inv(MSG_BLOCK, block.GetHash());\n         pfrom->AddInventoryKnown(inv);\n \n-        if (ProcessBlock(pfrom, &block))\n-            mapAlreadyAskedFor.erase(inv);\n-        if (block.nDoS) pfrom->Misbehaving(block.nDoS);\n+        phub->EmitBlock(block, false, pfrom);\n+\n+        // Though we request duplicates, Satoshi nodes will not return any,\n+        // thanks to setInventoryKnown, however they will still count them\n+        // towards the block size in the inv result, its still better to\n+        // request blocks now, but #973 will optimize this further.\n+        if (pfrom->hashLastInvLastBlock == block.GetHash())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r989870",
      "id" : 989870,
      "original_commit_id" : "669a5d4c9e49fb3027ec7110664faa42615698bc",
      "original_position" : 1305,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233",
      "updated_at" : "2012-06-28T17:47:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/989870",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r990052"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/990052"
         }
      },
      "body" : "Because the function name has changed.",
      "commit_id" : "1e2aff6a68b40a31d4833b256245bbbad0ad38c2",
      "created_at" : "2012-06-15T00:01:49Z",
      "diff_hunk" : "@@ -1724,135 +1711,152 @@ bool CBlock::CheckBlock() const\n     return true;\n }\n \n-bool CBlock::AcceptBlock()\n+bool CBlockStore::AcceptBlock(CBlock& block)\n {\n     // Check for duplicate\n-    uint256 hash = GetHash();\n+    uint256 hash = block.GetHash();\n     if (mapBlockIndex.count(hash))\n         return error(\"AcceptBlock() : block already in mapBlockIndex\");\n \n     // Get prev block index\n-    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n+    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n     if (mi == mapBlockIndex.end())\n-        return DoS(10, error(\"AcceptBlock() : prev block not found\"));\n+        return block.DoS(10, error(\"AcceptBlock() : prev block not found\"));\n     CBlockIndex* pindexPrev = (*mi).second;\n     int nHeight = pindexPrev->nHeight+1;\n \n     // Check proof of work\n-    if (nBits != GetNextWorkRequired(pindexPrev, this))\n-        return DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n+    if (block.nBits != GetNextWorkRequired(pindexPrev, &block))\n+        return block.DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n \n     // Check timestamp against prev\n-    if (GetBlockTime() <= pindexPrev->GetMedianTimePast())\n+    if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n         return error(\"AcceptBlock() : block's timestamp is too early\");\n \n     // Check that all transactions are finalized\n-    BOOST_FOREACH(const CTransaction& tx, vtx)\n-        if (!tx.IsFinal(nHeight, GetBlockTime()))\n-            return DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n+    BOOST_FOREACH(const CTransaction& tx, block.vtx)\n+        if (!tx.IsFinal(nHeight, block.GetBlockTime()))\n+            return block.DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n \n     // Check that the block chain matches the known block chain up to a checkpoint\n     if (!Checkpoints::CheckBlock(nHeight, hash))\n-        return DoS(100, error(\"AcceptBlock() : rejected by checkpoint lockin at %d\", nHeight));\n+        return block.DoS(100, error(\"AcceptBlock() : rejected by checkpoint lockin at %d\", nHeight));\n \n     // Write block to history file\n-    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n+    if (!CheckDiskSpace(GetSerializeSize(block, SER_DISK, CLIENT_VERSION)))\n         return error(\"AcceptBlock() : out of disk space\");\n     unsigned int nFile = -1;\n     unsigned int nBlockPos = 0;\n-    if (!WriteToDisk(nFile, nBlockPos))\n+    if (!block.WriteToDisk(nFile, nBlockPos))\n         return error(\"AcceptBlock() : WriteToDisk failed\");\n-    if (!AddToBlockIndex(nFile, nBlockPos))\n+    if (!AddToBlockIndex(block, nFile, nBlockPos))\n         return error(\"AcceptBlock() : AddToBlockIndex failed\");\n \n-    // Relay inventory, but don't relay old inventory during initial block download\n-    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n-    if (hashBestChain == hash)\n-    {\n-        LOCK(cs_vNodes);\n-        BOOST_FOREACH(CNode* pnode, vNodes)\n-            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n-                pnode->PushInventory(CInv(MSG_BLOCK, hash));\n-    }\n-\n     return true;\n }\n \n-bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n+bool CBlockStore::EmitBlock(CBlock& block, bool fBlocking, CNode* pNodeDoS)\n {\n     // Check for duplicate\n-    uint256 hash = pblock->GetHash();\n-    if (mapBlockIndex.count(hash))\n-        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n-    if (mapOrphanBlocks.count(hash))\n-        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n+    uint256 hash = block.GetHash();\n+    {\n+        LOCK(cs_setBlocksSeen);\n+        if (setBlocksSeen.count(hash) > 0)\n+            return error(\"CHub::EmitBlock() : already seen block %s\", hash.ToString().substr(0,20).c_str());\n+    }\n \n     // Preliminary checks\n-    if (!pblock->CheckBlock())\n-        return error(\"ProcessBlock() : CheckBlock FAILED\");\n+    if (!block.CheckBlock())\n+    {\n+        if (block.nDoS && pNodeDoS)\n+            CallbackDoS(pNodeDoS, block.nDoS);\n+        return error(\"CBlockStore::EmitBlock() : CheckBlock FAILED\");\n+    }\n \n-    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n-    if (pcheckpoint && pblock->hashPrevBlock != hashBestChain)\n+    const CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint();\n+    if (pcheckpoint && block.hashPrevBlock != hashBestChain)\n     {\n         // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n-        int64 deltaTime = pblock->GetBlockTime() - pcheckpoint->nTime;\n+        int64 deltaTime = block.GetBlockTime() - pcheckpoint->nTime;\n         if (deltaTime < 0)\n         {\n-            if (pfrom)\n-                pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with timestamp before last checkpoint\");\n+            if (pNodeDoS) CallbackDoS(pNodeDoS, 100);\n+            return block.DoS(100, error(\"CBlockStore::EmitBlock() : block with timestamp before last checkpoint\"));\n         }\n         CBigNum bnNewBlock;\n-        bnNewBlock.SetCompact(pblock->nBits);\n+        bnNewBlock.SetCompact(block.nBits);\n         CBigNum bnRequired;\n         bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n         if (bnNewBlock > bnRequired)\n         {\n-            if (pfrom)\n-                pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with too little proof-of-work\");\n+            if (pNodeDoS) CallbackDoS(pNodeDoS, 100);\n+            return block.DoS(100, error(\"CBlockStore::EmitBlock() : block with too little proof-of-work\"));\n         }\n     }\n \n+    {\n+        LOCK(cs_setBlocksSeen);\n+        setBlocksSeen.insert(hash);\n+    }\n+\n+    if (fBlocking)\n+        return FinishEmitBlock(block, pNodeDoS);\n+    else\n+        SubmitCallbackFinishEmitBlock(block, pNodeDoS);\n+\n+    return true;\n+}\n+\n+bool CBlockStore::FinishEmitBlock(CBlock& block, CNode* pNodeDoS)\n+{\n+    uint256 hash = block.GetHash();\n+\n+    LOCK(cs_main);\n \n     // If don't already have its previous block, shunt it off to holding area until we get it\n-    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n+    if (!mapBlockIndex.count(block.hashPrevBlock))\n     {\n-        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n-        CBlock* pblock2 = new CBlock(*pblock);\n-        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n-        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n+        printf(\"CBlockStore::FinishEmitBlock: ORPHAN BLOCK, prev=%s\\n\", block.hashPrevBlock.ToString().substr(0,20).c_str());\n+        CBlock* pblock = new CBlock(block);\n+        mapOrphanBlocks.insert(make_pair(hash, pblock));\n+        mapOrphanBlocksByPrev.insert(make_pair(pblock->hashPrevBlock, pblock));\n \n         // Ask this guy to fill in what we're missing\n-        if (pfrom)\n-            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n+        CallbackAskForBlocks(GetOrphanRoot(pblock), hash);\n         return true;\n     }\n \n     // Store to disk\n-    if (!pblock->AcceptBlock())\n-        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n+    if (!AcceptBlock(block))\n+    {\n+        if (block.nDoS && pNodeDoS)\n+            CallbackDoS(pNodeDoS, block.nDoS);\n+        return error(\"CBlockStore::FinishEmitBlock() : AcceptBlock FAILED\");\n+    }\n \n     // Recursively process any orphan blocks that depended on this one\n-    vector<uint256> vWorkQueue;\n-    vWorkQueue.push_back(hash);\n-    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n+    queue<uint256> qWorkQueue;\n+    qWorkQueue.push(hash);\n+    while (!qWorkQueue.empty())\n     {\n-        uint256 hashPrev = vWorkQueue[i];\n+        uint256 hashPrev = qWorkQueue.front();\n+        qWorkQueue.pop();\n         for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n              mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n              ++mi)\n         {\n             CBlock* pblockOrphan = (*mi).second;\n-            if (pblockOrphan->AcceptBlock())\n-                vWorkQueue.push_back(pblockOrphan->GetHash());\n-            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n+            uint256 hashOrphan = pblockOrphan->GetHash();\n+            if (AcceptBlock(*pblockOrphan))\n+                qWorkQueue.push(hashOrphan);\n+            mapOrphanBlocks.erase(hashOrphan);\n             delete pblockOrphan;\n         }\n         mapOrphanBlocksByPrev.erase(hashPrev);\n     }\n \n-    printf(\"ProcessBlock: ACCEPTED\\n\");\n+    printf(\"CBlockStore::FinishEmitBlock: ACCEPTED\\n\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r990052",
      "id" : 990052,
      "original_commit_id" : "669a5d4c9e49fb3027ec7110664faa42615698bc",
      "original_position" : 836,
      "path" : "src/main.cpp",
      "position" : 833,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233",
      "updated_at" : "2012-06-28T17:47:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/990052",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r990073"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/990073"
         }
      },
      "body" : "Its to guess if we have another getblocks to go after this one. \nIts MAX_BLOCK_SIZE = 1000000 / default -maxsendbuffer = 10000000 = 10 / 2 = 5\nSee https://github.com/TheBlueMatt/bitcoin/blob/669a5d4c9e49fb3027ec7110664faa42615698bc/src/main.cpp#L2798",
      "commit_id" : "1e2aff6a68b40a31d4833b256245bbbad0ad38c2",
      "created_at" : "2012-06-15T00:05:22Z",
      "diff_hunk" : "@@ -2551,6 +2696,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     printf(\"force request: %s\\n\", inv.ToString().c_str());\n             }\n \n+            if (inv.type == MSG_BLOCK)\n+                nBlockCount++;\n+\n+            // Don't set hashLastInvLastBlock if we are getting a hashContinue inv\n+            if (nInv == nLastBlock && nBlockCount > 5)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r990073",
      "id" : 990073,
      "original_commit_id" : "669a5d4c9e49fb3027ec7110664faa42615698bc",
      "original_position" : 1188,
      "path" : "src/main.cpp",
      "position" : 1297,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233",
      "updated_at" : "2012-06-28T17:47:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/990073",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r990080"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/990080"
         }
      },
      "body" : "Yep, changed.",
      "commit_id" : "1e2aff6a68b40a31d4833b256245bbbad0ad38c2",
      "created_at" : "2012-06-15T00:06:13Z",
      "diff_hunk" : "@@ -2767,14 +2869,24 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         CInv inv(MSG_BLOCK, block.GetHash());\n         pfrom->AddInventoryKnown(inv);\n \n-        if (ProcessBlock(pfrom, &block))\n-            mapAlreadyAskedFor.erase(inv);\n-        if (block.nDoS) pfrom->Misbehaving(block.nDoS);\n+        phub->EmitBlock(block, false, pfrom);\n+\n+        // Though we request duplicates, Satoshi nodes will not return any,\n+        // thanks to setInventoryKnown, however they will still count them\n+        // towards the block size in the inv result, its still better to\n+        // request blocks now, but #973 will optimize this further.\n+        if (pfrom->hashLastInvLastBlock == block.GetHash())",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r990080",
      "id" : 990080,
      "original_commit_id" : "669a5d4c9e49fb3027ec7110664faa42615698bc",
      "original_position" : 1305,
      "path" : "src/main.cpp",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233",
      "updated_at" : "2012-06-28T17:47:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/990080",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r1087027"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1087027"
         }
      },
      "body" : "ProcessBlock is more visually appealing IMHO.",
      "commit_id" : "1e2aff6a68b40a31d4833b256245bbbad0ad38c2",
      "created_at" : "2012-07-02T19:29:31Z",
      "diff_hunk" : "@@ -1724,135 +1711,152 @@ bool CBlock::CheckBlock() const\n     return true;\n }\n \n-bool CBlock::AcceptBlock()\n+bool CBlockStore::AcceptBlock(CBlock& block)\n {\n     // Check for duplicate\n-    uint256 hash = GetHash();\n+    uint256 hash = block.GetHash();\n     if (mapBlockIndex.count(hash))\n         return error(\"AcceptBlock() : block already in mapBlockIndex\");\n \n     // Get prev block index\n-    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n+    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n     if (mi == mapBlockIndex.end())\n-        return DoS(10, error(\"AcceptBlock() : prev block not found\"));\n+        return block.DoS(10, error(\"AcceptBlock() : prev block not found\"));\n     CBlockIndex* pindexPrev = (*mi).second;\n     int nHeight = pindexPrev->nHeight+1;\n \n     // Check proof of work\n-    if (nBits != GetNextWorkRequired(pindexPrev, this))\n-        return DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n+    if (block.nBits != GetNextWorkRequired(pindexPrev, &block))\n+        return block.DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n \n     // Check timestamp against prev\n-    if (GetBlockTime() <= pindexPrev->GetMedianTimePast())\n+    if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n         return error(\"AcceptBlock() : block's timestamp is too early\");\n \n     // Check that all transactions are finalized\n-    BOOST_FOREACH(const CTransaction& tx, vtx)\n-        if (!tx.IsFinal(nHeight, GetBlockTime()))\n-            return DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n+    BOOST_FOREACH(const CTransaction& tx, block.vtx)\n+        if (!tx.IsFinal(nHeight, block.GetBlockTime()))\n+            return block.DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n \n     // Check that the block chain matches the known block chain up to a checkpoint\n     if (!Checkpoints::CheckBlock(nHeight, hash))\n-        return DoS(100, error(\"AcceptBlock() : rejected by checkpoint lockin at %d\", nHeight));\n+        return block.DoS(100, error(\"AcceptBlock() : rejected by checkpoint lockin at %d\", nHeight));\n \n     // Write block to history file\n-    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n+    if (!CheckDiskSpace(GetSerializeSize(block, SER_DISK, CLIENT_VERSION)))\n         return error(\"AcceptBlock() : out of disk space\");\n     unsigned int nFile = -1;\n     unsigned int nBlockPos = 0;\n-    if (!WriteToDisk(nFile, nBlockPos))\n+    if (!block.WriteToDisk(nFile, nBlockPos))\n         return error(\"AcceptBlock() : WriteToDisk failed\");\n-    if (!AddToBlockIndex(nFile, nBlockPos))\n+    if (!AddToBlockIndex(block, nFile, nBlockPos))\n         return error(\"AcceptBlock() : AddToBlockIndex failed\");\n \n-    // Relay inventory, but don't relay old inventory during initial block download\n-    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n-    if (hashBestChain == hash)\n-    {\n-        LOCK(cs_vNodes);\n-        BOOST_FOREACH(CNode* pnode, vNodes)\n-            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n-                pnode->PushInventory(CInv(MSG_BLOCK, hash));\n-    }\n-\n     return true;\n }\n \n-bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n+bool CBlockStore::EmitBlock(CBlock& block, bool fBlocking, CNode* pNodeDoS)\n {\n     // Check for duplicate\n-    uint256 hash = pblock->GetHash();\n-    if (mapBlockIndex.count(hash))\n-        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n-    if (mapOrphanBlocks.count(hash))\n-        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n+    uint256 hash = block.GetHash();\n+    {\n+        LOCK(cs_setBlocksSeen);\n+        if (setBlocksSeen.count(hash) > 0)\n+            return error(\"CHub::EmitBlock() : already seen block %s\", hash.ToString().substr(0,20).c_str());\n+    }\n \n     // Preliminary checks\n-    if (!pblock->CheckBlock())\n-        return error(\"ProcessBlock() : CheckBlock FAILED\");\n+    if (!block.CheckBlock())\n+    {\n+        if (block.nDoS && pNodeDoS)\n+            CallbackDoS(pNodeDoS, block.nDoS);\n+        return error(\"CBlockStore::EmitBlock() : CheckBlock FAILED\");\n+    }\n \n-    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n-    if (pcheckpoint && pblock->hashPrevBlock != hashBestChain)\n+    const CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint();\n+    if (pcheckpoint && block.hashPrevBlock != hashBestChain)\n     {\n         // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n-        int64 deltaTime = pblock->GetBlockTime() - pcheckpoint->nTime;\n+        int64 deltaTime = block.GetBlockTime() - pcheckpoint->nTime;\n         if (deltaTime < 0)\n         {\n-            if (pfrom)\n-                pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with timestamp before last checkpoint\");\n+            if (pNodeDoS) CallbackDoS(pNodeDoS, 100);\n+            return block.DoS(100, error(\"CBlockStore::EmitBlock() : block with timestamp before last checkpoint\"));\n         }\n         CBigNum bnNewBlock;\n-        bnNewBlock.SetCompact(pblock->nBits);\n+        bnNewBlock.SetCompact(block.nBits);\n         CBigNum bnRequired;\n         bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n         if (bnNewBlock > bnRequired)\n         {\n-            if (pfrom)\n-                pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with too little proof-of-work\");\n+            if (pNodeDoS) CallbackDoS(pNodeDoS, 100);\n+            return block.DoS(100, error(\"CBlockStore::EmitBlock() : block with too little proof-of-work\"));\n         }\n     }\n \n+    {\n+        LOCK(cs_setBlocksSeen);\n+        setBlocksSeen.insert(hash);\n+    }\n+\n+    if (fBlocking)\n+        return FinishEmitBlock(block, pNodeDoS);\n+    else\n+        SubmitCallbackFinishEmitBlock(block, pNodeDoS);\n+\n+    return true;\n+}\n+\n+bool CBlockStore::FinishEmitBlock(CBlock& block, CNode* pNodeDoS)\n+{\n+    uint256 hash = block.GetHash();\n+\n+    LOCK(cs_main);\n \n     // If don't already have its previous block, shunt it off to holding area until we get it\n-    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n+    if (!mapBlockIndex.count(block.hashPrevBlock))\n     {\n-        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n-        CBlock* pblock2 = new CBlock(*pblock);\n-        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n-        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n+        printf(\"CBlockStore::FinishEmitBlock: ORPHAN BLOCK, prev=%s\\n\", block.hashPrevBlock.ToString().substr(0,20).c_str());\n+        CBlock* pblock = new CBlock(block);\n+        mapOrphanBlocks.insert(make_pair(hash, pblock));\n+        mapOrphanBlocksByPrev.insert(make_pair(pblock->hashPrevBlock, pblock));\n \n         // Ask this guy to fill in what we're missing\n-        if (pfrom)\n-            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n+        CallbackAskForBlocks(GetOrphanRoot(pblock), hash);\n         return true;\n     }\n \n     // Store to disk\n-    if (!pblock->AcceptBlock())\n-        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n+    if (!AcceptBlock(block))\n+    {\n+        if (block.nDoS && pNodeDoS)\n+            CallbackDoS(pNodeDoS, block.nDoS);\n+        return error(\"CBlockStore::FinishEmitBlock() : AcceptBlock FAILED\");\n+    }\n \n     // Recursively process any orphan blocks that depended on this one\n-    vector<uint256> vWorkQueue;\n-    vWorkQueue.push_back(hash);\n-    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n+    queue<uint256> qWorkQueue;\n+    qWorkQueue.push(hash);\n+    while (!qWorkQueue.empty())\n     {\n-        uint256 hashPrev = vWorkQueue[i];\n+        uint256 hashPrev = qWorkQueue.front();\n+        qWorkQueue.pop();\n         for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n              mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n              ++mi)\n         {\n             CBlock* pblockOrphan = (*mi).second;\n-            if (pblockOrphan->AcceptBlock())\n-                vWorkQueue.push_back(pblockOrphan->GetHash());\n-            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n+            uint256 hashOrphan = pblockOrphan->GetHash();\n+            if (AcceptBlock(*pblockOrphan))\n+                qWorkQueue.push(hashOrphan);\n+            mapOrphanBlocks.erase(hashOrphan);\n             delete pblockOrphan;\n         }\n         mapOrphanBlocksByPrev.erase(hashPrev);\n     }\n \n-    printf(\"ProcessBlock: ACCEPTED\\n\");\n+    printf(\"CBlockStore::FinishEmitBlock: ACCEPTED\\n\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r1087027",
      "id" : 1087027,
      "original_commit_id" : "669a5d4c9e49fb3027ec7110664faa42615698bc",
      "original_position" : 836,
      "path" : "src/main.cpp",
      "position" : 833,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233",
      "updated_at" : "2012-07-02T19:29:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1087027",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r1087043"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1087043"
         }
      },
      "body" : "But if it were ProcessBlock, it would be unclear and searching to code for where the printf was called would be harder (which is the point of prefixing the print with the function that called it)",
      "commit_id" : "1e2aff6a68b40a31d4833b256245bbbad0ad38c2",
      "created_at" : "2012-07-02T19:31:32Z",
      "diff_hunk" : "@@ -1724,135 +1711,152 @@ bool CBlock::CheckBlock() const\n     return true;\n }\n \n-bool CBlock::AcceptBlock()\n+bool CBlockStore::AcceptBlock(CBlock& block)\n {\n     // Check for duplicate\n-    uint256 hash = GetHash();\n+    uint256 hash = block.GetHash();\n     if (mapBlockIndex.count(hash))\n         return error(\"AcceptBlock() : block already in mapBlockIndex\");\n \n     // Get prev block index\n-    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(hashPrevBlock);\n+    map<uint256, CBlockIndex*>::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n     if (mi == mapBlockIndex.end())\n-        return DoS(10, error(\"AcceptBlock() : prev block not found\"));\n+        return block.DoS(10, error(\"AcceptBlock() : prev block not found\"));\n     CBlockIndex* pindexPrev = (*mi).second;\n     int nHeight = pindexPrev->nHeight+1;\n \n     // Check proof of work\n-    if (nBits != GetNextWorkRequired(pindexPrev, this))\n-        return DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n+    if (block.nBits != GetNextWorkRequired(pindexPrev, &block))\n+        return block.DoS(100, error(\"AcceptBlock() : incorrect proof of work\"));\n \n     // Check timestamp against prev\n-    if (GetBlockTime() <= pindexPrev->GetMedianTimePast())\n+    if (block.GetBlockTime() <= pindexPrev->GetMedianTimePast())\n         return error(\"AcceptBlock() : block's timestamp is too early\");\n \n     // Check that all transactions are finalized\n-    BOOST_FOREACH(const CTransaction& tx, vtx)\n-        if (!tx.IsFinal(nHeight, GetBlockTime()))\n-            return DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n+    BOOST_FOREACH(const CTransaction& tx, block.vtx)\n+        if (!tx.IsFinal(nHeight, block.GetBlockTime()))\n+            return block.DoS(10, error(\"AcceptBlock() : contains a non-final transaction\"));\n \n     // Check that the block chain matches the known block chain up to a checkpoint\n     if (!Checkpoints::CheckBlock(nHeight, hash))\n-        return DoS(100, error(\"AcceptBlock() : rejected by checkpoint lockin at %d\", nHeight));\n+        return block.DoS(100, error(\"AcceptBlock() : rejected by checkpoint lockin at %d\", nHeight));\n \n     // Write block to history file\n-    if (!CheckDiskSpace(::GetSerializeSize(*this, SER_DISK, CLIENT_VERSION)))\n+    if (!CheckDiskSpace(GetSerializeSize(block, SER_DISK, CLIENT_VERSION)))\n         return error(\"AcceptBlock() : out of disk space\");\n     unsigned int nFile = -1;\n     unsigned int nBlockPos = 0;\n-    if (!WriteToDisk(nFile, nBlockPos))\n+    if (!block.WriteToDisk(nFile, nBlockPos))\n         return error(\"AcceptBlock() : WriteToDisk failed\");\n-    if (!AddToBlockIndex(nFile, nBlockPos))\n+    if (!AddToBlockIndex(block, nFile, nBlockPos))\n         return error(\"AcceptBlock() : AddToBlockIndex failed\");\n \n-    // Relay inventory, but don't relay old inventory during initial block download\n-    int nBlockEstimate = Checkpoints::GetTotalBlocksEstimate();\n-    if (hashBestChain == hash)\n-    {\n-        LOCK(cs_vNodes);\n-        BOOST_FOREACH(CNode* pnode, vNodes)\n-            if (nBestHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : nBlockEstimate))\n-                pnode->PushInventory(CInv(MSG_BLOCK, hash));\n-    }\n-\n     return true;\n }\n \n-bool ProcessBlock(CNode* pfrom, CBlock* pblock)\n+bool CBlockStore::EmitBlock(CBlock& block, bool fBlocking, CNode* pNodeDoS)\n {\n     // Check for duplicate\n-    uint256 hash = pblock->GetHash();\n-    if (mapBlockIndex.count(hash))\n-        return error(\"ProcessBlock() : already have block %d %s\", mapBlockIndex[hash]->nHeight, hash.ToString().substr(0,20).c_str());\n-    if (mapOrphanBlocks.count(hash))\n-        return error(\"ProcessBlock() : already have block (orphan) %s\", hash.ToString().substr(0,20).c_str());\n+    uint256 hash = block.GetHash();\n+    {\n+        LOCK(cs_setBlocksSeen);\n+        if (setBlocksSeen.count(hash) > 0)\n+            return error(\"CHub::EmitBlock() : already seen block %s\", hash.ToString().substr(0,20).c_str());\n+    }\n \n     // Preliminary checks\n-    if (!pblock->CheckBlock())\n-        return error(\"ProcessBlock() : CheckBlock FAILED\");\n+    if (!block.CheckBlock())\n+    {\n+        if (block.nDoS && pNodeDoS)\n+            CallbackDoS(pNodeDoS, block.nDoS);\n+        return error(\"CBlockStore::EmitBlock() : CheckBlock FAILED\");\n+    }\n \n-    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n-    if (pcheckpoint && pblock->hashPrevBlock != hashBestChain)\n+    const CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint();\n+    if (pcheckpoint && block.hashPrevBlock != hashBestChain)\n     {\n         // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n-        int64 deltaTime = pblock->GetBlockTime() - pcheckpoint->nTime;\n+        int64 deltaTime = block.GetBlockTime() - pcheckpoint->nTime;\n         if (deltaTime < 0)\n         {\n-            if (pfrom)\n-                pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with timestamp before last checkpoint\");\n+            if (pNodeDoS) CallbackDoS(pNodeDoS, 100);\n+            return block.DoS(100, error(\"CBlockStore::EmitBlock() : block with timestamp before last checkpoint\"));\n         }\n         CBigNum bnNewBlock;\n-        bnNewBlock.SetCompact(pblock->nBits);\n+        bnNewBlock.SetCompact(block.nBits);\n         CBigNum bnRequired;\n         bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n         if (bnNewBlock > bnRequired)\n         {\n-            if (pfrom)\n-                pfrom->Misbehaving(100);\n-            return error(\"ProcessBlock() : block with too little proof-of-work\");\n+            if (pNodeDoS) CallbackDoS(pNodeDoS, 100);\n+            return block.DoS(100, error(\"CBlockStore::EmitBlock() : block with too little proof-of-work\"));\n         }\n     }\n \n+    {\n+        LOCK(cs_setBlocksSeen);\n+        setBlocksSeen.insert(hash);\n+    }\n+\n+    if (fBlocking)\n+        return FinishEmitBlock(block, pNodeDoS);\n+    else\n+        SubmitCallbackFinishEmitBlock(block, pNodeDoS);\n+\n+    return true;\n+}\n+\n+bool CBlockStore::FinishEmitBlock(CBlock& block, CNode* pNodeDoS)\n+{\n+    uint256 hash = block.GetHash();\n+\n+    LOCK(cs_main);\n \n     // If don't already have its previous block, shunt it off to holding area until we get it\n-    if (!mapBlockIndex.count(pblock->hashPrevBlock))\n+    if (!mapBlockIndex.count(block.hashPrevBlock))\n     {\n-        printf(\"ProcessBlock: ORPHAN BLOCK, prev=%s\\n\", pblock->hashPrevBlock.ToString().substr(0,20).c_str());\n-        CBlock* pblock2 = new CBlock(*pblock);\n-        mapOrphanBlocks.insert(make_pair(hash, pblock2));\n-        mapOrphanBlocksByPrev.insert(make_pair(pblock2->hashPrevBlock, pblock2));\n+        printf(\"CBlockStore::FinishEmitBlock: ORPHAN BLOCK, prev=%s\\n\", block.hashPrevBlock.ToString().substr(0,20).c_str());\n+        CBlock* pblock = new CBlock(block);\n+        mapOrphanBlocks.insert(make_pair(hash, pblock));\n+        mapOrphanBlocksByPrev.insert(make_pair(pblock->hashPrevBlock, pblock));\n \n         // Ask this guy to fill in what we're missing\n-        if (pfrom)\n-            pfrom->PushGetBlocks(pindexBest, GetOrphanRoot(pblock2));\n+        CallbackAskForBlocks(GetOrphanRoot(pblock), hash);\n         return true;\n     }\n \n     // Store to disk\n-    if (!pblock->AcceptBlock())\n-        return error(\"ProcessBlock() : AcceptBlock FAILED\");\n+    if (!AcceptBlock(block))\n+    {\n+        if (block.nDoS && pNodeDoS)\n+            CallbackDoS(pNodeDoS, block.nDoS);\n+        return error(\"CBlockStore::FinishEmitBlock() : AcceptBlock FAILED\");\n+    }\n \n     // Recursively process any orphan blocks that depended on this one\n-    vector<uint256> vWorkQueue;\n-    vWorkQueue.push_back(hash);\n-    for (unsigned int i = 0; i < vWorkQueue.size(); i++)\n+    queue<uint256> qWorkQueue;\n+    qWorkQueue.push(hash);\n+    while (!qWorkQueue.empty())\n     {\n-        uint256 hashPrev = vWorkQueue[i];\n+        uint256 hashPrev = qWorkQueue.front();\n+        qWorkQueue.pop();\n         for (multimap<uint256, CBlock*>::iterator mi = mapOrphanBlocksByPrev.lower_bound(hashPrev);\n              mi != mapOrphanBlocksByPrev.upper_bound(hashPrev);\n              ++mi)\n         {\n             CBlock* pblockOrphan = (*mi).second;\n-            if (pblockOrphan->AcceptBlock())\n-                vWorkQueue.push_back(pblockOrphan->GetHash());\n-            mapOrphanBlocks.erase(pblockOrphan->GetHash());\n+            uint256 hashOrphan = pblockOrphan->GetHash();\n+            if (AcceptBlock(*pblockOrphan))\n+                qWorkQueue.push(hashOrphan);\n+            mapOrphanBlocks.erase(hashOrphan);\n             delete pblockOrphan;\n         }\n         mapOrphanBlocksByPrev.erase(hashPrev);\n     }\n \n-    printf(\"ProcessBlock: ACCEPTED\\n\");\n+    printf(\"CBlockStore::FinishEmitBlock: ACCEPTED\\n\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r1087043",
      "id" : 1087043,
      "original_commit_id" : "669a5d4c9e49fb3027ec7110664faa42615698bc",
      "original_position" : 836,
      "path" : "src/main.cpp",
      "position" : 833,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233",
      "updated_at" : "2012-07-02T19:31:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1087043",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r1087167"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1087167"
         }
      },
      "body" : "I'm not sure what I'm looking at re the URL above. Why 5 rather than 4 or 6?",
      "commit_id" : "1e2aff6a68b40a31d4833b256245bbbad0ad38c2",
      "created_at" : "2012-07-02T19:43:21Z",
      "diff_hunk" : "@@ -2551,6 +2696,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     printf(\"force request: %s\\n\", inv.ToString().c_str());\n             }\n \n+            if (inv.type == MSG_BLOCK)\n+                nBlockCount++;\n+\n+            // Don't set hashLastInvLastBlock if we are getting a hashContinue inv\n+            if (nInv == nLastBlock && nBlockCount > 5)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r1087167",
      "id" : 1087167,
      "original_commit_id" : "669a5d4c9e49fb3027ec7110664faa42615698bc",
      "original_position" : 1188,
      "path" : "src/main.cpp",
      "position" : 1297,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233",
      "updated_at" : "2012-07-02T19:43:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1087167",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/1530283?v=3",
         "events_url" : "https://api.github.com/users/rebroad/events{/privacy}",
         "followers_url" : "https://api.github.com/users/rebroad/followers",
         "following_url" : "https://api.github.com/users/rebroad/following{/other_user}",
         "gists_url" : "https://api.github.com/users/rebroad/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/rebroad",
         "id" : 1530283,
         "login" : "rebroad",
         "organizations_url" : "https://api.github.com/users/rebroad/orgs",
         "received_events_url" : "https://api.github.com/users/rebroad/received_events",
         "repos_url" : "https://api.github.com/users/rebroad/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/rebroad/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/rebroad/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/rebroad"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r1087187"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1087187"
         }
      },
      "body" : "MAX_BLOCK_SIZE / (default -maxsendbuffer / 2)\nThe link simply explains why its maxsendbuffer/2.",
      "commit_id" : "1e2aff6a68b40a31d4833b256245bbbad0ad38c2",
      "created_at" : "2012-07-02T19:44:46Z",
      "diff_hunk" : "@@ -2551,6 +2696,13 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     printf(\"force request: %s\\n\", inv.ToString().c_str());\n             }\n \n+            if (inv.type == MSG_BLOCK)\n+                nBlockCount++;\n+\n+            // Don't set hashLastInvLastBlock if we are getting a hashContinue inv\n+            if (nInv == nLastBlock && nBlockCount > 5)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#discussion_r1087187",
      "id" : 1087187,
      "original_commit_id" : "669a5d4c9e49fb3027ec7110664faa42615698bc",
      "original_position" : 1188,
      "path" : "src/main.cpp",
      "position" : 1297,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/1233",
      "updated_at" : "2012-07-02T19:44:46Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/1087187",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   },
   {
      "body" : "This needs rebasing, and Im not going to keep rebasing this stuff without any interest in eventually merging.  If it ever gets interest, I may reopen.",
      "created_at" : "2012-07-05T20:15:42Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/1233#issuecomment-6789417",
      "id" : 6789417,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/1233",
      "updated_at" : "2012-07-05T20:15:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/6789417",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/649246?v=3",
         "events_url" : "https://api.github.com/users/TheBlueMatt/events{/privacy}",
         "followers_url" : "https://api.github.com/users/TheBlueMatt/followers",
         "following_url" : "https://api.github.com/users/TheBlueMatt/following{/other_user}",
         "gists_url" : "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/TheBlueMatt",
         "id" : 649246,
         "login" : "TheBlueMatt",
         "organizations_url" : "https://api.github.com/users/TheBlueMatt/orgs",
         "received_events_url" : "https://api.github.com/users/TheBlueMatt/received_events",
         "repos_url" : "https://api.github.com/users/TheBlueMatt/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/TheBlueMatt/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/TheBlueMatt"
      }
   }
]
