[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #22252 (policy: Trim Packages when transaction with same txid exists in mempool by glozow)\n* #21800 (mempool/validation: mempool ancestor/descendant limits for packages by glozow)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2021-06-20T17:19:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22290#issuecomment-864585675",
      "id" : 864585675,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22290",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg2NDU4NTY3NQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-20T17:19:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/864585675",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I have some concerns around what semantics are desired for bypassing the fee rate checks for a single transaction and using a notion of package fee rate instead.\r\n\r\nI think the logic here â of using the descendant fee rate as an alternate to the transactionâs fee rate â is insufficient for preventing free relay.  Consider a 3 transaction package where one child transaction C has two parents, A and B, all of equal size.  Suppose A and B are zero-fee transactions and C has a fee rate of 2.  Then each of A and B would evaluate to having a fee rate of 1 (with C), but as a package the fee rate would be just 2/3.  If the mempool min fee or min relay fee is 1, then this package would make it in despite being below the required fee rate.\r\n\r\nI think this type of issue may be somewhat difficult to avoid if we donât tailor our semantics to the use case(s) we are trying to support.  Right now, if I understand correctly, we donât enforce any particular topology on the packages we accept â in fact I think the package acceptance logic would even accept unrelated transactions as well?  One idea I had was to require the whole packageâs fee rate to be above the min relay and mempool min fee as well, but that doesnât work very well if we allow someone to bundle in an unrelated high fee transaction to âpayâ for some low fee rate package.\r\n\r\nWe could check that a package is connected (from a graph theory perspective) as a condition for acceptance, but that is also not quite sufficient for achieving the semantics that I think we want.  For instance, if we are processing some package that has a sub graph of transactions which would not make it in on its own, we probably wouldnât want to admit that whole graph?  Iâm not quite sure.  It seems like if there is a detachable sub graph that would get evicted shortly after acceptance because itâs below the mempool min fee, that might still admit some kind of free relay problem, similar to the issue with unrelated transactions.\r\n\r\nMy previous approach to the package relay problem was to define packages in a future p2p protocol extension as being the set of unconfirmed ancestors of a single target transaction.  If that is sufficient for the use cases we are currently trying to support, then I think that simplifies the concerns a great deal â in this simple case I believe we could just look at two things: (a) check the target transactionâs own fee rate is sufficient to get in, and (b) check that the entire ancestor package for that target transaction also has a total fee rate sufficient to get in.  (Of course weâd have to add a check that validates a package only contains ancestor transactions of the target, too.)\r\n\r\nThe other benefit of using a target transactionâs ancestors as how we define a package is that it lines up better with how the mining algorithm currently works.\r\n\r\nIf multiple children paying for multiple parents is some desired use case, Iâm not sure the mempool and mining code are set up well enough to support that, so it would be helpful to analyze those use cases better to make sure our implementation will work okay.",
      "created_at" : "2021-06-21T17:17:59Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22290#issuecomment-865208890",
      "id" : 865208890,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22290",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg2NTIwODg5MA==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-21T17:17:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/865208890",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "> in this simple case I believe we could just look at two things: (a) check the target transactionâs own fee rate is sufficient to get in, and (b) check that the entire ancestor package for that target transaction also has a total fee rate sufficient to get in.\r\n\r\nThis seems reasonable.",
      "created_at" : "2021-06-21T21:37:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22290#issuecomment-865362039",
      "id" : 865362039,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22290",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg2NTM2MjAzOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-21T21:37:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/865362039",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/24482484?v=4",
         "events_url" : "https://api.github.com/users/Rspigler/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Rspigler/followers",
         "following_url" : "https://api.github.com/users/Rspigler/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Rspigler/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Rspigler",
         "id" : 24482484,
         "login" : "Rspigler",
         "node_id" : "MDQ6VXNlcjI0NDgyNDg0",
         "organizations_url" : "https://api.github.com/users/Rspigler/orgs",
         "received_events_url" : "https://api.github.com/users/Rspigler/received_events",
         "repos_url" : "https://api.github.com/users/Rspigler/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Rspigler/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Rspigler/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Rspigler"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Thank you for the thoughtful review @sdaftuar!\r\n\r\n> I think the logic here â of using the descendant fee rate as an alternate to the transactionâs fee rate â is insufficient for preventing free relay. Consider a 3 transaction package where one child transaction C has two parents, A and B, all of equal size. Suppose A and B are zero-fee transactions and C has a fee rate of 2. Then each of A and B would evaluate to having a fee rate of 1 (with C), but as a package the fee rate would be just 2/3. If the mempool min fee or min relay fee is 1, then this package would make it in despite being below the required fee rate.\r\n\r\nGreat point. I had been thinking of descendant feerate as a good marker since that's how we evict from mempool, but it is imperfect: I think we already have the case where a transaction's ancestor score is too low to be mined, but descendant score too high to be evicted. And it's additionally problematic with package relay.\r\n\r\nA proposal: if the mempool is intended to store the best candidates for mining, then we should evict in the opposite order we include in blocks, which is ancestor score.\r\nSo a transaction's `minerscore = max([ancestorfeerate(tx) for tx in {itself, all its descendants}])`. (This is with the current mining code - I suppose the definition of `minerscore` would be updated if/when block template creation changes).\r\n\r\nIf we replaced descendant feerate with `minerscore`, would that solve this problem? We go through the package, calculate everyone's ancestor feerate (including in-package and in-mempool ancestors), then we calculate everyone's `minerscore` based on that? Everyone's `minerscore` must surpass the min mempool/relay feerate. I think, then, it might not be necessary to specify/figure out which transactions are sponsees and which ones are sponsors?\r\n\r\n(Very far down the line, but just throwing a thought out there: considering feefilters with package relay, I think we would also want to use [unmodified] `minerscore` for feefiltering as well).",
      "created_at" : "2021-06-22T11:05:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22290#issuecomment-865887922",
      "id" : 865887922,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22290",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg2NTg4NzkyMg==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-22T11:05:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/865887922",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/25183001?v=4",
         "events_url" : "https://api.github.com/users/glozow/events{/privacy}",
         "followers_url" : "https://api.github.com/users/glozow/followers",
         "following_url" : "https://api.github.com/users/glozow/following{/other_user}",
         "gists_url" : "https://api.github.com/users/glozow/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/glozow",
         "id" : 25183001,
         "login" : "glozow",
         "node_id" : "MDQ6VXNlcjI1MTgzMDAx",
         "organizations_url" : "https://api.github.com/users/glozow/orgs",
         "received_events_url" : "https://api.github.com/users/glozow/received_events",
         "repos_url" : "https://api.github.com/users/glozow/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/glozow/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/glozow/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/glozow"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "> A proposal: if the mempool is intended to store the best candidates for mining, then we should evict in the opposite order we include in blocks, which is ancestor score.\r\nSo a transaction's minerscore = max([ancestorfeerate(tx) for tx in {itself, all its descendants}]). (This is with the current mining code - I suppose the definition of minerscore would be updated if/when block template creation changes).\r\n\r\n> If we replaced descendant feerate with minerscore, would that solve this problem? \r\n\r\nI think we should consider these two things separately: (1) whether to change the eviction algorithm used by the mempool, and (2) whether to change the fee rate heuristic used to evaluate transaction / package acceptance.\r\n\r\n---\r\nRegarding the use of the miner score based on maximum-ancestor-feerate-of-descendants, I think that heuristic doesn't work very well for eviction.  Imagine this scenario: the mempool has a very large, very low fee rate transaction A, with children B and C.  C also is a child of another low feerate parent D.\r\n\r\nIt is possible then that B has such a high feerate that A and B would be selected for the next block, and then that C and D would be selected as well (once A is paid for by B, C's ancestor feerate score would go up).  However, if A is in fact very large, then C's own ancestor fee rate could be quite low, so that D's `minerscore` could be very small.  This might mean that D and C could be evicted if the mempool were full, even if they would be selected for the next block!\r\n\r\n(As an aside I think the worst-case computation required to maintain this score would be worse than the status quo, too -- going from O(n) to O(n^2) to update statistics in the mempool when transactions are added/removed, where n = ancestor/descendant count.)\r\n\r\n---\r\nHowever regarding the heuristic we use for admitting a package to the mempool, I think using this max-ancestor-feerate-of-descendants as an additional check that we compare to the min-relay-fee and mempool-min-fee probably does work.  It might mean that packages which include a transaction that would be relying on some in-mempool-sibling to pay for a low fee parent might not make it in, but if that's not a use case we're worried about then probably this is fine (if conservative)?\r\n\r\nThat seems to be a generalization of what I had proposed; I had suggested requiring a single ancestor-package that passes the fee rate check in total, while you're saying we can just require that every transaction in the package be part of some ancestor package that would pass the fee rate check.  I'll give that more thought but it seems like a plausible solution.\r\n",
      "created_at" : "2021-06-22T21:29:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/22290#issuecomment-866347317",
      "id" : 866347317,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/22290",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDg2NjM0NzMxNw==",
      "performed_via_github_app" : null,
      "updated_at" : "2021-06-22T21:29:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/866347317",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7463573?v=4",
         "events_url" : "https://api.github.com/users/sdaftuar/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sdaftuar/followers",
         "following_url" : "https://api.github.com/users/sdaftuar/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sdaftuar/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sdaftuar",
         "id" : 7463573,
         "login" : "sdaftuar",
         "node_id" : "MDQ6VXNlcjc0NjM1NzM=",
         "organizations_url" : "https://api.github.com/users/sdaftuar/orgs",
         "received_events_url" : "https://api.github.com/users/sdaftuar/received_events",
         "repos_url" : "https://api.github.com/users/sdaftuar/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sdaftuar/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sdaftuar/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sdaftuar"
      }
   }
]
