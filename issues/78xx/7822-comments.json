[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7822#discussion_r58731933"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7822"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/58731933"
         }
      },
      "body" : "Nit: typo",
      "commit_id" : "534ef0ca3c32f5d50eabd52e972b85a0449cb785",
      "created_at" : "2016-04-06T15:57:26Z",
      "diff_hunk" : "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ListUnspentTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(3, self.options.tmpdir)\n+\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 1, 2)\n+        connect_nodes_bi(self.nodes, 0, 2)\n+\n+        self.is_network_split=False\n+        self.sync_all()\n+\n+    def run_test(self):\n+\n+        ##########################################\n+        #  Test case 1                           #\n+        #  Mine some coins and spend one output  #\n+        ##########################################\n+\n+        # check there's no unspent output availabe on any nodes\n+        assert_equal(len(self.nodes[0].listunspent()), 0)\n+        assert_equal(len(self.nodes[1].listunspent()), 0)\n+        assert_equal(len(self.nodes[2].listunspent()), 0)\n+\n+        # mine enough blocks to generate one UTXO on first node\n+        self.nodes[0].generate(101)\n+        self.sync_all()\n+\n+        # list current unspents, only first node should return one unspent\n+        assert_equal(len(self.nodes[0].listunspent()), 1)\n+        assert_equal(len(self.nodes[1].listunspent()), 0)\n+        assert_equal(len(self.nodes[2].listunspent()), 0)\n+\n+        # make sure this output is spendable\n+        assert(self.nodes[0].listunspent()[0][\"spendable\"])\n+\n+        # sends some coins from first node to third node, to spend some available unspent outputs\n+        send_to_address = self.nodes[2].getnewaddress()\n+        txid = self.nodes[0].sendtoaddress(send_to_address, 10)\n+\n+        # since the only available UTXO was spent, there sould be none after the transaction\n+        assert_equal(len(self.nodes[0].listunspent()), 0)\n+\n+        # mine one more block to generate some more UTXOs\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        # list unspents after the transaction\n+        list_unspent_after = self.nodes[0].listunspent()\n+\n+        # retrieve that transaction and check if the transaction inputs are not among the unspents\n+        rawtx = self.nodes[0].getrawtransaction(txid, 1)\n+        for txin in rawtx[\"vin\"]:\n+            for utxo in list_unspent_after:\n+                if (txin[\"txid\"] == utxo[\"txid\"] and txin[\"vout\"] == utxo[\"vout\"]):\n+                    raise AssertionError(\"Fount used output on UTXOs list\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7822#discussion_r58731933",
      "id" : 58731933,
      "original_commit_id" : "0d8581d4a3b138824042c86bfbb23d29982806ce",
      "original_position" : 68,
      "path" : "qa/rpc-tests/listunspent.py",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7822",
      "updated_at" : "2016-04-06T17:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/58731933",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7822#discussion_r58732261"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7822"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/58732261"
         }
      },
      "body" : "You may want to try `assert_raises` instead.",
      "commit_id" : "534ef0ca3c32f5d50eabd52e972b85a0449cb785",
      "created_at" : "2016-04-06T15:59:14Z",
      "diff_hunk" : "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ListUnspentTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(3, self.options.tmpdir)\n+\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 1, 2)\n+        connect_nodes_bi(self.nodes, 0, 2)\n+\n+        self.is_network_split=False\n+        self.sync_all()\n+\n+    def run_test(self):\n+\n+        ##########################################\n+        #  Test case 1                           #\n+        #  Mine some coins and spend one output  #\n+        ##########################################\n+\n+        # check there's no unspent output availabe on any nodes\n+        assert_equal(len(self.nodes[0].listunspent()), 0)\n+        assert_equal(len(self.nodes[1].listunspent()), 0)\n+        assert_equal(len(self.nodes[2].listunspent()), 0)\n+\n+        # mine enough blocks to generate one UTXO on first node\n+        self.nodes[0].generate(101)\n+        self.sync_all()\n+\n+        # list current unspents, only first node should return one unspent\n+        assert_equal(len(self.nodes[0].listunspent()), 1)\n+        assert_equal(len(self.nodes[1].listunspent()), 0)\n+        assert_equal(len(self.nodes[2].listunspent()), 0)\n+\n+        # make sure this output is spendable\n+        assert(self.nodes[0].listunspent()[0][\"spendable\"])\n+\n+        # sends some coins from first node to third node, to spend some available unspent outputs\n+        send_to_address = self.nodes[2].getnewaddress()\n+        txid = self.nodes[0].sendtoaddress(send_to_address, 10)\n+\n+        # since the only available UTXO was spent, there sould be none after the transaction\n+        assert_equal(len(self.nodes[0].listunspent()), 0)\n+\n+        # mine one more block to generate some more UTXOs\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        # list unspents after the transaction\n+        list_unspent_after = self.nodes[0].listunspent()\n+\n+        # retrieve that transaction and check if the transaction inputs are not among the unspents\n+        rawtx = self.nodes[0].getrawtransaction(txid, 1)\n+        for txin in rawtx[\"vin\"]:\n+            for utxo in list_unspent_after:\n+                if (txin[\"txid\"] == utxo[\"txid\"] and txin[\"vout\"] == utxo[\"vout\"]):\n+                    raise AssertionError(\"Fount used output on UTXOs list\")\n+\n+\n+        ###########################################################################\n+        #  Test case 2                                                            #\n+        #  Import address (watch-only) and retrieve new unspents (not spendable)  #\n+        ###########################################################################\n+\n+        # second node shouldn't have any unpent at the moment\n+        assert_equal(len(self.nodes[1].listunspent()), 0)\n+\n+        # import address from another node\n+        self.nodes[1].importaddress(send_to_address)\n+\n+        # making sure this address is watch-only\n+        assert(self.nodes[1].validateaddress(send_to_address)[\"iswatchonly\"])\n+\n+        # there should be only one unspendable unspent, from the imported address\n+        assert_equal(len(self.nodes[1].listunspent()), 1)\n+        assert(not self.nodes[1].listunspent()[0][\"spendable\"])\n+\n+        try:\n+            self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n+        except JSONRPCException:\n+            print(\"Impossible to send coins. Available output is unspendable.\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7822#discussion_r58732261",
      "id" : 58732261,
      "original_commit_id" : "0d8581d4a3b138824042c86bfbb23d29982806ce",
      "original_position" : 92,
      "path" : "qa/rpc-tests/listunspent.py",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7822",
      "updated_at" : "2016-04-06T17:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/58732261",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7822#discussion_r58732375"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7822"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/58732375"
         }
      },
      "body" : "Please use py3 syntax here: `as e:`",
      "commit_id" : "534ef0ca3c32f5d50eabd52e972b85a0449cb785",
      "created_at" : "2016-04-06T16:00:04Z",
      "diff_hunk" : "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ListUnspentTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(3, self.options.tmpdir)\n+\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 1, 2)\n+        connect_nodes_bi(self.nodes, 0, 2)\n+\n+        self.is_network_split=False\n+        self.sync_all()\n+\n+    def run_test(self):\n+\n+        ##########################################\n+        #  Test case 1                           #\n+        #  Mine some coins and spend one output  #\n+        ##########################################\n+\n+        # check there's no unspent output availabe on any nodes\n+        assert_equal(len(self.nodes[0].listunspent()), 0)\n+        assert_equal(len(self.nodes[1].listunspent()), 0)\n+        assert_equal(len(self.nodes[2].listunspent()), 0)\n+\n+        # mine enough blocks to generate one UTXO on first node\n+        self.nodes[0].generate(101)\n+        self.sync_all()\n+\n+        # list current unspents, only first node should return one unspent\n+        assert_equal(len(self.nodes[0].listunspent()), 1)\n+        assert_equal(len(self.nodes[1].listunspent()), 0)\n+        assert_equal(len(self.nodes[2].listunspent()), 0)\n+\n+        # make sure this output is spendable\n+        assert(self.nodes[0].listunspent()[0][\"spendable\"])\n+\n+        # sends some coins from first node to third node, to spend some available unspent outputs\n+        send_to_address = self.nodes[2].getnewaddress()\n+        txid = self.nodes[0].sendtoaddress(send_to_address, 10)\n+\n+        # since the only available UTXO was spent, there sould be none after the transaction\n+        assert_equal(len(self.nodes[0].listunspent()), 0)\n+\n+        # mine one more block to generate some more UTXOs\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        # list unspents after the transaction\n+        list_unspent_after = self.nodes[0].listunspent()\n+\n+        # retrieve that transaction and check if the transaction inputs are not among the unspents\n+        rawtx = self.nodes[0].getrawtransaction(txid, 1)\n+        for txin in rawtx[\"vin\"]:\n+            for utxo in list_unspent_after:\n+                if (txin[\"txid\"] == utxo[\"txid\"] and txin[\"vout\"] == utxo[\"vout\"]):\n+                    raise AssertionError(\"Fount used output on UTXOs list\")\n+\n+\n+        ###########################################################################\n+        #  Test case 2                                                            #\n+        #  Import address (watch-only) and retrieve new unspents (not spendable)  #\n+        ###########################################################################\n+\n+        # second node shouldn't have any unpent at the moment\n+        assert_equal(len(self.nodes[1].listunspent()), 0)\n+\n+        # import address from another node\n+        self.nodes[1].importaddress(send_to_address)\n+\n+        # making sure this address is watch-only\n+        assert(self.nodes[1].validateaddress(send_to_address)[\"iswatchonly\"])\n+\n+        # there should be only one unspendable unspent, from the imported address\n+        assert_equal(len(self.nodes[1].listunspent()), 1)\n+        assert(not self.nodes[1].listunspent()[0][\"spendable\"])\n+\n+        try:\n+            self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n+        except JSONRPCException:\n+            print(\"Impossible to send coins. Available output is unspendable.\")\n+\n+\n+        #######################################################################\n+        #  Test case 3                                                        #\n+        #  Import private key and check for updated unspents (now spendable)  #\n+        #######################################################################\n+\n+        # import private key, so this node can spend the available UTXO\n+        priv_key = self.nodes[2].dumpprivkey(send_to_address)\n+        self.nodes[1].importprivkey(priv_key)\n+\n+        # there should be only one spendable unspent, after importing private key\n+        assert_equal(len(self.nodes[1].listunspent()), 1)\n+        assert(self.nodes[1].listunspent()[0][\"spendable\"])\n+\n+        try:\n+            self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 0.1)\n+        except JSONRPCException, e:",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7822#discussion_r58732375",
      "id" : 58732375,
      "original_commit_id" : "0d8581d4a3b138824042c86bfbb23d29982806ce",
      "original_position" : 110,
      "path" : "qa/rpc-tests/listunspent.py",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7822",
      "updated_at" : "2016-04-06T17:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/58732375",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7822#discussion_r58732622"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7822"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/58732622"
         }
      },
      "body" : "Nit: No need to shadow the original exception. You can just remove the try-except block altogether and only leave the sendtoaddress",
      "commit_id" : "534ef0ca3c32f5d50eabd52e972b85a0449cb785",
      "created_at" : "2016-04-06T16:01:29Z",
      "diff_hunk" : "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ListUnspentTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(3, self.options.tmpdir)\n+\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 1, 2)\n+        connect_nodes_bi(self.nodes, 0, 2)\n+\n+        self.is_network_split=False\n+        self.sync_all()\n+\n+    def run_test(self):\n+\n+        ##########################################\n+        #  Test case 1                           #\n+        #  Mine some coins and spend one output  #\n+        ##########################################\n+\n+        # check there's no unspent output availabe on any nodes\n+        assert_equal(len(self.nodes[0].listunspent()), 0)\n+        assert_equal(len(self.nodes[1].listunspent()), 0)\n+        assert_equal(len(self.nodes[2].listunspent()), 0)\n+\n+        # mine enough blocks to generate one UTXO on first node\n+        self.nodes[0].generate(101)\n+        self.sync_all()\n+\n+        # list current unspents, only first node should return one unspent\n+        assert_equal(len(self.nodes[0].listunspent()), 1)\n+        assert_equal(len(self.nodes[1].listunspent()), 0)\n+        assert_equal(len(self.nodes[2].listunspent()), 0)\n+\n+        # make sure this output is spendable\n+        assert(self.nodes[0].listunspent()[0][\"spendable\"])\n+\n+        # sends some coins from first node to third node, to spend some available unspent outputs\n+        send_to_address = self.nodes[2].getnewaddress()\n+        txid = self.nodes[0].sendtoaddress(send_to_address, 10)\n+\n+        # since the only available UTXO was spent, there sould be none after the transaction\n+        assert_equal(len(self.nodes[0].listunspent()), 0)\n+\n+        # mine one more block to generate some more UTXOs\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        # list unspents after the transaction\n+        list_unspent_after = self.nodes[0].listunspent()\n+\n+        # retrieve that transaction and check if the transaction inputs are not among the unspents\n+        rawtx = self.nodes[0].getrawtransaction(txid, 1)\n+        for txin in rawtx[\"vin\"]:\n+            for utxo in list_unspent_after:\n+                if (txin[\"txid\"] == utxo[\"txid\"] and txin[\"vout\"] == utxo[\"vout\"]):\n+                    raise AssertionError(\"Fount used output on UTXOs list\")\n+\n+\n+        ###########################################################################\n+        #  Test case 2                                                            #\n+        #  Import address (watch-only) and retrieve new unspents (not spendable)  #\n+        ###########################################################################\n+\n+        # second node shouldn't have any unpent at the moment\n+        assert_equal(len(self.nodes[1].listunspent()), 0)\n+\n+        # import address from another node\n+        self.nodes[1].importaddress(send_to_address)\n+\n+        # making sure this address is watch-only\n+        assert(self.nodes[1].validateaddress(send_to_address)[\"iswatchonly\"])\n+\n+        # there should be only one unspendable unspent, from the imported address\n+        assert_equal(len(self.nodes[1].listunspent()), 1)\n+        assert(not self.nodes[1].listunspent()[0][\"spendable\"])\n+\n+        try:\n+            self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n+        except JSONRPCException:\n+            print(\"Impossible to send coins. Available output is unspendable.\")\n+\n+\n+        #######################################################################\n+        #  Test case 3                                                        #\n+        #  Import private key and check for updated unspents (now spendable)  #\n+        #######################################################################\n+\n+        # import private key, so this node can spend the available UTXO\n+        priv_key = self.nodes[2].dumpprivkey(send_to_address)\n+        self.nodes[1].importprivkey(priv_key)\n+\n+        # there should be only one spendable unspent, after importing private key\n+        assert_equal(len(self.nodes[1].listunspent()), 1)\n+        assert(self.nodes[1].listunspent()[0][\"spendable\"])\n+\n+        try:\n+            self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 0.1)\n+        except JSONRPCException, e:\n+            raise AssertionError(\"Not possible to send coins. Possible unsufficient funds.\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7822#discussion_r58732622",
      "id" : 58732622,
      "original_commit_id" : "0d8581d4a3b138824042c86bfbb23d29982806ce",
      "original_position" : 111,
      "path" : "qa/rpc-tests/listunspent.py",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7822",
      "updated_at" : "2016-04-06T17:30:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/58732622",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6399679?v=3",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/7822#discussion_r58747552"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7822"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/58747552"
         }
      },
      "body" : "Thanks for the tips. Fixed and rebased.",
      "commit_id" : "534ef0ca3c32f5d50eabd52e972b85a0449cb785",
      "created_at" : "2016-04-06T17:31:21Z",
      "diff_hunk" : "@@ -0,0 +1,117 @@\n+#!/usr/bin/env python2\n+# Copyright (c) 2014-2016 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.util import *\n+\n+class ListUnspentTest(BitcoinTestFramework):\n+\n+    def setup_chain(self):\n+        print(\"Initializing test directory \"+self.options.tmpdir)\n+        initialize_chain_clean(self.options.tmpdir, 3)\n+\n+    def setup_network(self, split=False):\n+        self.nodes = start_nodes(3, self.options.tmpdir)\n+\n+        connect_nodes_bi(self.nodes, 0, 1)\n+        connect_nodes_bi(self.nodes, 1, 2)\n+        connect_nodes_bi(self.nodes, 0, 2)\n+\n+        self.is_network_split=False\n+        self.sync_all()\n+\n+    def run_test(self):\n+\n+        ##########################################\n+        #  Test case 1                           #\n+        #  Mine some coins and spend one output  #\n+        ##########################################\n+\n+        # check there's no unspent output availabe on any nodes\n+        assert_equal(len(self.nodes[0].listunspent()), 0)\n+        assert_equal(len(self.nodes[1].listunspent()), 0)\n+        assert_equal(len(self.nodes[2].listunspent()), 0)\n+\n+        # mine enough blocks to generate one UTXO on first node\n+        self.nodes[0].generate(101)\n+        self.sync_all()\n+\n+        # list current unspents, only first node should return one unspent\n+        assert_equal(len(self.nodes[0].listunspent()), 1)\n+        assert_equal(len(self.nodes[1].listunspent()), 0)\n+        assert_equal(len(self.nodes[2].listunspent()), 0)\n+\n+        # make sure this output is spendable\n+        assert(self.nodes[0].listunspent()[0][\"spendable\"])\n+\n+        # sends some coins from first node to third node, to spend some available unspent outputs\n+        send_to_address = self.nodes[2].getnewaddress()\n+        txid = self.nodes[0].sendtoaddress(send_to_address, 10)\n+\n+        # since the only available UTXO was spent, there sould be none after the transaction\n+        assert_equal(len(self.nodes[0].listunspent()), 0)\n+\n+        # mine one more block to generate some more UTXOs\n+        self.nodes[0].generate(1)\n+        self.sync_all()\n+\n+        # list unspents after the transaction\n+        list_unspent_after = self.nodes[0].listunspent()\n+\n+        # retrieve that transaction and check if the transaction inputs are not among the unspents\n+        rawtx = self.nodes[0].getrawtransaction(txid, 1)\n+        for txin in rawtx[\"vin\"]:\n+            for utxo in list_unspent_after:\n+                if (txin[\"txid\"] == utxo[\"txid\"] and txin[\"vout\"] == utxo[\"vout\"]):\n+                    raise AssertionError(\"Fount used output on UTXOs list\")\n+\n+\n+        ###########################################################################\n+        #  Test case 2                                                            #\n+        #  Import address (watch-only) and retrieve new unspents (not spendable)  #\n+        ###########################################################################\n+\n+        # second node shouldn't have any unpent at the moment\n+        assert_equal(len(self.nodes[1].listunspent()), 0)\n+\n+        # import address from another node\n+        self.nodes[1].importaddress(send_to_address)\n+\n+        # making sure this address is watch-only\n+        assert(self.nodes[1].validateaddress(send_to_address)[\"iswatchonly\"])\n+\n+        # there should be only one unspendable unspent, from the imported address\n+        assert_equal(len(self.nodes[1].listunspent()), 1)\n+        assert(not self.nodes[1].listunspent()[0][\"spendable\"])\n+\n+        try:\n+            self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n+        except JSONRPCException:\n+            print(\"Impossible to send coins. Available output is unspendable.\")\n+\n+\n+        #######################################################################\n+        #  Test case 3                                                        #\n+        #  Import private key and check for updated unspents (now spendable)  #\n+        #######################################################################\n+\n+        # import private key, so this node can spend the available UTXO\n+        priv_key = self.nodes[2].dumpprivkey(send_to_address)\n+        self.nodes[1].importprivkey(priv_key)\n+\n+        # there should be only one spendable unspent, after importing private key\n+        assert_equal(len(self.nodes[1].listunspent()), 1)\n+        assert(self.nodes[1].listunspent()[0][\"spendable\"])\n+\n+        try:\n+            self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), 0.1)\n+        except JSONRPCException, e:\n+            raise AssertionError(\"Not possible to send coins. Possible unsufficient funds.\")",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/7822#discussion_r58747552",
      "id" : 58747552,
      "original_commit_id" : "0d8581d4a3b138824042c86bfbb23d29982806ce",
      "original_position" : 111,
      "path" : "qa/rpc-tests/listunspent.py",
      "position" : null,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/7822",
      "updated_at" : "2016-04-06T17:31:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/58747552",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/16206754?v=3",
         "events_url" : "https://api.github.com/users/jpdffonseca/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jpdffonseca/followers",
         "following_url" : "https://api.github.com/users/jpdffonseca/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jpdffonseca/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jpdffonseca",
         "id" : 16206754,
         "login" : "jpdffonseca",
         "organizations_url" : "https://api.github.com/users/jpdffonseca/orgs",
         "received_events_url" : "https://api.github.com/users/jpdffonseca/received_events",
         "repos_url" : "https://api.github.com/users/jpdffonseca/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jpdffonseca/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jpdffonseca/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jpdffonseca"
      }
   }
]
