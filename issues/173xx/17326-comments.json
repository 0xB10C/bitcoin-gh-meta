[
   {
      "author_association" : "MEMBER",
      "body" : "ping @EthanHeilman @sdaftuar @naumenkogs ",
      "created_at" : "2019-10-30T21:09:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/17326#issuecomment-548113615",
      "id" : 548113615,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17326",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0ODExMzYxNQ==",
      "updated_at" : "2019-10-30T21:09:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/548113615",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Implementation\r\n====\r\n\r\nThis would be trivial to implement. Addrman already serializes its data to disk in the form of `peers.dat`. You would just need to maintain an outgoing connection vector, add it to the addrman serialization logic and then read that vector when calling select.\r\n\r\nThoughts\r\n====\r\n\r\n\r\nIn our paper we called these **countermeasure 5: anchor connections**. We suggested limiting them to two of the outgoing connections. We wrote:\r\n\r\n> Anchor connections.Inspired by Tor entry guard rotation rates [33], we add two connections that persist. Between restarts. Thus, we add an anchor table, recording  addresses  of  current  outgoing  connections  and  the time of first connection to each address.   Upon restart,the node dedicates two extra outgoing connections to the oldest anchor addresses that accept incoming connections.  Now, in addition to defeating our other counter-measures, a successful attacker must also disrupt anchor connections; eclipse attacks fail if the victim connects to an anchor address not controlled by the attacker\r\n>[...]\r\n>[33] - \"One Fast Guard for Life (or 9 months)\" - https://www-users.cs.umn.edu/~hoppernj/single_guard.pdf\r\n-Eclipse Attacks on Bitcoinâs Peer-to-Peer Network\r\n\r\n\r\n>Eclipse attack requires the victim node to restart so it can connect to adversarial addresses.\r\n\r\nSome things have changed from when that paper was written and that is no longer true.\r\n\r\n**Bitcoin 2015:**\r\n1. Bob has 116 incoming connections.\r\n2. Alice makes an outgoing connection to Bob. \r\n3. Bob has 117 incoming connections\r\n4. Carol attempts to make an outgoing connection to Bob\r\n5. Carol's connection is rejected.\r\n6. Alice still has an outgoing connection to Bob\r\n\r\n**Bitcoin 2019:**\r\n1. Bob has 116 incoming connections.\r\n2. Alice makes an outgoing connection to Bob. \r\n3. Bob has 117 incoming connections\r\n4. Carol attempts to make an outgoing connection to Bob\r\n5. There is a change Alice's connection is evicted and Carol's connection is established\r\n6. Alice loses her outgoing connection to Bob (sometimes)\r\n7. Carol now has an outgoing connection (sometimes)\r\n\r\nSee the incoming connection eviction logic here:\r\nhttps://github.com/bitcoin/bitcoin/blob/master/src/net.cpp#L857\r\n\r\nIf we were in **Bitcoin 2015** anchor connections could be bypassed using [a connection starvation attack](https://sourceforge.net/p/bitcoin/mailman/message/31168096/):\r\n1. Attacker makes up to 117 out connections to each full node on the network. This is actually pretty cheap to do. A laptop connected over WIFI could do this to **Bitcoin 2015**\r\n2. Attacker performs eclipse attack\r\n3. Victim reboots, attacker fills up the freed connection slots in the network\r\n4. Victim can't connect to nodes they were connected to before the reboot since all their connections are monopolized by attacker\r\n5. Eclipse attack succeeds.\r\n\r\nNow in **Bitcoin 2019** the victim could successfully evict the attackers connections and reconnect to the node. However in **BItcoin 2019** an attacker might be able to eclipse a node without reboots via connection eviction logic. There is a trade off here. Someone should research this!!!\r\n\r\n**Unsatisfying conclusion:**\r\n====\r\n\r\nAlways reconnecting outgoing connections to the same nodes would probably make Eclipse attacks more complex but it would also mean that outgoing connections would be more static. Is making them more static good or bad?\r\n\r\n",
      "created_at" : "2019-10-31T14:46:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/17326#issuecomment-548410548",
      "id" : 548410548,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17326",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0ODQxMDU0OA==",
      "updated_at" : "2019-10-31T14:46:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/548410548",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/274814?v=4",
         "events_url" : "https://api.github.com/users/EthanHeilman/events{/privacy}",
         "followers_url" : "https://api.github.com/users/EthanHeilman/followers",
         "following_url" : "https://api.github.com/users/EthanHeilman/following{/other_user}",
         "gists_url" : "https://api.github.com/users/EthanHeilman/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/EthanHeilman",
         "id" : 274814,
         "login" : "EthanHeilman",
         "node_id" : "MDQ6VXNlcjI3NDgxNA==",
         "organizations_url" : "https://api.github.com/users/EthanHeilman/orgs",
         "received_events_url" : "https://api.github.com/users/EthanHeilman/received_events",
         "repos_url" : "https://api.github.com/users/EthanHeilman/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/EthanHeilman/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/EthanHeilman/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/EthanHeilman"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "@EthanHeilman \r\nThanks for the thorough explanation of the difference between 2015 and 2019.\r\nJust wanted to highlight for the other readers that although it's very useful to understand the background, it does not directly affect reasoning about this PR.\r\nMaybe it does but in a positive way: anchors are stronger in 2019, so increasing their number today is even better.\r\n\r\n>However in BItcoin 2019 an attacker might be able to eclipse a node without reboots via connection eviction logic. There is a trade off here. Someone should research this!!!\r\n\r\nI agree, this is an important one, but again, not really related to whether we need anchors. I hope to find time to eventually look into this particular issue and measure the trade-offs.\r\n\r\nPlease correct me if im wrong.",
      "created_at" : "2019-10-31T17:47:39Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/17326#issuecomment-548492408",
      "id" : 548492408,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17326",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0ODQ5MjQwOA==",
      "updated_at" : "2019-10-31T18:06:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/548492408",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@EthanHeilman \r\n\r\nThank you for your review.\r\n\r\n> This would be trivial to implement. Addrman already serializes its data to disk in the form of `peers.dat`. You would just need to maintain an outgoing connection vector, add it to the addrman serialization logic and then read that vector when calling select.\r\n\r\n`CConnman::DumpAddresses()` is called from `CConnman::Stop()`. Therefore, `peers.dat` does not suit in case of unpredictable shutdown (e.g., power failure). IMO, outgoing connection vector should be dumped to the dedicated file, say  `anchors.dat`, periodically, like `banlist.dat` does, or after each change in it.",
      "created_at" : "2019-11-01T13:15:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/17326#issuecomment-548783750",
      "id" : 548783750,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17326",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0ODc4Mzc1MA==",
      "updated_at" : "2019-11-01T13:15:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/548783750",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "While thinking about this idea I came up with a formula ``a node is at most as secure as all the connections it has ever made``.\r\nWhat we really want is to be able to check with our former connections that we're on the same tip (at least to prevent full eclipsing with double-spends etc. Other sybil problems still apply).\r\n\r\nSo perhaps every N (say 2) minutes we can exchange recent block hashes with one of our former nodes?\r\nThis is a pretty big change, but we can start with doing it for our last 8+2 *outbound* disconnects.\r\nSo, logging in ``anchors.dat`` all our outgoing conns all the time, and exchanging last block hash with top-8 (except currently connected) over N*(8+2) minutes.\r\n\r\nI would suggest to not mix this logic with tried/new table. *Tried* currently doesn't even imply we're on the same tip (that's a shame, I want to fix it soon). But even if we do sync tips, this would be a cheap way for an attacker to fill our ``anchors.dat``, so I want anchors to represent persistent conns.",
      "created_at" : "2019-11-01T15:28:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/issues/17326#issuecomment-548831247",
      "id" : 548831247,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17326",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0ODgzMTI0Nw==",
      "updated_at" : "2019-11-01T15:50:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/548831247",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   }
]
