[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#17639](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17639.html) (tests: Add \"make check-valgrind\" to run the unit tests under Valgrind. Fix uninitialized read in CWallet::CreateTransaction(...). by practicalswift)\n* [#17568](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17568.html) (wallet: fix when sufficient preset inputs and subtractFeeFromOutputs by achow101)\n* [#17566](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17566.html) (Switch to weight units for all feerates computation by darosior)\n* [#17211](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17211.html) (Allow fundrawtransaction and walletcreatefundedpsbt to take external inputs by achow101)\n* [#17208](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/17208.html) (Make all tests pass UBSan without using any UBSan suppressions by practicalswift)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2019-10-31T19:22:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17331#issuecomment-548530629",
      "id" : 548530629,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17331",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0ODUzMDYyOQ==",
      "updated_at" : "2019-11-30T19:31:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/548530629",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "concept ACK, unifying to effective value should make 95% of my consternation with Core coin selection go away by making further improvements easier.\r\n\r\nSo with this change another idea is to have an opt-in Single Random Draw(SRD) which should be pretty drop-in after this which would allow more experimentation with less systemic risk.",
      "created_at" : "2019-11-01T16:17:24Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17331#issuecomment-548849424",
      "id" : 548849424,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17331",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0ODg0OTQyNA==",
      "updated_at" : "2019-11-01T16:17:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/548849424",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK, thanks for making this code more understandable.",
      "created_at" : "2019-11-02T10:27:57Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17331#issuecomment-549030800",
      "id" : 549030800,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17331",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU0OTAzMDgwMA==",
      "updated_at" : "2019-11-02T10:27:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/549030800",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "node_id" : "MDQ6VXNlcjEyNjY0Ng==",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I think there's a bug in here somewhere. I ran some [simulations](https://gist.github.com/achow101/edf6b5e308035a489fbb1f28d12e2109) and it looks like there is a significant difference in some things (e.g. minimum change value) but it should be the same as master. I'm investigating that.\r\n\r\nEdit: I think I fixed it. Requires #17458 now.",
      "created_at" : "2019-11-13T00:10:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17331#issuecomment-553176319",
      "id" : 553176319,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17331",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU1MzE3NjMxOQ==",
      "updated_at" : "2019-11-13T23:57:08Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/553176319",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2019-11-22T20:02:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17331#issuecomment-557674166",
      "id" : 557674166,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17331",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU1NzY3NDE2Ng==",
      "updated_at" : "2019-11-22T20:02:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/557674166",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2019-12-01T19:13:10Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17331#issuecomment-560146729",
      "id" : 560146729,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/17331",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDU2MDE0NjcyOQ==",
      "updated_at" : "2019-12-01T19:13:10Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/560146729",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17331#discussion_r392244023"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17331"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/392244023"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "rename `target_value` to `actual_target` here as well?",
      "commit_id" : "ebe0c8072847cdc204159cb7abcc8a0ec1a29396",
      "created_at" : "2020-03-13T13:58:50Z",
      "diff_hunk" : "@@ -99,7 +99,7 @@ struct OutputGroup\n     OutputGroup GetPositiveOnlyGroup();\n };\n \n-bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& target_value, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret, CAmount not_input_fees);\n+bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& target_value, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17331#discussion_r392244023",
      "id" : 392244023,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI0NDAyMw==",
      "original_commit_id" : "e8a280b98de4d306f2a98caf59f558472108ebd6",
      "original_position" : 5,
      "path" : "src/wallet/coinselection.h",
      "position" : null,
      "pull_request_review_id" : 374320627,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17331",
      "updated_at" : "2020-03-13T16:03:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/392244023",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17331#discussion_r392248385"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17331"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/392248385"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "This looks like a debug print?",
      "commit_id" : "ebe0c8072847cdc204159cb7abcc8a0ec1a29396",
      "created_at" : "2020-03-13T14:06:02Z",
      "diff_hunk" : "@@ -2653,9 +2658,10 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n \n                 // Never create dust outputs; if we would, just\n                 // add the dust to the fee.\n-                // When nChange is less than the cost of the change output,\n-                // send it to fees (this means BnB was used)\n-                if (IsDust(newTxOut, discard_rate) || nChange <= cost_of_change)\n+                // When the selected_value is within the exact match range\n+                // (nValue + not_input_fees + cost_of_change), don't make change.\n+                WalletLogPrintf(\"%d %d %d %d %d\\n\", selected_eff, nValue, not_input_fees, cost_of_change, selected_value);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17331#discussion_r392248385",
      "id" : 392248385,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI0ODM4NQ==",
      "original_commit_id" : "aee449e028cfbde13ebfc10d34ea2a903c4dd9ba",
      "original_position" : 21,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 374320627,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17331",
      "updated_at" : "2020-03-13T16:03:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/392248385",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17331#discussion_r392258026"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17331"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/392258026"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Is this missing a `continue` here?",
      "commit_id" : "ebe0c8072847cdc204159cb7abcc8a0ec1a29396",
      "created_at" : "2020-03-13T14:22:13Z",
      "diff_hunk" : "@@ -2586,209 +2584,159 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n             CFeeRate discard_rate = GetDiscardRate(*this);\n \n             // Get the fee rate to use effective values in coin selection\n-            CFeeRate nFeeRateNeeded = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n+            coin_selection_params.effective_fee = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n \n             nFeeRet = 0;\n-            bool pick_new_inputs = true;\n-            CAmount nValueIn = 0;\n \n             coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n-            // Start with no fee and loop until there is enough fee\n-            while (true)\n-            {\n-                nChangePosInOut = nChangePosRequest;\n-                txNew.vin.clear();\n-                txNew.vout.clear();\n-                bool fFirst = true;\n \n-                CAmount nValueToSelect = nValue;\n-                if (nSubtractFeeFromAmount == 0)\n-                    nValueToSelect += nFeeRet;\n+            txNew.vin.clear();\n+            txNew.vout.clear();\n \n-                // vouts to the payees\n+            // vouts to the payees\n+            if (!coin_selection_params.m_subtract_fee_outputs) {\n+                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+            }\n+            for (const auto& recipient : vecSend)\n+            {\n+                CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+\n+                // Include the fee cost for outputs. Note this is only used for BnB right now\n                 if (!coin_selection_params.m_subtract_fee_outputs) {\n-                    coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n                 }\n-                for (const auto& recipient : vecSend)\n-                {\n-                    CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n \n-                    if (recipient.fSubtractFeeFromAmount)\n-                    {\n-                        assert(nSubtractFeeFromAmount != 0);\n-                        txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n-\n-                        if (fFirst) // first receiver pays the remainder not divisible by output count\n-                        {\n-                            fFirst = false;\n-                            txout.nValue -= nFeeRet % nSubtractFeeFromAmount;\n-                        }\n-                    }\n-                    // Include the fee cost for outputs. Note this is only used for BnB right now\n-                    if (!coin_selection_params.m_subtract_fee_outputs) {\n-                        coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n-                    }\n-\n-                    if (IsDust(txout, chain().relayDustFee()))\n+                if (IsDust(txout, chain().relayDustFee()))\n+                {\n+                    if (recipient.fSubtractFeeFromAmount && nFeeRet > 0)\n                     {\n-                        if (recipient.fSubtractFeeFromAmount && nFeeRet > 0)\n-                        {\n-                            if (txout.nValue < 0)\n-                                strFailReason = _(\"The transaction amount is too small to pay the fee\").translated;\n-                            else\n-                                strFailReason = _(\"The transaction amount is too small to send after the fee has been deducted\").translated;\n-                        }\n+                        if (txout.nValue < 0)\n+                            strFailReason = _(\"The transaction amount is too small to pay the fee\").translated;\n                         else\n-                            strFailReason = _(\"Transaction amount too small\").translated;\n-                        return false;\n+                            strFailReason = _(\"The transaction amount is too small to send after the fee has been deducted\").translated;\n                     }\n-                    txNew.vout.push_back(txout);\n+                    else\n+                        strFailReason = _(\"Transaction amount too small\").translated;\n+                    return false;\n                 }\n+                txNew.vout.push_back(txout);\n+            }\n \n-                // Choose coins to use\n-                if (pick_new_inputs) {\n-                    nValueIn = 0;\n-                    setCoins.clear();\n-                    int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n-                    // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n-                    // as lower-bound to allow BnB to do it's thing\n-                    if (change_spend_size == -1) {\n-                        coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n-                    } else {\n-                        coin_selection_params.change_spend_size = (size_t)change_spend_size;\n-                    }\n-                    coin_selection_params.effective_fee = nFeeRateNeeded;\n+            // Choose coins to use\n+            CAmount selected_value = 0;\n+            setCoins.clear();\n+            int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+            // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n+            // as lower-bound to allow BnB to do it's thing\n+            if (change_spend_size == -1) {\n+                coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n+            } else {\n+                coin_selection_params.change_spend_size = (size_t)change_spend_size;\n+            }\n \n-                    // Calculate the fees for things that aren't inputs\n-                    CAmount not_input_fees = coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size);\n+            // Calculate the fees for things that aren't inputs\n+            CAmount not_input_fees = coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size);\n \n-                    if (!SelectCoins(vAvailableCoins, nValueToSelect + not_input_fees, setCoins, nValueIn, coin_control, coin_selection_params))\n-                    {\n-                        strFailReason = _(\"Insufficient funds\").translated;\n-                        return false;\n-                    }\n-                }\n+            if (!SelectCoins(vAvailableCoins, nValue + not_input_fees, setCoins, selected_value, coin_control, coin_selection_params))\n+            {\n+                strFailReason = _(\"Insufficient funds\").translated;\n+                return false;\n+            }\n \n-                const CAmount nChange = nValueIn - nValueToSelect;\n-                if (nChange > 0)\n-                {\n-                    // Fill a vout to ourself\n-                    CTxOut newTxOut(nChange, scriptChange);\n+            const CAmount nChange = selected_value - nValue;\n+            if (nChange > 0)\n+            {\n+                // Fill a vout to ourself\n+                CTxOut newTxOut(nChange, scriptChange);\n \n-                    CAmount cost_of_change = 0;\n-                    if (pick_new_inputs) {\n-                        cost_of_change = GetDiscardRate(*this).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n-                    }\n+                CAmount cost_of_change = GetDiscardRate(*this).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n \n-                    // Never create dust outputs; if we would, just\n-                    // add the dust to the fee.\n-                    // When nChange is less than the cost of the change output,\n-                    // send it to fees (this means BnB was used)\n-                    if (IsDust(newTxOut, discard_rate) || nChange <= cost_of_change)\n+                // Never create dust outputs; if we would, just\n+                // add the dust to the fee.\n+                // When nChange is less than the cost of the change output,\n+                // send it to fees (this means BnB was used)\n+                if (IsDust(newTxOut, discard_rate) || nChange <= cost_of_change)\n+                {\n+                    nChangePosInOut = -1;\n+                    nFeeRet = nChange;\n+                }\n+                else\n+                {\n+                    if (nChangePosInOut == -1)\n                     {\n-                        nChangePosInOut = -1;\n-                        nFeeRet += nChange;\n+                        // Insert change txn at random position:\n+                        nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n                     }\n-                    else\n+                    else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n                     {\n-                        if (nChangePosInOut == -1)\n-                        {\n-                            // Insert change txn at random position:\n-                            nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n-                        }\n-                        else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n-                        {\n-                            strFailReason = _(\"Change index out of range\").translated;\n-                            return false;\n-                        }\n-\n-                        std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n-                        txNew.vout.insert(position, newTxOut);\n+                        strFailReason = _(\"Change index out of range\").translated;\n+                        return false;\n                     }\n-                } else {\n-                    nChangePosInOut = -1;\n-                }\n \n-                // Dummy fill vin for maximum size estimation\n-                //\n-                for (const auto& coin : setCoins) {\n-                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n-                }\n-\n-                nBytes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n-                if (nBytes < 0) {\n-                    strFailReason = _(\"Signing transaction failed\").translated;\n-                    return false;\n-                }\n-\n-                nFeeNeeded = GetMinimumFee(*this, nBytes, coin_control, &feeCalc);\n-                if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n-                    // eventually allow a fallback fee\n-                    strFailReason = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\").translated;\n-                    return false;\n+                    std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n+                    txNew.vout.insert(position, newTxOut);\n                 }\n+            } else {\n+                nChangePosInOut = -1;\n+            }\n \n-                if (nFeeRet >= nFeeNeeded) {\n-                    // Reduce fee to only the needed amount if possible. This\n-                    // prevents potential overpayment in fees if the coins\n-                    // selected to meet nFeeNeeded result in a transaction that\n-                    // requires less fee than the prior iteration.\n-\n-                    // If we have no change and a big enough excess fee, then\n-                    // try to construct transaction again only without picking\n-                    // new inputs. We now know we only need the smaller fee\n-                    // (because of reduced tx size) and so we should add a\n-                    // change output. Only try this once.\n-                    if (nChangePosInOut == -1 && nSubtractFeeFromAmount == 0 && pick_new_inputs) {\n-                        unsigned int tx_size_with_change = nBytes + coin_selection_params.change_output_size + 2; // Add 2 as a buffer in case increasing # of outputs changes compact size\n-                        CAmount fee_needed_with_change = GetMinimumFee(*this, tx_size_with_change, coin_control, nullptr);\n-                        CAmount minimum_value_for_change = GetDustThreshold(change_prototype_txout, discard_rate);\n-                        if (nFeeRet >= fee_needed_with_change + minimum_value_for_change) {\n-                            pick_new_inputs = false;\n-                            nFeeRet = fee_needed_with_change;\n-                            continue;\n-                        }\n-                    }\n+            // Dummy fill vin for maximum size estimation\n+            //\n+            for (const auto& coin : setCoins) {\n+                txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n+            }\n \n-                    // If we have change output already, just increase it\n-                    if (nFeeRet > nFeeNeeded && nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n-                        CAmount extraFeePaid = nFeeRet - nFeeNeeded;\n-                        std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n-                        change_position->nValue += extraFeePaid;\n-                        nFeeRet -= extraFeePaid;\n-                    }\n-                    break; // Done, enough fee included.\n-                }\n-                else if (!pick_new_inputs) {\n-                    // This shouldn't happen, we should have had enough excess\n-                    // fee to pay for the new output and still meet nFeeNeeded\n-                    // Or we should have just subtracted fee from recipients and\n-                    // nFeeNeeded should not have changed\n-                    strFailReason = _(\"Transaction fee and change calculation failed\").translated;\n-                    return false;\n-                }\n+            nBytes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+            if (nBytes < 0) {\n+                strFailReason = _(\"Signing transaction failed\").translated;\n+                return false;\n+            }\n \n+            CAmount fee_needed = GetMinimumFee(*this, nBytes, coin_control, &feeCalc);\n+            if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                strFailReason = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\").translated;\n+                return false;\n+            }\n+            if (nFeeRet < fee_needed) {\n+                nFeeRet = fee_needed;\n                 // Try to reduce change to include necessary fee\n                 if (nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n-                    CAmount additionalFeeNeeded = nFeeNeeded - nFeeRet;\n                     std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n-                    // Only reduce change if remaining amount is still a large enough output.\n-                    if (change_position->nValue >= MIN_FINAL_CHANGE + additionalFeeNeeded) {\n-                        change_position->nValue -= additionalFeeNeeded;\n-                        nFeeRet += additionalFeeNeeded;\n-                        break; // Done, able to increase fee from change\n+                    change_position->nValue -= nFeeRet;\n+                    // If the change is now dust, get rid of it\n+                    if (IsDust(*change_position, discard_rate))\n+                    {\n+                        nChangePosInOut = -1;\n+                        nFeeRet += change_position->nValue;\n+                        txNew.vout.erase(change_position);\n                     }\n                 }\n+                // Reduce output values for subtractFeeFromAmount\n+                if (nSubtractFeeFromAmount != 0) {\n+                    int i = 0;\n+                    bool fFirst = true;\n+                    for (const auto& recipient : vecSend)\n+                    {\n+                        if (i == nChangePosInOut) {\n+                            ++i;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17331#discussion_r392258026",
      "id" : 392258026,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI1ODAyNg==",
      "original_commit_id" : "cd2f48cd73e2adfc9f3cf086e9a47d65ecb03c07",
      "original_position" : 315,
      "path" : "src/wallet/wallet.cpp",
      "position" : 463,
      "pull_request_review_id" : 374320627,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17331",
      "updated_at" : "2020-03-13T16:03:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/392258026",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1322187?v=4",
         "events_url" : "https://api.github.com/users/fjahr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/fjahr/followers",
         "following_url" : "https://api.github.com/users/fjahr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/fjahr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/fjahr",
         "id" : 1322187,
         "login" : "fjahr",
         "node_id" : "MDQ6VXNlcjEzMjIxODc=",
         "organizations_url" : "https://api.github.com/users/fjahr/orgs",
         "received_events_url" : "https://api.github.com/users/fjahr/received_events",
         "repos_url" : "https://api.github.com/users/fjahr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/fjahr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/fjahr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/fjahr"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17331#discussion_r392302913"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17331"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/392302913"
         }
      },
      "author_association" : "MEMBER",
      "body" : "No. What this is doing is that we are skipping the index that is reserved for the change output. Doing `continue` would skip the current recipient which we definitely don't want to do.",
      "commit_id" : "ebe0c8072847cdc204159cb7abcc8a0ec1a29396",
      "created_at" : "2020-03-13T15:34:27Z",
      "diff_hunk" : "@@ -2586,209 +2584,159 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n             CFeeRate discard_rate = GetDiscardRate(*this);\n \n             // Get the fee rate to use effective values in coin selection\n-            CFeeRate nFeeRateNeeded = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n+            coin_selection_params.effective_fee = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n \n             nFeeRet = 0;\n-            bool pick_new_inputs = true;\n-            CAmount nValueIn = 0;\n \n             coin_selection_params.m_subtract_fee_outputs = nSubtractFeeFromAmount != 0; // If we are doing subtract fee from recipient, don't use effective values\n-            // Start with no fee and loop until there is enough fee\n-            while (true)\n-            {\n-                nChangePosInOut = nChangePosRequest;\n-                txNew.vin.clear();\n-                txNew.vout.clear();\n-                bool fFirst = true;\n \n-                CAmount nValueToSelect = nValue;\n-                if (nSubtractFeeFromAmount == 0)\n-                    nValueToSelect += nFeeRet;\n+            txNew.vin.clear();\n+            txNew.vout.clear();\n \n-                // vouts to the payees\n+            // vouts to the payees\n+            if (!coin_selection_params.m_subtract_fee_outputs) {\n+                coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+            }\n+            for (const auto& recipient : vecSend)\n+            {\n+                CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n+\n+                // Include the fee cost for outputs. Note this is only used for BnB right now\n                 if (!coin_selection_params.m_subtract_fee_outputs) {\n-                    coin_selection_params.tx_noinputs_size = 11; // Static vsize overhead + outputs vsize. 4 nVersion, 4 nLocktime, 1 input count, 1 output count, 1 witness overhead (dummy, flag, stack size)\n+                    coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n                 }\n-                for (const auto& recipient : vecSend)\n-                {\n-                    CTxOut txout(recipient.nAmount, recipient.scriptPubKey);\n \n-                    if (recipient.fSubtractFeeFromAmount)\n-                    {\n-                        assert(nSubtractFeeFromAmount != 0);\n-                        txout.nValue -= nFeeRet / nSubtractFeeFromAmount; // Subtract fee equally from each selected recipient\n-\n-                        if (fFirst) // first receiver pays the remainder not divisible by output count\n-                        {\n-                            fFirst = false;\n-                            txout.nValue -= nFeeRet % nSubtractFeeFromAmount;\n-                        }\n-                    }\n-                    // Include the fee cost for outputs. Note this is only used for BnB right now\n-                    if (!coin_selection_params.m_subtract_fee_outputs) {\n-                        coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n-                    }\n-\n-                    if (IsDust(txout, chain().relayDustFee()))\n+                if (IsDust(txout, chain().relayDustFee()))\n+                {\n+                    if (recipient.fSubtractFeeFromAmount && nFeeRet > 0)\n                     {\n-                        if (recipient.fSubtractFeeFromAmount && nFeeRet > 0)\n-                        {\n-                            if (txout.nValue < 0)\n-                                strFailReason = _(\"The transaction amount is too small to pay the fee\").translated;\n-                            else\n-                                strFailReason = _(\"The transaction amount is too small to send after the fee has been deducted\").translated;\n-                        }\n+                        if (txout.nValue < 0)\n+                            strFailReason = _(\"The transaction amount is too small to pay the fee\").translated;\n                         else\n-                            strFailReason = _(\"Transaction amount too small\").translated;\n-                        return false;\n+                            strFailReason = _(\"The transaction amount is too small to send after the fee has been deducted\").translated;\n                     }\n-                    txNew.vout.push_back(txout);\n+                    else\n+                        strFailReason = _(\"Transaction amount too small\").translated;\n+                    return false;\n                 }\n+                txNew.vout.push_back(txout);\n+            }\n \n-                // Choose coins to use\n-                if (pick_new_inputs) {\n-                    nValueIn = 0;\n-                    setCoins.clear();\n-                    int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n-                    // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n-                    // as lower-bound to allow BnB to do it's thing\n-                    if (change_spend_size == -1) {\n-                        coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n-                    } else {\n-                        coin_selection_params.change_spend_size = (size_t)change_spend_size;\n-                    }\n-                    coin_selection_params.effective_fee = nFeeRateNeeded;\n+            // Choose coins to use\n+            CAmount selected_value = 0;\n+            setCoins.clear();\n+            int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+            // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n+            // as lower-bound to allow BnB to do it's thing\n+            if (change_spend_size == -1) {\n+                coin_selection_params.change_spend_size = DUMMY_NESTED_P2WPKH_INPUT_SIZE;\n+            } else {\n+                coin_selection_params.change_spend_size = (size_t)change_spend_size;\n+            }\n \n-                    // Calculate the fees for things that aren't inputs\n-                    CAmount not_input_fees = coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size);\n+            // Calculate the fees for things that aren't inputs\n+            CAmount not_input_fees = coin_selection_params.effective_fee.GetFee(coin_selection_params.tx_noinputs_size);\n \n-                    if (!SelectCoins(vAvailableCoins, nValueToSelect + not_input_fees, setCoins, nValueIn, coin_control, coin_selection_params))\n-                    {\n-                        strFailReason = _(\"Insufficient funds\").translated;\n-                        return false;\n-                    }\n-                }\n+            if (!SelectCoins(vAvailableCoins, nValue + not_input_fees, setCoins, selected_value, coin_control, coin_selection_params))\n+            {\n+                strFailReason = _(\"Insufficient funds\").translated;\n+                return false;\n+            }\n \n-                const CAmount nChange = nValueIn - nValueToSelect;\n-                if (nChange > 0)\n-                {\n-                    // Fill a vout to ourself\n-                    CTxOut newTxOut(nChange, scriptChange);\n+            const CAmount nChange = selected_value - nValue;\n+            if (nChange > 0)\n+            {\n+                // Fill a vout to ourself\n+                CTxOut newTxOut(nChange, scriptChange);\n \n-                    CAmount cost_of_change = 0;\n-                    if (pick_new_inputs) {\n-                        cost_of_change = GetDiscardRate(*this).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n-                    }\n+                CAmount cost_of_change = GetDiscardRate(*this).GetFee(coin_selection_params.change_spend_size) + coin_selection_params.effective_fee.GetFee(coin_selection_params.change_output_size);\n \n-                    // Never create dust outputs; if we would, just\n-                    // add the dust to the fee.\n-                    // When nChange is less than the cost of the change output,\n-                    // send it to fees (this means BnB was used)\n-                    if (IsDust(newTxOut, discard_rate) || nChange <= cost_of_change)\n+                // Never create dust outputs; if we would, just\n+                // add the dust to the fee.\n+                // When nChange is less than the cost of the change output,\n+                // send it to fees (this means BnB was used)\n+                if (IsDust(newTxOut, discard_rate) || nChange <= cost_of_change)\n+                {\n+                    nChangePosInOut = -1;\n+                    nFeeRet = nChange;\n+                }\n+                else\n+                {\n+                    if (nChangePosInOut == -1)\n                     {\n-                        nChangePosInOut = -1;\n-                        nFeeRet += nChange;\n+                        // Insert change txn at random position:\n+                        nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n                     }\n-                    else\n+                    else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n                     {\n-                        if (nChangePosInOut == -1)\n-                        {\n-                            // Insert change txn at random position:\n-                            nChangePosInOut = GetRandInt(txNew.vout.size()+1);\n-                        }\n-                        else if ((unsigned int)nChangePosInOut > txNew.vout.size())\n-                        {\n-                            strFailReason = _(\"Change index out of range\").translated;\n-                            return false;\n-                        }\n-\n-                        std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n-                        txNew.vout.insert(position, newTxOut);\n+                        strFailReason = _(\"Change index out of range\").translated;\n+                        return false;\n                     }\n-                } else {\n-                    nChangePosInOut = -1;\n-                }\n \n-                // Dummy fill vin for maximum size estimation\n-                //\n-                for (const auto& coin : setCoins) {\n-                    txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n-                }\n-\n-                nBytes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n-                if (nBytes < 0) {\n-                    strFailReason = _(\"Signing transaction failed\").translated;\n-                    return false;\n-                }\n-\n-                nFeeNeeded = GetMinimumFee(*this, nBytes, coin_control, &feeCalc);\n-                if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n-                    // eventually allow a fallback fee\n-                    strFailReason = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\").translated;\n-                    return false;\n+                    std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n+                    txNew.vout.insert(position, newTxOut);\n                 }\n+            } else {\n+                nChangePosInOut = -1;\n+            }\n \n-                if (nFeeRet >= nFeeNeeded) {\n-                    // Reduce fee to only the needed amount if possible. This\n-                    // prevents potential overpayment in fees if the coins\n-                    // selected to meet nFeeNeeded result in a transaction that\n-                    // requires less fee than the prior iteration.\n-\n-                    // If we have no change and a big enough excess fee, then\n-                    // try to construct transaction again only without picking\n-                    // new inputs. We now know we only need the smaller fee\n-                    // (because of reduced tx size) and so we should add a\n-                    // change output. Only try this once.\n-                    if (nChangePosInOut == -1 && nSubtractFeeFromAmount == 0 && pick_new_inputs) {\n-                        unsigned int tx_size_with_change = nBytes + coin_selection_params.change_output_size + 2; // Add 2 as a buffer in case increasing # of outputs changes compact size\n-                        CAmount fee_needed_with_change = GetMinimumFee(*this, tx_size_with_change, coin_control, nullptr);\n-                        CAmount minimum_value_for_change = GetDustThreshold(change_prototype_txout, discard_rate);\n-                        if (nFeeRet >= fee_needed_with_change + minimum_value_for_change) {\n-                            pick_new_inputs = false;\n-                            nFeeRet = fee_needed_with_change;\n-                            continue;\n-                        }\n-                    }\n+            // Dummy fill vin for maximum size estimation\n+            //\n+            for (const auto& coin : setCoins) {\n+                txNew.vin.push_back(CTxIn(coin.outpoint,CScript()));\n+            }\n \n-                    // If we have change output already, just increase it\n-                    if (nFeeRet > nFeeNeeded && nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n-                        CAmount extraFeePaid = nFeeRet - nFeeNeeded;\n-                        std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n-                        change_position->nValue += extraFeePaid;\n-                        nFeeRet -= extraFeePaid;\n-                    }\n-                    break; // Done, enough fee included.\n-                }\n-                else if (!pick_new_inputs) {\n-                    // This shouldn't happen, we should have had enough excess\n-                    // fee to pay for the new output and still meet nFeeNeeded\n-                    // Or we should have just subtracted fee from recipients and\n-                    // nFeeNeeded should not have changed\n-                    strFailReason = _(\"Transaction fee and change calculation failed\").translated;\n-                    return false;\n-                }\n+            nBytes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+            if (nBytes < 0) {\n+                strFailReason = _(\"Signing transaction failed\").translated;\n+                return false;\n+            }\n \n+            CAmount fee_needed = GetMinimumFee(*this, nBytes, coin_control, &feeCalc);\n+            if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n+                // eventually allow a fallback fee\n+                strFailReason = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\").translated;\n+                return false;\n+            }\n+            if (nFeeRet < fee_needed) {\n+                nFeeRet = fee_needed;\n                 // Try to reduce change to include necessary fee\n                 if (nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n-                    CAmount additionalFeeNeeded = nFeeNeeded - nFeeRet;\n                     std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n-                    // Only reduce change if remaining amount is still a large enough output.\n-                    if (change_position->nValue >= MIN_FINAL_CHANGE + additionalFeeNeeded) {\n-                        change_position->nValue -= additionalFeeNeeded;\n-                        nFeeRet += additionalFeeNeeded;\n-                        break; // Done, able to increase fee from change\n+                    change_position->nValue -= nFeeRet;\n+                    // If the change is now dust, get rid of it\n+                    if (IsDust(*change_position, discard_rate))\n+                    {\n+                        nChangePosInOut = -1;\n+                        nFeeRet += change_position->nValue;\n+                        txNew.vout.erase(change_position);\n                     }\n                 }\n+                // Reduce output values for subtractFeeFromAmount\n+                if (nSubtractFeeFromAmount != 0) {\n+                    int i = 0;\n+                    bool fFirst = true;\n+                    for (const auto& recipient : vecSend)\n+                    {\n+                        if (i == nChangePosInOut) {\n+                            ++i;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17331#discussion_r392302913",
      "id" : 392302913,
      "in_reply_to_id" : 392258026,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMwMjkxMw==",
      "original_commit_id" : "cd2f48cd73e2adfc9f3cf086e9a47d65ecb03c07",
      "original_position" : 315,
      "path" : "src/wallet/wallet.cpp",
      "position" : 463,
      "pull_request_review_id" : 374398963,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17331",
      "updated_at" : "2020-03-13T16:03:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/392302913",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17331#discussion_r392303022"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17331"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/392303022"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Done",
      "commit_id" : "ebe0c8072847cdc204159cb7abcc8a0ec1a29396",
      "created_at" : "2020-03-13T15:34:38Z",
      "diff_hunk" : "@@ -99,7 +99,7 @@ struct OutputGroup\n     OutputGroup GetPositiveOnlyGroup();\n };\n \n-bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& target_value, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret, CAmount not_input_fees);\n+bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& target_value, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17331#discussion_r392303022",
      "id" : 392303022,
      "in_reply_to_id" : 392244023,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMwMzAyMg==",
      "original_commit_id" : "e8a280b98de4d306f2a98caf59f558472108ebd6",
      "original_position" : 5,
      "path" : "src/wallet/coinselection.h",
      "position" : null,
      "pull_request_review_id" : 374399102,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17331",
      "updated_at" : "2020-03-13T16:03:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/392303022",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17331#discussion_r392303083"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17331"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/392303083"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Removed",
      "commit_id" : "ebe0c8072847cdc204159cb7abcc8a0ec1a29396",
      "created_at" : "2020-03-13T15:34:44Z",
      "diff_hunk" : "@@ -2653,9 +2658,10 @@ bool CWallet::CreateTransaction(interfaces::Chain::Lock& locked_chain, const std\n \n                 // Never create dust outputs; if we would, just\n                 // add the dust to the fee.\n-                // When nChange is less than the cost of the change output,\n-                // send it to fees (this means BnB was used)\n-                if (IsDust(newTxOut, discard_rate) || nChange <= cost_of_change)\n+                // When the selected_value is within the exact match range\n+                // (nValue + not_input_fees + cost_of_change), don't make change.\n+                WalletLogPrintf(\"%d %d %d %d %d\\n\", selected_eff, nValue, not_input_fees, cost_of_change, selected_value);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17331#discussion_r392303083",
      "id" : 392303083,
      "in_reply_to_id" : 392248385,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMwMzA4Mw==",
      "original_commit_id" : "aee449e028cfbde13ebfc10d34ea2a903c4dd9ba",
      "original_position" : 21,
      "path" : "src/wallet/wallet.cpp",
      "position" : null,
      "pull_request_review_id" : 374399179,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17331",
      "updated_at" : "2020-03-13T16:03:56Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/392303083",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   }
]
