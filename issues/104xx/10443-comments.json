[
   {
      "body" : "This is interesting but still no comment.\r\n\r\nConcept ACK\r\n\r\nI'll play around with this a bit.\r\n\r\n```\r\nWshadow statistics: \r\n   1 policy/fees_input.cpp:127:23: warning: declaration shadows a local variable [-Wshadow]\r\n   1 policy/fees_input.cpp:197:38: warning: declaration shadows a local variable [-Wshadow]\r\n   1 policy/fees_input.cpp:229:22: warning: declaration shadows a local variable [-Wshadow]\r\n   1 policy/fees_input.cpp:233:27: warning: declaration shadows a local variable [-Wshadow]\r\n   1 policy/fees_input.cpp:27:61: warning: declaration shadows a field of 'CBlockPolicyInput' [-Wshadow]\r\n   1 test/fee_est/fee_est.cpp:301:34: warning: declaration shadows a local variable [-Wshadow]\r\n   1 test/fee_est/fee_est.cpp:79:20: warning: declaration shadows a field of 'TxData' [-Wshadow]\r\n   1 test/fee_est/fee_est.cpp:79:29: warning: declaration shadows a field of 'TxData' [-Wshadow]\r\n   1 test/fee_est/fee_est.cpp:79:39: warning: declaration shadows a field of 'TxData' [-Wshadow]\r\n```",
      "created_at" : "2017-06-13T20:46:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#issuecomment-308243389",
      "id" : 308243389,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10443",
      "updated_at" : "2017-06-13T20:46:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/308243389",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "When estimate log doesn't have enough data, `fee_est` is generating empty data in the HTML file. Emit some warning in such cases?\r\n",
      "created_at" : "2017-06-14T07:21:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#issuecomment-308342619",
      "id" : 308342619,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10443",
      "updated_at" : "2017-06-14T07:21:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/308342619",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "For perfect output, there should be 3rd dimension - time or current block height when the tx was first seen :-)",
      "created_at" : "2017-06-14T07:24:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#issuecomment-308343380",
      "id" : 308343380,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10443",
      "updated_at" : "2017-06-14T07:24:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/308343380",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/6848764?v=3",
         "events_url" : "https://api.github.com/users/paveljanik/events{/privacy}",
         "followers_url" : "https://api.github.com/users/paveljanik/followers",
         "following_url" : "https://api.github.com/users/paveljanik/following{/other_user}",
         "gists_url" : "https://api.github.com/users/paveljanik/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/paveljanik",
         "id" : 6848764,
         "login" : "paveljanik",
         "organizations_url" : "https://api.github.com/users/paveljanik/orgs",
         "received_events_url" : "https://api.github.com/users/paveljanik/received_events",
         "repos_url" : "https://api.github.com/users/paveljanik/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/paveljanik/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/paveljanik/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/paveljanik"
      }
   },
   {
      "body" : "Concept ACK. I think this could be a useful tool.\r\n\r\nCould this be split into two PRs to aid reviewers? The first PR would cover the `-estlog` option and writing the fee estimation data to disk. The second PR would be for a tool to read and graph the logs.\r\n\r\nParsing and graphing json files seems like a problem that has probably been solved many times before. If I was approaching this, I'd look at implementing this as a script in /contrib or a separate repository. Was there a particular reason you chose to implement this as a new C++ program?",
      "created_at" : "2017-06-28T12:05:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#issuecomment-311640095",
      "id" : 311640095,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10443",
      "updated_at" : "2017-06-28T12:05:12Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/311640095",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/1063656?v=3",
         "events_url" : "https://api.github.com/users/jnewbery/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jnewbery/followers",
         "following_url" : "https://api.github.com/users/jnewbery/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jnewbery/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jnewbery",
         "id" : 1063656,
         "login" : "jnewbery",
         "organizations_url" : "https://api.github.com/users/jnewbery/orgs",
         "received_events_url" : "https://api.github.com/users/jnewbery/received_events",
         "repos_url" : "https://api.github.com/users/jnewbery/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jnewbery/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jnewbery/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jnewbery"
      }
   },
   {
      "author_association" : "OWNER",
      "body" : "> Could this be split into two PRs to aid reviewers? The first PR would cover the -estlog option and writing the fee estimation data to disk. The second PR would be for a tool to read and graph the logs.\r\n\r\nI think this is useful.\r\n\r\nHowever I'm not sure the analysis tool belongs in this repository. As it's specific to developers debugging the fee estimation code it's not something we want to ship with the distribution, or install by default. One place it could be is e.g. https://github.com/bitcoin-core/bitcoin-maintainer-tools . You could still document or refer to it from here.",
      "created_at" : "2018-04-10T18:20:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#issuecomment-380199151",
      "id" : 380199151,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10443",
      "updated_at" : "2018-04-10T18:20:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/380199151",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Agree that fee_est tool shouldn't be installed, since it's a tool specifically for made for modifying and debugging fee estimation code.\r\n\r\nBut it would be awkward to use and maintain from a separate repository because it links and calls into the fee estimation code. (The tool works by piping historical data into the fee estimator so it's possible to make experimental changes to fee estimation and see how those changes affect its output and internal state.)\r\n\r\nAs far as build / distribution is concerned I think it makes sense to think of it more like a unit test or benchmark than like a maintainer tool.",
      "created_at" : "2018-04-10T18:53:12Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#issuecomment-380209281",
      "id" : 380209281,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10443",
      "updated_at" : "2018-04-10T18:54:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/380209281",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "OWNER",
      "body" : "> But it would be awkward to use and maintain from a separate repository because it links and calls into the fee estimation code. \r\n\r\nYes, I agree, that's unfortunately true. That part needs to stay in the repository with the rest of the code.\r\n\r\n> Parsing and graphing json files seems like a problem that has probably been solved many times before. If I was approaching this, I'd look at implementing this as a script in /contrib or a separate repository.\r\n\r\nI agree - especially with the references to cloudflare CDN and such. It feels a bit ugly to have that in the C++ code. Better to spit out e.g. JSON or CSV or whatever is convenient, then use a separate script for pretty formatting. This would also keep open the option of using different (non-web) visualization tools.\r\n",
      "created_at" : "2018-05-14T14:18:30Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#issuecomment-388833486",
      "id" : 388833486,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10443",
      "updated_at" : "2018-05-14T14:30:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/388833486",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/126646?v=4",
         "events_url" : "https://api.github.com/users/laanwj/events{/privacy}",
         "followers_url" : "https://api.github.com/users/laanwj/followers",
         "following_url" : "https://api.github.com/users/laanwj/following{/other_user}",
         "gists_url" : "https://api.github.com/users/laanwj/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/laanwj",
         "id" : 126646,
         "login" : "laanwj",
         "organizations_url" : "https://api.github.com/users/laanwj/orgs",
         "received_events_url" : "https://api.github.com/users/laanwj/received_events",
         "repos_url" : "https://api.github.com/users/laanwj/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/laanwj/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/laanwj"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--5d09a71f8925f3f132321140b44b946d-->The last travis run for this pull request was 54 days ago and is thus outdated. To trigger a fresh travis build, this pull request should be closed and re-opened.",
      "created_at" : "2018-07-29T15:18:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#issuecomment-408684675",
      "id" : 408684675,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10443",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQwODY4NDY3NQ==",
      "updated_at" : "2018-07-29T15:18:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/408684675",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r216699784"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/216699784"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-11 16:31:38 mdl(pr=10443): src/test/fee_est/README.md:8: MD034 Bare URL used\r\n2018-09-11 16:31:38 mdl(pr=10443): src/test/fee_est/README.md:9: MD034 Bare URL used\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-11T14:52:49Z",
      "diff_hunk" : "@@ -0,0 +1,37 @@\n+src/test/fee_est -- Fee estimation offline testing tool\n+=======================================================\n+\n+The `fee_est` tool is intended to help debug and test changes in bitcoin fee\n+estimation code using transaction data gathered from live bitcoin nodes.\n+\n+Transaction data can be collected by running bitcoind with `-estlog` parameter\n+which will produce newline-delimited json file (http://ndjson.org/,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r216699784",
      "id" : 216699784,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNjY5OTc4NA==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 8,
      "path" : "src/test/fee_est/README.md",
      "position" : null,
      "pull_request_review_id" : 154242217,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/216699784",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r217878986"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217878986"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Mod by zero here.",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-15T07:58:24Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <txmempool.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator,\n+    CTxMemPool& pool)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(std::move(fee));\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            int j = rand() % i;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r217878986",
      "id" : 217878986,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxNzg3ODk4Ng==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 177,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : null,
      "pull_request_review_id" : 155707084,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/217878986",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219422492"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219422492"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:48:56 clang-tidy(pr=10443): src/policy/fees.h:199:10: warning: function 'CBlockPolicyEstimator::processTx' has a definition with different parameter names [readability-inconsistent-declaration-parameter-name]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:37:49Z",
      "diff_hunk" : "@@ -190,11 +191,12 @@ class CBlockPolicyEstimator\n     ~CBlockPolicyEstimator();\n \n     /** Process all the transactions that have been included in a block */\n+    struct Block;\n     void processBlock(unsigned int nBlockHeight,\n-                      std::vector<const CTxMemPoolEntry*>& entries);\n+                      const std::function<void(Block&)> process_txs);\n \n     /** Process a transaction accepted to the mempool*/\n-    void processTransaction(const CTxMemPoolEntry& entry, bool validFeeEstimate);\n+    void processTx(const uint256& hash, unsigned int height, CAmount fee, size_t size, Block* block, bool valid);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219422492",
      "id" : 219422492,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMjQ5Mg==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 19,
      "path" : "src/policy/fees.h",
      "position" : null,
      "pull_request_review_id" : 157594261,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219422492",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219422569"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219422569"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:48:56 clang-tidy(pr=10443): src/policy/fees.cpp:17:5: warning: single-argument constructors must be marked explicit to avoid unintentional implicit conversions [google-explicit-constructor]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:38:07Z",
      "diff_hunk" : "@@ -9,11 +9,17 @@\n #include <clientversion.h>\n #include <primitives/transaction.h>\n #include <streams.h>\n-#include <txmempool.h>\n #include <util.h>\n \n static constexpr double INF_FEERATE = 1e99;\n \n+struct CBlockPolicyEstimator::Block {\n+    Block(int height) : height(height) {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219422569",
      "id" : 219422569,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMjU2OQ==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 10,
      "path" : "src/policy/fees.cpp",
      "position" : null,
      "pull_request_review_id" : 157594364,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219422569",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219422843"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219422843"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:48:56 clang-tidy(pr=10443): src/test/fee_est/fee_est.cpp:149:17: warning: parameter 'pool' is unused [misc-unused-parameters]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:39:10Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <txmempool.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator,\n+    CTxMemPool& pool)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219422843",
      "id" : 219422843,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMjg0Mw==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 149,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : null,
      "pull_request_review_id" : 157594739,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219422843",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219422905"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219422905"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:48:56 clang-tidy(pr=10443): src/test/fee_est/fee_est.cpp:163:28: warning: passing result of std::move() as a const reference argument; no move will actually happen [hicpp-move-const-arg]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:39:24Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <txmempool.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator,\n+    CTxMemPool& pool)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(std::move(fee));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219422905",
      "id" : 219422905,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMjkwNQ==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 163,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : null,
      "pull_request_review_id" : 157594814,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219422905",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423092"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423092"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:48:56 clang-tidy(pr=10443): src/test/fee_est/fee_est.cpp:177:21: warning: rand() has limited randomness; use C++11 random library instead [cert-msc30-c]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:40:03Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <txmempool.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator,\n+    CTxMemPool& pool)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(std::move(fee));\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            int j = rand() % i;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423092",
      "id" : 219423092,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMzA5Mg==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 177,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : null,
      "pull_request_review_id" : 157595078,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423092",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423154"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423154"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:48:56 clang-tidy(pr=10443): src/test/fee_est/fee_est.cpp:185:9: warning: the 'empty' method should be used to check for emptiness instead of 'size' [readability-container-size-empty]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:40:17Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <txmempool.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator,\n+    CTxMemPool& pool)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(std::move(fee));\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            int j = rand() % i;\n+            if (j < SAMPLE_TXS) {\n+                sample[j] = &entry;\n+            }\n+        }\n+        ++i;\n+    }\n+\n+    if (sample.size() > 0) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423154",
      "id" : 219423154,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMzE1NA==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 185,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : null,
      "pull_request_review_id" : 157595156,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423154",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423187"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423187"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:48:56 clang-tidy(pr=10443): src/test/fee_est/fee_est.cpp:205:31: warning: passing result of std::move() as a const reference argument; no move will actually happen [hicpp-move-const-arg]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:40:26Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <txmempool.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator,\n+    CTxMemPool& pool)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(std::move(fee));\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            int j = rand() % i;\n+            if (j < SAMPLE_TXS) {\n+                sample[j] = &entry;\n+            }\n+        }\n+        ++i;\n+    }\n+\n+    if (sample.size() > 0) {\n+        std::vector<int64_t> feeRates;\n+        feeRates.reserve(sample.size());\n+        for (const auto& entry : sample) {\n+            feeRates.emplace_back(CFeeRate(entry->second.fee, entry->second.size).GetFeePerK());\n+        }\n+        auto nth = feeRates.begin() + sample.size() / DROP_FRAC;\n+        std::nth_element(feeRates.begin(), nth, feeRates.end(), std::greater<int64_t>());\n+        maxFeeRate = std::max(maxFeeRate, *nth);\n+    }\n+\n+    UniValue txs(UniValue::VARR);\n+    for (const auto& entry : sample) {\n+        if (entry->second.actualBlocks > 0) {\n+            int64_t feeRate = CFeeRate(entry->second.fee, entry->second.size).GetFeePerK();\n+            if (feeRate <= maxFeeRate) {\n+                UniValue tx(UniValue::VOBJ);\n+                tx.pushKV(\"feeRate\", feeRate);\n+                tx.pushKV(\"blocks\", entry->second.actualBlocks);\n+                tx.pushKV(\"height\", entry->second.height);\n+                txs.push_back(std::move(tx));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423187",
      "id" : 219423187,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMzE4Nw==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 205,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : 207,
      "pull_request_review_id" : 157595205,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423187",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423229"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423229"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:48:56 clang-tidy(pr=10443): src/test/fee_est/fee_est.cpp:229:38: warning: parameter 'targets' is unused [misc-unused-parameters]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:40:35Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <txmempool.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator,\n+    CTxMemPool& pool)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(std::move(fee));\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            int j = rand() % i;\n+            if (j < SAMPLE_TXS) {\n+                sample[j] = &entry;\n+            }\n+        }\n+        ++i;\n+    }\n+\n+    if (sample.size() > 0) {\n+        std::vector<int64_t> feeRates;\n+        feeRates.reserve(sample.size());\n+        for (const auto& entry : sample) {\n+            feeRates.emplace_back(CFeeRate(entry->second.fee, entry->second.size).GetFeePerK());\n+        }\n+        auto nth = feeRates.begin() + sample.size() / DROP_FRAC;\n+        std::nth_element(feeRates.begin(), nth, feeRates.end(), std::greater<int64_t>());\n+        maxFeeRate = std::max(maxFeeRate, *nth);\n+    }\n+\n+    UniValue txs(UniValue::VARR);\n+    for (const auto& entry : sample) {\n+        if (entry->second.actualBlocks > 0) {\n+            int64_t feeRate = CFeeRate(entry->second.fee, entry->second.size).GetFeePerK();\n+            if (feeRate <= maxFeeRate) {\n+                UniValue tx(UniValue::VOBJ);\n+                tx.pushKV(\"feeRate\", feeRate);\n+                tx.pushKV(\"blocks\", entry->second.actualBlocks);\n+                tx.pushKV(\"height\", entry->second.height);\n+                txs.push_back(std::move(tx));\n+            }\n+        }\n+    }\n+\n+    std::ofstream file(filename);\n+    file << strprintf(GRAPH_HTML, txs.write(), fees.write());\n+}\n+\n+bool UpdateCross(TxMap::value_type& tx, const std::vector<unsigned int>& targets, CBlockPolicyEstimator& estimator)\n+{\n+    if (*tx.first.begin() == 0) {\n+        auto it = std::lower_bound(targets.begin(), targets.end(), nullptr, [&](unsigned int target, std::nullptr_t) {\n+            CAmount estFee = estimator.estimateSmartFee(target, nullptr /* feeCalc */, false /* conservative */)\n+                                 .GetFee(tx.second.size);\n+            return estFee <= 1 || tx.second.fee < estFee;\n+        });\n+        tx.second.expectedBlocks = it == targets.end() ? std::numeric_limits<int>::max() : *it;\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void PrintCross(const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423229",
      "id" : 219423229,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMzIyOQ==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 229,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : null,
      "pull_request_review_id" : 157595259,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423229",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423270"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423270"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:48:56 clang-tidy(pr=10443): src/test/fee_est/fee_est.cpp:230:28: warning: parameter 'estimator' is unused [misc-unused-parameters]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:40:44Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <txmempool.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator,\n+    CTxMemPool& pool)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(std::move(fee));\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            int j = rand() % i;\n+            if (j < SAMPLE_TXS) {\n+                sample[j] = &entry;\n+            }\n+        }\n+        ++i;\n+    }\n+\n+    if (sample.size() > 0) {\n+        std::vector<int64_t> feeRates;\n+        feeRates.reserve(sample.size());\n+        for (const auto& entry : sample) {\n+            feeRates.emplace_back(CFeeRate(entry->second.fee, entry->second.size).GetFeePerK());\n+        }\n+        auto nth = feeRates.begin() + sample.size() / DROP_FRAC;\n+        std::nth_element(feeRates.begin(), nth, feeRates.end(), std::greater<int64_t>());\n+        maxFeeRate = std::max(maxFeeRate, *nth);\n+    }\n+\n+    UniValue txs(UniValue::VARR);\n+    for (const auto& entry : sample) {\n+        if (entry->second.actualBlocks > 0) {\n+            int64_t feeRate = CFeeRate(entry->second.fee, entry->second.size).GetFeePerK();\n+            if (feeRate <= maxFeeRate) {\n+                UniValue tx(UniValue::VOBJ);\n+                tx.pushKV(\"feeRate\", feeRate);\n+                tx.pushKV(\"blocks\", entry->second.actualBlocks);\n+                tx.pushKV(\"height\", entry->second.height);\n+                txs.push_back(std::move(tx));\n+            }\n+        }\n+    }\n+\n+    std::ofstream file(filename);\n+    file << strprintf(GRAPH_HTML, txs.write(), fees.write());\n+}\n+\n+bool UpdateCross(TxMap::value_type& tx, const std::vector<unsigned int>& targets, CBlockPolicyEstimator& estimator)\n+{\n+    if (*tx.first.begin() == 0) {\n+        auto it = std::lower_bound(targets.begin(), targets.end(), nullptr, [&](unsigned int target, std::nullptr_t) {\n+            CAmount estFee = estimator.estimateSmartFee(target, nullptr /* feeCalc */, false /* conservative */)\n+                                 .GetFee(tx.second.size);\n+            return estFee <= 1 || tx.second.fee < estFee;\n+        });\n+        tx.second.expectedBlocks = it == targets.end() ? std::numeric_limits<int>::max() : *it;\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void PrintCross(const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator,",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423270",
      "id" : 219423270,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMzI3MA==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 230,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : null,
      "pull_request_review_id" : 157595312,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423270",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423297"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423297"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:48:56 clang-tidy(pr=10443): src/test/fee_est/fee_est.cpp:231:17: warning: parameter 'pool' is unused [misc-unused-parameters]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:40:52Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <txmempool.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator,\n+    CTxMemPool& pool)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(std::move(fee));\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            int j = rand() % i;\n+            if (j < SAMPLE_TXS) {\n+                sample[j] = &entry;\n+            }\n+        }\n+        ++i;\n+    }\n+\n+    if (sample.size() > 0) {\n+        std::vector<int64_t> feeRates;\n+        feeRates.reserve(sample.size());\n+        for (const auto& entry : sample) {\n+            feeRates.emplace_back(CFeeRate(entry->second.fee, entry->second.size).GetFeePerK());\n+        }\n+        auto nth = feeRates.begin() + sample.size() / DROP_FRAC;\n+        std::nth_element(feeRates.begin(), nth, feeRates.end(), std::greater<int64_t>());\n+        maxFeeRate = std::max(maxFeeRate, *nth);\n+    }\n+\n+    UniValue txs(UniValue::VARR);\n+    for (const auto& entry : sample) {\n+        if (entry->second.actualBlocks > 0) {\n+            int64_t feeRate = CFeeRate(entry->second.fee, entry->second.size).GetFeePerK();\n+            if (feeRate <= maxFeeRate) {\n+                UniValue tx(UniValue::VOBJ);\n+                tx.pushKV(\"feeRate\", feeRate);\n+                tx.pushKV(\"blocks\", entry->second.actualBlocks);\n+                tx.pushKV(\"height\", entry->second.height);\n+                txs.push_back(std::move(tx));\n+            }\n+        }\n+    }\n+\n+    std::ofstream file(filename);\n+    file << strprintf(GRAPH_HTML, txs.write(), fees.write());\n+}\n+\n+bool UpdateCross(TxMap::value_type& tx, const std::vector<unsigned int>& targets, CBlockPolicyEstimator& estimator)\n+{\n+    if (*tx.first.begin() == 0) {\n+        auto it = std::lower_bound(targets.begin(), targets.end(), nullptr, [&](unsigned int target, std::nullptr_t) {\n+            CAmount estFee = estimator.estimateSmartFee(target, nullptr /* feeCalc */, false /* conservative */)\n+                                 .GetFee(tx.second.size);\n+            return estFee <= 1 || tx.second.fee < estFee;\n+        });\n+        tx.second.expectedBlocks = it == targets.end() ? std::numeric_limits<int>::max() : *it;\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void PrintCross(const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator,\n+    CTxMemPool& pool)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423297",
      "id" : 219423297,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMzI5Nw==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 231,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : null,
      "pull_request_review_id" : 157595362,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423297",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423451"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423451"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:48:56 clang-tidy(pr=10443): src/policy/fees_input.h:33:10: warning: function 'FeeEstInput::removeTx' has a definition with different parameter names [readability-inconsistent-declaration-parameter-name]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:41:26Z",
      "diff_hunk" : "@@ -0,0 +1,55 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_POLICY_FEES_INPUT_H\n+#define BITCOIN_POLICY_FEES_INPUT_H\n+\n+#include <amount.h>\n+#include <fs.h>\n+\n+#include <map>\n+#include <memory>\n+#include <vector>\n+\n+class CAutoFile;\n+class CBlockPolicyEstimator;\n+class UniValue;\n+class uint256;\n+\n+class FeeEstInput\n+{\n+public:\n+    FeeEstInput(CBlockPolicyEstimator& estimator);\n+\n+    /** Process all the transactions that have been included in a block */\n+    struct Block;\n+    void processBlock(int height, const std::function<void(Block&)>& process_txs);\n+\n+    /** Process a transaction added the mempool or a block */\n+    void processTx(const uint256& hash, unsigned int height, CAmount fee, size_t size, Block* block, bool valid);\n+\n+    /** Remove a transaction from the mempool tracking stats */\n+    void removeTx(const uint256& hash, bool in_block);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423451",
      "id" : 219423451,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMzQ1MQ==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 33,
      "path" : "src/policy/fees_input.h",
      "position" : 33,
      "pull_request_review_id" : 157595545,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423451",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423558"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423558"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:48:56 clang-tidy(pr=10443): src/policy/fees_input.cpp:30:39: warning: passing result of std::move() as a const reference argument; no move will actually happen [hicpp-move-const-arg]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:41:48Z",
      "diff_hunk" : "@@ -0,0 +1,218 @@\n+#include <policy/fees_input.h>\n+\n+#include <chainparams.h>\n+#include <clientversion.h>\n+#include <policy/fees.h>\n+#include <streams.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+#include <utiltime.h>\n+\n+#include <univalue.h>\n+\n+struct FeeEstInput::Block {\n+    UniValue json_txs{UniValue::VARR};\n+    CBlockPolicyEstimator::Block* est_block = nullptr;\n+};\n+\n+FeeEstInput::FeeEstInput(CBlockPolicyEstimator& estimator) : estimator(estimator) {}\n+\n+void FeeEstInput::processTx(const uint256& hash, unsigned int height, CAmount fee, size_t size, Block* block, bool valid)\n+{\n+    estimator.processTx(hash, height, fee, size, block ? block->est_block : nullptr, valid);\n+    if (log) {\n+        UniValue tx(UniValue::VOBJ);\n+        tx.pushKV(\"hash\", hash.ToString());\n+        tx.pushKV(\"height\", int(height));\n+        tx.pushKV(\"fee\", fee);\n+        tx.pushKV(\"size\", uint64_t(size));\n+        if (block) {\n+            block->json_txs.push_back(std::move(tx));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423558",
      "id" : 219423558,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMzU1OA==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 30,
      "path" : "src/policy/fees_input.cpp",
      "position" : 39,
      "pull_request_review_id" : 157595685,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423558",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423610"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423610"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:48:56 clang-tidy(pr=10443): src/policy/fees_input.cpp:33:32: warning: passing result of std::move() as a const reference argument; no move will actually happen [hicpp-move-const-arg]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:41:57Z",
      "diff_hunk" : "@@ -0,0 +1,218 @@\n+#include <policy/fees_input.h>\n+\n+#include <chainparams.h>\n+#include <clientversion.h>\n+#include <policy/fees.h>\n+#include <streams.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+#include <utiltime.h>\n+\n+#include <univalue.h>\n+\n+struct FeeEstInput::Block {\n+    UniValue json_txs{UniValue::VARR};\n+    CBlockPolicyEstimator::Block* est_block = nullptr;\n+};\n+\n+FeeEstInput::FeeEstInput(CBlockPolicyEstimator& estimator) : estimator(estimator) {}\n+\n+void FeeEstInput::processTx(const uint256& hash, unsigned int height, CAmount fee, size_t size, Block* block, bool valid)\n+{\n+    estimator.processTx(hash, height, fee, size, block ? block->est_block : nullptr, valid);\n+    if (log) {\n+        UniValue tx(UniValue::VOBJ);\n+        tx.pushKV(\"hash\", hash.ToString());\n+        tx.pushKV(\"height\", int(height));\n+        tx.pushKV(\"fee\", fee);\n+        tx.pushKV(\"size\", uint64_t(size));\n+        if (block) {\n+            block->json_txs.push_back(std::move(tx));\n+        } else {\n+            UniValue value(UniValue::VOBJ);\n+            value.pushKV(\"tx\", std::move(tx));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423610",
      "id" : 219423610,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMzYxMA==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 33,
      "path" : "src/policy/fees_input.cpp",
      "position" : 42,
      "pull_request_review_id" : 157595736,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423610",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423710"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423710"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:48:56 clang-tidy(pr=10443): src/policy/fees_input.cpp:126:13: warning: use std::make_unique instead [modernize-make-unique]\r\n```\r\n\r\n`MakeUnique` in our case :-)",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:42:20Z",
      "diff_hunk" : "@@ -0,0 +1,218 @@\n+#include <policy/fees_input.h>\n+\n+#include <chainparams.h>\n+#include <clientversion.h>\n+#include <policy/fees.h>\n+#include <streams.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+#include <utiltime.h>\n+\n+#include <univalue.h>\n+\n+struct FeeEstInput::Block {\n+    UniValue json_txs{UniValue::VARR};\n+    CBlockPolicyEstimator::Block* est_block = nullptr;\n+};\n+\n+FeeEstInput::FeeEstInput(CBlockPolicyEstimator& estimator) : estimator(estimator) {}\n+\n+void FeeEstInput::processTx(const uint256& hash, unsigned int height, CAmount fee, size_t size, Block* block, bool valid)\n+{\n+    estimator.processTx(hash, height, fee, size, block ? block->est_block : nullptr, valid);\n+    if (log) {\n+        UniValue tx(UniValue::VOBJ);\n+        tx.pushKV(\"hash\", hash.ToString());\n+        tx.pushKV(\"height\", int(height));\n+        tx.pushKV(\"fee\", fee);\n+        tx.pushKV(\"size\", uint64_t(size));\n+        if (block) {\n+            block->json_txs.push_back(std::move(tx));\n+        } else {\n+            UniValue value(UniValue::VOBJ);\n+            value.pushKV(\"tx\", std::move(tx));\n+            value.pushKV(\"valid\", UniValue(valid));\n+            value.pushKV(\"time\", GetTime());\n+            *log << value.write() << std::endl;\n+        }\n+    }\n+}\n+\n+void FeeEstInput::processBlock(int height, const std::function<void(Block&)>& process_txs)\n+{\n+    Block block;\n+    estimator.processBlock(height, [&](CBlockPolicyEstimator::Block& est_block) {\n+        block.est_block = &est_block;\n+        process_txs(block);\n+    });\n+    if (log) {\n+        UniValue json(UniValue::VOBJ);\n+        UniValue json_block(UniValue::VOBJ);\n+        json_block.pushKV(\"height\", height);\n+        json.pushKV(\"block\", json_block);\n+        json.pushKV(\"txs\", block.json_txs);\n+        json.pushKV(\"time\", GetTime());\n+        *log << json.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::removeTx(const uint256& hash, bool inBlock)\n+{\n+    estimator.removeTx(hash, inBlock);\n+\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue removeTx(UniValue::VOBJ);\n+        removeTx.pushKV(\"hash\", hash.ToString());\n+        removeTx.pushKV(\"inBlock\", UniValue(inBlock));\n+        value.pushKV(\"removeTx\", removeTx);\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::flushUnconfirmed()\n+{\n+    estimator.FlushUnconfirmed();\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue flush(UniValue::VARR);\n+        value.pushKV(\"flush\", flush);\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+}\n+\n+bool FeeEstInput::writeData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"wb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull()) {\n+        LogPrintf(\"%s: Failed to write fee estimates to %s\\n\", __func__, filename.string());\n+        return false;\n+    }\n+    estimator.Write(file);\n+    return true;\n+}\n+\n+bool FeeEstInput::readData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"rb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull() || !estimator.Read(file)) {\n+        return false;\n+    }\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        std::ifstream file(filename.string(), std::ifstream::binary);\n+        value.pushKV(\n+            \"read\", HexStr(std::string(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>())));\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+    return true;\n+}\n+\n+bool FeeEstInput::writeLog(const std::string& filename)\n+{\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        value.pushKV(\"stop\", Params().NetworkIDString());\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+\n+    if (filename.empty()) {\n+        log.reset();\n+    } else {\n+        log.reset(new std::ofstream(filename, std::ofstream::out | std::ofstream::app));",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423710",
      "id" : 219423710,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMzcxMA==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 126,
      "path" : "src/policy/fees_input.cpp",
      "position" : null,
      "pull_request_review_id" : 157595866,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423710",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423856"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423856"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:48:56 clang-tidy(pr=10443): src/policy/fees_input.cpp:143:87: warning: the parameter 'filter' is copied for each invocation but only used as a const reference; consider making it a const reference [performance-unnecessary-value-param]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:42:53Z",
      "diff_hunk" : "@@ -0,0 +1,218 @@\n+#include <policy/fees_input.h>\n+\n+#include <chainparams.h>\n+#include <clientversion.h>\n+#include <policy/fees.h>\n+#include <streams.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+#include <utiltime.h>\n+\n+#include <univalue.h>\n+\n+struct FeeEstInput::Block {\n+    UniValue json_txs{UniValue::VARR};\n+    CBlockPolicyEstimator::Block* est_block = nullptr;\n+};\n+\n+FeeEstInput::FeeEstInput(CBlockPolicyEstimator& estimator) : estimator(estimator) {}\n+\n+void FeeEstInput::processTx(const uint256& hash, unsigned int height, CAmount fee, size_t size, Block* block, bool valid)\n+{\n+    estimator.processTx(hash, height, fee, size, block ? block->est_block : nullptr, valid);\n+    if (log) {\n+        UniValue tx(UniValue::VOBJ);\n+        tx.pushKV(\"hash\", hash.ToString());\n+        tx.pushKV(\"height\", int(height));\n+        tx.pushKV(\"fee\", fee);\n+        tx.pushKV(\"size\", uint64_t(size));\n+        if (block) {\n+            block->json_txs.push_back(std::move(tx));\n+        } else {\n+            UniValue value(UniValue::VOBJ);\n+            value.pushKV(\"tx\", std::move(tx));\n+            value.pushKV(\"valid\", UniValue(valid));\n+            value.pushKV(\"time\", GetTime());\n+            *log << value.write() << std::endl;\n+        }\n+    }\n+}\n+\n+void FeeEstInput::processBlock(int height, const std::function<void(Block&)>& process_txs)\n+{\n+    Block block;\n+    estimator.processBlock(height, [&](CBlockPolicyEstimator::Block& est_block) {\n+        block.est_block = &est_block;\n+        process_txs(block);\n+    });\n+    if (log) {\n+        UniValue json(UniValue::VOBJ);\n+        UniValue json_block(UniValue::VOBJ);\n+        json_block.pushKV(\"height\", height);\n+        json.pushKV(\"block\", json_block);\n+        json.pushKV(\"txs\", block.json_txs);\n+        json.pushKV(\"time\", GetTime());\n+        *log << json.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::removeTx(const uint256& hash, bool inBlock)\n+{\n+    estimator.removeTx(hash, inBlock);\n+\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue removeTx(UniValue::VOBJ);\n+        removeTx.pushKV(\"hash\", hash.ToString());\n+        removeTx.pushKV(\"inBlock\", UniValue(inBlock));\n+        value.pushKV(\"removeTx\", removeTx);\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::flushUnconfirmed()\n+{\n+    estimator.FlushUnconfirmed();\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue flush(UniValue::VARR);\n+        value.pushKV(\"flush\", flush);\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+}\n+\n+bool FeeEstInput::writeData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"wb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull()) {\n+        LogPrintf(\"%s: Failed to write fee estimates to %s\\n\", __func__, filename.string());\n+        return false;\n+    }\n+    estimator.Write(file);\n+    return true;\n+}\n+\n+bool FeeEstInput::readData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"rb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull() || !estimator.Read(file)) {\n+        return false;\n+    }\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        std::ifstream file(filename.string(), std::ifstream::binary);\n+        value.pushKV(\n+            \"read\", HexStr(std::string(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>())));\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+    return true;\n+}\n+\n+bool FeeEstInput::writeLog(const std::string& filename)\n+{\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        value.pushKV(\"stop\", Params().NetworkIDString());\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+\n+    if (filename.empty()) {\n+        log.reset();\n+    } else {\n+        log.reset(new std::ofstream(filename, std::ofstream::out | std::ofstream::app));\n+        if (!*log) {\n+            log.reset();\n+            return false;\n+        }\n+    }\n+\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        value.pushKV(\"start\", Params().NetworkIDString());\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+\n+    return true;\n+}\n+\n+bool FeeEstInput::readLog(const std::string& filename, std::function<bool(UniValue&)> filter)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423856",
      "id" : 219423856,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMzg1Ng==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 143,
      "path" : "src/policy/fees_input.cpp",
      "position" : null,
      "pull_request_review_id" : 157596039,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423856",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423905"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423905"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 04:48:56 clang-tidy(pr=10443): src/policy/fees_input.cpp:198:13: warning: consider replacing 'unsigned short' with 'uint16' [google-runtime-int]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:43:06Z",
      "diff_hunk" : "@@ -0,0 +1,218 @@\n+#include <policy/fees_input.h>\n+\n+#include <chainparams.h>\n+#include <clientversion.h>\n+#include <policy/fees.h>\n+#include <streams.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+#include <utiltime.h>\n+\n+#include <univalue.h>\n+\n+struct FeeEstInput::Block {\n+    UniValue json_txs{UniValue::VARR};\n+    CBlockPolicyEstimator::Block* est_block = nullptr;\n+};\n+\n+FeeEstInput::FeeEstInput(CBlockPolicyEstimator& estimator) : estimator(estimator) {}\n+\n+void FeeEstInput::processTx(const uint256& hash, unsigned int height, CAmount fee, size_t size, Block* block, bool valid)\n+{\n+    estimator.processTx(hash, height, fee, size, block ? block->est_block : nullptr, valid);\n+    if (log) {\n+        UniValue tx(UniValue::VOBJ);\n+        tx.pushKV(\"hash\", hash.ToString());\n+        tx.pushKV(\"height\", int(height));\n+        tx.pushKV(\"fee\", fee);\n+        tx.pushKV(\"size\", uint64_t(size));\n+        if (block) {\n+            block->json_txs.push_back(std::move(tx));\n+        } else {\n+            UniValue value(UniValue::VOBJ);\n+            value.pushKV(\"tx\", std::move(tx));\n+            value.pushKV(\"valid\", UniValue(valid));\n+            value.pushKV(\"time\", GetTime());\n+            *log << value.write() << std::endl;\n+        }\n+    }\n+}\n+\n+void FeeEstInput::processBlock(int height, const std::function<void(Block&)>& process_txs)\n+{\n+    Block block;\n+    estimator.processBlock(height, [&](CBlockPolicyEstimator::Block& est_block) {\n+        block.est_block = &est_block;\n+        process_txs(block);\n+    });\n+    if (log) {\n+        UniValue json(UniValue::VOBJ);\n+        UniValue json_block(UniValue::VOBJ);\n+        json_block.pushKV(\"height\", height);\n+        json.pushKV(\"block\", json_block);\n+        json.pushKV(\"txs\", block.json_txs);\n+        json.pushKV(\"time\", GetTime());\n+        *log << json.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::removeTx(const uint256& hash, bool inBlock)\n+{\n+    estimator.removeTx(hash, inBlock);\n+\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue removeTx(UniValue::VOBJ);\n+        removeTx.pushKV(\"hash\", hash.ToString());\n+        removeTx.pushKV(\"inBlock\", UniValue(inBlock));\n+        value.pushKV(\"removeTx\", removeTx);\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::flushUnconfirmed()\n+{\n+    estimator.FlushUnconfirmed();\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue flush(UniValue::VARR);\n+        value.pushKV(\"flush\", flush);\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+}\n+\n+bool FeeEstInput::writeData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"wb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull()) {\n+        LogPrintf(\"%s: Failed to write fee estimates to %s\\n\", __func__, filename.string());\n+        return false;\n+    }\n+    estimator.Write(file);\n+    return true;\n+}\n+\n+bool FeeEstInput::readData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"rb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull() || !estimator.Read(file)) {\n+        return false;\n+    }\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        std::ifstream file(filename.string(), std::ifstream::binary);\n+        value.pushKV(\n+            \"read\", HexStr(std::string(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>())));\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+    return true;\n+}\n+\n+bool FeeEstInput::writeLog(const std::string& filename)\n+{\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        value.pushKV(\"stop\", Params().NetworkIDString());\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+\n+    if (filename.empty()) {\n+        log.reset();\n+    } else {\n+        log.reset(new std::ofstream(filename, std::ofstream::out | std::ofstream::app));\n+        if (!*log) {\n+            log.reset();\n+            return false;\n+        }\n+    }\n+\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        value.pushKV(\"start\", Params().NetworkIDString());\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+\n+    return true;\n+}\n+\n+bool FeeEstInput::readLog(const std::string& filename, std::function<bool(UniValue&)> filter)\n+{\n+    std::ifstream file(filename);\n+    if (!file) {\n+        LogPrintf(\"%s: Failed to open log file %s\\n\", __func__, filename);\n+        return false;\n+    }\n+\n+    std::string line;\n+    while (std::getline(file, line)) {\n+        UniValue value;\n+        if (!value.read(line)) {\n+            throw std::runtime_error(\"Failed to parse fee estimate log line.\");\n+        }\n+\n+        if (filter && !filter(value)) {\n+            continue;\n+        }\n+\n+        const UniValue& tx = value[\"tx\"];\n+        if (tx.isObject()) {\n+            estimator.processTx(uint256S(tx[\"hash\"].get_str()), tx[\"height\"].get_int(), tx[\"fee\"].get_int64(),\n+                tx[\"size\"].get_int(), nullptr /* block */, value[\"valid\"].get_bool());\n+            continue;\n+        }\n+\n+        const UniValue& block = value[\"block\"];\n+        if (block.isObject()) {\n+            int height = block[\"height\"].get_int();\n+            estimator.processBlock(height, [&](CBlockPolicyEstimator::Block& est_block) {\n+                const auto& txs = value[\"txs\"].getValues();\n+                for (const UniValue& tx : txs) {\n+                    estimator.processTx(uint256S(tx[\"hash\"].get_str()), tx[\"height\"].get_int(),\n+                        tx[\"fee\"].get_int64(), tx[\"size\"].get_int(), &est_block, true /* valid */);\n+                }\n+                return txs.size();\n+            });\n+            continue;\n+        }\n+\n+        const UniValue& removeTx = value[\"removeTx\"];\n+        if (removeTx.isObject()) {\n+            estimator.removeTx(uint256S(removeTx[\"hash\"].get_str()), removeTx[\"inBlock\"].get_bool());\n+            continue;\n+        }\n+\n+        const UniValue& flush = value[\"flush\"];\n+        if (flush.isArray()) {\n+            estimator.FlushUnconfirmed();\n+            continue;\n+        }\n+\n+        const UniValue& read = value[\"read\"];\n+        if (read.isStr()) {\n+            std::vector<unsigned char> data = ParseHex(read.get_str());\n+            unsigned short randv = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219423905",
      "id" : 219423905,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyMzkwNQ==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 198,
      "path" : "src/policy/fees_input.cpp",
      "position" : null,
      "pull_request_review_id" : 157596111,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219423905",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219424018"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219424018"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 05:13:44 cppcheck(pr=10443): [src/policy/fees_input.h:23]: (style) Class 'FeeEstInput' has a constructor with 1 argument that is not explicit.\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:43:28Z",
      "diff_hunk" : "@@ -0,0 +1,55 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_POLICY_FEES_INPUT_H\n+#define BITCOIN_POLICY_FEES_INPUT_H\n+\n+#include <amount.h>\n+#include <fs.h>\n+\n+#include <map>\n+#include <memory>\n+#include <vector>\n+\n+class CAutoFile;\n+class CBlockPolicyEstimator;\n+class UniValue;\n+class uint256;\n+\n+class FeeEstInput\n+{\n+public:\n+    FeeEstInput(CBlockPolicyEstimator& estimator);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219424018",
      "id" : 219424018,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyNDAxOA==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 23,
      "path" : "src/policy/fees_input.h",
      "position" : null,
      "pull_request_review_id" : 157596252,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219424018",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219424086"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219424086"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-20 05:13:44 cppcheck(pr=10443): [src/policy/fees.cpp:17]: (style) Struct 'Block' has a constructor with 1 argument that is not explicit.\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-21T08:43:43Z",
      "diff_hunk" : "@@ -9,11 +9,17 @@\n #include <clientversion.h>\n #include <primitives/transaction.h>\n #include <streams.h>\n-#include <txmempool.h>\n #include <util.h>\n \n static constexpr double INF_FEERATE = 1e99;\n \n+struct CBlockPolicyEstimator::Block {\n+    Block(int height) : height(height) {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219424086",
      "id" : 219424086,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTQyNDA4Ng==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 10,
      "path" : "src/policy/fees.cpp",
      "position" : null,
      "pull_request_review_id" : 157596329,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219424086",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#14224](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14224.html) (Document intentional and unintentional unsigned integer overflows (wraparounds) using annotations by practicalswift)\n* [#14111](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14111.html) (index: Create IndexRunner class for activing indexes. by jimpo)\n* [#13949](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/13949.html) (Introduce MempoolObserver interface to break \"policy/fees -> txmempool -> policy/fees\" circular dependency by Empact)\n* [#13804](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/13804.html) (WIP: Transaction Pool Layer by MarcoFalke)\n* [#13189](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/13189.html) (Remove 2nd mapTx lookup in CTxMemPool::removeForBlock by promag)\n* [#13128](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/13128.html) (policy: Add Clang thread safety annotations for variables guarded by cs_feeEstimator by practicalswift)\n* [#13088](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/13088.html) (Log early messages with -printtoconsole by ajtowns)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-09-21T13:33:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#issuecomment-423532381",
      "id" : 423532381,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10443",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyMzUzMjM4MQ==",
      "updated_at" : "2018-11-06T23:08:57Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/423532381",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219691822"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691822"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-22 22:51:38 cpplint(pr=10443): src/policy/fees.cpp:17:  Single-parameter constructors should be marked explicit.  [runtime/explicit] [5]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-23T08:25:35Z",
      "diff_hunk" : "@@ -9,11 +9,17 @@\n #include <clientversion.h>\n #include <primitives/transaction.h>\n #include <streams.h>\n-#include <txmempool.h>\n #include <util.h>\n \n static constexpr double INF_FEERATE = 1e99;\n \n+struct CBlockPolicyEstimator::Block {\n+    Block(int height) : height(height) {}",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219691822",
      "id" : 219691822,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTY5MTgyMg==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 10,
      "path" : "src/policy/fees.cpp",
      "position" : null,
      "pull_request_review_id" : 157932420,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691822",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219691831"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691831"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-22 22:51:38 cpplint(pr=10443): src/policy/fees_input.cpp:0:  No copyright message found.\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-23T08:25:54Z",
      "diff_hunk" : "@@ -0,0 +1,218 @@\n+#include <policy/fees_input.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219691831",
      "id" : 219691831,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTY5MTgzMQ==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 1,
      "path" : "src/policy/fees_input.cpp",
      "position" : 5,
      "pull_request_review_id" : 157932426,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691831",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219691848"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691848"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-22 22:51:38 cpplint(pr=10443): src/policy/fees_input.cpp:198:  Use int16/int64/etc, rather than the C type short  [runtime/int] [4]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-23T08:26:48Z",
      "diff_hunk" : "@@ -0,0 +1,218 @@\n+#include <policy/fees_input.h>\n+\n+#include <chainparams.h>\n+#include <clientversion.h>\n+#include <policy/fees.h>\n+#include <streams.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+#include <utiltime.h>\n+\n+#include <univalue.h>\n+\n+struct FeeEstInput::Block {\n+    UniValue json_txs{UniValue::VARR};\n+    CBlockPolicyEstimator::Block* est_block = nullptr;\n+};\n+\n+FeeEstInput::FeeEstInput(CBlockPolicyEstimator& estimator) : estimator(estimator) {}\n+\n+void FeeEstInput::processTx(const uint256& hash, unsigned int height, CAmount fee, size_t size, Block* block, bool valid)\n+{\n+    estimator.processTx(hash, height, fee, size, block ? block->est_block : nullptr, valid);\n+    if (log) {\n+        UniValue tx(UniValue::VOBJ);\n+        tx.pushKV(\"hash\", hash.ToString());\n+        tx.pushKV(\"height\", int(height));\n+        tx.pushKV(\"fee\", fee);\n+        tx.pushKV(\"size\", uint64_t(size));\n+        if (block) {\n+            block->json_txs.push_back(std::move(tx));\n+        } else {\n+            UniValue value(UniValue::VOBJ);\n+            value.pushKV(\"tx\", std::move(tx));\n+            value.pushKV(\"valid\", UniValue(valid));\n+            value.pushKV(\"time\", GetTime());\n+            *log << value.write() << std::endl;\n+        }\n+    }\n+}\n+\n+void FeeEstInput::processBlock(int height, const std::function<void(Block&)>& process_txs)\n+{\n+    Block block;\n+    estimator.processBlock(height, [&](CBlockPolicyEstimator::Block& est_block) {\n+        block.est_block = &est_block;\n+        process_txs(block);\n+    });\n+    if (log) {\n+        UniValue json(UniValue::VOBJ);\n+        UniValue json_block(UniValue::VOBJ);\n+        json_block.pushKV(\"height\", height);\n+        json.pushKV(\"block\", json_block);\n+        json.pushKV(\"txs\", block.json_txs);\n+        json.pushKV(\"time\", GetTime());\n+        *log << json.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::removeTx(const uint256& hash, bool inBlock)\n+{\n+    estimator.removeTx(hash, inBlock);\n+\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue removeTx(UniValue::VOBJ);\n+        removeTx.pushKV(\"hash\", hash.ToString());\n+        removeTx.pushKV(\"inBlock\", UniValue(inBlock));\n+        value.pushKV(\"removeTx\", removeTx);\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::flushUnconfirmed()\n+{\n+    estimator.FlushUnconfirmed();\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue flush(UniValue::VARR);\n+        value.pushKV(\"flush\", flush);\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+}\n+\n+bool FeeEstInput::writeData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"wb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull()) {\n+        LogPrintf(\"%s: Failed to write fee estimates to %s\\n\", __func__, filename.string());\n+        return false;\n+    }\n+    estimator.Write(file);\n+    return true;\n+}\n+\n+bool FeeEstInput::readData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"rb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull() || !estimator.Read(file)) {\n+        return false;\n+    }\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        std::ifstream file(filename.string(), std::ifstream::binary);\n+        value.pushKV(\n+            \"read\", HexStr(std::string(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>())));\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+    return true;\n+}\n+\n+bool FeeEstInput::writeLog(const std::string& filename)\n+{\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        value.pushKV(\"stop\", Params().NetworkIDString());\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+\n+    if (filename.empty()) {\n+        log.reset();\n+    } else {\n+        log.reset(new std::ofstream(filename, std::ofstream::out | std::ofstream::app));\n+        if (!*log) {\n+            log.reset();\n+            return false;\n+        }\n+    }\n+\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        value.pushKV(\"start\", Params().NetworkIDString());\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+\n+    return true;\n+}\n+\n+bool FeeEstInput::readLog(const std::string& filename, std::function<bool(UniValue&)> filter)\n+{\n+    std::ifstream file(filename);\n+    if (!file) {\n+        LogPrintf(\"%s: Failed to open log file %s\\n\", __func__, filename);\n+        return false;\n+    }\n+\n+    std::string line;\n+    while (std::getline(file, line)) {\n+        UniValue value;\n+        if (!value.read(line)) {\n+            throw std::runtime_error(\"Failed to parse fee estimate log line.\");\n+        }\n+\n+        if (filter && !filter(value)) {\n+            continue;\n+        }\n+\n+        const UniValue& tx = value[\"tx\"];\n+        if (tx.isObject()) {\n+            estimator.processTx(uint256S(tx[\"hash\"].get_str()), tx[\"height\"].get_int(), tx[\"fee\"].get_int64(),\n+                tx[\"size\"].get_int(), nullptr /* block */, value[\"valid\"].get_bool());\n+            continue;\n+        }\n+\n+        const UniValue& block = value[\"block\"];\n+        if (block.isObject()) {\n+            int height = block[\"height\"].get_int();\n+            estimator.processBlock(height, [&](CBlockPolicyEstimator::Block& est_block) {\n+                const auto& txs = value[\"txs\"].getValues();\n+                for (const UniValue& tx : txs) {\n+                    estimator.processTx(uint256S(tx[\"hash\"].get_str()), tx[\"height\"].get_int(),\n+                        tx[\"fee\"].get_int64(), tx[\"size\"].get_int(), &est_block, true /* valid */);\n+                }\n+                return txs.size();\n+            });\n+            continue;\n+        }\n+\n+        const UniValue& removeTx = value[\"removeTx\"];\n+        if (removeTx.isObject()) {\n+            estimator.removeTx(uint256S(removeTx[\"hash\"].get_str()), removeTx[\"inBlock\"].get_bool());\n+            continue;\n+        }\n+\n+        const UniValue& flush = value[\"flush\"];\n+        if (flush.isArray()) {\n+            estimator.FlushUnconfirmed();\n+            continue;\n+        }\n+\n+        const UniValue& read = value[\"read\"];\n+        if (read.isStr()) {\n+            std::vector<unsigned char> data = ParseHex(read.get_str());\n+            unsigned short randv = 0;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219691848",
      "id" : 219691848,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTY5MTg0OA==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 198,
      "path" : "src/policy/fees_input.cpp",
      "position" : null,
      "pull_request_review_id" : 157932444,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691848",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219691867"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691867"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-22 22:51:38 cpplint(pr=10443): src/policy/fees_input.h:23:  Single-parameter constructors should be marked explicit.  [runtime/explicit] [5]\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-23T08:27:39Z",
      "diff_hunk" : "@@ -0,0 +1,55 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_POLICY_FEES_INPUT_H\n+#define BITCOIN_POLICY_FEES_INPUT_H\n+\n+#include <amount.h>\n+#include <fs.h>\n+\n+#include <map>\n+#include <memory>\n+#include <vector>\n+\n+class CAutoFile;\n+class CBlockPolicyEstimator;\n+class UniValue;\n+class uint256;\n+\n+class FeeEstInput\n+{\n+public:\n+    FeeEstInput(CBlockPolicyEstimator& estimator);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219691867",
      "id" : 219691867,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTY5MTg2Nw==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 23,
      "path" : "src/policy/fees_input.h",
      "position" : null,
      "pull_request_review_id" : 157932466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691867",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219691876"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691876"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```\r\n2018-09-22 22:51:38 cpplint(pr=10443): src/test/fee_est/fee_est.cpp:0:  No copyright message found.\r\n```",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-09-23T08:28:05Z",
      "diff_hunk" : "@@ -0,0 +1,332 @@\n+#include <policy/fees.h>",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r219691876",
      "id" : 219691876,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIxOTY5MTg3Ng==",
      "original_commit_id" : "8cd1bb684bfec22fc54e091dc96c782a26847393",
      "original_position" : 1,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : 5,
      "pull_request_review_id" : 157932474,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/219691876",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-09-24T22:24:15Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#issuecomment-424145518",
      "id" : 424145518,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10443",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQyNDE0NTUxOA==",
      "updated_at" : "2018-09-24T22:24:15Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/424145518",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224318978"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224318978"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Isn't `height` guaranteed to be non-negative? Should be `unsigned int`?",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-10-11T05:32:58Z",
      "diff_hunk" : "@@ -0,0 +1,55 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_POLICY_FEES_INPUT_H\n+#define BITCOIN_POLICY_FEES_INPUT_H\n+\n+#include <amount.h>\n+#include <fs.h>\n+\n+#include <map>\n+#include <memory>\n+#include <vector>\n+\n+class CAutoFile;\n+class CBlockPolicyEstimator;\n+class UniValue;\n+class uint256;\n+\n+class FeeEstInput\n+{\n+public:\n+    explicit FeeEstInput(CBlockPolicyEstimator& estimator);\n+\n+    /** Process all the transactions that have been included in a block */\n+    struct Block;\n+    void processBlock(int height, const std::function<void(Block&)>& process_txs);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224318978",
      "id" : 224318978,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMxODk3OA==",
      "original_commit_id" : "56446378f5d0c2bdeb7a45fa7382ccd58c9b994c",
      "original_position" : 27,
      "path" : "src/policy/fees_input.h",
      "position" : null,
      "pull_request_review_id" : 163654386,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224318978",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319126"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319126"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The variable `file` shadows an already existing local variable. Please choose another name :-)",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-10-11T05:34:13Z",
      "diff_hunk" : "@@ -0,0 +1,222 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees_input.h>\n+\n+#include <chainparams.h>\n+#include <clientversion.h>\n+#include <policy/fees.h>\n+#include <streams.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+#include <utiltime.h>\n+\n+#include <univalue.h>\n+\n+struct FeeEstInput::Block {\n+    UniValue json_txs{UniValue::VARR};\n+    CBlockPolicyEstimator::Block* est_block = nullptr;\n+};\n+\n+FeeEstInput::FeeEstInput(CBlockPolicyEstimator& estimator) : estimator(estimator) {}\n+\n+void FeeEstInput::processTx(const uint256& hash, unsigned int height, CAmount fee, size_t size, Block* block, bool valid)\n+{\n+    estimator.processTx(hash, height, fee, size, block ? block->est_block : nullptr, valid);\n+    if (log) {\n+        UniValue tx(UniValue::VOBJ);\n+        tx.pushKV(\"hash\", hash.ToString());\n+        tx.pushKV(\"height\", int(height));\n+        tx.pushKV(\"fee\", fee);\n+        tx.pushKV(\"size\", uint64_t(size));\n+        if (block) {\n+            block->json_txs.push_back(std::move(tx));\n+        } else {\n+            UniValue value(UniValue::VOBJ);\n+            value.pushKV(\"tx\", std::move(tx));\n+            value.pushKV(\"valid\", UniValue(valid));\n+            value.pushKV(\"time\", GetTime());\n+            *log << value.write() << std::endl;\n+        }\n+    }\n+}\n+\n+void FeeEstInput::processBlock(int height, const std::function<void(Block&)>& process_txs)\n+{\n+    Block block;\n+    estimator.processBlock(height, [&](CBlockPolicyEstimator::Block& est_block) {\n+        block.est_block = &est_block;\n+        process_txs(block);\n+    });\n+    if (log) {\n+        UniValue json(UniValue::VOBJ);\n+        UniValue json_block(UniValue::VOBJ);\n+        json_block.pushKV(\"height\", height);\n+        json.pushKV(\"block\", json_block);\n+        json.pushKV(\"txs\", block.json_txs);\n+        json.pushKV(\"time\", GetTime());\n+        *log << json.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::removeTx(const uint256& hash, bool in_block)\n+{\n+    estimator.removeTx(hash, in_block);\n+\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue removeTx(UniValue::VOBJ);\n+        removeTx.pushKV(\"hash\", hash.ToString());\n+        removeTx.pushKV(\"inBlock\", UniValue(in_block));\n+        value.pushKV(\"removeTx\", removeTx);\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::flushUnconfirmed()\n+{\n+    estimator.FlushUnconfirmed();\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue flush(UniValue::VARR);\n+        value.pushKV(\"flush\", flush);\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+}\n+\n+bool FeeEstInput::writeData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"wb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull()) {\n+        LogPrintf(\"%s: Failed to write fee estimates to %s\\n\", __func__, filename.string());\n+        return false;\n+    }\n+    estimator.Write(file);\n+    return true;\n+}\n+\n+bool FeeEstInput::readData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"rb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull() || !estimator.Read(file)) {\n+        return false;\n+    }\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        std::ifstream file(filename.string(), std::ifstream::binary);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319126",
      "id" : 224319126,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMxOTEyNg==",
      "original_commit_id" : "56446378f5d0c2bdeb7a45fa7382ccd58c9b994c",
      "original_position" : 109,
      "path" : "src/policy/fees_input.cpp",
      "position" : null,
      "pull_request_review_id" : 163654570,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319126",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319364"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319364"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`tx` shadows a local variable. Please choose another name :-)",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-10-11T05:35:42Z",
      "diff_hunk" : "@@ -0,0 +1,222 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees_input.h>\n+\n+#include <chainparams.h>\n+#include <clientversion.h>\n+#include <policy/fees.h>\n+#include <streams.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+#include <utiltime.h>\n+\n+#include <univalue.h>\n+\n+struct FeeEstInput::Block {\n+    UniValue json_txs{UniValue::VARR};\n+    CBlockPolicyEstimator::Block* est_block = nullptr;\n+};\n+\n+FeeEstInput::FeeEstInput(CBlockPolicyEstimator& estimator) : estimator(estimator) {}\n+\n+void FeeEstInput::processTx(const uint256& hash, unsigned int height, CAmount fee, size_t size, Block* block, bool valid)\n+{\n+    estimator.processTx(hash, height, fee, size, block ? block->est_block : nullptr, valid);\n+    if (log) {\n+        UniValue tx(UniValue::VOBJ);\n+        tx.pushKV(\"hash\", hash.ToString());\n+        tx.pushKV(\"height\", int(height));\n+        tx.pushKV(\"fee\", fee);\n+        tx.pushKV(\"size\", uint64_t(size));\n+        if (block) {\n+            block->json_txs.push_back(std::move(tx));\n+        } else {\n+            UniValue value(UniValue::VOBJ);\n+            value.pushKV(\"tx\", std::move(tx));\n+            value.pushKV(\"valid\", UniValue(valid));\n+            value.pushKV(\"time\", GetTime());\n+            *log << value.write() << std::endl;\n+        }\n+    }\n+}\n+\n+void FeeEstInput::processBlock(int height, const std::function<void(Block&)>& process_txs)\n+{\n+    Block block;\n+    estimator.processBlock(height, [&](CBlockPolicyEstimator::Block& est_block) {\n+        block.est_block = &est_block;\n+        process_txs(block);\n+    });\n+    if (log) {\n+        UniValue json(UniValue::VOBJ);\n+        UniValue json_block(UniValue::VOBJ);\n+        json_block.pushKV(\"height\", height);\n+        json.pushKV(\"block\", json_block);\n+        json.pushKV(\"txs\", block.json_txs);\n+        json.pushKV(\"time\", GetTime());\n+        *log << json.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::removeTx(const uint256& hash, bool in_block)\n+{\n+    estimator.removeTx(hash, in_block);\n+\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue removeTx(UniValue::VOBJ);\n+        removeTx.pushKV(\"hash\", hash.ToString());\n+        removeTx.pushKV(\"inBlock\", UniValue(in_block));\n+        value.pushKV(\"removeTx\", removeTx);\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::flushUnconfirmed()\n+{\n+    estimator.FlushUnconfirmed();\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue flush(UniValue::VARR);\n+        value.pushKV(\"flush\", flush);\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+}\n+\n+bool FeeEstInput::writeData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"wb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull()) {\n+        LogPrintf(\"%s: Failed to write fee estimates to %s\\n\", __func__, filename.string());\n+        return false;\n+    }\n+    estimator.Write(file);\n+    return true;\n+}\n+\n+bool FeeEstInput::readData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"rb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull() || !estimator.Read(file)) {\n+        return false;\n+    }\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        std::ifstream file(filename.string(), std::ifstream::binary);\n+        value.pushKV(\n+            \"read\", HexStr(std::string(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>())));\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+    return true;\n+}\n+\n+bool FeeEstInput::writeLog(const std::string& filename)\n+{\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        value.pushKV(\"stop\", Params().NetworkIDString());\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+\n+    if (filename.empty()) {\n+        log.reset();\n+    } else {\n+        log = MakeUnique<std::ofstream>(filename, std::ofstream::out | std::ofstream::app);\n+        if (!*log) {\n+            log.reset();\n+            return false;\n+        }\n+    }\n+\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        value.pushKV(\"start\", Params().NetworkIDString());\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+\n+    return true;\n+}\n+\n+bool FeeEstInput::readLog(const std::string& filename, const std::function<bool(UniValue&)>& filter)\n+{\n+    std::ifstream file(filename);\n+    if (!file) {\n+        LogPrintf(\"%s: Failed to open log file %s\\n\", __func__, filename);\n+        return false;\n+    }\n+\n+    std::string line;\n+    while (std::getline(file, line)) {\n+        UniValue value;\n+        if (!value.read(line)) {\n+            throw std::runtime_error(\"Failed to parse fee estimate log line.\");\n+        }\n+\n+        if (filter && !filter(value)) {\n+            continue;\n+        }\n+\n+        const UniValue& tx = value[\"tx\"];\n+        if (tx.isObject()) {\n+            estimator.processTx(uint256S(tx[\"hash\"].get_str()), tx[\"height\"].get_int(), tx[\"fee\"].get_int64(),\n+                tx[\"size\"].get_int(), nullptr /* block */, value[\"valid\"].get_bool());\n+            continue;\n+        }\n+\n+        const UniValue& block = value[\"block\"];\n+        if (block.isObject()) {\n+            int height = block[\"height\"].get_int();\n+            estimator.processBlock(height, [&](CBlockPolicyEstimator::Block& est_block) {\n+                const auto& txs = value[\"txs\"].getValues();\n+                for (const UniValue& tx : txs) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319364",
      "id" : 224319364,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMxOTM2NA==",
      "original_commit_id" : "56446378f5d0c2bdeb7a45fa7382ccd58c9b994c",
      "original_position" : 178,
      "path" : "src/policy/fees_input.cpp",
      "position" : null,
      "pull_request_review_id" : 163654863,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319364",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319465"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319465"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`filename` shadows another variable. Please use another name :-)",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-10-11T05:36:28Z",
      "diff_hunk" : "@@ -0,0 +1,222 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees_input.h>\n+\n+#include <chainparams.h>\n+#include <clientversion.h>\n+#include <policy/fees.h>\n+#include <streams.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+#include <utiltime.h>\n+\n+#include <univalue.h>\n+\n+struct FeeEstInput::Block {\n+    UniValue json_txs{UniValue::VARR};\n+    CBlockPolicyEstimator::Block* est_block = nullptr;\n+};\n+\n+FeeEstInput::FeeEstInput(CBlockPolicyEstimator& estimator) : estimator(estimator) {}\n+\n+void FeeEstInput::processTx(const uint256& hash, unsigned int height, CAmount fee, size_t size, Block* block, bool valid)\n+{\n+    estimator.processTx(hash, height, fee, size, block ? block->est_block : nullptr, valid);\n+    if (log) {\n+        UniValue tx(UniValue::VOBJ);\n+        tx.pushKV(\"hash\", hash.ToString());\n+        tx.pushKV(\"height\", int(height));\n+        tx.pushKV(\"fee\", fee);\n+        tx.pushKV(\"size\", uint64_t(size));\n+        if (block) {\n+            block->json_txs.push_back(std::move(tx));\n+        } else {\n+            UniValue value(UniValue::VOBJ);\n+            value.pushKV(\"tx\", std::move(tx));\n+            value.pushKV(\"valid\", UniValue(valid));\n+            value.pushKV(\"time\", GetTime());\n+            *log << value.write() << std::endl;\n+        }\n+    }\n+}\n+\n+void FeeEstInput::processBlock(int height, const std::function<void(Block&)>& process_txs)\n+{\n+    Block block;\n+    estimator.processBlock(height, [&](CBlockPolicyEstimator::Block& est_block) {\n+        block.est_block = &est_block;\n+        process_txs(block);\n+    });\n+    if (log) {\n+        UniValue json(UniValue::VOBJ);\n+        UniValue json_block(UniValue::VOBJ);\n+        json_block.pushKV(\"height\", height);\n+        json.pushKV(\"block\", json_block);\n+        json.pushKV(\"txs\", block.json_txs);\n+        json.pushKV(\"time\", GetTime());\n+        *log << json.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::removeTx(const uint256& hash, bool in_block)\n+{\n+    estimator.removeTx(hash, in_block);\n+\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue removeTx(UniValue::VOBJ);\n+        removeTx.pushKV(\"hash\", hash.ToString());\n+        removeTx.pushKV(\"inBlock\", UniValue(in_block));\n+        value.pushKV(\"removeTx\", removeTx);\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::flushUnconfirmed()\n+{\n+    estimator.FlushUnconfirmed();\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue flush(UniValue::VARR);\n+        value.pushKV(\"flush\", flush);\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+}\n+\n+bool FeeEstInput::writeData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"wb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull()) {\n+        LogPrintf(\"%s: Failed to write fee estimates to %s\\n\", __func__, filename.string());\n+        return false;\n+    }\n+    estimator.Write(file);\n+    return true;\n+}\n+\n+bool FeeEstInput::readData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"rb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull() || !estimator.Read(file)) {\n+        return false;\n+    }\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        std::ifstream file(filename.string(), std::ifstream::binary);\n+        value.pushKV(\n+            \"read\", HexStr(std::string(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>())));\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+    return true;\n+}\n+\n+bool FeeEstInput::writeLog(const std::string& filename)\n+{\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        value.pushKV(\"stop\", Params().NetworkIDString());\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+\n+    if (filename.empty()) {\n+        log.reset();\n+    } else {\n+        log = MakeUnique<std::ofstream>(filename, std::ofstream::out | std::ofstream::app);\n+        if (!*log) {\n+            log.reset();\n+            return false;\n+        }\n+    }\n+\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        value.pushKV(\"start\", Params().NetworkIDString());\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+\n+    return true;\n+}\n+\n+bool FeeEstInput::readLog(const std::string& filename, const std::function<bool(UniValue&)>& filter)\n+{\n+    std::ifstream file(filename);\n+    if (!file) {\n+        LogPrintf(\"%s: Failed to open log file %s\\n\", __func__, filename);\n+        return false;\n+    }\n+\n+    std::string line;\n+    while (std::getline(file, line)) {\n+        UniValue value;\n+        if (!value.read(line)) {\n+            throw std::runtime_error(\"Failed to parse fee estimate log line.\");\n+        }\n+\n+        if (filter && !filter(value)) {\n+            continue;\n+        }\n+\n+        const UniValue& tx = value[\"tx\"];\n+        if (tx.isObject()) {\n+            estimator.processTx(uint256S(tx[\"hash\"].get_str()), tx[\"height\"].get_int(), tx[\"fee\"].get_int64(),\n+                tx[\"size\"].get_int(), nullptr /* block */, value[\"valid\"].get_bool());\n+            continue;\n+        }\n+\n+        const UniValue& block = value[\"block\"];\n+        if (block.isObject()) {\n+            int height = block[\"height\"].get_int();\n+            estimator.processBlock(height, [&](CBlockPolicyEstimator::Block& est_block) {\n+                const auto& txs = value[\"txs\"].getValues();\n+                for (const UniValue& tx : txs) {\n+                    estimator.processTx(uint256S(tx[\"hash\"].get_str()), tx[\"height\"].get_int(),\n+                        tx[\"fee\"].get_int64(), tx[\"size\"].get_int(), &est_block, true /* valid */);\n+                }\n+                return txs.size();\n+            });\n+            continue;\n+        }\n+\n+        const UniValue& removeTx = value[\"removeTx\"];\n+        if (removeTx.isObject()) {\n+            estimator.removeTx(uint256S(removeTx[\"hash\"].get_str()), removeTx[\"inBlock\"].get_bool());\n+            continue;\n+        }\n+\n+        const UniValue& flush = value[\"flush\"];\n+        if (flush.isArray()) {\n+            estimator.FlushUnconfirmed();\n+            continue;\n+        }\n+\n+        const UniValue& read = value[\"read\"];\n+        if (read.isStr()) {\n+            std::vector<unsigned char> data = ParseHex(read.get_str());\n+            uint16_t randv = 0;\n+            GetRandBytes((unsigned char*)&randv, sizeof(randv));\n+            fs::path filename = strprintf(\"fee_estimates.tmp.%04x\", randv);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319465",
      "id" : 224319465,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMxOTQ2NQ==",
      "original_commit_id" : "56446378f5d0c2bdeb7a45fa7382ccd58c9b994c",
      "original_position" : 204,
      "path" : "src/policy/fees_input.cpp",
      "position" : null,
      "pull_request_review_id" : 163654979,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319465",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319504"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319504"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Same here: shadows another local variable :-)",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-10-11T05:36:47Z",
      "diff_hunk" : "@@ -0,0 +1,222 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees_input.h>\n+\n+#include <chainparams.h>\n+#include <clientversion.h>\n+#include <policy/fees.h>\n+#include <streams.h>\n+#include <util.h>\n+#include <utilstrencodings.h>\n+#include <utiltime.h>\n+\n+#include <univalue.h>\n+\n+struct FeeEstInput::Block {\n+    UniValue json_txs{UniValue::VARR};\n+    CBlockPolicyEstimator::Block* est_block = nullptr;\n+};\n+\n+FeeEstInput::FeeEstInput(CBlockPolicyEstimator& estimator) : estimator(estimator) {}\n+\n+void FeeEstInput::processTx(const uint256& hash, unsigned int height, CAmount fee, size_t size, Block* block, bool valid)\n+{\n+    estimator.processTx(hash, height, fee, size, block ? block->est_block : nullptr, valid);\n+    if (log) {\n+        UniValue tx(UniValue::VOBJ);\n+        tx.pushKV(\"hash\", hash.ToString());\n+        tx.pushKV(\"height\", int(height));\n+        tx.pushKV(\"fee\", fee);\n+        tx.pushKV(\"size\", uint64_t(size));\n+        if (block) {\n+            block->json_txs.push_back(std::move(tx));\n+        } else {\n+            UniValue value(UniValue::VOBJ);\n+            value.pushKV(\"tx\", std::move(tx));\n+            value.pushKV(\"valid\", UniValue(valid));\n+            value.pushKV(\"time\", GetTime());\n+            *log << value.write() << std::endl;\n+        }\n+    }\n+}\n+\n+void FeeEstInput::processBlock(int height, const std::function<void(Block&)>& process_txs)\n+{\n+    Block block;\n+    estimator.processBlock(height, [&](CBlockPolicyEstimator::Block& est_block) {\n+        block.est_block = &est_block;\n+        process_txs(block);\n+    });\n+    if (log) {\n+        UniValue json(UniValue::VOBJ);\n+        UniValue json_block(UniValue::VOBJ);\n+        json_block.pushKV(\"height\", height);\n+        json.pushKV(\"block\", json_block);\n+        json.pushKV(\"txs\", block.json_txs);\n+        json.pushKV(\"time\", GetTime());\n+        *log << json.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::removeTx(const uint256& hash, bool in_block)\n+{\n+    estimator.removeTx(hash, in_block);\n+\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue removeTx(UniValue::VOBJ);\n+        removeTx.pushKV(\"hash\", hash.ToString());\n+        removeTx.pushKV(\"inBlock\", UniValue(in_block));\n+        value.pushKV(\"removeTx\", removeTx);\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+}\n+\n+void FeeEstInput::flushUnconfirmed()\n+{\n+    estimator.FlushUnconfirmed();\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        UniValue flush(UniValue::VARR);\n+        value.pushKV(\"flush\", flush);\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+}\n+\n+bool FeeEstInput::writeData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"wb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull()) {\n+        LogPrintf(\"%s: Failed to write fee estimates to %s\\n\", __func__, filename.string());\n+        return false;\n+    }\n+    estimator.Write(file);\n+    return true;\n+}\n+\n+bool FeeEstInput::readData(const fs::path& filename)\n+{\n+    CAutoFile file(fsbridge::fopen(filename, \"rb\"), SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull() || !estimator.Read(file)) {\n+        return false;\n+    }\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        std::ifstream file(filename.string(), std::ifstream::binary);\n+        value.pushKV(\n+            \"read\", HexStr(std::string(std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>())));\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+    return true;\n+}\n+\n+bool FeeEstInput::writeLog(const std::string& filename)\n+{\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        value.pushKV(\"stop\", Params().NetworkIDString());\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+\n+    if (filename.empty()) {\n+        log.reset();\n+    } else {\n+        log = MakeUnique<std::ofstream>(filename, std::ofstream::out | std::ofstream::app);\n+        if (!*log) {\n+            log.reset();\n+            return false;\n+        }\n+    }\n+\n+    if (log) {\n+        UniValue value(UniValue::VOBJ);\n+        value.pushKV(\"start\", Params().NetworkIDString());\n+        value.pushKV(\"time\", GetTime());\n+        *log << value.write() << std::endl;\n+    }\n+\n+    return true;\n+}\n+\n+bool FeeEstInput::readLog(const std::string& filename, const std::function<bool(UniValue&)>& filter)\n+{\n+    std::ifstream file(filename);\n+    if (!file) {\n+        LogPrintf(\"%s: Failed to open log file %s\\n\", __func__, filename);\n+        return false;\n+    }\n+\n+    std::string line;\n+    while (std::getline(file, line)) {\n+        UniValue value;\n+        if (!value.read(line)) {\n+            throw std::runtime_error(\"Failed to parse fee estimate log line.\");\n+        }\n+\n+        if (filter && !filter(value)) {\n+            continue;\n+        }\n+\n+        const UniValue& tx = value[\"tx\"];\n+        if (tx.isObject()) {\n+            estimator.processTx(uint256S(tx[\"hash\"].get_str()), tx[\"height\"].get_int(), tx[\"fee\"].get_int64(),\n+                tx[\"size\"].get_int(), nullptr /* block */, value[\"valid\"].get_bool());\n+            continue;\n+        }\n+\n+        const UniValue& block = value[\"block\"];\n+        if (block.isObject()) {\n+            int height = block[\"height\"].get_int();\n+            estimator.processBlock(height, [&](CBlockPolicyEstimator::Block& est_block) {\n+                const auto& txs = value[\"txs\"].getValues();\n+                for (const UniValue& tx : txs) {\n+                    estimator.processTx(uint256S(tx[\"hash\"].get_str()), tx[\"height\"].get_int(),\n+                        tx[\"fee\"].get_int64(), tx[\"size\"].get_int(), &est_block, true /* valid */);\n+                }\n+                return txs.size();\n+            });\n+            continue;\n+        }\n+\n+        const UniValue& removeTx = value[\"removeTx\"];\n+        if (removeTx.isObject()) {\n+            estimator.removeTx(uint256S(removeTx[\"hash\"].get_str()), removeTx[\"inBlock\"].get_bool());\n+            continue;\n+        }\n+\n+        const UniValue& flush = value[\"flush\"];\n+        if (flush.isArray()) {\n+            estimator.FlushUnconfirmed();\n+            continue;\n+        }\n+\n+        const UniValue& read = value[\"read\"];\n+        if (read.isStr()) {\n+            std::vector<unsigned char> data = ParseHex(read.get_str());\n+            uint16_t randv = 0;\n+            GetRandBytes((unsigned char*)&randv, sizeof(randv));\n+            fs::path filename = strprintf(\"fee_estimates.tmp.%04x\", randv);\n+            CAutoFile(fsbridge::fopen(filename, \"wb\"), SER_DISK, CLIENT_VERSION)\n+                .write((const char*)data.data(), data.size());\n+            {\n+                CAutoFile file(fsbridge::fopen(filename, \"rb\"), SER_DISK, CLIENT_VERSION);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319504",
      "id" : 224319504,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMxOTUwNA==",
      "original_commit_id" : "56446378f5d0c2bdeb7a45fa7382ccd58c9b994c",
      "original_position" : 208,
      "path" : "src/policy/fees_input.cpp",
      "position" : null,
      "pull_request_review_id" : 163655029,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319504",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319764"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319764"
         }
      },
      "author_association" : "MEMBER",
      "body" : "An implicit signedness changing conversion takes place here. Avoid or make it explicit :-)",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-10-11T05:38:58Z",
      "diff_hunk" : "@@ -0,0 +1,333 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <random>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319764",
      "id" : 224319764,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMxOTc2NA==",
      "original_commit_id" : "56446378f5d0c2bdeb7a45fa7382ccd58c9b994c",
      "original_position" : 164,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : null,
      "pull_request_review_id" : 163655353,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319764",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319785"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319785"
         }
      },
      "author_association" : "MEMBER",
      "body" : "An implicit signedness changing conversion takes place here. Avoid or make it explicit :-)",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-10-11T05:39:14Z",
      "diff_hunk" : "@@ -0,0 +1,333 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <random>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(fee);\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    std::minstd_rand randint;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            int j = randint() % i;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319785",
      "id" : 224319785,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMxOTc4NQ==",
      "original_commit_id" : "56446378f5d0c2bdeb7a45fa7382ccd58c9b994c",
      "original_position" : 181,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : null,
      "pull_request_review_id" : 163655387,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319785",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319825"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319825"
         }
      },
      "author_association" : "MEMBER",
      "body" : "An implicit signedness changing conversion takes place here. Avoid or make it explicit :-)",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-10-11T05:39:30Z",
      "diff_hunk" : "@@ -0,0 +1,333 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <random>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(fee);\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    std::minstd_rand randint;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            int j = randint() % i;\n+            if (j < SAMPLE_TXS) {\n+                sample[j] = &entry;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319825",
      "id" : 224319825,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMxOTgyNQ==",
      "original_commit_id" : "56446378f5d0c2bdeb7a45fa7382ccd58c9b994c",
      "original_position" : 183,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : 181,
      "pull_request_review_id" : 163655431,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319825",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319845"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319845"
         }
      },
      "author_association" : "MEMBER",
      "body" : "An implicit signedness changing conversion takes place here. Avoid or make it explicit :-)",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-10-11T05:39:44Z",
      "diff_hunk" : "@@ -0,0 +1,333 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <random>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(fee);\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    std::minstd_rand randint;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            int j = randint() % i;\n+            if (j < SAMPLE_TXS) {\n+                sample[j] = &entry;\n+            }\n+        }\n+        ++i;\n+    }\n+\n+    if (!sample.empty()) {\n+        std::vector<int64_t> feeRates;\n+        feeRates.reserve(sample.size());\n+        for (const auto& entry : sample) {\n+            feeRates.emplace_back(CFeeRate(entry->second.fee, entry->second.size).GetFeePerK());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319845",
      "id" : 224319845,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMxOTg0NQ==",
      "original_commit_id" : "56446378f5d0c2bdeb7a45fa7382ccd58c9b994c",
      "original_position" : 193,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : 191,
      "pull_request_review_id" : 163655461,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319845",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319898"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319898"
         }
      },
      "author_association" : "MEMBER",
      "body" : "An implicit signedness changing conversion takes place here. Avoid or make it explicit :-)",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-10-11T05:40:09Z",
      "diff_hunk" : "@@ -0,0 +1,333 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <random>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(fee);\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    std::minstd_rand randint;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            int j = randint() % i;\n+            if (j < SAMPLE_TXS) {\n+                sample[j] = &entry;\n+            }\n+        }\n+        ++i;\n+    }\n+\n+    if (!sample.empty()) {\n+        std::vector<int64_t> feeRates;\n+        feeRates.reserve(sample.size());\n+        for (const auto& entry : sample) {\n+            feeRates.emplace_back(CFeeRate(entry->second.fee, entry->second.size).GetFeePerK());\n+        }\n+        auto nth = feeRates.begin() + sample.size() / DROP_FRAC;\n+        std::nth_element(feeRates.begin(), nth, feeRates.end(), std::greater<int64_t>());\n+        maxFeeRate = std::max(maxFeeRate, *nth);\n+    }\n+\n+    UniValue txs(UniValue::VARR);\n+    for (const auto& entry : sample) {\n+        if (entry->second.actualBlocks > 0) {\n+            int64_t feeRate = CFeeRate(entry->second.fee, entry->second.size).GetFeePerK();",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319898",
      "id" : 224319898,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMxOTg5OA==",
      "original_commit_id" : "56446378f5d0c2bdeb7a45fa7382ccd58c9b994c",
      "original_position" : 203,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : null,
      "pull_request_review_id" : 163655520,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319898",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319971"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319971"
         }
      },
      "author_association" : "MEMBER",
      "body" : "An implicit signedness changing conversion takes place here. Avoid or make it explicit :-)",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-10-11T05:40:44Z",
      "diff_hunk" : "@@ -0,0 +1,333 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <random>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(fee);\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    std::minstd_rand randint;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            int j = randint() % i;\n+            if (j < SAMPLE_TXS) {\n+                sample[j] = &entry;\n+            }\n+        }\n+        ++i;\n+    }\n+\n+    if (!sample.empty()) {\n+        std::vector<int64_t> feeRates;\n+        feeRates.reserve(sample.size());\n+        for (const auto& entry : sample) {\n+            feeRates.emplace_back(CFeeRate(entry->second.fee, entry->second.size).GetFeePerK());\n+        }\n+        auto nth = feeRates.begin() + sample.size() / DROP_FRAC;\n+        std::nth_element(feeRates.begin(), nth, feeRates.end(), std::greater<int64_t>());\n+        maxFeeRate = std::max(maxFeeRate, *nth);\n+    }\n+\n+    UniValue txs(UniValue::VARR);\n+    for (const auto& entry : sample) {\n+        if (entry->second.actualBlocks > 0) {\n+            int64_t feeRate = CFeeRate(entry->second.fee, entry->second.size).GetFeePerK();\n+            if (feeRate <= maxFeeRate) {\n+                UniValue tx(UniValue::VOBJ);\n+                tx.pushKV(\"feeRate\", feeRate);\n+                tx.pushKV(\"blocks\", entry->second.actualBlocks);\n+                tx.pushKV(\"height\", entry->second.height);\n+                txs.push_back(std::move(tx));\n+            }\n+        }\n+    }\n+\n+    std::ofstream file(filename);\n+    file << strprintf(GRAPH_HTML, txs.write(), fees.write());\n+}\n+\n+bool UpdateCross(TxMap::value_type& tx, const std::vector<unsigned int>& targets, CBlockPolicyEstimator& estimator)\n+{\n+    if (*tx.first.begin() == 0) {\n+        auto it = std::lower_bound(targets.begin(), targets.end(), nullptr, [&](unsigned int target, std::nullptr_t) {\n+            CAmount estFee = estimator.estimateSmartFee(target, nullptr /* feeCalc */, false /* conservative */)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319971",
      "id" : 224319971,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMxOTk3MQ==",
      "original_commit_id" : "56446378f5d0c2bdeb7a45fa7382ccd58c9b994c",
      "original_position" : 222,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : null,
      "pull_request_review_id" : 163655603,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319971",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319995"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319995"
         }
      },
      "author_association" : "MEMBER",
      "body" : "An implicit signedness changing conversion takes place here. Avoid or make it explicit :-)",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-10-11T05:40:54Z",
      "diff_hunk" : "@@ -0,0 +1,333 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <random>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(fee);\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    std::minstd_rand randint;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            int j = randint() % i;\n+            if (j < SAMPLE_TXS) {\n+                sample[j] = &entry;\n+            }\n+        }\n+        ++i;\n+    }\n+\n+    if (!sample.empty()) {\n+        std::vector<int64_t> feeRates;\n+        feeRates.reserve(sample.size());\n+        for (const auto& entry : sample) {\n+            feeRates.emplace_back(CFeeRate(entry->second.fee, entry->second.size).GetFeePerK());\n+        }\n+        auto nth = feeRates.begin() + sample.size() / DROP_FRAC;\n+        std::nth_element(feeRates.begin(), nth, feeRates.end(), std::greater<int64_t>());\n+        maxFeeRate = std::max(maxFeeRate, *nth);\n+    }\n+\n+    UniValue txs(UniValue::VARR);\n+    for (const auto& entry : sample) {\n+        if (entry->second.actualBlocks > 0) {\n+            int64_t feeRate = CFeeRate(entry->second.fee, entry->second.size).GetFeePerK();\n+            if (feeRate <= maxFeeRate) {\n+                UniValue tx(UniValue::VOBJ);\n+                tx.pushKV(\"feeRate\", feeRate);\n+                tx.pushKV(\"blocks\", entry->second.actualBlocks);\n+                tx.pushKV(\"height\", entry->second.height);\n+                txs.push_back(std::move(tx));\n+            }\n+        }\n+    }\n+\n+    std::ofstream file(filename);\n+    file << strprintf(GRAPH_HTML, txs.write(), fees.write());\n+}\n+\n+bool UpdateCross(TxMap::value_type& tx, const std::vector<unsigned int>& targets, CBlockPolicyEstimator& estimator)\n+{\n+    if (*tx.first.begin() == 0) {\n+        auto it = std::lower_bound(targets.begin(), targets.end(), nullptr, [&](unsigned int target, std::nullptr_t) {\n+            CAmount estFee = estimator.estimateSmartFee(target, nullptr /* feeCalc */, false /* conservative */)\n+                                 .GetFee(tx.second.size);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224319995",
      "id" : 224319995,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMxOTk5NQ==",
      "original_commit_id" : "56446378f5d0c2bdeb7a45fa7382ccd58c9b994c",
      "original_position" : 223,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : 221,
      "pull_request_review_id" : 163655636,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224319995",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224320065"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224320065"
         }
      },
      "author_association" : "MEMBER",
      "body" : "An implicit signedness changing conversion takes place here. Avoid or make it explicit :-)",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-10-11T05:41:26Z",
      "diff_hunk" : "@@ -0,0 +1,333 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <random>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(fee);\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    std::minstd_rand randint;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            int j = randint() % i;\n+            if (j < SAMPLE_TXS) {\n+                sample[j] = &entry;\n+            }\n+        }\n+        ++i;\n+    }\n+\n+    if (!sample.empty()) {\n+        std::vector<int64_t> feeRates;\n+        feeRates.reserve(sample.size());\n+        for (const auto& entry : sample) {\n+            feeRates.emplace_back(CFeeRate(entry->second.fee, entry->second.size).GetFeePerK());\n+        }\n+        auto nth = feeRates.begin() + sample.size() / DROP_FRAC;\n+        std::nth_element(feeRates.begin(), nth, feeRates.end(), std::greater<int64_t>());\n+        maxFeeRate = std::max(maxFeeRate, *nth);\n+    }\n+\n+    UniValue txs(UniValue::VARR);\n+    for (const auto& entry : sample) {\n+        if (entry->second.actualBlocks > 0) {\n+            int64_t feeRate = CFeeRate(entry->second.fee, entry->second.size).GetFeePerK();\n+            if (feeRate <= maxFeeRate) {\n+                UniValue tx(UniValue::VOBJ);\n+                tx.pushKV(\"feeRate\", feeRate);\n+                tx.pushKV(\"blocks\", entry->second.actualBlocks);\n+                tx.pushKV(\"height\", entry->second.height);\n+                txs.push_back(std::move(tx));\n+            }\n+        }\n+    }\n+\n+    std::ofstream file(filename);\n+    file << strprintf(GRAPH_HTML, txs.write(), fees.write());\n+}\n+\n+bool UpdateCross(TxMap::value_type& tx, const std::vector<unsigned int>& targets, CBlockPolicyEstimator& estimator)\n+{\n+    if (*tx.first.begin() == 0) {\n+        auto it = std::lower_bound(targets.begin(), targets.end(), nullptr, [&](unsigned int target, std::nullptr_t) {\n+            CAmount estFee = estimator.estimateSmartFee(target, nullptr /* feeCalc */, false /* conservative */)\n+                                 .GetFee(tx.second.size);\n+            return estFee <= 1 || tx.second.fee < estFee;\n+        });\n+        tx.second.expectedBlocks = it == targets.end() ? std::numeric_limits<int>::max() : *it;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224320065",
      "id" : 224320065,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMyMDA2NQ==",
      "original_commit_id" : "56446378f5d0c2bdeb7a45fa7382ccd58c9b994c",
      "original_position" : 226,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : null,
      "pull_request_review_id" : 163655731,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224320065",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224320184"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224320184"
         }
      },
      "author_association" : "MEMBER",
      "body" : "The unused parameter `estimator` can be removed?",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-10-11T05:42:24Z",
      "diff_hunk" : "@@ -0,0 +1,333 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <random>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(fee);\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    std::minstd_rand randint;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            int j = randint() % i;\n+            if (j < SAMPLE_TXS) {\n+                sample[j] = &entry;\n+            }\n+        }\n+        ++i;\n+    }\n+\n+    if (!sample.empty()) {\n+        std::vector<int64_t> feeRates;\n+        feeRates.reserve(sample.size());\n+        for (const auto& entry : sample) {\n+            feeRates.emplace_back(CFeeRate(entry->second.fee, entry->second.size).GetFeePerK());\n+        }\n+        auto nth = feeRates.begin() + sample.size() / DROP_FRAC;\n+        std::nth_element(feeRates.begin(), nth, feeRates.end(), std::greater<int64_t>());\n+        maxFeeRate = std::max(maxFeeRate, *nth);\n+    }\n+\n+    UniValue txs(UniValue::VARR);\n+    for (const auto& entry : sample) {\n+        if (entry->second.actualBlocks > 0) {\n+            int64_t feeRate = CFeeRate(entry->second.fee, entry->second.size).GetFeePerK();\n+            if (feeRate <= maxFeeRate) {\n+                UniValue tx(UniValue::VOBJ);\n+                tx.pushKV(\"feeRate\", feeRate);\n+                tx.pushKV(\"blocks\", entry->second.actualBlocks);\n+                tx.pushKV(\"height\", entry->second.height);\n+                txs.push_back(std::move(tx));\n+            }\n+        }\n+    }\n+\n+    std::ofstream file(filename);\n+    file << strprintf(GRAPH_HTML, txs.write(), fees.write());\n+}\n+\n+bool UpdateCross(TxMap::value_type& tx, const std::vector<unsigned int>& targets, CBlockPolicyEstimator& estimator)\n+{\n+    if (*tx.first.begin() == 0) {\n+        auto it = std::lower_bound(targets.begin(), targets.end(), nullptr, [&](unsigned int target, std::nullptr_t) {\n+            CAmount estFee = estimator.estimateSmartFee(target, nullptr /* feeCalc */, false /* conservative */)\n+                                 .GetFee(tx.second.size);\n+            return estFee <= 1 || tx.second.fee < estFee;\n+        });\n+        tx.second.expectedBlocks = it == targets.end() ? std::numeric_limits<int>::max() : *it;\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void PrintCross(const TxMap& txMap,\n+    CBlockPolicyEstimator& estimator)",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224320184",
      "id" : 224320184,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMyMDE4NA==",
      "original_commit_id" : "56446378f5d0c2bdeb7a45fa7382ccd58c9b994c",
      "original_position" : 233,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : null,
      "pull_request_review_id" : 163655868,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224320184",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224320246"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224320246"
         }
      },
      "author_association" : "MEMBER",
      "body" : "`tx` here shadows an already existing local variable. Please choose another name :-)",
      "commit_id" : "50cd9b1cb7d03a81140d8a59698eba8d06b89612",
      "created_at" : "2018-10-11T05:42:56Z",
      "diff_hunk" : "@@ -0,0 +1,333 @@\n+// Copyright (c) 2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <policy/fees.h>\n+#include <policy/fees_input.h>\n+#include <util.h>\n+\n+#include <univalue.h>\n+\n+#include <fstream>\n+#include <random>\n+#include <stdio.h>\n+\n+const std::function<std::string(const char*)> G_TRANSLATION_FUN = nullptr;\n+\n+std::string Usage()\n+{\n+    std::string usage = \"Usage: fee_est [options] <estlog.txt>\\n\";\n+    usage += HelpMessageGroup(\"Options:\");\n+    usage += HelpMessageOpt(\"-?, -help\", \"This help message\");\n+    usage += HelpMessageOpt(\"-ograph=<graph.html>\", \"Generate target vs feerate graph output after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-odat=<fee_estimates.dat>\", \"Save fee estimator state after after replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-idat=<fee_estimates.dat>\", \"Load fee estimator state after before replaying transaction log.\");\n+    usage += HelpMessageOpt(\"-dat=<fee_estimates.dat>\", \"Shortcut for -idat=<fee_estimates.dat> -odat=<fee_estimates.dat>\");\n+    usage += HelpMessageOpt(\"-cross\", \"Treat half the transactions from the log as test data and print cross-validation statistics.\");\n+    return usage;\n+}\n+\n+struct Options\n+{\n+    std::string logFileIn;\n+    std::string dataFileIn;\n+    std::string dataFileOut;\n+    std::string graphFileOut;\n+    bool cross = false;\n+    bool help = false;\n+    bool error = false;\n+};\n+\n+Options ParseCommandLine(int argc, char** argv)\n+{\n+    auto match = [&](const char* arg, const char* name, const char** value = nullptr) {\n+        if (arg[0] != '-') return false;\n+        size_t n = strlen(name);\n+        if (strncmp(arg + 1, name, n) != 0) return false;\n+        if (value) return (*value = arg[n + 1] == '=' ? arg + n + 2 : nullptr) != nullptr;\n+        return arg[n + 1] == '\\0';\n+    };\n+\n+    Options options;\n+    for (int i = 1; i < argc; ++i) {\n+        const char* arg = argv[i];\n+        const char* value;\n+        if (match(arg, \"ograph\", &value)) {\n+            options.graphFileOut = value;\n+        } else if (match(arg, \"odat\", &value)) {\n+            options.dataFileOut = value;\n+        } else if (match(arg, \"idat\", &value)) {\n+            options.dataFileIn = value;\n+        } else if (match(arg, \"dat\", &value)) {\n+            options.dataFileIn = options.dataFileOut = value;\n+        } else if (match(arg, \"cross\")) {\n+            options.cross = true;\n+        } else if (match(arg, \"help\") || match(arg, \"h\") || match(arg, \"?\")) {\n+            options.help = true;\n+        } else if (arg[0] != '-' && options.logFileIn.empty()) {\n+            options.logFileIn = arg;\n+        } else {\n+            fprintf(stderr, \"Error: unexpected argument: '%s'\\n\", arg);\n+            options.error = true;\n+        }\n+    }\n+\n+    if (options.logFileIn.empty() && !options.help) {\n+        fprintf(stderr, \"Error: missing required log file argument.\\n\");\n+        options.error = true;\n+    }\n+\n+    return options;\n+}\n+\n+struct TxData\n+{\n+    TxData(CAmount fee, int size, int height) : fee(fee), size(size), height(height) {}\n+    CAmount fee;\n+    int size;\n+    int height;\n+    int expectedBlocks = -1;\n+    int actualBlocks = -1;\n+};\n+\n+using TxMap = std::map<uint256, TxData>;\n+\n+const char* const GRAPH_HTML = R\"(<!DOCTYPE html>\n+<meta charset=\"utf-8\">\n+<title>Fee Graph</title>\n+<script src=\"https://d3js.org/d3.v3.min.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega/3.0.0-beta.30/vega.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-lite/2.0.0-beta.2/vega-lite.js\"></script>\n+<script src=\"https://cdnjs.cloudflare.com/ajax/libs/vega-embed/3.0.0-beta.14/vega-embed.js\"></script>\n+<style media=\"screen\">\n+.vega-actions a {\n+    margin-right: 5px;\n+}\n+</style>\n+<div id=vis></div>\n+<script>\n+var spec = {\n+  \"$schema\": \"https://vega.github.io/schema/vega-lite/v2.json\",\n+  \"width\": 800,\n+  \"height\": 600,\n+  \"layer\": [\n+    {\n+        \"data\": {\n+            \"values\": %s\n+        },\n+        \"mark\": \"tick\",\n+        \"encoding\": {\n+            \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+            \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+            \"color\": {\"field\": \"height\", \"type\": \"quantitative\"}\n+        }\n+    },\n+    {\n+      \"data\": {\n+        \"values\": %s\n+      },\n+      \"encoding\": {\n+        \"x\": {\"field\": \"blocks\", \"type\": \"quantitative\"},\n+        \"y\": {\"field\": \"feeRate\", \"type\": \"quantitative\"},\n+        \"color\": {\"field\": \"mode\", \"type\": \"nominal\"}\n+      },\n+      \"mark\": \"line\",\n+    }\n+  ]\n+}\n+vega.embed(\"#vis\", spec);\n+</script>\n+)\";\n+\n+// Maximum number of randomly sampled transactions to show on graph.\n+const int SAMPLE_TXS = 50000;\n+\n+// Drop 1/20th of sampled transactions with highest feerates if they are\n+// outliers that would change the scale of the graph.\n+const int DROP_FRAC = 20;\n+\n+void WriteGraph(const std::string& filename,\n+    const TxMap& txMap,\n+    const std::vector<unsigned int>& targets,\n+    CBlockPolicyEstimator& estimator)\n+{\n+    UniValue fees(UniValue::VARR);\n+\n+    int64_t maxFeeRate = 0;\n+    const unsigned int maxTarget = estimator.getMaxTarget();\n+    for (bool conservative : {false, true}) {\n+        for (unsigned int target : targets) {\n+            if (target > maxTarget) continue;\n+            UniValue fee(UniValue::VOBJ);\n+            fee.pushKV(\"mode\", conservative ? \"conservative\" : \"default\");\n+            fee.pushKV(\"blocks\", int(target));\n+            int64_t feeRate = estimator.estimateSmartFee(target, nullptr /* confTarget */, conservative).GetFeePerK();\n+            fee.pushKV(\"feeRate\", feeRate);\n+            fees.push_back(fee);\n+            maxFeeRate = std::max(maxFeeRate, feeRate);\n+        }\n+    }\n+\n+    std::vector<const TxMap::value_type*> sample;\n+    sample.reserve(SAMPLE_TXS);\n+    int i = 0;\n+    std::minstd_rand randint;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.actualBlocks > int(maxTarget)) {\n+            continue;\n+        } else if (sample.size() < SAMPLE_TXS) {\n+            sample.emplace_back(&entry);\n+        } else {\n+            int j = randint() % i;\n+            if (j < SAMPLE_TXS) {\n+                sample[j] = &entry;\n+            }\n+        }\n+        ++i;\n+    }\n+\n+    if (!sample.empty()) {\n+        std::vector<int64_t> feeRates;\n+        feeRates.reserve(sample.size());\n+        for (const auto& entry : sample) {\n+            feeRates.emplace_back(CFeeRate(entry->second.fee, entry->second.size).GetFeePerK());\n+        }\n+        auto nth = feeRates.begin() + sample.size() / DROP_FRAC;\n+        std::nth_element(feeRates.begin(), nth, feeRates.end(), std::greater<int64_t>());\n+        maxFeeRate = std::max(maxFeeRate, *nth);\n+    }\n+\n+    UniValue txs(UniValue::VARR);\n+    for (const auto& entry : sample) {\n+        if (entry->second.actualBlocks > 0) {\n+            int64_t feeRate = CFeeRate(entry->second.fee, entry->second.size).GetFeePerK();\n+            if (feeRate <= maxFeeRate) {\n+                UniValue tx(UniValue::VOBJ);\n+                tx.pushKV(\"feeRate\", feeRate);\n+                tx.pushKV(\"blocks\", entry->second.actualBlocks);\n+                tx.pushKV(\"height\", entry->second.height);\n+                txs.push_back(std::move(tx));\n+            }\n+        }\n+    }\n+\n+    std::ofstream file(filename);\n+    file << strprintf(GRAPH_HTML, txs.write(), fees.write());\n+}\n+\n+bool UpdateCross(TxMap::value_type& tx, const std::vector<unsigned int>& targets, CBlockPolicyEstimator& estimator)\n+{\n+    if (*tx.first.begin() == 0) {\n+        auto it = std::lower_bound(targets.begin(), targets.end(), nullptr, [&](unsigned int target, std::nullptr_t) {\n+            CAmount estFee = estimator.estimateSmartFee(target, nullptr /* feeCalc */, false /* conservative */)\n+                                 .GetFee(tx.second.size);\n+            return estFee <= 1 || tx.second.fee < estFee;\n+        });\n+        tx.second.expectedBlocks = it == targets.end() ? std::numeric_limits<int>::max() : *it;\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void PrintCross(const TxMap& txMap,\n+    CBlockPolicyEstimator& estimator)\n+{\n+    int nonTestTxs = 0;\n+    int unconfirmedTestTxs = 0;\n+    int outlierTestTxs = 0;\n+    int keptTestTxs = 0;\n+    int64_t errsq = 0;\n+    for (const auto& entry : txMap) {\n+        if (entry.second.expectedBlocks == -1) {\n+            ++nonTestTxs;\n+        } else if (entry.second.actualBlocks == -1) {\n+            ++unconfirmedTestTxs;\n+        } else if (entry.second.expectedBlocks == std::numeric_limits<int>::max()) {\n+            ++outlierTestTxs;\n+        } else {\n+            ++keptTestTxs;\n+            int err = entry.second.expectedBlocks - entry.second.actualBlocks;\n+            errsq += err * err;\n+        }\n+    }\n+    printf(\"Non-test txs: %i\\n\", nonTestTxs);\n+    printf(\"Test txs: %i total (%i kept, %i discarded unconfirmed, %i discarded outliers)\\n\",\n+        keptTestTxs + unconfirmedTestTxs + outlierTestTxs, keptTestTxs, unconfirmedTestTxs, outlierTestTxs);\n+    if (keptTestTxs > 0) {\n+        printf(\"Mean squared error: %g\\n\", double(errsq) / double(keptTestTxs));\n+    }\n+}\n+\n+int main(int argc, char** argv)\n+{\n+    Options options = ParseCommandLine(argc, argv);\n+\n+    if (options.help) {\n+        printf(\"%s\", Usage().c_str());\n+        return EXIT_SUCCESS;\n+    } else if (options.error) {\n+        fprintf(stderr, \"Try `fee_est -h` for more information.\\n\");\n+        return EXIT_FAILURE;\n+    } else if (options.dataFileOut.empty() && options.graphFileOut.empty() && !options.cross) {\n+        fprintf(stderr, \"Warning: No output options specified. Try -ograph, -odat, -cross options, or `fee_est -h` \"\n+                        \"for more information.\\n\");\n+    }\n+\n+    CBlockPolicyEstimator estimator;\n+    FeeEstInput input(estimator);\n+\n+    if (!options.dataFileIn.empty() && !input.readData(options.dataFileIn)) {\n+        fprintf(stderr, \"Error: failed to load fee estimate data file '%s'\\n\", options.dataFileOut.c_str());\n+        return 1;\n+    }\n+\n+    const std::vector<unsigned int> targets = estimator.getUniqueTargets();\n+    TxMap txMap;\n+\n+    auto filter = [&](UniValue& value) {\n+        bool keep = true;\n+        const UniValue& tx = value[\"tx\"];\n+        if (tx.isObject()) {\n+            auto inserted = txMap.emplace(uint256S(tx[\"hash\"].get_str()),\n+                TxData(tx[\"fee\"].get_int64(), tx[\"size\"].get_int(), tx[\"height\"].get_int()));\n+            if (options.cross && !UpdateCross(*inserted.first, targets, estimator)) {\n+                keep = false;\n+            }\n+        }\n+\n+        const UniValue& block = value[\"block\"];\n+        if (block.isObject()) {\n+            int blockHeight = block[\"height\"].get_int();\n+            const auto& txs = value[\"txs\"].getValues();\n+            for (const UniValue& tx : txs) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#discussion_r224320246",
      "id" : 224320246,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNDMyMDI0Ng==",
      "original_commit_id" : "56446378f5d0c2bdeb7a45fa7382ccd58c9b994c",
      "original_position" : 302,
      "path" : "src/test/fee_est/fee_est.cpp",
      "position" : null,
      "pull_request_review_id" : 163655948,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/10443",
      "updated_at" : "2018-11-06T18:26:25Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/224320246",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-11-05T11:18:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/10443#issuecomment-435839844",
      "id" : 435839844,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/10443",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTgzOTg0NA==",
      "updated_at" : "2018-11-05T11:18:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435839844",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   }
]
