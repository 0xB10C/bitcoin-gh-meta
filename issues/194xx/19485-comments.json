[
   {
      "author_association" : "MEMBER",
      "body" : "What's the point if we can't advertise the address?\r\n\r\nAlso, shouldn't it be possible to have both v2 and v3 addresses?",
      "created_at" : "2020-07-10T15:59:19Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19485#issuecomment-656751436",
      "id" : 656751436,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19485",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1Njc1MTQzNg==",
      "updated_at" : "2020-07-10T15:59:19Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/656751436",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> What's the point if we can't advertise the address?\r\n> \r\n> Also, shouldn't it be possible to have both v2 and v3 addresses?\r\n\r\nIf BIP155 get merged...  ?\r\nI have a working patch for @vasild Tor v3/ADDRv2  implementation that i will  post him now.\r\n\r\nBtw. I use for myself a patch i made fro myself to tunnel V3 in V2 ADDR message that works right now with current master.\r\nIt uses FC00/7 address that we ignore and resembles on the end to a v3 address to drop in and out from the peers.dat,\r\nThat should not even need a BIP since its fully transparent to the actual implementation, although a bit ugly and stealth. \r\n\r\n> Also, shouldn't it be possible to have both v2 and v3 addresses?\r\n\r\nThis PR create both V2 and V3  in one sweep.  \r\n\r\n\r\n",
      "created_at" : "2020-07-10T16:17:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19485#issuecomment-656760845",
      "id" : 656760845,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19485",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1Njc2MDg0NQ==",
      "updated_at" : "2020-07-10T16:25:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/656760845",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/34917548?v=4",
         "events_url" : "https://api.github.com/users/Saibato/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Saibato/followers",
         "following_url" : "https://api.github.com/users/Saibato/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Saibato/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Saibato",
         "id" : 34917548,
         "login" : "Saibato",
         "node_id" : "MDQ6VXNlcjM0OTE3NTQ4",
         "organizations_url" : "https://api.github.com/users/Saibato/orgs",
         "received_events_url" : "https://api.github.com/users/Saibato/received_events",
         "repos_url" : "https://api.github.com/users/Saibato/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Saibato/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Saibato/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Saibato"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : ">It uses FC00/7 address that we ignore and resembles on the end to a v3 address to drop in and out from the peers.dat,\r\nThat should not even need a BIP since its fully transparent to the actual implementation, although a bit ugly and stealth.\r\n\r\nI don't know why it wouldn't need a BIP... it's a protocol change at the p2p layer still.",
      "created_at" : "2020-07-10T16:30:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19485#issuecomment-656766884",
      "id" : 656766884,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19485",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1Njc2Njg4NA==",
      "updated_at" : "2020-07-10T16:30:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/656766884",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/1095675?v=4",
         "events_url" : "https://api.github.com/users/luke-jr/events{/privacy}",
         "followers_url" : "https://api.github.com/users/luke-jr/followers",
         "following_url" : "https://api.github.com/users/luke-jr/following{/other_user}",
         "gists_url" : "https://api.github.com/users/luke-jr/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/luke-jr",
         "id" : 1095675,
         "login" : "luke-jr",
         "node_id" : "MDQ6VXNlcjEwOTU2NzU=",
         "organizations_url" : "https://api.github.com/users/luke-jr/orgs",
         "received_events_url" : "https://api.github.com/users/luke-jr/received_events",
         "repos_url" : "https://api.github.com/users/luke-jr/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/luke-jr/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/luke-jr/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/luke-jr"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I don't know why it wouldn't need a BIP... it's a protocol change at the p2p layer ...\r\n\r\nSo then we propose this ?",
      "created_at" : "2020-07-10T16:50:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19485#issuecomment-656776257",
      "id" : 656776257,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19485",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1Njc3NjI1Nw==",
      "updated_at" : "2020-07-10T16:50:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/656776257",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/34917548?v=4",
         "events_url" : "https://api.github.com/users/Saibato/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Saibato/followers",
         "following_url" : "https://api.github.com/users/Saibato/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Saibato/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Saibato",
         "id" : 34917548,
         "login" : "Saibato",
         "node_id" : "MDQ6VXNlcjM0OTE3NTQ4",
         "organizations_url" : "https://api.github.com/users/Saibato/orgs",
         "received_events_url" : "https://api.github.com/users/Saibato/received_events",
         "repos_url" : "https://api.github.com/users/Saibato/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Saibato/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Saibato/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Saibato"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* #19288 (tests: Add fuzzing harness for TorController by practicalswift)\n* #15421 (torcontrol: Launch a private Tor instance when not already running by luke-jr)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2020-07-11T00:20:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19485#issuecomment-656947713",
      "id" : 656947713,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19485",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1Njk0NzcxMw==",
      "updated_at" : "2020-07-11T00:20:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/656947713",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "This POC V3 tunnel patch does the QD job of tunnel v3 onion in ipv6 standard bitcoin ADDR format packets This a working prof of concept . And can sure be optimized in many ways,\r\nOn top of this PR to easy test on the fly v3 onions  \r\n[repro](https://github.com/Saibato/bitcoin/tree/tunnel-v3-onions)\r\n\r\ni.e with a running open  tor browser you can generate v3 onions on the fly. Use\r\n` bitcoin-qt  -proxy=127.0.0.1:9150 -torcontrol=127.0.0.1:9151`\r\n\r\nBtw the tor browser like Orbot sits at 9150/9151 not 9050/9051\r\n\r\n``` Diff\r\ndiff --git a/src/addrman.h b/src/addrman.h\r\nindex 8e82020df..4a810e53f 100644\r\n--- a/src/addrman.h\r\n+++ b/src/addrman.h\r\n@@ -61,6 +61,7 @@ public:\r\n     SERIALIZE_METHODS(CAddrInfo, obj)\r\n     {\r\n         READWRITEAS(CAddress, obj);\r\n+        READWRITEAS(CNetAddr, obj);\r\n         READWRITE(obj.source, obj.nLastSuccess, obj.nAttempts);\r\n     }\r\n \r\ndiff --git a/src/net.cpp b/src/net.cpp\r\nindex 05ee26f8a..74f8ee898 100644\r\n--- a/src/net.cpp\r\n+++ b/src/net.cpp\r\n@@ -156,6 +156,7 @@ static std::vector<CAddress> convertSeed6(const std::vector<SeedSpec6> &vSeedsIn\r\n         struct in6_addr ip;\r\n         memcpy(&ip, seed_in.addr, sizeof(ip));\r\n         CAddress addr(CService(ip, seed_in.port), GetDesirableServiceFlags(NODE_NONE));\r\n+        LogPrintf(\"seeds %s\\n\", CNetAddr(addr).ToString());\r\n         addr.nTime = GetTime() - rng.randrange(nOneWeek) - nOneWeek;\r\n         vSeedsOut.push_back(addr);\r\n     }\r\n@@ -368,32 +369,42 @@ static CAddress GetBindAddress(SOCKET sock)\r\n     return addr_bind;\r\n }\r\n \r\n+static CAddress getadrr(std::string name) {\r\n+       return CAddress(CService(name,18444), NODE_NONE);\r\n+}\r\n CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure, bool manual_connection, bool block_relay_only)\r\n {\r\n-    if (pszDest == nullptr) {\r\n+     if (pszDest == nullptr) {\r\n         if (IsLocal(addrConnect))\r\n             return nullptr;\r\n \r\n         // Look for an existing connection\r\n         CNode* pnode = FindNode(static_cast<CService>(addrConnect));\r\n-        if (pnode)\r\n-        {\r\n+        if (pnode) {\r\n             LogPrintf(\"Failed to open new connection, already connected\\n\");\r\n             return nullptr;\r\n         }\r\n     }\r\n \r\n     /// debug print\r\n-    LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\r\n-        pszDest ? pszDest : addrConnect.ToString(),\r\n+           LogPrint(BCLog::NET, \"trying connection %s unresolved address %s lastseen=%.1fhrs\\n\",\r\n+        pszDest ? pszDest:\"\", addrConnect.ToString(),\r\n         pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\r\n \r\n+    std::string strName = std::string( pszDest ? pszDest:\"\");\r\n+\r\n     // Resolve\r\n     const int default_port = Params().GetDefaultPort();\r\n     if (pszDest) {\r\n         std::vector<CService> resolved;\r\n         if (Lookup(pszDest, resolved,  default_port, fNameLookup && !HaveNameProxy(), 256) && !resolved.empty()) {\r\n+\r\n+       // dont resolv local the onions\r\n+       if (!strName.find(\".onion\")) {\r\n+\r\n             addrConnect = CAddress(resolved[GetRand(resolved.size())], NODE_NONE);\r\n+\r\n+\r\n             if (!addrConnect.IsValid()) {\r\n                 LogPrint(BCLog::NET, \"Resolver returned invalid address %s for %s\\n\", addrConnect.ToString(), pszDest);\r\n                 return nullptr;\r\n@@ -404,12 +415,12 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\r\n             // name catch this early.\r\n             LOCK(cs_vNodes);\r\n             CNode* pnode = FindNode(static_cast<CService>(addrConnect));\r\n-            if (pnode)\r\n-            {\r\n+            if (pnode) {\r\n                 pnode->MaybeSetAddrName(std::string(pszDest));\r\n                 LogPrintf(\"Failed to open new connection, already connected\\n\");\r\n                 return nullptr;\r\n             }\r\n+            }\r\n         }\r\n     }\r\n \r\n@@ -417,7 +428,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\r\n     bool connected = false;\r\n     SOCKET hSocket = INVALID_SOCKET;\r\n     proxyType proxy;\r\n-    if (addrConnect.IsValid()) {\r\n+    if (addrConnect.IsValid() && addrConnect.IsTor() && !pszDest) {\r\n         bool proxyConnectionFailed = false;\r\n \r\n         if (GetProxy(addrConnect.GetNetwork(), proxy)) {\r\n@@ -425,14 +436,21 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\r\n             if (hSocket == INVALID_SOCKET) {\r\n                 return nullptr;\r\n             }\r\n-            connected = ConnectThroughProxy(proxy, addrConnect.ToStringIP(), addrConnect.GetPort(), hSocket, nConnectTimeout, proxyConnectionFailed);\r\n+\r\n+           if (addrConnect.ToStringIP() != \"\") {\r\n+                connected = ConnectThroughProxy(proxy, addrConnect.ToStringIP(), addrConnect.GetPort(), hSocket, nConnectTimeout, proxyConnectionFailed);\r\n+        } else return nullptr;\r\n+\r\n         } else {\r\n-            // no proxy needed (none set for target network)\r\n+            // no proxy needed (none set for tastrName.find(\".onion\")rget network)\r\n             hSocket = CreateSocket(addrConnect);\r\n             if (hSocket == INVALID_SOCKET) {\r\n                 return nullptr;\r\n             }\r\n-            connected = ConnectSocketDirectly(addrConnect, hSocket, nConnectTimeout, manual_connection);\r\n+\r\n+            if (addrConnect.ToString() != \"\") {\r\n+                connected = ConnectSocketDirectly(addrConnect, hSocket, nConnectTimeout, manual_connection);\r\n+            } else return nullptr;\r\n         }\r\n         if (!proxyConnectionFailed) {\r\n             // If a connection to the node was attempted, and failure (if any) is not caused by a problem connecting to\r\n@@ -444,14 +462,24 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\r\n         if (hSocket == INVALID_SOCKET) {\r\n             return nullptr;\r\n         }\r\n+\r\n         std::string host;\r\n         int port = default_port;\r\n         SplitHostPort(std::string(pszDest), port, host);\r\n         bool proxyConnectionFailed;\r\n-        connected = ConnectThroughProxy(proxy, host, port, hSocket, nConnectTimeout, proxyConnectionFailed);\r\n+        connected = false;\r\n+        //proxyConnectionFailed = true;\r\n+\r\n+\r\n+       if (strlen(pszDest) > 0) //strName.find(\".onion\"))\r\n+        {\r\n+                       LogPrintf(\"Address to connect over proxz  %s %d\\n\", host, port);\r\n+            connected = ConnectThroughProxy(proxy, host, port, hSocket, nConnectTimeout, proxyConnectionFailed);\r\n+        } else return nullptr;\r\n+\r\n     }\r\n     if (!connected) {\r\n-        CloseSocket(hSocket);\r\n+        if (hSocket) CloseSocket(hSocket);\r\n         return nullptr;\r\n     }\r\n \r\n@@ -1704,17 +1732,6 @@ void CConnman::ThreadDNSAddressSeed()\r\n     LogPrintf(\"%d addresses found from DNS seeds\\n\", found);\r\n }\r\n \r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n-\r\n void CConnman::DumpAddresses()\r\n {\r\n     int64_t nStart = GetTimeMillis();\r\n@@ -2056,6 +2073,9 @@ void CConnman::OpenNetworkConnection(const CAddress& addrConnect, bool fCountFai\r\n         }\r\n     } else if (FindNode(std::string(pszDest)))\r\n         return;\r\n+    // will \"\":port ever work?\r\n+\r\n+       if(!pszDest && (addrConnect.ToStringIP() == \"\")) return;\r\n \r\n     CNode* pnode = ConnectNode(addrConnect, pszDest, fCountFailure, manual_connection, block_relay_only);\r\n \r\n@@ -2760,6 +2780,7 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\r\n     // peers (to prevent adversaries from inferring these links from addr\r\n     // traffic).\r\n     m_addr_known{block_relay_only ? nullptr : MakeUnique<CRollingBloomFilter>(5000, 0.001)},\r\n+\r\n     id(idIn),\r\n     nLocalHostNonce(nLocalHostNonceIn),\r\n     nLocalServices(nLocalServicesIn),\r\ndiff --git a/src/net_processing.cpp b/src/net_processing.cpp\r\nindex 7f8944324..29465f9fa 100644\r\n--- a/src/net_processing.cpp\r\n+++ b/src/net_processing.cpp\r\n@@ -113,9 +113,9 @@ static const int MAX_UNCONNECTING_HEADERS = 10;\r\n /** Minimum blocks required to signal NODE_NETWORK_LIMITED */\r\n static const unsigned int NODE_NETWORK_LIMITED_MIN_BLOCKS = 288;\r\n /** Average delay between local address broadcasts */\r\n-static constexpr std::chrono::hours AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL{24};\r\n+static constexpr std::chrono::hours AVG_LOCAL_ADDRESS_BROADCAST_INTERVAL{2};\r\n /** Average delay between peer address broadcasts */\r\n-static constexpr std::chrono::seconds AVG_ADDRESS_BROADCAST_INTERVAL{30};\r\n+static constexpr std::chrono::seconds AVG_ADDRESS_BROADCAST_INTERVAL{2};\r\n /** Average delay between trickled inventory transmissions in seconds.\r\n  *  Blocks and whitelisted receivers bypass this, outbound peers get half this delay. */\r\n static const unsigned int INVENTORY_BROADCAST_INTERVAL = 5;\r\n@@ -1872,11 +1872,11 @@ static void ProcessHeadersMessage(CNode& pfrom, CConnman* connman, ChainstateMan\r\n                     uint32_t nFetchFlags = GetFetchFlags(pfrom);\r\n                     vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\r\n                     MarkBlockAsInFlight(mempool, pfrom.GetId(), pindex->GetBlockHash(), pindex);\r\n-                    LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\r\n+                    LogPrint(BCLog::BENCH, \"Requesting block %s from  peer=%d\\n\",\r\n                             pindex->GetBlockHash().ToString(), pfrom.GetId());\r\n                 }\r\n                 if (vGetData.size() > 1) {\r\n-                    LogPrint(BCLog::NET, \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\r\n+                    LogPrint(BCLog::BENCH, \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\r\n                             pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\r\n                 }\r\n                 if (vGetData.size() > 0) {\r\n@@ -2221,7 +2221,6 @@ void ProcessMessage(\r\n         return;\r\n     }\r\n \r\n-\r\n     if (msg_type == NetMsgType::VERSION) {\r\n         // Each connection can only send one version message\r\n         if (pfrom.nVersion != 0)\r\n@@ -2460,14 +2459,44 @@ void ProcessMessage(\r\n         std::vector<CAddress> vAddrOk;\r\n         int64_t nNow = GetAdjustedTime();\r\n         int64_t nSince = nNow - 10 * 60;\r\n+        int i = 0;\r\n+        size_t len = 10;\r\n+        CAddress Tor = CAddress(vAddr[0]);\r\n+        char rawaddr[256] = {};\r\n+\r\n         for (CAddress& addr : vAddr)\r\n         {\r\n-            if (interruptMsgProc)\r\n-                return;\r\n+\r\n+        if (addr.IsTorSequence(i)) {\r\n+            if (i == 0 ) {\r\n+                // LogPrintf(\"Adrress addr V3 raw  rec =\");\r\n+                Tor = addr;\r\n+            }\r\n+        //V3sequence())\r\n+        addr.SetSpecial_v3(addr, 256); //fill hostdata from ip;\r\n+        memcpy(&rawaddr[i*10], &addr.fqdn.c_str()[0], 10);\r\n+        i++;\r\n+        if (i != 8) continue;\r\n+\r\n+               } else addr.fqdn = {};\r\n+\r\n+        //LogPrintf(\"\\nAdrress add raw? %s\\n\",  &rawaddr[0]);\r\n+\r\n+        if ( i == 8 ) {\r\n+            Tor.SetSpecial_v3(addr, 255); // set clasic tor flag\r\n+            Tor.fqdn = rawaddr;\r\n+            if ( i == 8 ) Tor.fqdn = rawaddr;\r\n+            addr = Tor;\r\n+        }\r\n+\r\n+        if (addr.IsTor() && strlen(addr.fqdn.c_str()) < 32) addr.SetSpecial_v3(addr, 255); // v2 stzle\r\n+        LogPrint(BCLog::NET, \"Adrress add? %s\\n\",  addr.ToString());\r\n+\r\n \r\n             // We only bother storing full nodes, though this may include\r\n             // things which we would not make an outbound connection to, in\r\n             // part because we may make feeler connections to them.\r\n+\r\n             if (!MayHaveUsefulAddressDB(addr.nServices) && !HasAllDesirableServiceFlags(addr.nServices))\r\n                 continue;\r\n \r\n@@ -2583,7 +2612,7 @@ void ProcessMessage(\r\n \r\n         if (best_block != nullptr) {\r\n             connman->PushMessage(&pfrom, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(pindexBestHeader), *best_block));\r\n-            LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, best_block->ToString(), pfrom.GetId());\r\n+            LogPrint(BCLog::BENCH, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, best_block->ToString(), pfrom.GetId());\r\n         }\r\n \r\n         return;\r\n@@ -2599,10 +2628,10 @@ void ProcessMessage(\r\n             return;\r\n         }\r\n \r\n-        LogPrint(BCLog::NET, \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom.GetId());\r\n+        LogPrint(BCLog::BENCH, \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom.GetId());\r\n \r\n         if (vInv.size() > 0) {\r\n-            LogPrint(BCLog::NET, \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom.GetId());\r\n+            LogPrint(BCLog::BENCH, \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom.GetId());\r\n         }\r\n \r\n         pfrom.vRecvGetData.insert(pfrom.vRecvGetData.end(), vInv.begin(), vInv.end());\r\n@@ -3906,12 +3935,25 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\r\n             std::vector<CAddress> vAddr;\r\n             vAddr.reserve(pto->vAddrToSend.size());\r\n             assert(pto->m_addr_known);\r\n+            CAddress addr_add;\r\n             for (const CAddress& addr : pto->vAddrToSend)\r\n             {\r\n                 if (!pto->m_addr_known->contains(addr.GetKey()))\r\n                 {\r\n                     pto->m_addr_known->insert(addr.GetKey());\r\n-                    vAddr.push_back(addr);\r\n+                    if (!addr.IsTor()) vAddr.push_back(addr);\r\n+                    if (addr.IsTor()) LogPrint(BCLog::NET, \"Try to send onion address = %s\\n\", addr.fqdn);\r\n+\r\n+                    if (addr.IsTor() && strlen(addr.fqdn.c_str()) > 32) {\r\n+                        for (int i=0;i<8;i++) {\r\n+                            addr_add = addr;\r\n+                            addr_add.SetSpecial_v3(addr, (i)*10);\r\n+\r\n+                            vAddr.push_back(addr_add);\r\n+\r\n+                        }\r\n+                    } else  vAddr.push_back(addr); //v2 tor\r\n+\r\n                     // receiver rejects addr messages larger than 1000\r\n                     if (vAddr.size() >= 1000)\r\n                     {\r\n@@ -3924,7 +3966,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\r\n             if (!vAddr.empty())\r\n                 connman->PushMessage(pto, msgMaker.Make(NetMsgType::ADDR, vAddr));\r\n             // we only send the big addr message once\r\n-            if (pto->vAddrToSend.capacity() > 40)\r\n+            if (pto->vAddrToSend.capacity() > 400)\r\n                 pto->vAddrToSend.shrink_to_fit();\r\n         }\r\n \r\n@@ -4310,7 +4352,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\r\n                 uint32_t nFetchFlags = GetFetchFlags(*pto);\r\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\r\n                 MarkBlockAsInFlight(m_mempool, pto->GetId(), pindex->GetBlockHash(), pindex);\r\n-                LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\r\n+                LogPrint(BCLog::BENCH, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\r\n                     pindex->nHeight, pto->GetId());\r\n             }\r\n             if (state.nBlocksInFlight == 0 && staller != -1) {\r\ndiff --git a/src/netaddress.cpp b/src/netaddress.cpp\r\nindex 674439161..f74dbd30a 100644\r\n--- a/src/netaddress.cpp\r\n+++ b/src/netaddress.cpp\r\n@@ -5,13 +5,20 @@\r\n \r\n #include <cstdint>\r\n #include <netaddress.h>\r\n+#include <netbase.h>\r\n+\r\n #include <hash.h>\r\n #include <util/strencodings.h>\r\n #include <util/asmap.h>\r\n #include <tinyformat.h>\r\n \r\n-static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\r\n+\r\n+#include <util/system.h>\r\n+\r\n+\r\n+static const unsigned char pchIPv4[12] = {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\r\n static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};\r\n+static const unsigned char pchOnionSeq[] = {0xFD,'l','o','r','3',0x00};\r\n \r\n // 0xFD + sha256(\"bitcoin\")[0:5]\r\n static const unsigned char g_internal_prefix[] = { 0xFD, 0x6B, 0x88, 0xC0, 0x87, 0x24 };\r\n@@ -47,6 +54,12 @@ void CNetAddr::SetRaw(Network network, const uint8_t *ip_in)\r\n     }\r\n }\r\n \r\n+void CNetAddr::SetRawByte(char p , int pos)\r\n+{\r\n+               ip[6+pos] = p;\r\n+\r\n+}\r\n+\r\n /**\r\n  * Try to make this a dummy address that maps the specified name into IPv6 like\r\n  * so: (0xFD + %sha256(\"bitcoin\")[0:5]) + %sha256(name)[0:10]. Such dummy\r\n@@ -70,12 +83,21 @@ bool CNetAddr::SetInternal(const std::string &name)\r\n     CSHA256().Write((const unsigned char*)name.data(), name.size()).Finalize(hash);\r\n     memcpy(ip, g_internal_prefix, sizeof(g_internal_prefix));\r\n     memcpy(ip + sizeof(g_internal_prefix), hash, sizeof(ip) - sizeof(g_internal_prefix));\r\n+\r\n+    fqdn = name;\r\n     return true;\r\n }\r\n \r\n /**\r\n  * Try to make this a dummy address that maps the specified onion address into\r\n- * IPv6 using OnionCat's range and encoding. Such dummy addresses have a prefix\r\n+ * IPv6 using OnionCat's range        std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\r\n+        if (vchAddr.size() != 16-sizeof(pchOnionCat))\r\n+            return false;\r\n+        memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\r\n+        for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)\r\n+            ip[i + sizeof(pchOnionCat)] = vchAddr[i];\r\n+        return true;\r\n+    }and encoding. Such dummy addresses have a prefix\r\n  * of fd87:d87e:eb43::/48 and are guaranteed to not be publicly routable as they\r\n  * fall under RFC4193's fc00::/7 subnet allocated to unique-local addresses.\r\n  *\r\n@@ -83,20 +105,52 @@ bool CNetAddr::SetInternal(const std::string &name)\r\n  *\r\n  * @see CNetAddr::IsTor(), CNetAddr::IsRFC4193()\r\n  */\r\n-bool CNetAddr::SetSpecial(const std::string &strName)\r\n+bool CNetAddr::SetSpecial(const std::string &strName, int flag)\r\n {\r\n     if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\r\n-        std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\r\n-        if (vchAddr.size() != 16-sizeof(pchOnionCat))\r\n+        std::vector<unsigned char> vchAddr =  DecodeBase32(strName.substr(flag*10, strName.size() - 6).c_str());\r\n+        if (vchAddr.size() != 16-sizeof(pchOnionCat) && vchAddr.size() != 35)\r\n             return false;\r\n         memcpy(ip, pchOnionCat, sizeof(pchOnionCat));\r\n         for (unsigned int i=0; i<16-sizeof(pchOnionCat); i++)\r\n             ip[i + sizeof(pchOnionCat)] = vchAddr[i];\r\n+        fqdn = strName;\r\n+\r\n+        LogPrint(BCLog::NET, \"setspecail called with %s %d\\n\", strName, flag);\r\n         return true;\r\n     }\r\n     return false;\r\n }\r\n \r\n+bool CNetAddr::SetSpecial_v3(CNetAddr ref , int flag)\r\n+{\r\n+    //fqdn.resize(256);\r\n+    std::string cp = ref.fqdn;\r\n+    cp.resize(256);\r\n+    if( flag < 254 ) {  memcpy(ip, pchOnionSeq, sizeof(pchOnionSeq));\r\n+        for (unsigned int i=0; i<16-sizeof(pchOnionSeq); i++) {\r\n+            ip[i + sizeof(pchOnionSeq)] = cp.c_str()[flag+i];\r\n+        }\r\n+        fqdn = cp.substr(flag,10);\r\n+    }\r\n+    if (flag == 255) { // backward comp\r\n+        std::string name = EncodeBase32(&ip[6], 10) + \".onion\";\r\n+        fqdn = name;\r\n+    }\r\n+    if (flag == 256) {\r\n+        for (unsigned int i=0; i<16-sizeof(pchOnionSeq); i++) {\r\n+            fqdn[i] = char(ip[i + sizeof(pchOnionSeq)]);\r\n+        }\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+CNetAddr::CNetAddr(const std::string &strName)\r\n+{\r\n+    SetSpecial(strName);\r\n+    LogPrint(BCLog::NET,  \"CNetAddr internal setspecail called from addr by name\\n\");\r\n+}\r\n+\r\n CNetAddr::CNetAddr(const struct in_addr& ipv4Addr)\r\n {\r\n     SetRaw(NET_IPV4, (const uint8_t*)&ipv4Addr);\r\n@@ -224,9 +278,21 @@ bool CNetAddr::IsHeNet() const\r\n  */\r\n bool CNetAddr::IsTor() const\r\n {\r\n-    return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0);\r\n+    return (memcmp(ip, pchOnionCat, sizeof(pchOnionCat)) == 0) || IsTorSequence(0x0);\r\n }\r\n \r\n+/**\r\n+\r\n+ * @see CNetAddr::SetSpecial(const std::string &)\r\n+ */\r\n+bool CNetAddr::IsTorSequence(char seq) const\r\n+{\r\n+    return  memcmp(ip, pchOnionSeq, sizeof(pchOnionSeq)) == 0;\r\n+}\r\n+\r\n+\r\n+\r\n+\r\n bool CNetAddr::IsLocal() const\r\n {\r\n     // IPv4 loopback (127.0.0.0/8 or 0.0.0.0/8)\r\n@@ -333,26 +399,29 @@ enum Network CNetAddr::GetNetwork() const\r\n \r\n std::string CNetAddr::ToStringIP() const\r\n {\r\n-    if (IsTor())\r\n-        return EncodeBase32(&ip[6], 10) + \".onion\";\r\n+    if (IsTor()) {\r\n+            return fqdn;\r\n+       }\r\n     if (IsInternal())\r\n         return EncodeBase32(ip + sizeof(g_internal_prefix), sizeof(ip) - sizeof(g_internal_prefix)) + \".internal\";\r\n-    CService serv(*this, 0);\r\n-    struct sockaddr_storage sockaddr;\r\n-    socklen_t socklen = sizeof(sockaddr);\r\n-    if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\r\n-        char name[1025] = \"\";\r\n-        if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), nullptr, 0, NI_NUMERICHOST))\r\n-            return std::string(name);\r\n-    }\r\n+\r\n+    //CService serv(*this, 0);\r\n+    //struct sockaddr_storage sockaddr;\r\n+    //socklen_t socklen = sizeof(sockaddr);\r\n+    //if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\r\n+        //char name[1025] = \"\";\r\n+        //if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), nullptr, 0, NI_NUMERICHOST))\r\n+        //return std::string(name);\r\n+    //}\r\n+\r\n     if (IsIPv4())\r\n         return strprintf(\"%u.%u.%u.%u\", GetByte(3), GetByte(2), GetByte(1), GetByte(0));\r\n     else\r\n-        return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\r\n-                         GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\r\n-                         GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\r\n-                         GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\r\n-                         GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\r\n+               return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\r\n+                        GetByte(15) << 8 | GetByte(14), GetByte(13) << 8 | GetByte(12),\r\n+                        GetByte(11) << 8 | GetByte(10), GetByte(9) << 8 | GetByte(8),\r\n+                        GetByte(7) << 8 | GetByte(6), GetByte(5) << 8 | GetByte(4),\r\n+                        GetByte(3) << 8 | GetByte(2), GetByte(1) << 8 | GetByte(0));\r\n }\r\n \r\n std::string CNetAddr::ToString() const\r\n@@ -640,6 +709,10 @@ CService::CService(const struct in6_addr& ipv6Addr, uint16_t portIn) : CNetAddr(\r\n {\r\n }\r\n \r\n+CService::CService(const std::string fqdn, uint16_t portIn) : CNetAddr(fqdn), port(portIn)\r\n+{\r\n+}\r\n+\r\n CService::CService(const struct sockaddr_in& addr) : CNetAddr(addr.sin_addr), port(ntohs(addr.sin_port))\r\n {\r\n     assert(addr.sin_family == AF_INET);\r\ndiff --git a/src/netaddress.h b/src/netaddress.h\r\nindex c20101215..e18cc31a1 100644\r\n--- a/src/netaddress.h\r\n+++ b/src/netaddress.h\r\n@@ -38,16 +38,18 @@ class CNetAddr\r\n         CNetAddr();\r\n         explicit CNetAddr(const struct in_addr& ipv4Addr);\r\n         void SetIP(const CNetAddr& ip);\r\n+        std::string fqdn = {};\r\n \r\n         /**\r\n          * Set raw IPv4 or IPv6 address (in network byte order)\r\n-         * @note Only NET_IPV4 and NET_IPV6 are allowed for network.\r\n+         * @note void SetRawBytes(const uint8_t *ip_in);Only NET_IPV4 and NET_IPV6 are allowed for network.\r\n          */\r\n         void SetRaw(Network network, const uint8_t *data);\r\n-\r\n+               void SetRawByte(char b, int pos);\r\n         bool SetInternal(const std::string& name);\r\n \r\n-        bool SetSpecial(const std::string &strName); // for Tor addresses\r\n+        bool SetSpecial_v3(CNetAddr ref , int flag); // for Tor addresses\r\n+        bool SetSpecial(const std::string &strName, int flag = 0);\r\n         bool IsBindAny() const; // INADDR_ANY equivalent\r\n         bool IsIPv4() const;    // IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)\r\n         bool IsIPv6() const;    // IPv6 address (not mapped IPv4, not Tor)\r\n@@ -67,6 +69,7 @@ class CNetAddr\r\n         bool IsRFC6145() const; // IPv6 IPv4-translated address (::FFFF:0:0:0/96) (actually defined in RFC2765)\r\n         bool IsHeNet() const;   // IPv6 Hurricane Electric - https://he.net (2001:0470::/36)\r\n         bool IsTor() const;\r\n+        bool IsTorSequence(char pseq) const;\r\n         bool IsLocal() const;\r\n         bool IsRoutable() const;\r\n         bool IsInternal() const;\r\n@@ -94,13 +97,14 @@ class CNetAddr\r\n         int GetReachabilityFrom(const CNetAddr *paddrPartner = nullptr) const;\r\n \r\n         explicit CNetAddr(const struct in6_addr& pipv6Addr, const uint32_t scope = 0);\r\n+        CNetAddr(const std::string &strName);\r\n         bool GetIn6Addr(struct in6_addr* pipv6Addr) const;\r\n \r\n         friend bool operator==(const CNetAddr& a, const CNetAddr& b);\r\n         friend bool operator!=(const CNetAddr& a, const CNetAddr& b) { return !(a == b); }\r\n         friend bool operator<(const CNetAddr& a, const CNetAddr& b);\r\n \r\n-        SERIALIZE_METHODS(CNetAddr, obj) { READWRITE(obj.ip); }\r\n+        SERIALIZE_METHODS(CNetAddr, obj) { READWRITE(obj.ip, obj.fqdn); }\r\n \r\n         friend class CSubNet;\r\n };\r\n@@ -144,7 +148,8 @@ class CService : public CNetAddr\r\n     public:\r\n         CService();\r\n         CService(const CNetAddr& ip, uint16_t port);\r\n-        CService(const struct in_addr& ipv4Addr, uint16_t port);\r\n+        CService(const struct in_addr& ipv4Addr, uint16_t port);;\r\n+        CService(const std::string, uint16_t port);\r\n         explicit CService(const struct sockaddr_in& addr);\r\n         uint16_t GetPort() const;\r\n         bool GetSockAddr(struct sockaddr* paddr, socklen_t *addrlen) const;\r\ndiff --git a/src/netbase.cpp b/src/netbase.cpp\r\nindex 3a3b5f3e6..2c16524e8 100644\r\n--- a/src/netbase.cpp\r\n+++ b/src/netbase.cpp\r\n@@ -4,6 +4,7 @@\r\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n \r\n #include <netbase.h>\r\n+#include <net.h>\r\n \r\n #include <sync.h>\r\n #include <tinyformat.h>\r\n@@ -69,17 +70,18 @@ bool static LookupIntern(const std::string& name, std::vector<CNetAddr>& vIP, un\r\n         return false;\r\n     }\r\n \r\n-    {\r\n-        CNetAddr addr;\r\n-        // From our perspective, onion addresses are not hostnames but rather\r\n-        // direct encodings of CNetAddr much like IPv4 dotted-decimal notation\r\n-        // or IPv6 colon-separated hextet notation. Since we can't use\r\n-        // getaddrinfo to decode them and it wouldn't make sense to resolve\r\n-        // them, we return a network address representing it instead. See\r\n-        // CNetAddr::SetSpecial(const std::string&) for more details.\r\n-        if (addr.SetSpecial(name)) {\r\n+    CNetAddr addr;\r\n+    // From our perspective, onion addresses are not hostnames but rather\r\n+    // direct encodings of CNetAddr much like IPv4 dotted-decimal notation\r\n+    // or IPv6 colon-separated hextet notation. Since we can't use\r\n+    // getaddrinfo to decode them and it wouldn't make sense to resolve\r\n+    // them, we return a network address representing it instead. See\r\n+    // CNetAddr::SetSpecial(const std::string&) for more details.\r\n+\r\n+    if (name.find(\".onion\")) {\r\n+        if (addr.SetSpecial(name,0)) {\r\n             vIP.push_back(addr);\r\n-            return true;\r\n+            return false;\r\n         }\r\n     }\r\n \r\n@@ -97,12 +99,19 @@ bool static LookupIntern(const std::string& name, std::vector<CNetAddr>& vIP, un\r\n     // If we don't allow lookups, then use the AI_NUMERICHOST flag for\r\n     // getaddrinfo to only decode numerical network addresses and suppress\r\n     // hostname lookups.\r\n-    aiHint.ai_flags = fAllowLookup ? AI_ADDRCONFIG : AI_NUMERICHOST;\r\n+    aiHint.ai_flags = fAllowLookup && !HaveNameProxy() ? AI_ADDRCONFIG : AI_NUMERICHOST;\r\n     struct addrinfo *aiRes = nullptr;\r\n     int nErr = getaddrinfo(name.c_str(), nullptr, &aiHint, &aiRes);\r\n-    if (nErr)\r\n-        return false;\r\n \r\n+    LogPrintf(\"Resolver :%s error = %d  local resolve allowed %s  %s\\n\", name.c_str() ,nErr,fAllowLookup, nErr?\"fail\":\"local resolved\");\r\n+    if (nErr ) {\r\n+        CNetAddr resolved;\r\n+        resolved.SetInternal(name);\r\n+        if (resolved.IsInternal()) {\r\n+            vIP.push_back(resolved);\r\n+        }\r\n+        return false;\r\n+    }\r\n     // Traverse the linked list starting with aiTrav, add all non-internal\r\n     // IPv4,v6 addresses to vIP while respecting nMaxSolutions.\r\n     struct addrinfo *aiTrav = aiRes;\r\n@@ -112,7 +121,7 @@ bool static LookupIntern(const std::string& name, std::vector<CNetAddr>& vIP, un\r\n         if (aiTrav->ai_family == AF_INET)\r\n         {\r\n             assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in));\r\n-            resolved = CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr);\r\n+            resolved =  CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr);\r\n         }\r\n \r\n         if (aiTrav->ai_family == AF_INET6)\r\n@@ -139,7 +148,7 @@ bool static LookupIntern(const std::string& name, std::vector<CNetAddr>& vIP, un\r\n  *\r\n  * @param name    The string representing a host. Could be a name or a numerical\r\n  *                IP address (IPv6 addresses in their bracketed form are\r\n- *                allowed).\r\n+ *                //        allowed).\r\n  * @param[out] vIP The resulting network addresses to which the specified host\r\n  *                 string resolved.\r\n  *\r\n@@ -182,7 +191,7 @@ bool LookupHost(const std::string& name, CNetAddr& addr, bool fAllowLookup)\r\n     addr = vIP.front();\r\n     return true;\r\n }\r\n-\r\n+;\r\n /**\r\n  * Resolve a service string to its corresponding service.\r\n  *\r\n@@ -204,7 +213,7 @@ bool LookupHost(const std::string& name, CNetAddr& addr, bool fAllowLookup)\r\n  *          resulting services.\r\n  */\r\n bool Lookup(const std::string& name, std::vector<CService>& vAddr, int portDefault, bool fAllowLookup, unsigned int nMaxSolutions)\r\n-{\r\n+{;\r\n     if (name.empty() || !ValidAsCString(name)) {\r\n         return false;\r\n     }\r\n@@ -214,8 +223,19 @@ bool Lookup(const std::string& name, std::vector<CService>& vAddr, int portDefau\r\n \r\n     std::vector<CNetAddr> vIP;\r\n     bool fRet = LookupIntern(hostname, vIP, nMaxSolutions, fAllowLookup);\r\n-    if (!fRet)\r\n+    if (vIP[0].IsTor()) {\r\n+                vAddr.resize(hostname.size());\r\n+       for (unsigned int i = 0; i < 1; i++)\r\n+        vAddr[i] = CService(hostname, port);\r\n+        return true;\r\n         return false;\r\n+       }\r\n+       if (!fRet) // mayby just a name  and only onion we do not resovel so use tor\r\n+       {\r\n+                        vAddr.resize(hostname.size());\r\n+             vAddr[0] = CService(hostname, port);\r\n+               return true;\r\n+       }\r\n     vAddr.resize(vIP.size());\r\n     for (unsigned int i = 0; i < vIP.size(); i++)\r\n         vAddr[i] = CService(vIP[i], port);\r\ndiff --git a/src/torcontrol.cpp b/src/torcontrol.cpp\r\nindex 84118b36e..ed2fd008b 100644\r\n--- a/src/torcontrol.cpp\r\n+++ b/src/torcontrol.cpp\r\n@@ -47,6 +47,11 @@ static const float RECONNECT_TIMEOUT_EXP = 1.5;\r\n  */\r\n static const int MAX_LINE_LENGTH = 100000;\r\n \r\n+enum Tor_proto_version {\r\n+                TOR_NET_V2,\r\n+                TOR_NET_V3\r\n+};\r\n+\r\n /****** Low-level TorControlConnection ********/\r\n \r\n /** Reply from Tor, can be single or multi-line */\r\n@@ -422,6 +427,7 @@ private:\r\n     struct event_base* base;\r\n     std::string target;\r\n     TorControlConnection conn;\r\n+    Tor_proto_version tor_version = TOR_NET_V2;\r\n     std::string private_key;\r\n     std::string service_id;\r\n     bool reconnect;\r\n@@ -463,12 +469,7 @@ TorController::TorController(struct event_base* _base, const std::string& _targe\r\n          std::bind(&TorController::disconnected_cb, this, std::placeholders::_1) )) {\r\n         LogPrintf(\"tor: Initiating connection to Tor control port %s failed\\n\", _target);\r\n     }\r\n-    // Read service private key if cached\r\n-    std::pair<bool,std::string> pkf = ReadBinaryFile(GetPrivateKeyFile());\r\n-    if (pkf.first) {\r\n-        LogPrint(BCLog::TOR, \"tor: Reading cached private key from %s\\n\", GetPrivateKeyFile().string());\r\n-        private_key = pkf.second;\r\n-    }\r\n+\r\n }\r\n \r\n TorController::~TorController()\r\n@@ -485,7 +486,7 @@ TorController::~TorController()\r\n void TorController::add_onion_cb(TorControlConnection& _conn, const TorControlReply& reply)\r\n {\r\n     if (reply.code == 250) {\r\n-        LogPrint(BCLog::TOR, \"tor: ADD_ONION successful\\n\");\r\n+        LogPrint(BCLog::TOR, \"tor: ADD_ONION %s successful\\n\", tor_version == TOR_NET_V2?\"V2\":\"V3\");\r\n         for (const std::string &s : reply.lines) {\r\n             std::map<std::string,std::string> m = ParseTorReplyMapping(s);\r\n             std::map<std::string,std::string>::iterator i;\r\n@@ -495,25 +496,47 @@ void TorController::add_onion_cb(TorControlConnection& _conn, const TorControlRe\r\n                 private_key = i->second;\r\n         }\r\n         if (service_id.empty()) {\r\n-            LogPrintf(\"tor: Error parsing ADD_ONION parameters:\\n\");\r\n+            LogPrintf(\"tor: Error parsing ADD_ONION %s parameters:\\n\", tor_version == TOR_NET_V2?\"V2\":\"V3\");\r\n             for (const std::string &s : reply.lines) {\r\n                 LogPrintf(\"    %s\\n\", SanitizeString(s));\r\n             }\r\n-            return;\r\n+\r\n+        } else {\r\n+            service = LookupNumeric(std::string(service_id+\".onion\"), Params().GetDefaultPort());\r\n+            if (service_id.length() > 16) tor_version = TOR_NET_V3;\r\n+            else tor_version = TOR_NET_V2;\r\n+            LogPrintf(\"tor: Got service ID %s, advertising service %s\\n\", service_id, service.ToString());\r\n+            if (WriteBinaryFile(GetPrivateKeyFile(), private_key)) {\r\n+                LogPrint(BCLog::TOR, \"tor: Write cached service private key to %s\\n\", GetPrivateKeyFile().string());\r\n+            } else {\r\n+                LogPrintf(\"tor: Error writing service private key to %s\\n\", GetPrivateKeyFile().string());\r\n+            }\r\n+            AddLocal(service, LOCAL_MANUAL);\r\n+            // ... onion requested - keep connection open\r\n+\r\n+            if (reply.code == 510) { // 510 Unrecognized command\r\n+            LogPrintf(\"tor: Add onion failed with unrecognized command (You probably need to upgrade Tor)\\n\");\r\n+            }\r\n         }\r\n-        service = LookupNumeric(std::string(service_id+\".onion\"), Params().GetDefaultPort());\r\n-        LogPrintf(\"tor: Got service ID %s, advertising service %s\\n\", service_id, service.ToString());\r\n-        if (WriteBinaryFile(GetPrivateKeyFile(), private_key)) {\r\n-            LogPrint(BCLog::TOR, \"tor: Cached service private key to %s\\n\", GetPrivateKeyFile().string());\r\n         } else {\r\n-            LogPrintf(\"tor: Error writing service private key to %s\\n\", GetPrivateKeyFile().string());\r\n+            LogPrintf(\"tor: Add onion failed; error code %d\\n\", reply.code);\r\n         }\r\n-        AddLocal(service, LOCAL_MANUAL);\r\n-        // ... onion requested - keep connection open\r\n-    } else if (reply.code == 510) { // 510 Unrecognized command\r\n-        LogPrintf(\"tor: Add onion failed with unrecognized command (You probably need to upgrade Tor)\\n\");\r\n-    } else {\r\n-        LogPrintf(\"tor: Add onion failed; error code %d\\n\", reply.code);\r\n+    // Tor might deprecate v2-onions so we try to create from now on also v3 onions\r\n+    // Now we try to create the v3-service\r\n+    if (tor_version == TOR_NET_V2) {\r\n+        tor_version = TOR_NET_V3;\r\n+        private_key = \"\";\r\n+        std::pair<bool,std::string> pkf = ReadBinaryFile(GetPrivateKeyFile());\r\n+        if (pkf.first) {\r\n+            LogPrint(BCLog::TOR, \"tor: Reading cached private key from %s\\n\", GetPrivateKeyFile().string());\r\n+            private_key = pkf.second;\r\n+        }\r\n+        if (private_key.empty()) // No private key, generate one\r\n+            private_key= \"NEW:ED25519-V3\"; // Explicitly request ED25519-V3\r\n+        // Request v3-hidden service, redirect port.\r\n+        // Note that the 'virtual' port is always the default port to avoid decloaking nodes using other ports.\r\n+        conn.Command(strprintf(\"ADD_ONION %s Port=%i,127.0.0.1:%i\", private_key, Params().GetDefaultPort(), GetListenPort()),\r\n+            std::bind(&TorController::add_onion_cb, this, std::placeholders::_1, std::placeholders::_2));\r\n     }\r\n }\r\n \r\n@@ -531,13 +554,22 @@ void TorController::auth_cb(TorControlConnection& _conn, const TorControlReply&\r\n             SetReachable(NET_ONION, true);\r\n         }\r\n \r\n-        // Finally - now create the service\r\n+        // Finaly we create the v2-service\r\n+        tor_version = TOR_NET_V2;\r\n+        private_key = \"\";\r\n+        std::pair<bool,std::string> pkf = ReadBinaryFile(GetPrivateKeyFile());\r\n+        if (pkf.first) {\r\n+            LogPrint(BCLog::TOR, \"tor: Reading cached private key from %s\\n\", GetPrivateKeyFile().string());\r\n+            private_key = pkf.second;\r\n+        }\r\n+        tor_version = TOR_NET_V2;\r\n         if (private_key.empty()) // No private key, generate one\r\n             private_key = \"NEW:RSA1024\"; // Explicitly request RSA1024 - see issue #9214\r\n-        // Request hidden service, redirect port.\r\n+        // Request v2-hidden service, redirect port.\r\n         // Note that the 'virtual' port is always the default port to avoid decloaking nodes using other ports.\r\n         _conn.Command(strprintf(\"ADD_ONION %s Port=%i,127.0.0.1:%i\", private_key, Params().GetDefaultPort(), GetListenPort()),\r\n             std::bind(&TorController::add_onion_cb, this, std::placeholders::_1, std::placeholders::_2));\r\n+\r\n     } else {\r\n         LogPrintf(\"tor: Authentication failed\\n\");\r\n     }\r\n@@ -718,7 +750,8 @@ void TorController::Reconnect()\r\n \r\n fs::path TorController::GetPrivateKeyFile()\r\n {\r\n-    return GetDataDir() / \"onion_private_key\";\r\n+    if (tor_version == TOR_NET_V2) return GetDataDir() / \"onion_private_key\";\r\n+    return GetDataDir() / \"onion_private_key_v3\";\r\n }\r\n \r\n void TorController::reconnect_cb(evutil_socket_t fd, short what, void *arg)\r\n@@ -734,7 +767,6 @@ static std::thread torControlThread;\r\n static void TorControlThread()\r\n {\r\n     TorController ctrl(gBase, gArgs.GetArg(\"-torcontrol\", DEFAULT_TOR_CONTROL));\r\n-\r\n     event_base_dispatch(gBase);\r\n }\r\n \r\n@@ -772,4 +804,5 @@ void StopTorControl()\r\n         event_base_free(gBase);\r\n         gBase = nullptr;\r\n     }\r\n+\r\n }\r\n\r\n```",
      "created_at" : "2020-07-11T00:25:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19485#issuecomment-656948716",
      "id" : 656948716,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19485",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY1Njk0ODcxNg==",
      "updated_at" : "2020-07-11T00:25:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/656948716",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/34917548?v=4",
         "events_url" : "https://api.github.com/users/Saibato/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Saibato/followers",
         "following_url" : "https://api.github.com/users/Saibato/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Saibato/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Saibato",
         "id" : 34917548,
         "login" : "Saibato",
         "node_id" : "MDQ6VXNlcjM0OTE3NTQ4",
         "organizations_url" : "https://api.github.com/users/Saibato/orgs",
         "received_events_url" : "https://api.github.com/users/Saibato/received_events",
         "repos_url" : "https://api.github.com/users/Saibato/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Saibato/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Saibato/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Saibato"
      }
   }
]
