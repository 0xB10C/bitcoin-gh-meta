[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225408327"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225408327"
         }
      },
      "author_association" : "MEMBER",
      "body" : "For the same reason as pointed out in the other PR, you can't do this; you're going to mark payments to individual multisig pubkeys as incoming payments.\r\n\r\nYou'll need a way to restrict this to P2PK, P2WPKH, and P2SH/P2WSH wrapped versions of those.\r\n\r\nEDIT: I realize that when it's about private keys, the same effect applies too, and there it can't be avoided. Perhaps this stuff is just to scary, and we should wait until there's a way to actually specify what to treat as ours explicitly...",
      "commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "created_at" : "2018-10-16T06:11:05Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225408327",
      "id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQwODMyNw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 486,
      "pull_request_review_id" : 164997487,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-10-16T06:15:30Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225408327",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225484727"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225484727"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```cpp\r\nif (data.exists(\"scriptPubKey\") && data.exists(\"descriptor\")) {\r\n    // throw error because these should be exclusive?\r\n}\r\n```\r\nand add test.",
      "commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "created_at" : "2018-10-16T10:32:07Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225484727",
      "id" : 225484727,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NDcyNw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 536,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 536,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-10-16T13:44:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225484727",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487379"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487379"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing test.",
      "commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "created_at" : "2018-10-16T10:41:39Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487379",
      "id" : 225487379,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NzM3OQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 444,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 444,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-10-16T13:44:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487379",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487418"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487418"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing test.",
      "commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "created_at" : "2018-10-16T10:41:50Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487418",
      "id" : 225487418,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NzQxOA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 446,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 446,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-10-16T13:44:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487418",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487555"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487555"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit `++i`.",
      "commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "created_at" : "2018-10-16T10:42:14Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487555",
      "id" : 225487555,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NzU1NQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 450,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 450,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-10-16T13:44:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487555",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487698"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487698"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit `++i`;",
      "commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "created_at" : "2018-10-16T10:42:48Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487698",
      "id" : 225487698,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NzY5OA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 491,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 491,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-10-16T13:44:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487698",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487854"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487854"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing test.",
      "commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "created_at" : "2018-10-16T10:43:16Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {\n+            ProcessImportLegacy(pwallet, data, timestamp);\n+        } else if (data.exists(\"descriptor\")) {\n+            ProcessImportDesc(pwallet, data, timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Either a descriptor or scriptPubKey must be provided.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487854",
      "id" : 225487854,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4Nzg1NA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 541,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 541,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-10-16T13:44:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487854",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487947"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487947"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, `ProcessImportDescriptor`.",
      "commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "created_at" : "2018-10-16T10:43:40Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {\n+            ProcessImportLegacy(pwallet, data, timestamp);\n+        } else if (data.exists(\"descriptor\")) {\n+            ProcessImportDesc(pwallet, data, timestamp);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487947",
      "id" : 225487947,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4Nzk0Nw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 539,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 539,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-10-16T13:44:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487947",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225495251"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225495251"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, extra `-` :sweat_smile:",
      "commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "created_at" : "2018-10-16T11:10:21Z",
      "diff_hunk" : "@@ -0,0 +1,6 @@\n+Low-level RPC changes\n+----------------------",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225495251",
      "id" : 225495251,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ5NTI1MQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 2,
      "path" : "doc/release-notes-14454.md",
      "position" : 2,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-10-16T13:44:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225495251",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225505588"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225505588"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit space after `if`.",
      "commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "created_at" : "2018-10-16T11:51:14Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225505588",
      "id" : 225505588,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTUwNTU4OA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 431,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 431,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-10-16T13:44:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225505588",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225531603"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225531603"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Restricting it from multisig(to avoid being tricked as you mention) would make this even more confusing to a user. \r\n\r\nUnfortunate. ",
      "commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "created_at" : "2018-10-16T13:10:52Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225531603",
      "id" : 225531603,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTUzMTYwMw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 486,
      "pull_request_review_id" : 165149268,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-10-16T13:10:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225531603",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225654495"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225654495"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Mentioned on IRC, but what if we just never import public keys at all, and only either A) add the scriptPubKey as watch only or B) import the private key. If we have the private key then IMO it's less scary, because it's still \"ours\" and we can access the funds",
      "commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "created_at" : "2018-10-16T18:21:27Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225654495",
      "id" : 225654495,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY1NDQ5NQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 486,
      "pull_request_review_id" : 165301641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-10-16T18:21:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225654495",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225662278"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225662278"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You're right; the same concern doesn't exist for private keys as you're obviously able to spend those coins anyway.",
      "commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "created_at" : "2018-10-16T18:40:24Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225662278",
      "id" : 225662278,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY2MjI3OA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 486,
      "pull_request_review_id" : 165309946,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-10-16T18:40:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225662278",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   }
]
