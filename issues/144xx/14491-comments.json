[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225408327"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225408327"
         }
      },
      "author_association" : "MEMBER",
      "body" : "For the same reason as pointed out in the other PR, you can't do this; you're going to mark payments to individual multisig pubkeys as incoming payments.\r\n\r\nYou'll need a way to restrict this to P2PK, P2WPKH, and P2SH/P2WSH wrapped versions of those.\r\n\r\nEDIT: I realize that when it's about private keys, the same effect applies too, and there it can't be avoided. Perhaps this stuff is just to scary, and we should wait until there's a way to actually specify what to treat as ours explicitly...",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-10-16T06:11:05Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225408327",
      "id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQwODMyNw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 164997487,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225408327",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225484727"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225484727"
         }
      },
      "author_association" : "MEMBER",
      "body" : "```cpp\r\nif (data.exists(\"scriptPubKey\") && data.exists(\"descriptor\")) {\r\n    // throw error because these should be exclusive?\r\n}\r\n```\r\nand add test.",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-10-16T10:32:07Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225484727",
      "id" : 225484727,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NDcyNw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 536,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225484727",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487379"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487379"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing test.",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-10-16T10:41:39Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487379",
      "id" : 225487379,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NzM3OQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 444,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 353,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487379",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487418"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487418"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing test.",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-10-16T10:41:50Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487418",
      "id" : 225487418,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NzQxOA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 446,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487418",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487555"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487555"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit `++i`.",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-10-16T10:42:14Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487555",
      "id" : 225487555,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NzU1NQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 450,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487555",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487698"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487698"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit `++i`;",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-10-16T10:42:48Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487698",
      "id" : 225487698,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4NzY5OA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 491,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487698",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487854"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487854"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Missing test.",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-10-16T10:43:16Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {\n+            ProcessImportLegacy(pwallet, data, timestamp);\n+        } else if (data.exists(\"descriptor\")) {\n+            ProcessImportDesc(pwallet, data, timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Either a descriptor or scriptPubKey must be provided.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487854",
      "id" : 225487854,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4Nzg1NA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 541,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 492,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487854",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487947"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487947"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, `ProcessImportDescriptor`.",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-10-16T10:43:40Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {\n+            ProcessImportLegacy(pwallet, data, timestamp);\n+        } else if (data.exists(\"descriptor\")) {\n+            ProcessImportDesc(pwallet, data, timestamp);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225487947",
      "id" : 225487947,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ4Nzk0Nw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 539,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225487947",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225495251"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225495251"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit, extra `-` :sweat_smile:",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-10-16T11:10:21Z",
      "diff_hunk" : "@@ -0,0 +1,6 @@\n+Low-level RPC changes\n+----------------------",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225495251",
      "id" : 225495251,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTQ5NTI1MQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 2,
      "path" : "doc/release-notes-14454.md",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225495251",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225505588"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225505588"
         }
      },
      "author_association" : "MEMBER",
      "body" : "nit space after `if`.",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-10-16T11:51:14Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225505588",
      "id" : 225505588,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTUwNTU4OA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 431,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165091113,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225505588",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225531603"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225531603"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Restricting it from multisig(to avoid being tricked as you mention) would make this even more confusing to a user. \r\n\r\nUnfortunate. ",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-10-16T13:10:52Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225531603",
      "id" : 225531603,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTUzMTYwMw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165149268,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225531603",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225654495"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225654495"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Mentioned on IRC, but what if we just never import public keys at all, and only either A) add the scriptPubKey as watch only or B) import the private key. If we have the private key then IMO it's less scary, because it's still \"ours\" and we can access the funds",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-10-16T18:21:27Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225654495",
      "id" : 225654495,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY1NDQ5NQ==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165301641,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225654495",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225662278"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225662278"
         }
      },
      "author_association" : "MEMBER",
      "body" : "You're right; the same concern doesn't exist for private keys as you're obviously able to spend those coins anyway.",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-10-16T18:40:24Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225662278",
      "id" : 225662278,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY2MjI3OA==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165309946,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225662278",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225665843"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225665843"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Would not importing the pubkeys affect the wallet's ability to construct PSBT inputs?",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-10-16T18:50:50Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225665843",
      "id" : 225665843,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY2NTg0Mw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165314304,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225665843",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225666972"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225666972"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Only for things that have PKH/WPKH construction in them (GetPubKey is needed for those, which finds a pubkey based on pubkeyhash).\r\n\r\n@MeshCollider To be clear, we do have to import the pubkey for those; otherwise the result is not solvable.",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-10-16T18:54:12Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225666972",
      "id" : 225666972,
      "in_reply_to_id" : 225408327,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTY2Njk3Mg==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 486,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 165315744,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225666972",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225736677"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225736677"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I said more tests were coming Ã°ÂÂÂ",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-10-16T23:08:21Z",
      "diff_hunk" : "@@ -806,266 +807,338 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n }\n \n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static void ProcessImportLegacy(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n {\n-    try {\n-        bool success = false;\n-\n-        // Required fields.\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-\n-        // Should have script or JSON with \"address\".\n-        if (!(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\")) && !(scriptPubKey.getType() == UniValue::VSTR)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n-        }\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n-\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        bool isP2SH = strRedeemScript.length() > 0;\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Parse the output.\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n-\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid scriptPubKey\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n \n-        // Internal + Label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n \n-        // Keys / PubKeys size check.\n-        if (!isP2SH && (keys.size() > 1 || pubKeys.size() > 1)) { // Address / scriptPubKey\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than private key given for one address\");\n-        }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Provide witnessscript not redeemscript for P2WSH address\");\n+    }\n \n-        // Invalid P2SH redeemScript\n-        if (isP2SH && !IsHex(strRedeemScript)) {\n+    // P2SH\n+    if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n+        // Check the redeemScript is valid\n+        if (!IsHex(strRedeemScript)) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script\");\n         }\n \n-        // Process. //\n+        // Import redeem script.\n+        std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n+        CScript redeemScript = CScript(vData.begin(), vData.end());\n+        CScriptID redeem_id(redeemScript);\n \n-        // P2SH\n-        if (isP2SH) {\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n+        // Check that the redeemScript and scriptPubKey match\n+        if (GetScriptForDestination(redeem_id) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n+        }\n \n-            // Invalid P2SH address\n-            if (!script.IsPayToScriptHash()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid P2SH address / script\");\n-            }\n+        pwallet->MarkDirty();\n \n-            pwallet->MarkDirty();\n+        if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+        if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        }\n \n-            CScriptID redeem_id(redeemScript);\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n+        // Check for P2SH-P2WSH\n+        if (redeemScript.IsPayToWitnessScriptHash()) {\n+            if (!IsHex(witness_script_hex)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n             }\n \n-            CScript redeemDestination = GetScriptForDestination(redeem_id);\n+            // Generate the scripts\n+            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+            CScriptID witness_id(witness_script);\n \n-            if (::IsMine(*pwallet, redeemDestination) == ISMINE_SPENDABLE) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            // Check that the witnessScript and P2SH redeemScript match\n+            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != redeemScript) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the redeemScript\");\n             }\n \n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemDestination, timestamp)) {\n+            // Import into the wallet\n+            if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n                 throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n \n-            // add to address book or update label\n-            if (IsValidDestination(dest)) {\n-                pwallet->SetAddressBook(dest, label, \"receive\");\n+            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh-p2wsh witnessScript to wallet\");\n             }\n+        }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                for (size_t i = 0; i < keys.size(); i++) {\n-                    const std::string& privkey = keys[i].get_str();\n-\n-                    CKey key = DecodeSecret(privkey);\n-\n-                    if (!key.IsValid()) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                    }\n-\n-                    CPubKey pubkey = key.GetPubKey();\n-                    assert(key.VerifyPubKey(pubkey));\n+    // P2WSH\n+    } else if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script\");\n+        }\n \n-                    CKeyID vchAddress = pubkey.GetID();\n-                    pwallet->MarkDirty();\n-                    pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        // Generate the scripts\n+        std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n+        CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n+        CScriptID witness_id(witness_script);\n \n-                    if (pwallet->HaveKey(vchAddress)) {\n-                        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n-                    }\n+        // Check that the witnessScript and scriptPubKey match\n+        if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey\");\n+        }\n \n-                    pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        // Import into the wallet\n+        if (!pwallet->AddWatchOnly(witness_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n \n-                    if (!pwallet->AddKeyPubKey(key, pubkey)) {\n-                        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                    }\n+        if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        }\n \n-                    pwallet->UpdateTimeFirstKey(timestamp);\n-                }\n+    // P2PK/P2PKH/P2WPKH\n+    } else if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n+        if (keys.size() > 1 || pubKeys.size() > 1) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n+        }\n+        CPubKey pubkey;\n+        if (keys.size()) {\n+            pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n+        }\n+        if (pubKeys.size()) {\n+            const std::string& strPubKey = pubKeys[0].get_str();\n+            if (!IsHex(strPubKey)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+            }\n+            std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n+            CPubKey pubkey_temp(vData.begin(), vData.end());\n+            if (pubkey.size() && pubkey_temp != pubkey) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+            }\n+            pubkey = pubkey_temp;\n+        }\n+        if (pubkey.size() > 0) {\n+            if (!pubkey.IsFullyValid()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n             }\n \n-            success = true;\n-        } else {\n-            // Import public keys.\n-            if (pubKeys.size() && keys.size() == 0) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-\n-                std::vector<unsigned char> vData(ParseHex(strPubKey));\n-                CPubKey pubKey(vData.begin(), vData.end());\n-\n-                if (!pubKey.IsFullyValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n-                }\n-\n-                CTxDestination pubkey_dest = pubKey.GetID();\n-\n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n-\n-                CScript pubKeyScript = GetScriptForDestination(pubkey_dest);\n-\n-                if (::IsMine(*pwallet, pubKeyScript) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n-\n-                pwallet->MarkDirty();\n-\n-                if (!pwallet->AddWatchOnly(pubKeyScript, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n-\n-                // add to address book or update label\n-                if (IsValidDestination(pubkey_dest)) {\n-                    pwallet->SetAddressBook(pubkey_dest, label, \"receive\");\n-                }\n-\n-                // TODO Is this necessary?\n-                CScript scriptRawPubKey = GetScriptForRawPubKey(pubKey);\n+            // Check the key corresponds to the destination given\n+            std::vector<CTxDestination> destinations = GetAllDestinationsForKey(pubkey);\n+            if (std::find(destinations.begin(), destinations.end(), dest) == destinations.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+            }\n \n-                if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+            // This is necessary to force the wallet to import the pubKey\n+            CScript scriptRawPubKey = GetScriptForRawPubKey(pubkey);\n \n-                pwallet->MarkDirty();\n+            if (::IsMine(*pwallet, scriptRawPubKey) == ISMINE_SPENDABLE) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+            }\n \n-                if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+            pwallet->MarkDirty();\n \n-                success = true;\n+            if (!pwallet->AddWatchOnly(scriptRawPubKey, timestamp)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n             }\n+        }\n+    }\n \n-            // Import private keys.\n-            if (keys.size()) {\n-                const std::string& strPrivkey = keys[0].get_str();\n+    // Import the address\n+    if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+    }\n \n-                // Checks.\n-                CKey key = DecodeSecret(strPrivkey);\n+    pwallet->MarkDirty();\n \n-                if (!key.IsValid()) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-                }\n+    if (!pwallet->AddWatchOnly(script, timestamp)) {\n+        throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+    }\n \n-                CPubKey pubKey = key.GetPubKey();\n-                assert(key.VerifyPubKey(pubKey));\n+    // add to address book or update label\n+    if (IsValidDestination(dest)) {\n+        pwallet->SetAddressBook(dest, label, \"receive\");\n+    }\n \n-                CTxDestination pubkey_dest = pubKey.GetID();\n+    // Import private keys.\n+    for (size_t i = 0; i < keys.size(); i++) {\n+        const std::string& strPrivkey = keys[i].get_str();\n \n-                // Consistency check.\n-                if (!(pubkey_dest == dest)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Consistency check failed\");\n-                }\n+        // Checks.\n+        CKey key = DecodeSecret(strPrivkey);\n \n-                CKeyID vchAddress = pubKey.GetID();\n-                pwallet->MarkDirty();\n-                pwallet->SetAddressBook(vchAddress, label, \"receive\");\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n \n-                if (pwallet->HaveKey(vchAddress)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        CPubKey pubKey = key.GetPubKey();\n+        assert(key.VerifyPubKey(pubKey));\n \n-                pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n+        CKeyID vchAddress = pubKey.GetID();\n+        pwallet->MarkDirty();\n \n-                if (!pwallet->AddKeyPubKey(key, pubKey)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n-                }\n+        if (pwallet->HaveKey(vchAddress)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+        }\n \n-                pwallet->UpdateTimeFirstKey(timestamp);\n+        pwallet->mapKeyMetadata[vchAddress].nCreateTime = timestamp;\n \n-                success = true;\n-            }\n+        if (!pwallet->AddKeyPubKey(key, pubKey)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+        }\n \n-            // Import scriptPubKey only.\n-            if (pubKeys.size() == 0 && keys.size() == 0) {\n-                if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n-                }\n+        pwallet->UpdateTimeFirstKey(timestamp);\n+    }\n+}\n \n-                pwallet->MarkDirty();\n+static void ProcessImportDesc(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    const std::string& descriptor = data[\"descriptor\"].get_str();\n+    const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    const UniValue& range = data.exists(\"range\") ? data[\"range\"].get_array() : UniValue();\n+    const int64_t range_start = range.size() > 0 ? range[0].get_int64() : 0;\n+    const int64_t range_end = range.size() > 1 ? range[1].get_int64() : range_start;\n+    if(range.size() > 2) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid range specified\");\n+    }\n \n-                if (!pwallet->AddWatchOnly(script, timestamp)) {\n-                    throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-                }\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange() && !data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n+    }\n+    FlatSigningProvider out_keys;\n+    std::vector<CScript> script_pub_keys;\n+    for (int i = range_start; i <= range_end; i++) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        script_pub_keys.insert(script_pub_keys.end(), scripts_temp.begin(), scripts_temp.end());\n+    }\n+    pwallet->MarkDirty();\n+    // Import all scriptPubKeys\n+    for (const CScript& script : script_pub_keys) {\n+        if (::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n+        }\n+        if (!pwallet->AddWatchOnly(script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+        // add to address book or update label\n+        CTxDestination destination;\n+        if (ExtractDestination(script, destination) && IsValidDestination(destination)) {\n+            pwallet->SetAddressBook(destination, label, \"receive\");\n+        }\n+    }\n+    // Import all scripts from descriptors\n+    for (auto const& x : out_keys.scripts) {\n+        if (!pwallet->AddWatchOnly(x.second, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+        if (!pwallet->HaveCScript(x.first) && !pwallet->AddCScript(x.second)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding script to wallet\");\n+        }\n+    }\n+    // Import all public keys from descriptors\n+    for (auto const& x : out_keys.pubkeys) {\n+        // This is necessary to force the wallet to import the pubKey\n+        CScript raw_pubkey_script = GetScriptForRawPubKey(x.second);\n+        if (::IsMine(*pwallet, raw_pubkey_script) == ISMINE_SPENDABLE) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this public key\");\n+        }\n+        if (!pwallet->AddWatchOnly(raw_pubkey_script, timestamp)) {\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n+        }\n+    }\n+    // Import private keys.\n+    for (size_t i = 0; i < priv_keys.size(); i++) {\n+        CKey priv_key = DecodeSecret(priv_keys[i].get_str());\n+        if (!priv_key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pub_key = priv_key.GetPubKey();\n+        assert(priv_key.VerifyPubKey(pub_key));\n+        CKeyID pub_key_id = pub_key.GetID();\n+        // Check if this private key corresponds to one from the descriptor\n+        if (out_keys.GetPubKey(pub_key_id, pub_key)) {\n+            // If so, import it\n+            if (pwallet->HaveKey(pub_key_id)) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Already have this key\");\n+            }\n+            pwallet->mapKeyMetadata[pub_key_id].nCreateTime = timestamp;\n+            if (!pwallet->AddKeyPubKey(priv_key, pub_key)) {\n+                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding key to wallet\");\n+            }\n+            pwallet->UpdateTimeFirstKey(timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n+        }\n+    }\n+}\n \n-                // add to address book or update label\n-                if (IsValidDestination(dest)) {\n-                    pwallet->SetAddressBook(dest, label, \"receive\");\n-                }\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+        // Internal addresses should not have a label\n+        if (internal && data.exists(\"label\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between internal and label\");\n+        }\n+        // Watchonly should not include any private keys\n+        if (watchOnly && data.exists(\"keys\") && data[\"keys\"].size()) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Incompatibility found between watchonly and keys\");\n+        }\n \n-                success = true;\n-            }\n+        if (data.exists(\"scriptPubKey\")) {\n+            ProcessImportLegacy(pwallet, data, timestamp);\n+        } else if (data.exists(\"descriptor\")) {\n+            ProcessImportDesc(pwallet, data, timestamp);\n+        } else {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Either a descriptor or scriptPubKey must be provided.\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r225736677",
      "id" : 225736677,
      "in_reply_to_id" : 225487854,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIyNTczNjY3Nw==",
      "original_commit_id" : "58d8a3d1fdc821610e2607e208f77a39f0102d18",
      "original_position" : 541,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 492,
      "pull_request_review_id" : 165403464,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/225736677",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "After discussion with sipa, closing for now, will come back to this after #14454 is merged",
      "created_at" : "2018-10-16T23:48:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-430440099",
      "id" : 430440099,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzMDQ0MDA5OQ==",
      "updated_at" : "2018-10-16T23:48:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/430440099",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Since #14454 has been merged, this can be reopened?",
      "created_at" : "2018-11-01T19:13:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-435153258",
      "id" : 435153258,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTE1MzI1OA==",
      "updated_at" : "2018-11-01T19:13:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435153258",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I believe a simpler approach is possible on top of #14565.",
      "created_at" : "2018-11-01T19:20:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-435155301",
      "id" : 435155301,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTE1NTMwMQ==",
      "updated_at" : "2018-11-01T19:20:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435155301",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Yep I'll reopen this when rebased on 14565",
      "created_at" : "2018-11-01T19:24:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-435156556",
      "id" : 435156556,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTE1NjU1Ng==",
      "updated_at" : "2018-11-01T19:24:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435156556",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Rebased on https://github.com/bitcoin/bitcoin/pull/14565\r\n\r\nStill planning on adding more tests + release notes, please don't nitpick the lack of tests yet",
      "created_at" : "2018-11-03T00:23:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-435544886",
      "id" : 435544886,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNTU0NDg4Ng==",
      "updated_at" : "2018-11-03T02:02:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/435544886",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@Sjors thanks for the feedback :) \r\n\r\n> If I use watchonly: true, then getaddressinfo doesn't show a descriptor and it says solvable: false, which seems wrong (the latter also happens without cherry-pick).\r\n\r\nIt should only watch for the scriptPubKey and import no other information, watch-only is a different requirement than being solvable without private keys.\r\n\r\n>  the origin info in the descriptor seems both wrong and incomplete: \"desc\": \"wpkh([224885f8]026...)\", where 224885f8 is not the master fingerprint I used, and derivation info is missing. \r\n\r\nYou're right, good point. I'll take a look at andrews PR\r\n\r\n> I didn't use the watchonly while importing a descriptor with an xpub, should that be allowed? Or should watchonly argument not be allowed when using a descriptor?\r\n\r\nI think it should be allowed, because of the above reason. Using an xpub without watch only allows it to be solvable without being spendable",
      "created_at" : "2018-11-05T23:33:34Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436075791",
      "id" : 436075791,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjA3NTc5MQ==",
      "updated_at" : "2018-11-05T23:33:34Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436075791",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@MeshCollider @Sjors I was imagining that \"watchonly\" would be implicit when using descriptors (`addr()` and `raw()` would be watchonly; anything else would result in a solvable result).\r\n\r\nThe reason for \"watchonly\" is so that users need to be explicit about the fact they _don't_ want solvability (generally, you should always want solvability, but if you can't, you can tell importmulti that it's fine without).",
      "created_at" : "2018-11-05T23:39:47Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436077191",
      "id" : 436077191,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjA3NzE5MQ==",
      "updated_at" : "2018-11-05T23:39:47Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436077191",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@sipa I like your suggestion. In that case we should disallow usage of the `watchonly` param when combined with a descriptor.\r\n\r\nRegarding getting origin information from the descriptors, @achow101  just rebased #14021 on top of this PR. It's a non trivial change. Perhaps for this PR it's best to not store origin information. Just make sure that if you do `walletcreatefundedpsbt` with bip32 flag set to true, then the result doesn't crash `decodepsbt`.",
      "created_at" : "2018-11-06T08:56:52Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436177401",
      "id" : 436177401,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjE3NzQwMQ==",
      "updated_at" : "2018-11-06T08:56:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436177401",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I don't see the problem if you want to add a ranged descriptor as watch only to import all the scriptPubKeys but not retain any more info than that?",
      "created_at" : "2018-11-06T10:02:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436197110",
      "id" : 436197110,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjE5NzExMA==",
      "updated_at" : "2018-11-06T10:02:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436197110",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "IIUC you would indicate that in the descriptor by wrapping the result in `addr(...)`. Mandating that removes ambiguity from how a descriptor ends up in a wallet.",
      "created_at" : "2018-11-06T10:15:48Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436201303",
      "id" : 436201303,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjIwMTMwMw==",
      "updated_at" : "2018-11-06T10:15:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436201303",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@Sjors It was my understanding that `addr(...)` cannot contain another type of descriptor or key (e.g. a ranged BIP32 key), only the base58/bech32 encoded address formats. If I'm wrong then I'm happy to change this PR, @sipa could weigh in here",
      "created_at" : "2018-11-06T11:19:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436218992",
      "id" : 436218992,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjIxODk5Mg==",
      "updated_at" : "2018-11-06T11:20:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436218992",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "xpub byte prefix mismatch results in very generic error; would be nice to give something more meaningful ",
      "created_at" : "2018-11-07T18:15:40Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-436723660",
      "id" : 436723660,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNjcyMzY2MA==",
      "updated_at" : "2018-11-07T18:15:40Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/436723660",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#14952](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14952.html) ([do not merge] [tests] tidy up wallet_importmulti.py by jnewbery)\n* [#14918](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14918.html) (RPCHelpMan: Check default values are given at compile-time by MarcoFalke)\n* [#14912](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14912.html) ([WIP] External signer support (e.g. hardware wallet) by Sjors)\n* [#14565](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14565.html) (Overhaul importmulti logic by sipa)\n* [#14459](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14459.html) (More RPC help description fixes by ch4ot1c)\n* [#14075](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14075.html) (Import watch only pubkeys to the keypool if private keys are disabled by achow101)\n* [#14021](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/14021.html) (Import key origin data through descriptors in importmulti by achow101)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2018-11-08T21:28:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-437162334",
      "id" : 437162334,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNzE2MjMzNA==",
      "updated_at" : "2018-12-17T21:24:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/437162334",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r232172774"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232172774"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Could use `std::any_of`? :-)",
      "commit_id" : "ed21a15e835b7eec1fb909c9095e6078a6541b5c",
      "created_at" : "2018-11-09T08:28:57Z",
      "diff_hunk" : "@@ -804,233 +805,351 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     return reply;\n }\n \n-\n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+struct ImportData\n {\n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    // Input data\n+    std::unique_ptr<CScript> redeemscript; //! Provided redeemScript; will be mvoed to `import_scripts` if relevant.\n+    std::unique_ptr<CScript> witnessscript; //! Provided witnessScript; will be moved to `import_scripts` if relevant.\n+    std::map<CKeyID, CPubKey> pubkeys;\n+    std::map<CKeyID, CKey> privkeys;\n+\n+    // Output data\n+    std::set<CScript> script_pub_keys;\n+    std::set<CScript> import_scripts;\n+    std::set<CKeyID> used_keys; // Import these private keys if available\n+    std::set<CKeyID> require_keys; // Fail if these public keys are not available\n+};\n+\n+enum class ScriptContext\n+{\n+    TOP, //! Top-level scriptPubKey\n+    P2SH, //! P2SH redeemScript\n+    WITNESS_V0, //! P2WSH witnessScript\n+};\n+\n+// Analyse the provided script, process the import data accordinging, and recurse into subscripts if necessary.\n+// Returns an error string, or the empty string for success.\n+static std::string RecurseImportData(const CScript& script, ImportData& data, ScriptContext ctx)\n+{\n+    // Use Solver to obtain script type and parsed pubkeys or hashes:\n+    std::vector<std::vector<unsigned char>> solverdata;\n+    txnouttype script_type = Solver(script, solverdata);\n+\n+    switch (script_type) {\n+    case TX_PUBKEY: {\n+        CPubKey pubkey(solverdata[0].begin(), solverdata[0].end());\n+        data.used_keys.emplace(pubkey.GetID());\n+        break;\n+    }\n+    case TX_PUBKEYHASH: {\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        data.require_keys.emplace(id);\n+        data.used_keys.emplace(id);\n+        break;\n+    }\n+    case TX_SCRIPTHASH: {\n+        if (ctx == ScriptContext::P2SH) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside another P2SH\");\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2SH inside a P2WSH\");\n+        CScriptID id = CScriptID(uint160(solverdata[0]));\n+        auto subscript = std::move(data.redeemscript);\n+        if (!subscript) return \"missing redeemscript\";\n+        if (CScriptID(*subscript) != id) return \"redeemScript does not match the scriptPubKey\";\n+        data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, data, ScriptContext::P2SH);\n+        break;\n+    }\n+    case TX_MULTISIG: {\n+        for (size_t i = 1; i + 1< solverdata.size(); ++i) {\n+            CPubKey pubkey(solverdata[i].begin(), solverdata[i].end());\n+            data.used_keys.emplace(pubkey.GetID());\n         }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n-\n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n-\n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n-            }\n-            script = GetScriptForDestination(dest);\n-        } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n-            }\n+        break;\n+    }\n+    case TX_WITNESS_V0_SCRIPTHASH: {\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WSH inside another P2WSH\");\n+        uint256 fullid(solverdata[0]);\n+        CScriptID id;\n+        CRIPEMD160().Write(fullid.begin(), fullid.size()).Finalize(id.begin());\n+        auto subscript = std::move(data.witnessscript);\n+        if (!subscript) return \"missing witnessscript\";\n+        if (CScriptID(*subscript) != id) return \"witnessScript does not match the scriptPubKey or redeemScript\";\n+        data.import_scripts.emplace(script); // Special rule for IsMine: native P2WSH requires the full script imported\n+        data.import_scripts.emplace(*subscript);\n+        RecurseImportData(*subscript, data, ScriptContext::WITNESS_V0);\n+        break;\n+    }\n+    case TX_WITNESS_V0_KEYHASH: {\n+        if (ctx == ScriptContext::WITNESS_V0) throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Trying to nest P2WPKH inside P2WSH\");\n+        CKeyID id = CKeyID(uint160(solverdata[0]));\n+        data.require_keys.emplace(id);\n+        data.used_keys.emplace(id);\n+        data.import_scripts.emplace(script); // Special rule for IsMine: native P2WPKH requires the full script imported\n+        break;\n+    }\n+    default:\n+        return \"nonstandard script\";\n+    }\n+    return \"\";\n+}\n \n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n-            }\n+static UniValue ProcessImportLegacy(ImportData& import_data, const UniValue& data, bool& watch_only)\n+{\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address\");\n         }\n-\n-        // Watchonly and private keys\n-        if (watchOnly && keys.size()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Watch-only addresses should not include private keys\");\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey\");\n         }\n-\n-        // Internal addresses should not have a label\n-        if (internal && data.exists(\"label\")) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal addresses should not have a label\");\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n+    }\n+    import_data.script_pub_keys.emplace(script);\n \n-        // Force users to provide the witness script in its field rather than redeemscript\n-        if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n         }\n-\n-        CScript scriptpubkey_script = script;\n-        CTxDestination scriptpubkey_dest = dest;\n-        bool allow_p2wpkh = true;\n-\n-        // P2SH\n-        if (!strRedeemScript.empty() && script.IsPayToScriptHash()) {\n-            // Check the redeemScript is valid\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script: must be hex string\");\n-            }\n-\n-            // Import redeem script.\n-            std::vector<unsigned char> vData(ParseHex(strRedeemScript));\n-            CScript redeemScript = CScript(vData.begin(), vData.end());\n-            CScriptID redeem_id(redeemScript);\n-\n-            // Check that the redeemScript and scriptPubKey match\n-            if (GetScriptForDestination(redeem_id) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The redeemScript does not match the scriptPubKey\");\n-            }\n-\n-            pwallet->MarkDirty();\n-\n-            if (!pwallet->AddWatchOnly(redeemScript, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n-\n-            if (!pwallet->HaveCScript(redeem_id) && !pwallet->AddCScript(redeemScript)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2sh redeemScript to wallet\");\n-            }\n-\n-            // Now set script to the redeemScript so we parse the inner script as P2WSH or P2WPKH below\n-            script = redeemScript;\n-            ExtractDestination(script, dest);\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n         }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey is not a valid public key\");\n+        }\n+        import_data.pubkeys.emplace(pubkey.GetID(), pubkey);\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (import_data.pubkeys.count(id)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Both public and private key specified for \" + HexStr(pubkey.begin(), pubkey.end()));\n+        }\n+        import_data.privkeys.emplace(id, key);\n+    }\n \n-        // (P2SH-)P2WSH\n-        if (!witness_script_hex.empty() && script.IsPayToWitnessScriptHash()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script: must be hex string\");\n-            }\n-\n-            // Generate the scripts\n-            std::vector<unsigned char> witness_script_parsed(ParseHex(witness_script_hex));\n-            CScript witness_script = CScript(witness_script_parsed.begin(), witness_script_parsed.end());\n-            CScriptID witness_id(witness_script);\n+    // Warn about inconsistencies between watch_only and provided keys/scripts\n+    UniValue warnings(UniValue::VARR);\n+    bool have_solving_data = import_data.redeemscript || import_data.witnessscript || import_data.pubkeys.size() || import_data.privkeys.size();\n+    if (watch_only && have_solving_data) {\n+        warnings.push_back(\"redeemscript, witnessscript, keys, and pubkeys are ignored when watchonly is set.\");\n+    }\n+    if (!watch_only && !have_solving_data) {\n+        warnings.push_back(\"Assuming watchonly as no redeemscript, witnessscript, keys, or pubkeys are provided.\");\n+        watch_only = true;\n+    }\n \n-            // Check that the witnessScript and scriptPubKey match\n-            if (GetScriptForDestination(WitnessV0ScriptHash(witness_script)) != script) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"The witnessScript does not match the scriptPubKey or redeemScript\");\n-            }\n+    // Force users to provide the witness script in its field rather than redeemscript\n+    if (!strRedeemScript.empty() && script.IsPayToWitnessScriptHash()) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WSH addresses have an empty redeemscript. Please provide the witnessscript instead.\");\n+    }\n \n-            // Add the witness script as watch only only if it is not for P2SH-P2WSH\n-            if (!scriptpubkey_script.IsPayToScriptHash() && !pwallet->AddWatchOnly(witness_script, timestamp)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding address to wallet\");\n-            }\n+    // Verify and process input data\n+    if (!watch_only) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n \n-            if (!pwallet->HaveCScript(witness_id) && !pwallet->AddCScript(witness_script)) {\n-                throw JSONRPCError(RPC_WALLET_ERROR, \"Error adding p2wsh witnessScript to wallet\");\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.require_keys) {\n+                if (import_data.pubkeys.count(require_key) == 0 && import_data.privkeys.count(require_key) == 0) {\n+                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Key does not match address destination\");\n+                }\n             }\n-\n-            // Now set script to the witnessScript so we parse the inner script as P2PK or P2PKH below\n-            script = witness_script;\n-            ExtractDestination(script, dest);\n-            allow_p2wpkh = false; // P2WPKH cannot be embedded in P2WSH\n         }\n \n-        // (P2SH-)P2PK/P2PKH/P2WPKH\n-        if (dest.type() == typeid(CKeyID) || dest.type() == typeid(WitnessV0KeyHash)) {\n-            if (!allow_p2wpkh && dest.type() == typeid(WitnessV0KeyHash)) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"P2WPKH cannot be embedded in P2WSH\");\n-            }\n-            if (keys.size() > 1 || pubKeys.size() > 1) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"More than one key given for one single-key address\");\n-            }\n-            CPubKey pubkey;\n-            if (keys.size()) {\n-                pubkey = DecodeSecret(keys[0].get_str()).GetPubKey();\n-            }\n-            if (pubKeys.size()) {\n-                const std::string& strPubKey = pubKeys[0].get_str();\n-                if (!IsHex(strPubKey)) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n-                }\n-                std::vector<unsigned char> vData(ParseHex(pubKeys[0].get_str()));\n-                CPubKey pubkey_temp(vData.begin(), vData.end());\n-                if (pubkey.size() && pubkey_temp != pubkey) {\n-                    throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key does not match public key for address\");\n+        if (!error.empty()) {\n+            warnings.push_back(\"Ignoring information in keys, pubkeys, redeemscript, and witnessscript:: \" + error);\n+            import_data = ImportData();\n+        } else {\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript \" + strRedeemScript + \" as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript \" + witness_script_hex + \" as this is not a P2WSH script.\");\n+            for (const auto& privkey : import_data.privkeys) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r232172774",
      "id" : 232172774,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDIzMjE3Mjc3NA==",
      "original_commit_id" : "ed21a15e835b7eec1fb909c9095e6078a6541b5c",
      "original_position" : 345,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : 345,
      "pull_request_review_id" : 173311534,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-11-09T08:28:58Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/232172774",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "~~Can you rebase this on most recent #14565 ? It has a few logic fixes.~~ discussing what I think are bugs\r\n\r\nIn addition, you can not ignore the `watch_only` field for descriptor import. `watch_only` needs to be set to true if the descriptor deals with public keys only: https://github.com/bitcoin/bitcoin/pull/14565/files#diff-522490d83dce5375d423b23886e4125eR1019 (this code is from the refreshed dependent PR)",
      "created_at" : "2018-11-09T17:06:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-437426180",
      "id" : 437426180,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzNzQyNjE4MA==",
      "updated_at" : "2018-11-09T17:25:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/437426180",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--cf906140f33d8803c4a75a2196329ecb-->Needs rebase",
      "created_at" : "2018-11-13T17:40:53Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-438366545",
      "id" : 438366545,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQzODM2NjU0NQ==",
      "updated_at" : "2018-11-13T17:40:53Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/438366545",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Now might be a good to time to rebase it, because testing this might reveal anything we've missed in the overhaul PR #14565.",
      "created_at" : "2018-12-12T09:34:03Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-446522157",
      "id" : 446522157,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0NjUyMjE1Nw==",
      "updated_at" : "2018-12-12T09:34:03Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/446522157",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've rebased this but haven't tested, it was a bit of a messy rebase and still a couple of things to address such as adding the warnings to the descriptor import function, plus more tests. I'll hopefully finish those things off in the next couple of days too.",
      "created_at" : "2018-12-13T01:03:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-446803700",
      "id" : 446803700,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0NjgwMzcwMA==",
      "updated_at" : "2018-12-13T01:03:21Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/446803700",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "By \"haven't tested\" you mean \"haven't compiled\" right? :-)\r\n\r\nIt looks like a tricky rebase. E.g. your code is referring to `import_data.pubkeys` and `import_data.privkeys`, the latter has been renamed to `import_data.used_keys`, but the former doesn't exist anymore.\r\n\r\nThe `ProcessImport` function is now duplicated.",
      "created_at" : "2018-12-13T09:24:05Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-446898912",
      "id" : 446898912,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0Njg5ODkxMg==",
      "updated_at" : "2018-12-13T09:24:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/446898912",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/10217?v=4",
         "events_url" : "https://api.github.com/users/Sjors/events{/privacy}",
         "followers_url" : "https://api.github.com/users/Sjors/followers",
         "following_url" : "https://api.github.com/users/Sjors/following{/other_user}",
         "gists_url" : "https://api.github.com/users/Sjors/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/Sjors",
         "id" : 10217,
         "login" : "Sjors",
         "node_id" : "MDQ6VXNlcjEwMjE3",
         "organizations_url" : "https://api.github.com/users/Sjors/orgs",
         "received_events_url" : "https://api.github.com/users/Sjors/received_events",
         "repos_url" : "https://api.github.com/users/Sjors/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/Sjors/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/Sjors/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/Sjors"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "I've now finished rebasing, lightly tested, added some warnings, and added a couple more tests. \r\n\r\nThere is one thing that still needs addressing, which is that a descriptor which provides a private key should import that private key. Currently it only Expands() the descriptor and imports the public keys. The implementation of that is likely going to require some discussion so I will open a future PR for that, and leave it as a TODO for now.",
      "created_at" : "2018-12-14T07:32:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#issuecomment-447240211",
      "id" : 447240211,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/14491",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDQ0NzI0MDIxMQ==",
      "updated_at" : "2018-12-19T03:10:50Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/447240211",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/3211283?v=4",
         "events_url" : "https://api.github.com/users/MeshCollider/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MeshCollider/followers",
         "following_url" : "https://api.github.com/users/MeshCollider/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MeshCollider/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MeshCollider",
         "id" : 3211283,
         "login" : "MeshCollider",
         "node_id" : "MDQ6VXNlcjMyMTEyODM=",
         "organizations_url" : "https://api.github.com/users/MeshCollider/orgs",
         "received_events_url" : "https://api.github.com/users/MeshCollider/received_events",
         "repos_url" : "https://api.github.com/users/MeshCollider/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MeshCollider/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MeshCollider/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MeshCollider"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r241992959"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241992959"
         }
      },
      "author_association" : "MEMBER",
      "body" : "This variable is unused in this function",
      "commit_id" : "bc239c1189e792f9036784ac17ad1e2bec1df728",
      "created_at" : "2018-12-16T19:35:03Z",
      "diff_hunk" : "@@ -923,203 +924,291 @@ static std::string RecurseImportData(const CScript& script, ImportData& import_d\n     }\n }\n \n-static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+static UniValue ProcessImportLegacy(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n {\n     UniValue warnings(UniValue::VARR);\n-    UniValue result(UniValue::VOBJ);\n \n-    try {\n-        // First ensure scriptPubKey has either a script or JSON with \"address\" string\n-        const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n-        bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n-        if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    // First ensure scriptPubKey has either a script or JSON with \"address\" string\n+    const UniValue& scriptPubKey = data[\"scriptPubKey\"];\n+    bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n+    if (!isScript && !(scriptPubKey.getType() == UniValue::VOBJ && scriptPubKey.exists(\"address\"))) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"scriptPubKey must be string with script or JSON with address string\");\n+    }\n+    const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+\n+    // Optional fields.\n+    const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+    const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n+    const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n+    const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+    const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n+    const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n+\n+    // Generate the script and destination for the scriptPubKey provided\n+    CScript script;\n+    CTxDestination dest;\n+    if (!isScript) {\n+        dest = DecodeDestination(output);\n+        if (!IsValidDestination(dest)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+        }\n+        script = GetScriptForDestination(dest);\n+    } else {\n+        if (!IsHex(output)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+        }\n+        std::vector<unsigned char> vData(ParseHex(output));\n+        script = CScript(vData.begin(), vData.end());\n+        if (!ExtractDestination(script, dest) && !internal) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n         }\n-        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+    }\n+    script_pub_keys.emplace(script);\n \n-        // Optional fields.\n-        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n-        const std::string& witness_script_hex = data.exists(\"witnessscript\") ? data[\"witnessscript\"].get_str() : \"\";\n-        const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n-        const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n-        const bool internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n-        const bool watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const std::string& label = data.exists(\"label\") ? data[\"label\"].get_str() : \"\";\n+    // Parse all arguments\n+    if (strRedeemScript.size()) {\n+        if (!IsHex(strRedeemScript)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n+        }\n+        auto parsed_redeemscript = ParseHex(strRedeemScript);\n+        import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    }\n+    if (witness_script_hex.size()) {\n+        if (!IsHex(witness_script_hex)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n+        }\n+        auto parsed_witnessscript = ParseHex(witness_script_hex);\n+        import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+    }\n+    for (size_t i = 0; i < pubKeys.size(); ++i) {\n+        const auto& str = pubKeys[i].get_str();\n+        if (!IsHex(str)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n+        }\n+        auto parsed_pubkey = ParseHex(str);\n+        CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n+        if (!pubkey.IsFullyValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n+        }\n+        pubkey_map.emplace(pubkey.GetID(), pubkey);\n+    }\n+    for (size_t i = 0; i < keys.size(); ++i) {\n+        const auto& str = keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n+        }\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        if (pubkey_map.count(id)) {\n+            pubkey_map.erase(id);\n+        }\n+        privkey_map.emplace(id, key);\n+    }\n \n-        // Generate the script and destination for the scriptPubKey provided\n-        CScript script;\n-        CTxDestination dest;\n-        if (!isScript) {\n-            dest = DecodeDestination(output);\n-            if (!IsValidDestination(dest)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid address \\\"\" + output + \"\\\"\");\n+    // Verify and process input data\n+    have_solving_data = import_data.redeemscript || import_data.witnessscript || pubkey_map.size() || privkey_map.size();\n+    if (have_solving_data) {\n+        // Match up data in import_data with the scriptPubKey in script.\n+        auto error = RecurseImportData(script, import_data, ScriptContext::TOP);\n+\n+        // Verify whether the watchonly option corresponds to the availability of private keys.\n+        bool spendable = std::all_of(import_data.used_keys.begin(), import_data.used_keys.end(), [&](const std::pair<CKeyID, bool>& used_key){ return privkey_map.count(used_key.first) > 0; });\n+        if (!watchOnly && !spendable) {\n+            warnings.push_back(\"Some private keys are missing, outputs will be considered watchonly. If this is intentional, specify the watchonly flag.\");\n+        }\n+        if (watchOnly && spendable) {\n+            warnings.push_back(\"All private keys are provided, outputs will be considered spendable. If this is intentional, do not specify the watchonly flag.\");\n+        }\n+\n+        // Check that all required keys for solvability are provided.\n+        if (error.empty()) {\n+            for (const auto& require_key : import_data.used_keys) {\n+                if (!require_key.second) continue; // Not a required key\n+                if (pubkey_map.count(require_key.first) == 0 && privkey_map.count(require_key.first) == 0) {\n+                    error = \"some required keys are missing\";\n+                }\n             }\n-            script = GetScriptForDestination(dest);\n+        }\n+\n+        if (!error.empty()) {\n+            warnings.push_back(\"Importing as non-solvable: \" + error + \". If this is intentional, don't provide any keys, pubkeys, witnessscript, or redeemscript.\");\n+            import_data = ImportData();\n+            pubkey_map.clear();\n+            privkey_map.clear();\n+            have_solving_data = false;\n         } else {\n-            if (!IsHex(output)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid scriptPubKey \\\"\" + output + \"\\\"\");\n+            // RecurseImportData() removes any relevant redeemscript/witnessscript from import_data, so we can use that to discover if a superfluous one was provided.\n+            if (import_data.redeemscript) warnings.push_back(\"Ignoring redeemscript as this is not a P2SH script.\");\n+            if (import_data.witnessscript) warnings.push_back(\"Ignoring witnessscript as this is not a (P2SH-)P2WSH script.\");\n+            for (auto it = privkey_map.begin(); it != privkey_map.end(); ) {\n+                auto oldit = it++;\n+                if (import_data.used_keys.count(oldit->first) == 0) {\n+                    warnings.push_back(\"Ignoring irrelevant private key.\");\n+                    privkey_map.erase(oldit);\n+                }\n             }\n-            std::vector<unsigned char> vData(ParseHex(output));\n-            script = CScript(vData.begin(), vData.end());\n-            if (!ExtractDestination(script, dest) && !internal) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Internal must be set to true for nonstandard scriptPubKey imports.\");\n+            for (auto it = pubkey_map.begin(); it != pubkey_map.end(); ) {\n+                auto oldit = it++;\n+                auto key_data_it = import_data.used_keys.find(oldit->first);\n+                if (key_data_it == import_data.used_keys.end() || !key_data_it->second) {\n+                    warnings.push_back(\"Ignoring public key \\\"\" + HexStr(oldit->first) + \"\\\" as it doesn't appear inside P2PKH or P2WPKH.\");\n+                    pubkey_map.erase(oldit);\n+                }\n             }\n         }\n+    }\n \n-        // Parse all arguments\n-        ImportData import_data;\n-        if (strRedeemScript.size()) {\n-            if (!IsHex(strRedeemScript)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid redeem script \\\"\" + strRedeemScript + \"\\\": must be hex string\");\n-            }\n-            auto parsed_redeemscript = ParseHex(strRedeemScript);\n-            import_data.redeemscript = MakeUnique<CScript>(parsed_redeemscript.begin(), parsed_redeemscript.end());\n+    return warnings;\n+}\n+\n+static UniValue ProcessImportDescriptor(ImportData& import_data, std::map<CKeyID, CPubKey>& pubkey_map, std::map<CKeyID, CKey>& privkey_map, std::set<CScript>& script_pub_keys, bool& have_solving_data, const UniValue& data)\n+{\n+    UniValue warnings(UniValue::VARR);\n+\n+    const std::string& descriptor = data[\"desc\"].get_str();\n+    FlatSigningProvider keys;\n+    auto parsed_desc = Parse(descriptor, keys);\n+    if (!parsed_desc) {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Descriptor is invalid\");\n+    }\n+\n+    int64_t range_start = 0, range_end = 0;\n+    if (!parsed_desc->IsRange() && data.exists(\"range\")) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Range should not be specified for an un-ranged descriptor\");\n+    } else if (parsed_desc->IsRange()) {\n+        if (!data.exists(\"range\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Descriptor is ranged, please specify the range\");\n         }\n-        if (witness_script_hex.size()) {\n-            if (!IsHex(witness_script_hex)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid witness script \\\"\" + witness_script_hex + \"\\\": must be hex string\");\n-            }\n-            auto parsed_witnessscript = ParseHex(witness_script_hex);\n-            import_data.witnessscript = MakeUnique<CScript>(parsed_witnessscript.begin(), parsed_witnessscript.end());\n+        const UniValue& range = data[\"range\"];\n+        range_start = range.exists(\"start\") ? range[\"start\"].get_int64() : 0;\n+        if (!range.exists(\"end\")) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"End of range for descriptor must be specified\");\n         }\n-        std::map<CKeyID, CPubKey> pubkey_map;\n-        for (size_t i = 0; i < pubKeys.size(); ++i) {\n-            const auto& str = pubKeys[i].get_str();\n-            if (!IsHex(str)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" must be a hex string\");\n-            }\n-            auto parsed_pubkey = ParseHex(str);\n-            CPubKey pubkey(parsed_pubkey.begin(), parsed_pubkey.end());\n-            if (!pubkey.IsFullyValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey \\\"\" + str + \"\\\" is not a valid public key\");\n-            }\n-            pubkey_map.emplace(pubkey.GetID(), pubkey);\n+        range_end = range[\"end\"].get_int64();\n+    }\n+\n+    const UniValue& priv_keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n+\n+    FlatSigningProvider out_keys;\n+    for (int i = range_start; i <= range_end; ++i) {\n+        std::vector<CScript> scripts_temp;\n+        parsed_desc->Expand(i, keys, scripts_temp, out_keys);\n+        std::copy(scripts_temp.begin(), scripts_temp.end(), std::inserter(script_pub_keys, script_pub_keys.end()));\n+    }\n+    for (auto const& x : out_keys.scripts) {\n+        import_data.import_scripts.emplace(x.second);\n+    }\n+    std::copy(out_keys.pubkeys.begin(), out_keys.pubkeys.end(), std::inserter(pubkey_map, pubkey_map.end()));\n+    for (size_t i = 0; i < priv_keys.size(); ++i) {\n+        const auto& str = priv_keys[i].get_str();\n+        CKey key = DecodeSecret(str);\n+        if (!key.IsValid()) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n         }\n-        std::map<CKeyID, CKey> privkey_map;\n-        for (size_t i = 0; i < keys.size(); ++i) {\n-            const auto& str = keys[i].get_str();\n-            CKey key = DecodeSecret(str);\n-            if (!key.IsValid()) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key encoding\");\n-            }\n-            CPubKey pubkey = key.GetPubKey();\n-            CKeyID id = pubkey.GetID();\n-            if (pubkey_map.count(id)) {\n-                pubkey_map.erase(id);\n-            }\n-            privkey_map.emplace(id, key);\n+        CPubKey pubkey = key.GetPubKey();\n+        CKeyID id = pubkey.GetID();\n+        // Check if this private key corresponds to a public key from the descriptor\n+        if (!pubkey_map.count(id)) {\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Unused private key provided\");\n         }\n+        privkey_map.emplace(id, key);\n+    }\n \n-        // Internal addresses should not have a label\n+    // TODO: add warnings if private keys don't correspond to watch-only\n+    return warnings;\n+}\n+\n+static UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int64_t timestamp) EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\n+{\n+    try {\n+        bool watch_only = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/14491#discussion_r241992959",
      "id" : 241992959,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDI0MTk5Mjk1OQ==",
      "original_commit_id" : "85b235cf9b029fa706b9373ef0f75811678da1f3",
      "original_position" : 281,
      "path" : "src/wallet/rpcdump.cpp",
      "position" : null,
      "pull_request_review_id" : 185400604,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/14491",
      "updated_at" : "2018-12-19T02:52:52Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/241992959",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/3782274?v=4",
         "events_url" : "https://api.github.com/users/achow101/events{/privacy}",
         "followers_url" : "https://api.github.com/users/achow101/followers",
         "following_url" : "https://api.github.com/users/achow101/following{/other_user}",
         "gists_url" : "https://api.github.com/users/achow101/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/achow101",
         "id" : 3782274,
         "login" : "achow101",
         "node_id" : "MDQ6VXNlcjM3ODIyNzQ=",
         "organizations_url" : "https://api.github.com/users/achow101/orgs",
         "received_events_url" : "https://api.github.com/users/achow101/received_events",
         "repos_url" : "https://api.github.com/users/achow101/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/achow101/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/achow101/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/achow101"
      }
   }
]
