[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "<!--e57a25ab6845829454e8d69fc972939a-->\n\nThe following sections might be updated with supplementary metadata relevant to reviewers and maintainers.\n\n<!--174a7506f384e20aa4161008e828411d-->\n### Conflicts\nReviewers, this pull request conflicts with the following ones:\n\n* [#16718](https://drahtbot.github.io/bitcoin_core_issue_redirect/r/16718.html) (Improve speed, memory efficiency with alternate hashmap by jamesob)\n\nIf you consider this pull request important, please also help to review the conflicting pull requests. Ideally, start with the one that should be merged first.",
      "created_at" : "2019-09-04T07:45:49Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-527784726",
      "id" : 527784726,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16801",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNzc4NDcyNg==",
      "updated_at" : "2019-09-04T07:45:49Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/527784726",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/39886733?v=4",
         "events_url" : "https://api.github.com/users/DrahtBot/events{/privacy}",
         "followers_url" : "https://api.github.com/users/DrahtBot/followers",
         "following_url" : "https://api.github.com/users/DrahtBot/following{/other_user}",
         "gists_url" : "https://api.github.com/users/DrahtBot/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/DrahtBot",
         "id" : 39886733,
         "login" : "DrahtBot",
         "node_id" : "MDQ6VXNlcjM5ODg2NzMz",
         "organizations_url" : "https://api.github.com/users/DrahtBot/orgs",
         "received_events_url" : "https://api.github.com/users/DrahtBot/received_events",
         "repos_url" : "https://api.github.com/users/DrahtBot/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/DrahtBot/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/DrahtBot/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/DrahtBot"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "re-run ci",
      "created_at" : "2019-09-04T11:26:27Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-527859568",
      "id" : 527859568,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16801",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNzg1OTU2OA==",
      "updated_at" : "2019-09-04T11:26:27Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/527859568",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK. Thanks for working on this. I did a cursory skim over the code and it looks very readable. The tests are nice too.\r\n\r\nI'll do a more thorough review and some benchmark runs in the next few days. ",
      "created_at" : "2019-09-04T13:52:18Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-527910427",
      "id" : 527910427,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16801",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUyNzkxMDQyNw==",
      "updated_at" : "2019-09-04T13:52:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/527910427",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/73197?v=4",
         "events_url" : "https://api.github.com/users/jamesob/events{/privacy}",
         "followers_url" : "https://api.github.com/users/jamesob/followers",
         "following_url" : "https://api.github.com/users/jamesob/following{/other_user}",
         "gists_url" : "https://api.github.com/users/jamesob/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/jamesob",
         "id" : 73197,
         "login" : "jamesob",
         "node_id" : "MDQ6VXNlcjczMTk3",
         "organizations_url" : "https://api.github.com/users/jamesob/orgs",
         "received_events_url" : "https://api.github.com/users/jamesob/received_events",
         "repos_url" : "https://api.github.com/users/jamesob/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/jamesob/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/jamesob"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16801#discussion_r321963843"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16801"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321963843"
         }
      },
      "author_association" : "MEMBER",
      "body" : "&lt;language lawyer hat on&gt;\r\n\r\nIs this really defined behaviour? :-)\r\n\r\n&lt;/language lawyer hat on&gt;",
      "commit_id" : "52ee5735304cb8be342e264a19274afc0f422fa8",
      "created_at" : "2019-09-07T10:17:08Z",
      "diff_hunk" : "@@ -0,0 +1,331 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_BULK_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_BULK_POOL_H\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+namespace bulk_pool {\n+\n+/// This pool allocates one object (memory chunk) at a time. The first call to allocate determine\n+/// the size of elements in the pool. Subsequent calls with other types of different size will\n+/// return nullptr. It is designed for use in node-based container like std::unordered_map or\n+/// std::list, where most allocations are for 1 element. It allocates increasingly large blocks\n+/// of memory, and only deallocates at destruction.\n+///\n+/// When the pool is empty, increasingly large blocks of are allocate, doubling its size until\n+/// m_max_num_allocs is reached. This way we don't have too large an overhead for small pool usage,\n+/// and still get efficiency for lots of elements since number of mallocs() are very reduced. Also,\n+/// less bookkeeping is necessary, so it's more space efficient than allocating one chunk at a time.\n+///\n+/// Deallocate() does not actually free memory, but puts the data into a linked list which can then\n+/// be used for allocate() calls when 1 element is requested. The linked list is in place, reusing\n+/// the memory of the T's.\n+///\n+/// Memory layout:\n+///\n+///  m_blocks\n+///        v\n+///    [ nextList, T, T, ... T]\n+///        v\n+///    [ nextList, T, T, ... T]\n+///        v\n+///      nullptr\n+///\n+/// m_free_chunks represents a singly linked list of all T's that have been deallocated.\n+class Pool\n+{\n+public:\n+    /// Explicitly specify the Pool's chunk size. It will only allocate chunks of this size, returning\n+    /// nullptr if a type of different size is specified. If set to 0, the first Allocate() call will\n+    /// determine the chunk size of the pool.\n+    explicit Pool(size_t chunk_size) noexcept\n+        : m_chunk_size(chunk_size)\n+    {\n+    }\n+\n+    /// Doesn't specify the chunk size, so it's determined by the first call to Allocate.\n+    Pool() = default;\n+\n+    // Don't allow moving/copying a pool, it's dangerous\n+    Pool(Pool&&) = delete;\n+    Pool& operator=(Pool&&) = delete;\n+    Pool(const Pool&) = delete;\n+    Pool& operator=(const Pool&) = delete;\n+\n+    /// Don't allow allocation for types that are smaller than a void*. This does not make sense\n+    /// because we need to fit a pointer into the memory.\n+    template <typename T, typename std::enable_if<sizeof(T) < sizeof(void*), int>::type = 0>\n+    T* Allocate() noexcept\n+    {\n+        return nullptr;\n+    }\n+\n+    /// As with Allocate(), don't allow for types that are smaller than a void*.\n+    template <typename T, typename std::enable_if<sizeof(T) < sizeof(void*), int>::type = 0>\n+    bool Deallocate() noexcept\n+    {\n+        return false;\n+    }\n+\n+    /// Tries to allocate one T. If allocation is not possible, returns nullptr and the callee\n+    /// has to do something else to get memory. First caller decides the size of the pool's data.\n+    template <typename T, typename std::enable_if<sizeof(T) >= sizeof(void*), int>::type = 0>\n+    T* Allocate()\n+    {\n+        if (m_chunk_size == 0) {\n+            // allocator not yet used, so this type determines the size.\n+            m_chunk_size = sizeof(T);\n+        } else if (m_chunk_size != sizeof(T)) {\n+            // allocator's size does not match sizeof(T), don't allocate.\n+            return nullptr;\n+        }\n+\n+        // Make sure we have memory available\n+        if (m_free_chunks == nullptr) {\n+            AllocateAndCreateFreelist();\n+        }\n+\n+        // pop one element from the linked list, returning previous head\n+        auto old_head = m_free_chunks;\n+        m_free_chunks = *reinterpret_cast<void**>(old_head);\n+        return reinterpret_cast<T*>(old_head);\n+    }\n+\n+    /// Puts p back into the freelist, if it was the correct size. Only allowed with objects\n+    /// that were allocated with this pool!\n+    template <typename T, typename std::enable_if<sizeof(T) >= sizeof(void*), int>::type = 0>\n+    bool Deallocate(T* p) noexcept\n+    {\n+        if (m_chunk_size != sizeof(T)) {\n+            // allocation didn't happen with this allocator\n+            return false;\n+        }\n+\n+        // put it into the linked list\n+        *reinterpret_cast<void**>(p) = m_free_chunks;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16801#discussion_r321963843",
      "id" : 321963843,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk2Mzg0Mw==",
      "original_commit_id" : "ad55a26725b015f00f99d99048e992e637aaebf4",
      "original_position" : 111,
      "path" : "src/support/allocators/bulk_pool.h",
      "position" : null,
      "pull_request_review_id" : 285166006,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16801",
      "updated_at" : "2019-09-08T09:03:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321963843",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16801#discussion_r321966253"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16801"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321966253"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "hm, I could add a \r\n```cpp\r\nstruct Node {\r\n    Node* next;\r\n};\r\n```\r\nAnd then use `Node*` instead of `void*`. Then instead of \r\n```cpp\r\n// put it into the linked list\r\n*reinterpret_cast<void**>(p) = m_free_chunks;\r\nm_free_chunks = p;\r\n```\r\nI could write \r\n```cpp\r\nauto n = reinterpret_cast<Node*>(p);\r\nn->next = m_free_chunks;\r\nm_free_chunks = n;\r\n```\r\nI guess the code is a bit better readable with that, but I honestly don't know if it's more defined behavior :thinking:",
      "commit_id" : "52ee5735304cb8be342e264a19274afc0f422fa8",
      "created_at" : "2019-09-07T11:54:27Z",
      "diff_hunk" : "@@ -0,0 +1,331 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_BULK_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_BULK_POOL_H\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+namespace bulk_pool {\n+\n+/// This pool allocates one object (memory chunk) at a time. The first call to allocate determine\n+/// the size of elements in the pool. Subsequent calls with other types of different size will\n+/// return nullptr. It is designed for use in node-based container like std::unordered_map or\n+/// std::list, where most allocations are for 1 element. It allocates increasingly large blocks\n+/// of memory, and only deallocates at destruction.\n+///\n+/// When the pool is empty, increasingly large blocks of are allocate, doubling its size until\n+/// m_max_num_allocs is reached. This way we don't have too large an overhead for small pool usage,\n+/// and still get efficiency for lots of elements since number of mallocs() are very reduced. Also,\n+/// less bookkeeping is necessary, so it's more space efficient than allocating one chunk at a time.\n+///\n+/// Deallocate() does not actually free memory, but puts the data into a linked list which can then\n+/// be used for allocate() calls when 1 element is requested. The linked list is in place, reusing\n+/// the memory of the T's.\n+///\n+/// Memory layout:\n+///\n+///  m_blocks\n+///        v\n+///    [ nextList, T, T, ... T]\n+///        v\n+///    [ nextList, T, T, ... T]\n+///        v\n+///      nullptr\n+///\n+/// m_free_chunks represents a singly linked list of all T's that have been deallocated.\n+class Pool\n+{\n+public:\n+    /// Explicitly specify the Pool's chunk size. It will only allocate chunks of this size, returning\n+    /// nullptr if a type of different size is specified. If set to 0, the first Allocate() call will\n+    /// determine the chunk size of the pool.\n+    explicit Pool(size_t chunk_size) noexcept\n+        : m_chunk_size(chunk_size)\n+    {\n+    }\n+\n+    /// Doesn't specify the chunk size, so it's determined by the first call to Allocate.\n+    Pool() = default;\n+\n+    // Don't allow moving/copying a pool, it's dangerous\n+    Pool(Pool&&) = delete;\n+    Pool& operator=(Pool&&) = delete;\n+    Pool(const Pool&) = delete;\n+    Pool& operator=(const Pool&) = delete;\n+\n+    /// Don't allow allocation for types that are smaller than a void*. This does not make sense\n+    /// because we need to fit a pointer into the memory.\n+    template <typename T, typename std::enable_if<sizeof(T) < sizeof(void*), int>::type = 0>\n+    T* Allocate() noexcept\n+    {\n+        return nullptr;\n+    }\n+\n+    /// As with Allocate(), don't allow for types that are smaller than a void*.\n+    template <typename T, typename std::enable_if<sizeof(T) < sizeof(void*), int>::type = 0>\n+    bool Deallocate() noexcept\n+    {\n+        return false;\n+    }\n+\n+    /// Tries to allocate one T. If allocation is not possible, returns nullptr and the callee\n+    /// has to do something else to get memory. First caller decides the size of the pool's data.\n+    template <typename T, typename std::enable_if<sizeof(T) >= sizeof(void*), int>::type = 0>\n+    T* Allocate()\n+    {\n+        if (m_chunk_size == 0) {\n+            // allocator not yet used, so this type determines the size.\n+            m_chunk_size = sizeof(T);\n+        } else if (m_chunk_size != sizeof(T)) {\n+            // allocator's size does not match sizeof(T), don't allocate.\n+            return nullptr;\n+        }\n+\n+        // Make sure we have memory available\n+        if (m_free_chunks == nullptr) {\n+            AllocateAndCreateFreelist();\n+        }\n+\n+        // pop one element from the linked list, returning previous head\n+        auto old_head = m_free_chunks;\n+        m_free_chunks = *reinterpret_cast<void**>(old_head);\n+        return reinterpret_cast<T*>(old_head);\n+    }\n+\n+    /// Puts p back into the freelist, if it was the correct size. Only allowed with objects\n+    /// that were allocated with this pool!\n+    template <typename T, typename std::enable_if<sizeof(T) >= sizeof(void*), int>::type = 0>\n+    bool Deallocate(T* p) noexcept\n+    {\n+        if (m_chunk_size != sizeof(T)) {\n+            // allocation didn't happen with this allocator\n+            return false;\n+        }\n+\n+        // put it into the linked list\n+        *reinterpret_cast<void**>(p) = m_free_chunks;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16801#discussion_r321966253",
      "id" : 321966253,
      "in_reply_to_id" : 321963843,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk2NjI1Mw==",
      "original_commit_id" : "ad55a26725b015f00f99d99048e992e637aaebf4",
      "original_position" : 111,
      "path" : "src/support/allocators/bulk_pool.h",
      "position" : null,
      "pull_request_review_id" : 285168816,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16801",
      "updated_at" : "2019-09-08T09:03:00Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321966253",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/16801#discussion_r321999022"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16801"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321999022"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "I got rid of the `void**` casts in in https://github.com/bitcoin/bitcoin/pull/16801/commits/52ee5735304cb8be342e264a19274afc0f422fa8",
      "commit_id" : "52ee5735304cb8be342e264a19274afc0f422fa8",
      "created_at" : "2019-09-08T09:04:09Z",
      "diff_hunk" : "@@ -0,0 +1,331 @@\n+// Copyright (c) 2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SUPPORT_ALLOCATORS_BULK_POOL_H\n+#define BITCOIN_SUPPORT_ALLOCATORS_BULK_POOL_H\n+\n+#include <cstddef>\n+#include <new>\n+#include <type_traits>\n+#include <utility>\n+\n+namespace bulk_pool {\n+\n+/// This pool allocates one object (memory chunk) at a time. The first call to allocate determine\n+/// the size of elements in the pool. Subsequent calls with other types of different size will\n+/// return nullptr. It is designed for use in node-based container like std::unordered_map or\n+/// std::list, where most allocations are for 1 element. It allocates increasingly large blocks\n+/// of memory, and only deallocates at destruction.\n+///\n+/// When the pool is empty, increasingly large blocks of are allocate, doubling its size until\n+/// m_max_num_allocs is reached. This way we don't have too large an overhead for small pool usage,\n+/// and still get efficiency for lots of elements since number of mallocs() are very reduced. Also,\n+/// less bookkeeping is necessary, so it's more space efficient than allocating one chunk at a time.\n+///\n+/// Deallocate() does not actually free memory, but puts the data into a linked list which can then\n+/// be used for allocate() calls when 1 element is requested. The linked list is in place, reusing\n+/// the memory of the T's.\n+///\n+/// Memory layout:\n+///\n+///  m_blocks\n+///        v\n+///    [ nextList, T, T, ... T]\n+///        v\n+///    [ nextList, T, T, ... T]\n+///        v\n+///      nullptr\n+///\n+/// m_free_chunks represents a singly linked list of all T's that have been deallocated.\n+class Pool\n+{\n+public:\n+    /// Explicitly specify the Pool's chunk size. It will only allocate chunks of this size, returning\n+    /// nullptr if a type of different size is specified. If set to 0, the first Allocate() call will\n+    /// determine the chunk size of the pool.\n+    explicit Pool(size_t chunk_size) noexcept\n+        : m_chunk_size(chunk_size)\n+    {\n+    }\n+\n+    /// Doesn't specify the chunk size, so it's determined by the first call to Allocate.\n+    Pool() = default;\n+\n+    // Don't allow moving/copying a pool, it's dangerous\n+    Pool(Pool&&) = delete;\n+    Pool& operator=(Pool&&) = delete;\n+    Pool(const Pool&) = delete;\n+    Pool& operator=(const Pool&) = delete;\n+\n+    /// Don't allow allocation for types that are smaller than a void*. This does not make sense\n+    /// because we need to fit a pointer into the memory.\n+    template <typename T, typename std::enable_if<sizeof(T) < sizeof(void*), int>::type = 0>\n+    T* Allocate() noexcept\n+    {\n+        return nullptr;\n+    }\n+\n+    /// As with Allocate(), don't allow for types that are smaller than a void*.\n+    template <typename T, typename std::enable_if<sizeof(T) < sizeof(void*), int>::type = 0>\n+    bool Deallocate() noexcept\n+    {\n+        return false;\n+    }\n+\n+    /// Tries to allocate one T. If allocation is not possible, returns nullptr and the callee\n+    /// has to do something else to get memory. First caller decides the size of the pool's data.\n+    template <typename T, typename std::enable_if<sizeof(T) >= sizeof(void*), int>::type = 0>\n+    T* Allocate()\n+    {\n+        if (m_chunk_size == 0) {\n+            // allocator not yet used, so this type determines the size.\n+            m_chunk_size = sizeof(T);\n+        } else if (m_chunk_size != sizeof(T)) {\n+            // allocator's size does not match sizeof(T), don't allocate.\n+            return nullptr;\n+        }\n+\n+        // Make sure we have memory available\n+        if (m_free_chunks == nullptr) {\n+            AllocateAndCreateFreelist();\n+        }\n+\n+        // pop one element from the linked list, returning previous head\n+        auto old_head = m_free_chunks;\n+        m_free_chunks = *reinterpret_cast<void**>(old_head);\n+        return reinterpret_cast<T*>(old_head);\n+    }\n+\n+    /// Puts p back into the freelist, if it was the correct size. Only allowed with objects\n+    /// that were allocated with this pool!\n+    template <typename T, typename std::enable_if<sizeof(T) >= sizeof(void*), int>::type = 0>\n+    bool Deallocate(T* p) noexcept\n+    {\n+        if (m_chunk_size != sizeof(T)) {\n+            // allocation didn't happen with this allocator\n+            return false;\n+        }\n+\n+        // put it into the linked list\n+        *reinterpret_cast<void**>(p) = m_free_chunks;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16801#discussion_r321999022",
      "id" : 321999022,
      "in_reply_to_id" : 321963843,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDMyMTk5OTAyMg==",
      "original_commit_id" : "ad55a26725b015f00f99d99048e992e637aaebf4",
      "original_position" : 111,
      "path" : "src/support/allocators/bulk_pool.h",
      "position" : null,
      "pull_request_review_id" : 285204867,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/16801",
      "updated_at" : "2019-09-08T09:04:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/321999022",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Here is a graph of another comparison run of the indexing progress over time that I get on my machine (Intel i7-8700 @ 3.20GHz, 32GB of RAM)\r\n\r\n![out](https://user-images.githubusercontent.com/14386/64724584-09da4c00-d4d3-11e9-8888-6586ad5829ba.png)\r\n\r\n* 3432sec for 2019-08-bulkpoolallocator, 4135 sec for master.\r\n* 6.973.488 kbyte max RSS for 2019-08-bulkpoolallocator, 7.643.956 kbyte for master.\r\n\r\nThe straight lines where no progress is made are when the cache is full and then dumped into the leveldb database.\r\n",
      "created_at" : "2019-09-11T18:37:21Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-530510425",
      "id" : 530510425,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16801",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUzMDUxMDQyNQ==",
      "updated_at" : "2019-09-11T18:39:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/530510425",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "NONE",
      "body" : "I want to how to migrate your good bulk pool to my project.",
      "created_at" : "2019-09-12T15:16:45Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-530874101",
      "id" : 530874101,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16801",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUzMDg3NDEwMQ==",
      "updated_at" : "2019-09-12T15:16:45Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/530874101",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1461362?v=4",
         "events_url" : "https://api.github.com/users/ktprime/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ktprime/followers",
         "following_url" : "https://api.github.com/users/ktprime/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ktprime/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ktprime",
         "id" : 1461362,
         "login" : "ktprime",
         "node_id" : "MDQ6VXNlcjE0NjEzNjI=",
         "organizations_url" : "https://api.github.com/users/ktprime/orgs",
         "received_events_url" : "https://api.github.com/users/ktprime/received_events",
         "repos_url" : "https://api.github.com/users/ktprime/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ktprime/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ktprime/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ktprime"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "> I want to how to migrate your good bulk pool to my project.\r\n\r\nFeel free to copy the bulk_pool.h to your project. It's under the MIT license. I might extract the file into a standalone project with more benchmarks, but thats not high on my priority list.\r\n\r\nI am interested though in any improvements you see with this allocator!",
      "created_at" : "2019-09-12T16:55:26Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-530913306",
      "id" : 530913306,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16801",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUzMDkxMzMwNg==",
      "updated_at" : "2019-09-12T17:07:24Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/530913306",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/14386?v=4",
         "events_url" : "https://api.github.com/users/martinus/events{/privacy}",
         "followers_url" : "https://api.github.com/users/martinus/followers",
         "following_url" : "https://api.github.com/users/martinus/following{/other_user}",
         "gists_url" : "https://api.github.com/users/martinus/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/martinus",
         "id" : 14386,
         "login" : "martinus",
         "node_id" : "MDQ6VXNlcjE0Mzg2",
         "organizations_url" : "https://api.github.com/users/martinus/orgs",
         "received_events_url" : "https://api.github.com/users/martinus/received_events",
         "repos_url" : "https://api.github.com/users/martinus/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/martinus/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/martinus/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/martinus"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Looks like the improvement grows over time/progress? Have you checked with a greater `-stopatheight`?",
      "created_at" : "2019-09-15T23:05:13Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/16801#issuecomment-531607115",
      "id" : 531607115,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/16801",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDUzMTYwNzExNQ==",
      "updated_at" : "2019-09-15T23:05:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/531607115",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   }
]
