[
   {
      "body" : "Yes! This is indeed what I was referring to. Thanks!\r\n\r\nI'd rather the flag be a boolean (\"Skip validation of burried blocks\"), as is right now it's trivial to (accidentally) set it to 0 and not check anything, which isn't a configuration we should operate on; other people may also have opinions there.   One thing that will likely be requested is a unidirectional latch, similar to how IsInitialBlockDownload works, so that in a reorg the signatures will still be validated. (Rationale: a reorg of burred blocks should never happen, so we don't care if its slow. Having it ends any concern \"zomg what if all the hashpower goes rogue for a month!\"-- no need to debate how unlikely an attack is when we can instead make it so that it would only impact installing new nodes).\r\n\r\nI'll give your patch more review soon.",
      "created_at" : "2016-11-17T23:55:25Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9180#issuecomment-261407827",
      "id" : 261407827,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9180",
      "updated_at" : "2016-11-17T23:58:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/261407827",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "Cool!\r\n\r\nAbout the flag: I'm flexible. I kind of like the ability to choose a time/depth/amount of work beyond just buried validation being allowed or not. It does make it easier for people to be extra conservative and increase it. Although, any non-boolean usage would be only for super-power-users and it might not be prudent to use values much lower than the default. I could make the minimum acceptable value be two weeks (nPowTargetTimespan) instead of zero. Less than one re-target interval kinda seems risky when considering possible sudden increases in rate of work. The default of being equivalent to 30 days worth of current work is longer than two re-targets, so I figured that would mitigate some risk. I guess we'd need to provide some kind of guidance on usage if it's not a boolean flag too.\r\n\r\nAbout the latch: Your rationale seems to make sense, but I don't see right now how a block would have to be re-validated again. A theoretical ginormous re-org could re-org the buried block off the active branch, or layer different work on top. But, a re-org could not make the buried block be covered by less total work. I'll dig into this more in the morning.",
      "created_at" : "2016-11-18T01:26:31Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9180#issuecomment-261422893",
      "id" : 261422893,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9180",
      "updated_at" : "2016-11-18T01:26:31Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/261422893",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6440430?v=3",
         "events_url" : "https://api.github.com/users/mruddy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mruddy/followers",
         "following_url" : "https://api.github.com/users/mruddy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mruddy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mruddy",
         "id" : 6440430,
         "login" : "mruddy",
         "organizations_url" : "https://api.github.com/users/mruddy/orgs",
         "received_events_url" : "https://api.github.com/users/mruddy/received_events",
         "repos_url" : "https://api.github.com/users/mruddy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mruddy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mruddy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mruddy"
      }
   },
   {
      "body" : "The latch isn't about checking the same block twice,  it's the idea that if there is a big reorg our definition of \"burried\" must be wrong and so we shouldn't skip validation of anything new that shows up.\r\n\r\nE.g.  you have    blocks  \"A B C D ..... Y Z \"  where B, C, D had their scriptchecks skipped because they were burred: then later  there is a reorg to   \"A B C' D' .... Y' Z' ZZ\", C' and D' should still get scriptchecked even though they are buried.  This limits the exposure to attack to just initialization, and doesn't harm performance because we are already assuming such a large reorg will never happen.  (Also: There is less reason for miners to ever try it when it won't let them bypass validation.)  \r\n\r\nI think the latch could work like this:  Remember the greatest height the function has been called on so far, and only return burried on blocks that are greater height. Make sure to init at the current height at start. Alternatively, I believe the same could be done with total work instead which would be less subject to shenanigans: malicious peer feeds you 100k fake early blocks to cause you to have to run scriptchecks when you reorg to the real chain. Another way to avoid those kinds of shenanigans would be to guard the function with a check that the header tip has total work greater than nMinimumChainWork. \r\n\r\nActually, this last point is a protection you should put in regardless of the latching: do not return burried while the header tip has less than nMinimumChainWork.  This protects against the case where I have network isolated you and I fork the chain early and give you 'burried' junk which is all at low difficulty.\r\n\r\nAs far as configuration goes:  Every configuration option has a large maintenance cost: We need to test it-- what happens when it's set to crazy values?-- what do we do when the logic changes and the old setting can't really be applied? -- e.g. we realize 'age' is a bad metric, and want to use total work differences?.  It also has a direct cost to the user-- one more setting to worry about,  some users will misunderstand it and set it in ways that are contrary to their own interests and expectations. There are, indeed, differences in use cases-- at least a few, but generally we're in a better position to pick settings: we have a wider view of the system, we can conduct extensive tests, gather peer review.. etc.  So in principle we should think carefully before adding more than the minimally necessary options.  I _hope_ we can find settings here which are good enough for performance that the defaults will work for everyone who could otherwise run Bitcoin Core-- and any setting would just be a 'paranoid' mode the primarily exists for auditing and software testing purposes, like the checkpoints=0 setting today. :)\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n \r\n\r\n\r\n",
      "created_at" : "2016-11-18T07:42:23Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9180#issuecomment-261468418",
      "id" : 261468418,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9180",
      "updated_at" : "2016-11-18T07:42:23Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/261468418",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "@petertodd  @maaku   I recall both of you specifically having thoughts about this kind of functionality.",
      "created_at" : "2016-11-18T07:43:01Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9180#issuecomment-261468511",
      "id" : 261468511,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9180",
      "updated_at" : "2016-11-18T07:43:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/261468511",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "Thanks for the explanation @gmaxwell. I think I understand. Updates made to incorporate all of your feedback.\r\nI removed the new config option and just left it just gated by -checkpoints.\r\nOn the latch: I call it a high water mark in the code. It's not done yet (see the TODO), but figured I'd put up what I had so far to make sure I was on the right track.\r\nAlso, minor note: I added a new GetAncestor check before GetBlockProofEquivalentTime in IsBuried. I added it for completeness although I haven't found it actually necessary while running some regtest scenarios.",
      "created_at" : "2016-11-18T19:47:09Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9180#issuecomment-261624534",
      "id" : 261624534,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9180",
      "updated_at" : "2016-11-18T19:47:09Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/261624534",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6440430?v=3",
         "events_url" : "https://api.github.com/users/mruddy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mruddy/followers",
         "following_url" : "https://api.github.com/users/mruddy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mruddy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mruddy",
         "id" : 6440430,
         "login" : "mruddy",
         "organizations_url" : "https://api.github.com/users/mruddy/orgs",
         "received_events_url" : "https://api.github.com/users/mruddy/received_events",
         "repos_url" : "https://api.github.com/users/mruddy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mruddy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mruddy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mruddy"
      }
   },
   {
      "body" : "I'm going to try to prod people who are likely to oppose this and lets see if we can satisfy whatever concerns they have.",
      "created_at" : "2016-11-19T10:43:37Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9180#issuecomment-261706663",
      "id" : 261706663,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9180",
      "updated_at" : "2016-11-19T10:43:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/261706663",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "So, if I understand this correctly, this pull-req would define a certain amount of work at which point script validation is skipped?\r\n\r\nI don't think this is a good idea, as you're changing the system to quite clearly give miners the ability to override the rules of the system. This has political and legal implications. For example, if miners can override the rules of the system, it becomes tempting to force them to do so to do things like confiscate funds that authorities believe should belong to different owners.\r\n\r\nHere's an alternative: Known-Good Blocks. The idea here is your client would come with a set of block hashes that the developers asserted correctly followed all the Bitcoin protocol rules, and thus were known to be valid. Unlike checkpoints, in the event of a reorg you would still accept the reorg, but because the blocks in the reorg don't match the known-good block hashes, you'd validate them fully against the protocol rules.\r\n\r\nUnlike this pull-req, Known-Good Blocks don't change the trust model of Bitcoin. Like the rest of the codebase, they're easily audited: anyone with a copy of the relevant parts of the blockchain can verify that those block hashes do in fact refer to valid blocks. If the developers maliciously or otherwise add an invalid known-good block to the codebase, it's easy to prove to the rest of the world that they have done so. Similarly, if the community fails to properly audit changes to the codebase, it's quite possible for the developers to insert changes into it that cause invalid blocks to be accepted as valid - a fake known-good hash is just one of *many* ways this could be done. Finally, unlike checkpoints known-good blocks don't change the protocol: they're just an implementation detail, and different implementations can have different sets of known-good blocks with no effect on consensus, so long as the blocks picked are in fact valid.\r\n\r\nFinally it's important to note that the fact that the Bitcoin protocol requires blocks to be valid against a large set of protocol rules is an optimization that's needed by SPV clients - it's *not* an inherent requirement for Bitcoin to function. I explained this in detail a few years back in my article [Disentangling Crypto-Coin Mining: Timestamping, Proof-of-Publication, and Validation](https://petertodd.org/2013/disentangling-crypto-coin-mining).",
      "created_at" : "2016-11-19T13:31:32Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9180#issuecomment-261714018",
      "id" : 261714018,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9180",
      "updated_at" : "2016-11-19T13:31:32Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/261714018",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/7042?v=3",
         "events_url" : "https://api.github.com/users/petertodd/events{/privacy}",
         "followers_url" : "https://api.github.com/users/petertodd/followers",
         "following_url" : "https://api.github.com/users/petertodd/following{/other_user}",
         "gists_url" : "https://api.github.com/users/petertodd/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/petertodd",
         "id" : 7042,
         "login" : "petertodd",
         "organizations_url" : "https://api.github.com/users/petertodd/orgs",
         "received_events_url" : "https://api.github.com/users/petertodd/received_events",
         "repos_url" : "https://api.github.com/users/petertodd/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/petertodd/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/petertodd/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/petertodd"
      }
   },
   {
      "body" : "@petertodd \r\n\r\nThanks for taking the time to comment. I strongly believe that if we don't do something prudent here people will either do something more foolish, or there won't be full nodes around anymore for us to worry about them anymore.\r\n\r\nLets define work equivalent days (WED), as function of two blocks that returns the number of days of hashing that would be required to mine from the lower to the upper given the difficulties hashrate.\r\n\r\nLets define a \"buried block\". To be buried a block must be below a certain amount of WED with respect to the current best header, must be an ancestor of the current best header and  must have a timestamp below the best known tip by a certain amount (same as the WED).\r\n\r\nThis patch skips validation for the initial sync of buried blocks when the best header chain has more work than a hardcoded amount known to be in the best chain. Note the \"initial sync\", if there is a reorganization that disrupts our concept of \"buried\" the newly connected blocks should be checked.\r\n\r\nAs a result, this exposure only exist for newly initializing nodes and ones that had been offline and fallen behind.  An attacker who attempted to rewrite the state would find their efforts ignored by _all_ preexisting nodes.  I believe this may largely mitigates your 'override' concern. \r\n\r\nIn particular, an attacker that can replace >100 blocks will start replacing the coinbase transactions in them without any rule violation. A 30 day reorg alone would grant 54000 BTC. An attacker who was technically able to mine back 30 days and catch back up would also almost certainly be technically able to mine back to 0 and catch back up, it would just take them longer. At 30 days there is also enough coinbase intermixing into the transaction flow that most people who transacted during that interval will have their transactions reversed even if the attacker would prefer that they weren't.\r\n\r\nWith respect to known good, I would be incredibly hesitant to ship some long hardcoded list of blocks: it is _very_ easily misunderstood as actually fixing the consensus state. It also arguably carries your 'easy to force' (yes, it would be 'visible', but a huge reorg is also visible and that didn't eliminate it from your concern), though I think that always exists it is strongly preferable to not amplify it with an easily misunderstood functionality.  If not for the constant negative experiences with checkpoints I'd be more prone to agree with you, but I do not think the distinction between pinning the chain and not really rises to people's minds. The bad experiences with checkpoints often take the form of \"we're already trusting these people to validate the chain, lets also trust these authorities to claw back stolen coins\" the second class is also \"reviewable\" in some sense and I feel the fact a slow and highly objective review process is qualitatively different from something highly subjective and ill-suited to public review is a distinction too fine for many.\r\n\r\nThe next consideration is that known-good will suffer constant \"bitrot\", the PR as is skips up to 30 days worth of work back-- which would be a phenomenal system ending reorg-- but a known good check would be stuck with the last release. If the system is depending on known good values, the result may be that frequent releases are encouraged which would diminish the value of review. I think this is a bad incentive for both developers and users.\r\n\r\nI can think of a number of ways to further harden this kind of proposal-- for example, it could validate (say) 1/1000 of the burred blocks at random with a negligible performance hit but create a consequence that an attacker who performed a phenomenal amount of computation to perform an attack like this against an isolated newly syncing peer could _still_ fail. The WED metric could be more aggressive in what hashrate it uses, a somewhat longer interval could be used, the presence of competing header chains could be considered. I don't know if you'd find any of them persuasive.\r\n\r\nDo you have any proposals on how a known good could avoid becoming outdated, resulting in an excessively slow synchronization and creating bad incentives to upgrade too often for developers and users alike?\r\n\r\n",
      "created_at" : "2016-11-19T20:33:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9180#issuecomment-261737915",
      "id" : 261737915,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9180",
      "updated_at" : "2016-11-19T20:33:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/261737915",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/858454?v=3",
         "events_url" : "https://api.github.com/users/gmaxwell/events{/privacy}",
         "followers_url" : "https://api.github.com/users/gmaxwell/followers",
         "following_url" : "https://api.github.com/users/gmaxwell/following{/other_user}",
         "gists_url" : "https://api.github.com/users/gmaxwell/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/gmaxwell",
         "id" : 858454,
         "login" : "gmaxwell",
         "organizations_url" : "https://api.github.com/users/gmaxwell/orgs",
         "received_events_url" : "https://api.github.com/users/gmaxwell/received_events",
         "repos_url" : "https://api.github.com/users/gmaxwell/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/gmaxwell/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/gmaxwell"
      }
   },
   {
      "body" : "@petertodd @gmaxwell Wow, the review you guys are doing is amazing! Good stuff, thanks!\r\n\r\nI've been thinking through all of it and have like a page of thoughts, but it came to mind that by itself (forgetting the high watermark part), the IsBuried code turns the full node into a hybrid SPV-full node when active (with a little bit of extra additional safety if there is a re-org). So, is the simplest fix to just make it guarded by a new flag that is off by default, but that could be turned on by a node operator during initial sync and turned off afterwards? That seems like the simplest change that allows the performance optimization during initial sync and then true full node functionality any time the flag is not explicitly turned on. Thus, node operators would have the choice whether to go full node only, or hybrid full-SPV. It would make this patch easier too :)\r\n\r\nedit: Had some ambiguous wording above... By hybrid SPV-full node, I mean it's a hybrid and somewhere on the spectrum in-between. If a node operator never used the new flag, then they'd be running a true fully validating (full) node. If they turned the flag on at any point, then it could become a hybrid node depending on when it was turned on. If it was on during initial sync (really the only sensical time to turn it on), during IBD for a node that had been offline for 30 days, or during a large re-org then it would be(come) a hybrid node. Then depending on when they turn the flag off again changes how much checking (none or all) that they'd do on a large IsBuried assumption invalidating re-org or long offline IBD.",
      "created_at" : "2016-11-19T22:49:50Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9180#issuecomment-261745041",
      "id" : 261745041,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9180",
      "updated_at" : "2016-11-19T23:18:51Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/261745041",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6440430?v=3",
         "events_url" : "https://api.github.com/users/mruddy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mruddy/followers",
         "following_url" : "https://api.github.com/users/mruddy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mruddy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mruddy",
         "id" : 6440430,
         "login" : "mruddy",
         "organizations_url" : "https://api.github.com/users/mruddy/orgs",
         "received_events_url" : "https://api.github.com/users/mruddy/received_events",
         "repos_url" : "https://api.github.com/users/mruddy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mruddy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mruddy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mruddy"
      }
   },
   {
      "body" : "If hybrid node mode is not worth considering, then a full node implementing \"known-good, fully validate other\" could be implemented with a simple command line option that takes a known-good user-obtained block hash. The node operator would just have to find a trusted source for such a hash. What could be trusted would be up to the threat model for each user and would not be limited to just the software distributors. It could be the developers signing something, any other trusted website, etc..., or even a new function in the node where the node starts up and gets a view of header chains from its peers and shows the user a hash with 30 days of work and from a chain with at least so much work that _could_ be used. What I think is important is that the source not be mandated by the code so as to reduce risk of coercion or homogeneity and dependence on a single group such as miners, developers, distributors, etc...",
      "created_at" : "2016-11-20T00:30:54Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/9180#issuecomment-261749562",
      "id" : 261749562,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/9180",
      "updated_at" : "2016-11-20T00:30:54Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/261749562",
      "user" : {
         "avatar_url" : "https://avatars.githubusercontent.com/u/6440430?v=3",
         "events_url" : "https://api.github.com/users/mruddy/events{/privacy}",
         "followers_url" : "https://api.github.com/users/mruddy/followers",
         "following_url" : "https://api.github.com/users/mruddy/following{/other_user}",
         "gists_url" : "https://api.github.com/users/mruddy/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/mruddy",
         "id" : 6440430,
         "login" : "mruddy",
         "organizations_url" : "https://api.github.com/users/mruddy/orgs",
         "received_events_url" : "https://api.github.com/users/mruddy/received_events",
         "repos_url" : "https://api.github.com/users/mruddy/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/mruddy/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/mruddy/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/mruddy"
      }
   }
]
