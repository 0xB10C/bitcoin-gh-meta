[
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK: less boost is better",
      "created_at" : "2020-04-04T16:37:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609054980",
      "id" : 609054980,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18524",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwOTA1NDk4MA==",
      "updated_at" : "2020-04-04T16:37:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/609054980",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK: it solved [the issue](https://github.com/bitcoin/bitcoin/issues/18517) I had.",
      "created_at" : "2020-04-04T16:39:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609055282",
      "id" : 609055282,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18524",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwOTA1NTI4Mg==",
      "updated_at" : "2020-04-04T16:39:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/609055282",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK.",
      "created_at" : "2020-04-04T16:40:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609055471",
      "id" : 609055471,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18524",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwOTA1NTQ3MQ==",
      "updated_at" : "2020-04-04T16:40:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/609055471",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Updated ba8312c7dca427463c83acd490281bc35dde34b7 -> ad067a98ea1ca383898bf26d4abd00981246471f ([`pr/nosig.1`](https://github.com/ryanofsky/bitcoin/commits/pr/nosig.1) -> [`pr/nosig.2`](https://github.com/ryanofsky/bitcoin/commits/pr/nosig.2), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/nosig.1..pr/nosig.2)) avoiding unneeded shared_ptr copies and cleaning up typedefs\r\nUpdated ad067a98ea1ca383898bf26d4abd00981246471f -> 01639a21d12df54895d0214542b84335d7f58a94 ([`pr/nosig.2`](https://github.com/ryanofsky/bitcoin/commits/pr/nosig.2) -> [`pr/nosig.3`](https://github.com/ryanofsky/bitcoin/commits/pr/nosig.3), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/nosig.2..pr/nosig.3)) removing last typedef",
      "created_at" : "2020-04-04T16:55:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609057547",
      "id" : 609057547,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18524",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwOTA1NzU0Nw==",
      "updated_at" : "2020-04-04T17:04:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/609057547",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493465"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403493465"
         }
      },
      "author_association" : "MEMBER",
      "body" : "So we add the same twice?",
      "commit_id" : "3d463addfe2859bc55916f61086aaab624132411",
      "created_at" : "2020-04-04T17:15:53Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493465",
      "id" : 403493465,
      "line" : 34,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ5MzQ2NQ==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 34,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 42,
      "pull_request_review_id" : 387717466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-04T23:30:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403493465",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493569"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403493569"
         }
      },
      "author_association" : "MEMBER",
      "body" : "How about local copy and then iterate it lock free?",
      "commit_id" : "3d463addfe2859bc55916f61086aaab624132411",
      "created_at" : "2020-04-04T17:16:57Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493569",
      "id" : 403493569,
      "line" : 63,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ5MzU2OQ==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 63,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 71,
      "pull_request_review_id" : 387717466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-04T23:30:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403493569",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403513585"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403513585"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think some C++ compilers don't allow to use `auto` in combination with C++11 list initialization for non-primitive types. You might have to write \r\n```suggestion\r\n        for (auto it = m_list.begin(), prev{m_list.end()};; prev = it++) {\r\n```",
      "commit_id" : "3d463addfe2859bc55916f61086aaab624132411",
      "created_at" : "2020-04-04T20:31:17Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);\n+        for (auto it{m_list.begin()}, prev{m_list.end()};; prev = it++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403513585",
      "id" : 403513585,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzUxMzU4NQ==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 64,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : null,
      "pull_request_review_id" : 387732352,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-04T23:30:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403513585",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403514268"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403514268"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> I think some C++ compilers don't allow to use `auto` in combination with C++11 list initialization for non-primitive types.\r\n\r\nI think they allow to do it, but the [deducted type](https://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts) is `std::initializer_list` in this case, which is not what we want here.",
      "commit_id" : "3d463addfe2859bc55916f61086aaab624132411",
      "created_at" : "2020-04-04T20:38:31Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);\n+        for (auto it{m_list.begin()}, prev{m_list.end()};; prev = it++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403514268",
      "id" : 403514268,
      "in_reply_to_id" : 403513585,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzUxNDI2OA==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 64,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : null,
      "pull_request_review_id" : 387732840,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-04T23:30:16Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403514268",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403565141"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403565141"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493465\r\n\r\n> So we add the same twice?\r\n\r\nThere's two emplaces because of the map and list (if that's the question)",
      "commit_id" : "3d463addfe2859bc55916f61086aaab624132411",
      "created_at" : "2020-04-04T23:13:39Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403565141",
      "id" : 403565141,
      "in_reply_to_id" : 403493465,
      "line" : 34,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU2NTE0MQ==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 34,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 42,
      "pull_request_review_id" : 387766291,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-04T23:35:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403565141",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403570017"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403570017"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493569\r\n\r\n> How about local copy and then iterate it lock free?\r\n\r\nI'm not sure what approach could be entirely lock free since the list is global and can be modified from any thread.\r\n\r\nI just implemented something simple that can be changed and optimized in the future. The lock is not held when calling CValidation interface methods. It avoids copying so allocations aren't needed just to iterate the list. Assumption is that the list is iterated frequently and modified infrequently",
      "commit_id" : "3d463addfe2859bc55916f61086aaab624132411",
      "created_at" : "2020-04-04T23:25:24Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403570017",
      "id" : 403570017,
      "in_reply_to_id" : 403493569,
      "line" : 63,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU3MDAxNw==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 63,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 71,
      "pull_request_review_id" : 387766291,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-04T23:35:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403570017",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403570978"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403570978"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403513585\r\n\r\n> I think they allow to do it, but the [deducted type](https://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts) is `std::initializer_list` in this case, which is not what we want here.\r\n\r\nThis seems to be causing compile errors on centos 7:\r\n\r\nhttps://travis-ci.org/github/bitcoin/bitcoin/jobs/671000374#L2207\r\n\r\nChanged `{}` to `()` to see if it helps with that compiler",
      "commit_id" : "3d463addfe2859bc55916f61086aaab624132411",
      "created_at" : "2020-04-04T23:27:41Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);\n+        for (auto it{m_list.begin()}, prev{m_list.end()};; prev = it++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403570978",
      "id" : 403570978,
      "in_reply_to_id" : 403513585,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU3MDk3OA==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 64,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : null,
      "pull_request_review_id" : 387766291,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-04T23:35:18Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403570978",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403577276"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403577276"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I mean this is allowing adding the same callbacks. Why not `assert(inserted.second)`?",
      "commit_id" : "3d463addfe2859bc55916f61086aaab624132411",
      "created_at" : "2020-04-04T23:42:29Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403577276",
      "id" : 403577276,
      "in_reply_to_id" : 403493465,
      "line" : 34,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU3NzI3Ng==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 34,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 42,
      "pull_request_review_id" : 387767664,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-04T23:42:29Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403577276",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403579194"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403579194"
         }
      },
      "author_association" : "MEMBER",
      "body" : "So at best case it would be lock free I think.",
      "commit_id" : "3d463addfe2859bc55916f61086aaab624132411",
      "created_at" : "2020-04-04T23:46:55Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403579194",
      "id" : 403579194,
      "in_reply_to_id" : 403493569,
      "line" : 63,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU3OTE5NA==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 63,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 71,
      "pull_request_review_id" : 387767918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-04T23:46:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403579194",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403580354"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403580354"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oops, I wanted to delete my own comment, but it seems I misclicked and deleted @promag's. Restoring from mail:\r\n\r\n> > Assumption is that the list is iterated frequently and modified infrequently\r\n>\r\n> Right. What I had in mind is 2 lists and an atomic book list_changed. On iterating it would then sync the list with the mutex locked.",
      "commit_id" : "3d463addfe2859bc55916f61086aaab624132411",
      "created_at" : "2020-04-04T23:49:35Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403580354",
      "id" : 403580354,
      "in_reply_to_id" : 403493569,
      "line" : 63,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU4MDM1NA==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 63,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 71,
      "pull_request_review_id" : 387768036,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-04T23:49:35Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403580354",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403582919"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403582919"
         }
      },
      "author_association" : "MEMBER",
      "body" : ":) I was wondering what happened. So draft:\r\n```\r\nif (list_changed) {\r\n  lock;\r\n  iterate_list = list;\r\n  list_changed = false\r\n}\r\nfor (f : iterate_list) f()\r\n```\r\n ",
      "commit_id" : "3d463addfe2859bc55916f61086aaab624132411",
      "created_at" : "2020-04-04T23:55:32Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403582919",
      "id" : 403582919,
      "in_reply_to_id" : 403493569,
      "line" : 63,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU4MjkxOQ==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 63,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 71,
      "pull_request_review_id" : 387768366,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-04T23:55:48Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403582919",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403588495"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403588495"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493465\r\n\r\n> I mean this is allowing adding the same callbacks. Why not `assert(inserted.second)`?\r\n\r\nUnit tests fail if the unregister function is not idempotent, so it seems good to me that the register function is idempotent as well. I could imagine an idempotent API here making calling code simpler, even though I could also imagine an assert catching potential bugs. I think asserts tend to work a better at short range within a module instead of being used to make an API rigid in an attempt to catch external bugs. But I don't think there is a right answer here and would be ok with a PR that took a different approach.",
      "commit_id" : "3d463addfe2859bc55916f61086aaab624132411",
      "created_at" : "2020-04-05T00:08:38Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403588495",
      "id" : 403588495,
      "in_reply_to_id" : 403493465,
      "line" : 34,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU4ODQ5NQ==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 34,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 42,
      "pull_request_review_id" : 387769084,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-05T00:42:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403588495",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403594731"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403594731"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493569\r\n\r\n> Right. What I had in mind is 2 lists and an atomic book list_changed. On iterating it would then sync the list with the mutex locked.\r\n\r\nI don't understand the suggestion from the pseudocode. I don't love the idea of having multiple lists, but even if you have them, I don't see how you avoid locks copying the list if you do create copies, or avoid needing a condition variable to delay modifying the list if you don't create copies. I'm probably just making an incorrect assumption about what you want to accomplish here. Feel free to post sample code, or just change the implementation in an alternate PR or followup PR. I'd be especially interested if it's a simplification and not just an optimization.",
      "commit_id" : "3d463addfe2859bc55916f61086aaab624132411",
      "created_at" : "2020-04-05T00:23:32Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403594731",
      "id" : 403594731,
      "in_reply_to_id" : 403493569,
      "line" : 63,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU5NDczMQ==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 63,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 71,
      "pull_request_review_id" : 387769084,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-05T00:42:06Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403594731",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403600366"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403600366"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is it not possible that there are two invocations of Iterate simultaneously?",
      "commit_id" : "3d463addfe2859bc55916f61086aaab624132411",
      "created_at" : "2020-04-05T00:37:04Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403600366",
      "id" : 403600366,
      "in_reply_to_id" : 403493569,
      "line" : 63,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzYwMDM2Ng==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 63,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 71,
      "pull_request_review_id" : 387770583,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-05T00:37:05Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403600366",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   }
]
