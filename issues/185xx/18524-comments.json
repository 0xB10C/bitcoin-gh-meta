[
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK: less boost is better",
      "created_at" : "2020-04-04T16:37:44Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609054980",
      "id" : 609054980,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18524",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwOTA1NDk4MA==",
      "updated_at" : "2020-04-04T16:37:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/609054980",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7826565?v=4",
         "events_url" : "https://api.github.com/users/practicalswift/events{/privacy}",
         "followers_url" : "https://api.github.com/users/practicalswift/followers",
         "following_url" : "https://api.github.com/users/practicalswift/following{/other_user}",
         "gists_url" : "https://api.github.com/users/practicalswift/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/practicalswift",
         "id" : 7826565,
         "login" : "practicalswift",
         "node_id" : "MDQ6VXNlcjc4MjY1NjU=",
         "organizations_url" : "https://api.github.com/users/practicalswift/orgs",
         "received_events_url" : "https://api.github.com/users/practicalswift/received_events",
         "repos_url" : "https://api.github.com/users/practicalswift/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/practicalswift/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/practicalswift"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Concept ACK: it solved [the issue](https://github.com/bitcoin/bitcoin/issues/18517) I had.",
      "created_at" : "2020-04-04T16:39:07Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609055282",
      "id" : 609055282,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18524",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwOTA1NTI4Mg==",
      "updated_at" : "2020-04-04T16:39:07Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/609055282",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/7975071?v=4",
         "events_url" : "https://api.github.com/users/naumenkogs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/naumenkogs/followers",
         "following_url" : "https://api.github.com/users/naumenkogs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/naumenkogs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/naumenkogs",
         "id" : 7975071,
         "login" : "naumenkogs",
         "node_id" : "MDQ6VXNlcjc5NzUwNzE=",
         "organizations_url" : "https://api.github.com/users/naumenkogs/orgs",
         "received_events_url" : "https://api.github.com/users/naumenkogs/received_events",
         "repos_url" : "https://api.github.com/users/naumenkogs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/naumenkogs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/naumenkogs"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Concept ACK.",
      "created_at" : "2020-04-04T16:40:04Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609055471",
      "id" : 609055471,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18524",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwOTA1NTQ3MQ==",
      "updated_at" : "2020-04-04T16:40:04Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/609055471",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Updated ba8312c7dca427463c83acd490281bc35dde34b7 -> ad067a98ea1ca383898bf26d4abd00981246471f ([`pr/nosig.1`](https://github.com/ryanofsky/bitcoin/commits/pr/nosig.1) -> [`pr/nosig.2`](https://github.com/ryanofsky/bitcoin/commits/pr/nosig.2), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/nosig.1..pr/nosig.2)) avoiding unneeded shared_ptr copies and cleaning up typedefs\r\nUpdated ad067a98ea1ca383898bf26d4abd00981246471f -> 01639a21d12df54895d0214542b84335d7f58a94 ([`pr/nosig.2`](https://github.com/ryanofsky/bitcoin/commits/pr/nosig.2) -> [`pr/nosig.3`](https://github.com/ryanofsky/bitcoin/commits/pr/nosig.3), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/nosig.2..pr/nosig.3)) removing last typedef",
      "created_at" : "2020-04-04T16:55:00Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609057547",
      "id" : 609057547,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18524",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwOTA1NzU0Nw==",
      "updated_at" : "2020-04-04T17:04:38Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/609057547",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493465"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403493465"
         }
      },
      "author_association" : "MEMBER",
      "body" : "So we add the same twice?",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-04T17:15:53Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493465",
      "id" : 403493465,
      "line" : 48,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ5MzQ2NQ==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 48,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 56,
      "pull_request_review_id" : 387717466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403493465",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493569"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403493569"
         }
      },
      "author_association" : "MEMBER",
      "body" : "How about local copy and then iterate it lock free?",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-04T17:16:57Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493569",
      "id" : 403493569,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQ5MzU2OQ==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 78,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 86,
      "pull_request_review_id" : 387717466,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403493569",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403513585"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403513585"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think some C++ compilers don't allow to use `auto` in combination with C++11 list initialization for non-primitive types. You might have to write \r\n```suggestion\r\n        for (auto it = m_list.begin(), prev{m_list.end()};; prev = it++) {\r\n```",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-04T20:31:17Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);\n+        for (auto it{m_list.begin()}, prev{m_list.end()};; prev = it++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403513585",
      "id" : 403513585,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzUxMzU4NQ==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 64,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : null,
      "pull_request_review_id" : 387732352,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403513585",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403514268"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403514268"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> I think some C++ compilers don't allow to use `auto` in combination with C++11 list initialization for non-primitive types.\r\n\r\nI think they allow to do it, but the [deducted type](https://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts) is `std::initializer_list` in this case, which is not what we want here.",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-04T20:38:31Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);\n+        for (auto it{m_list.begin()}, prev{m_list.end()};; prev = it++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403514268",
      "id" : 403514268,
      "in_reply_to_id" : 403513585,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzUxNDI2OA==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 64,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : null,
      "pull_request_review_id" : 387732840,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403514268",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403565141"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403565141"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493465\r\n\r\n> So we add the same twice?\r\n\r\nThere's two emplaces because of the map and list (if that's the question)",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-04T23:13:39Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403565141",
      "id" : 403565141,
      "in_reply_to_id" : 403493465,
      "line" : 48,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU2NTE0MQ==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 48,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 56,
      "pull_request_review_id" : 387766291,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403565141",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403570017"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403570017"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493569\r\n\r\n> How about local copy and then iterate it lock free?\r\n\r\nI'm not sure what approach could be entirely lock free since the list is global and can be modified from any thread.\r\n\r\nI just implemented something simple that can be changed and optimized in the future. The lock is not held when calling CValidation interface methods. It avoids copying so allocations aren't needed just to iterate the list. Assumption is that the list is iterated frequently and modified infrequently",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-04T23:25:24Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403570017",
      "id" : 403570017,
      "in_reply_to_id" : 403493569,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU3MDAxNw==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 78,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 86,
      "pull_request_review_id" : 387766291,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403570017",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403570978"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403570978"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403513585\r\n\r\n> I think they allow to do it, but the [deducted type](https://en.cppreference.com/w/cpp/language/template_argument_deduction#Other_contexts) is `std::initializer_list` in this case, which is not what we want here.\r\n\r\nThis seems to be causing compile errors on centos 7:\r\n\r\nhttps://travis-ci.org/github/bitcoin/bitcoin/jobs/671000374#L2207\r\n\r\nChanged `{}` to `()` to see if it helps with that compiler",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-04T23:27:41Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);\n+        for (auto it{m_list.begin()}, prev{m_list.end()};; prev = it++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403570978",
      "id" : 403570978,
      "in_reply_to_id" : 403513585,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU3MDk3OA==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 64,
      "original_position" : 72,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : null,
      "pull_request_review_id" : 387766291,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403570978",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403577276"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403577276"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I mean this is allowing adding the same callbacks. Why not `assert(inserted.second)`?",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-04T23:42:29Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403577276",
      "id" : 403577276,
      "in_reply_to_id" : 403493465,
      "line" : 48,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU3NzI3Ng==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 48,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 56,
      "pull_request_review_id" : 387767664,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403577276",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403579194"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403579194"
         }
      },
      "author_association" : "MEMBER",
      "body" : "So at best case it would be lock free I think.",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-04T23:46:55Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403579194",
      "id" : 403579194,
      "in_reply_to_id" : 403493569,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU3OTE5NA==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 78,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 86,
      "pull_request_review_id" : 387767918,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403579194",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403580354"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403580354"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Oops, I wanted to delete my own comment, but it seems I misclicked and deleted @promag's. Restoring from mail:\r\n\r\n> > Assumption is that the list is iterated frequently and modified infrequently\r\n>\r\n> Right. What I had in mind is 2 lists and an atomic book list_changed. On iterating it would then sync the list with the mutex locked.",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-04T23:49:35Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403580354",
      "id" : 403580354,
      "in_reply_to_id" : 403493569,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU4MDM1NA==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 78,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 86,
      "pull_request_review_id" : 387768036,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403580354",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403582919"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403582919"
         }
      },
      "author_association" : "MEMBER",
      "body" : ":) I was wondering what happened. So draft:\r\n```\r\nif (list_changed) {\r\n  lock;\r\n  iterate_list = list;\r\n  list_changed = false\r\n}\r\nfor (f : iterate_list) f()\r\n```\r\n ",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-04T23:55:32Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403582919",
      "id" : 403582919,
      "in_reply_to_id" : 403493569,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU4MjkxOQ==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 78,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 86,
      "pull_request_review_id" : 387768366,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403582919",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403588495"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403588495"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493465\r\n\r\n> I mean this is allowing adding the same callbacks. Why not `assert(inserted.second)`?\r\n\r\nUnit tests fail if the unregister function is not idempotent, so it seems good to me that the register function is idempotent as well. I could imagine an idempotent API here making calling code simpler, even though I could also imagine an assert catching potential bugs. I think asserts tend to work a better at short range within a module instead of being used to make an API rigid in an attempt to catch external bugs. But I don't think there is a right answer here and would be ok with a PR that took a different approach.",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-05T00:08:38Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403588495",
      "id" : 403588495,
      "in_reply_to_id" : 403493465,
      "line" : 48,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU4ODQ5NQ==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 48,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 56,
      "pull_request_review_id" : 387769084,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403588495",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403594731"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403594731"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403493569\r\n\r\n> Right. What I had in mind is 2 lists and an atomic book list_changed. On iterating it would then sync the list with the mutex locked.\r\n\r\nI don't understand the suggestion from the pseudocode. I don't love the idea of having multiple lists, but even if you have them, I don't see how you avoid locks copying the list if you do create copies, or avoid needing a condition variable to delay modifying the list if you don't create copies. I'm probably just making an incorrect assumption about what you want to accomplish here. Feel free to post sample code, or just change the implementation in an alternate PR or followup PR. I'd be especially interested if it's a simplification and not just an optimization.",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-05T00:23:32Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403594731",
      "id" : 403594731,
      "in_reply_to_id" : 403493569,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzU5NDczMQ==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 78,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 86,
      "pull_request_review_id" : 387769084,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403594731",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403600366"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403600366"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is it not possible that there are two invocations of Iterate simultaneously?",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-05T00:37:04Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403600366",
      "id" : 403600366,
      "in_reply_to_id" : 403493569,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzYwMDM2Ng==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 78,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 86,
      "pull_request_review_id" : 387770583,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403600366",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403605613"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403605613"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403600366\r\n\r\n> Is it not possible that there are two invocations of Iterate simultaneously?\r\n\r\nIt shouldn't be the most common thing but should be possible because notifications like CMainSignals::BlockChecked and CMainSignals::NewPoWValidBlock run on calling thread. Other notifications are sent from the scheduler so shouldn't happen simultaneously.",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-05T00:49:38Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403605613",
      "id" : 403605613,
      "in_reply_to_id" : 403493569,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzYwNTYxMw==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 78,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 86,
      "pull_request_review_id" : 387771289,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403605613",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403687245"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403687245"
         }
      },
      "author_association" : "MEMBER",
      "body" : "It follows from the code of the `Clear()` function that `m_list` could be non-empty when the function returns.\r\n\r\nIs it consistent state if `m_list.empty() == false` and `m_map.empty() == true` ?",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-05T11:18:57Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403687245",
      "id" : 403687245,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY4NzI0NQ==",
      "original_commit_id" : "3d463addfe2859bc55916f61086aaab624132411",
      "original_line" : 74,
      "original_position" : 67,
      "original_start_line" : 52,
      "path" : "src/validationinterface.cpp",
      "position" : null,
      "pull_request_review_id" : 387807723,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403687245",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403693635"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403693635"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403687245\r\n\r\n> It follows from the code of the `Clear()` function that `m_list` could be non-empty when the function returns.\r\n> \r\n> Is it consistent state if `m_list.empty() == false` and `m_map.empty() == true` ?\r\n\r\nYes, this happens when the reference count of one or more callbacks in the list is nonzero, which means they are currently being called, and will be removed by the iterate function when they are done being called, clearing the list.",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-05T12:15:47Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403693635",
      "id" : 403693635,
      "in_reply_to_id" : 403687245,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzY5MzYzNQ==",
      "original_commit_id" : "3d463addfe2859bc55916f61086aaab624132411",
      "original_line" : 74,
      "original_position" : 67,
      "original_start_line" : 52,
      "path" : "src/validationinterface.cpp",
      "position" : null,
      "pull_request_review_id" : 387812483,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403693635",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "Updated 3d463addfe2859bc55916f61086aaab624132411 -> b5fea244e5ac38758d295203209b66bd5905d714 ([`pr/nosig.4`](https://github.com/ryanofsky/bitcoin/commits/pr/nosig.4) -> [`pr/nosig.5`](https://github.com/ryanofsky/bitcoin/commits/pr/nosig.5), [compare](https://github.com/ryanofsky/bitcoin/compare/pr/nosig.4..pr/nosig.5)) to destroy scheduler before callback list (no real change but makes more sense logically)\r\n\r\nAlso I'm noticing random appveyor test failures with `OSError: [WinError 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted` https://ci.appveyor.com/project/DrahtBot/bitcoin/builds/31959888#L3892, I'm assuming not related to the PR",
      "created_at" : "2020-04-05T12:33:20Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609409312",
      "id" : 609409312,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18524",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwOTQwOTMxMg==",
      "updated_at" : "2020-04-05T12:33:20Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/609409312",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403702991"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403702991"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Why `callbacks` are moved into the `m_list` always, but not only when an insertion into `m_map` occurs?",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-05T13:37:08Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403702991",
      "id" : 403702991,
      "line" : 50,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzcwMjk5MQ==",
      "original_commit_id" : "b5fea244e5ac38758d295203209b66bd5905d714",
      "original_line" : 50,
      "original_position" : 47,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 58,
      "pull_request_review_id" : 387819834,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403702991",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403717827"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403717827"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403702991\r\n\r\n> Why `callbacks` are moved into the `m_list` always, but not only when an insertion into `m_map` occurs?\r\n\r\nShouldn't make a difference in practice, but it seemed better to me to call operator=(&&) and do empty destroy on the RHS object consistently instead of having different call sequences depending on a basically unrelated condition. Also, this will probably never matter but maybe always updating could be useful and worth guaranteeing in the future if there's internal property of the pointer worth updating like a new custom deleter.",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-05T15:33:40Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403717827",
      "id" : 403717827,
      "in_reply_to_id" : 403702991,
      "line" : 50,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzcxNzgyNw==",
      "original_commit_id" : "b5fea244e5ac38758d295203209b66bd5905d714",
      "original_line" : 50,
      "original_position" : 47,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 58,
      "pull_request_review_id" : 387831264,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403717827",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK b5fea244e5ac38758d295203209b66bd5905d714",
      "created_at" : "2020-04-05T22:33:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609495700",
      "id" : 609495700,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18524",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwOTQ5NTcwMA==",
      "updated_at" : "2020-04-05T22:33:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/609495700",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/6399679?v=4",
         "events_url" : "https://api.github.com/users/MarcoFalke/events{/privacy}",
         "followers_url" : "https://api.github.com/users/MarcoFalke/followers",
         "following_url" : "https://api.github.com/users/MarcoFalke/following{/other_user}",
         "gists_url" : "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/MarcoFalke",
         "id" : 6399679,
         "login" : "MarcoFalke",
         "node_id" : "MDQ6VXNlcjYzOTk2Nzk=",
         "organizations_url" : "https://api.github.com/users/MarcoFalke/orgs",
         "received_events_url" : "https://api.github.com/users/MarcoFalke/received_events",
         "repos_url" : "https://api.github.com/users/MarcoFalke/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/MarcoFalke/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/MarcoFalke"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403771944"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403771944"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Am I correct in stating the invariants here?\r\n* There are two types of callbacks, ones that are registered (in m_map) and ones that are not (because they're still being executed while being deleted).\r\n* m_list contains all callbacks of both types\r\n* entry.count is equal to the number of current executions of that entry, plus 1 if it's registered. It cannot be 0 (because that would imply being unregistered, and not being executed).\r\n\r\nPerhaps it's worth spelling these out.",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-05T23:23:24Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403771944",
      "id" : 403771944,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3MTk0NA==",
      "original_commit_id" : "b5fea244e5ac38758d295203209b66bd5905d714",
      "original_line" : 21,
      "original_position" : 28,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : null,
      "pull_request_review_id" : 387873463,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403771944",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "One way to test this change is to load and unload wallets repeatedly like in #18362. Each time a wallet is loaded and unloaded, a CValidationInterface instance gets registered and unregistered. If this is done during a sync when there are lots of UpdateTip and BlockConnected callbacks, it can be a good way to mix registrations with notifications and try to trigger deadlocks & segfaults we've previously seen here. Some command lines I used for testing this:\r\n\r\n```sh\r\nsrc/bitcoind -testnet -debug=1 -debugexclude=libevent -server=1 -printtoconsole\r\n\r\nsrc/bitcoin-cli -testnet createwallet w1\r\nsrc/bitcoin-cli -testnet unloadwallet w1\r\nsrc/bitcoin-cli -testnet createwallet w2\r\nsrc/bitcoin-cli -testnet unloadwallet w2\r\n\r\nwhile src/bitcoin-cli -testnet loadwallet w1 && src/bitcoin-cli -testnet unloadwallet w1; do true; done\r\n\r\nwhile src/bitcoin-cli -testnet loadwallet w2 && src/bitcoin-cli -testnet unloadwallet w2; do true; done\r\n```",
      "created_at" : "2020-04-05T23:25:36Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609502600",
      "id" : 609502600,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18524",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwOTUwMjYwMA==",
      "updated_at" : "2020-04-05T23:25:36Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/609502600",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403772517"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403772517"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Am I correct in stating the invariants here?\r\n\r\nYes, that's all correct and well stated. I'll add this as a comment",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-05T23:28:01Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403772517",
      "id" : 403772517,
      "in_reply_to_id" : 403771944,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3MjUxNw==",
      "original_commit_id" : "b5fea244e5ac38758d295203209b66bd5905d714",
      "original_line" : 21,
      "original_position" : 28,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : null,
      "pull_request_review_id" : 387873965,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403772517",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403772689"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403772689"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Nit: I think `else` on the same line like this without braces is hard to read (and easily changed into something with different semantics).",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-05T23:29:13Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403772689",
      "id" : 403772689,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3MjY4OQ==",
      "original_commit_id" : "b5fea244e5ac38758d295203209b66bd5905d714",
      "original_line" : 56,
      "original_position" : 64,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : null,
      "pull_request_review_id" : 387874097,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403772689",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403773935"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403773935"
         }
      },
      "author_association" : "MEMBER",
      "body" : "> Is it not possible that there are two invocations of Iterate simultaneously?\r\n\r\nMy previous suggestion isn't possible in this case.",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-05T23:39:39Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403773935",
      "id" : 403773935,
      "in_reply_to_id" : 403493569,
      "line" : 78,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3MzkzNQ==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 78,
      "original_position" : 71,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 86,
      "pull_request_review_id" : 387875252,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403773935",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "Out of curiosity, have you considered a read write lock?",
      "created_at" : "2020-04-05T23:39:55Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609504395",
      "id" : 609504395,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18524",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwOTUwNDM5NQ==",
      "updated_at" : "2020-04-05T23:39:55Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/609504395",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403775079"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403775079"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Nit: I think `else` on the same line like this without braces is hard to read (and easily changed into something with different semantics).\r\n\r\nChanged to assign statement here. You're right the else is easy to miss",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-05T23:48:44Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Remove(CValidationInterface* key)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(key);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            if (--it->count == 0) it = m_list.erase(it); else ++it;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403775079",
      "id" : 403775079,
      "in_reply_to_id" : 403772689,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3NTA3OQ==",
      "original_commit_id" : "b5fea244e5ac38758d295203209b66bd5905d714",
      "original_line" : 56,
      "original_position" : 64,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : null,
      "pull_request_review_id" : 387876252,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403775079",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403777744"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403777744"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Is this loop equivalent to the following?\r\n\r\n```c++\r\nWAIT_LOCK(m_mutex, lock);\r\nfor (auto it = m_list.begin(); it != m_list.end();) {\r\n    ++it->count;\r\n    {\r\n        REVERSE_LOCK(lock);\r\n        f(*it->callbacks);\r\n    }\r\n    it = (--it->count) ? std::next(it) : m_list.erase(it);\r\n}\r\n```",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-06T00:10:20Z",
      "diff_hunk" : "@@ -16,36 +16,74 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n+//! The MainSignalsInstance manages a list of shared_ptr<CValidationInterface>\n+//! callbacks.\n+//!\n+//! A std::unordered_map is used to track what callbacks are currently\n+//! registered, and a std::list is to used to store the callbacks that are\n+//! currently registered as well as any callbacks that are just unregistered\n+//! and about to be deleted when they are done executing.\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n+    Mutex m_mutex;\n+    //! List entries consist of a callback pointer and reference count. The\n+    //! count is equal to the number of current executions of that entry, plus 1\n+    //! if it's registered. It cannot be 0 because that would imply it is\n+    //! unregistered and also not being executed (so shouldn't exist).\n+    struct ListEntry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<ListEntry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<ListEntry>::iterator> m_map GUARDED_BY(m_mutex);\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Register(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Unregister(CValidationInterface* callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(callbacks);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    //! Clear unregisters every previously registered callback, erasing every\n+    //! map entry. After this call, the list may still contain callbacks that\n+    //! are currently executing, but it will be cleared when they are done\n+    //! executing.\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            it = --it->count == 0 ? m_list.erase(it) : std::next(it);\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);\n+        for (auto it(m_list.begin()), prev(m_list.end());; prev = it++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403777744",
      "id" : 403777744,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3Nzc0NA==",
      "original_commit_id" : "c3a471604b1ef263d32c7d90db27b2fcfadc7166",
      "original_line" : 79,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : null,
      "pull_request_review_id" : 387878658,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403777744",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403779135"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403779135"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> Is this loop equivalent to the following?\r\n\r\nYes and that's more straightforward. Updated",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-06T00:20:58Z",
      "diff_hunk" : "@@ -16,36 +16,74 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n+//! The MainSignalsInstance manages a list of shared_ptr<CValidationInterface>\n+//! callbacks.\n+//!\n+//! A std::unordered_map is used to track what callbacks are currently\n+//! registered, and a std::list is to used to store the callbacks that are\n+//! currently registered as well as any callbacks that are just unregistered\n+//! and about to be deleted when they are done executing.\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n+    Mutex m_mutex;\n+    //! List entries consist of a callback pointer and reference count. The\n+    //! count is equal to the number of current executions of that entry, plus 1\n+    //! if it's registered. It cannot be 0 because that would imply it is\n+    //! unregistered and also not being executed (so shouldn't exist).\n+    struct ListEntry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<ListEntry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<ListEntry>::iterator> m_map GUARDED_BY(m_mutex);\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Register(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());\n+        }\n+        inserted.first->second->callbacks = std::move(callbacks);\n+    }\n+\n+    void Unregister(CValidationInterface* callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto it = m_map.find(callbacks);\n+        if (it != m_map.end()) {\n+            if (--it->second->count == 0) m_list.erase(it->second);\n+            m_map.erase(it);\n+        }\n+    }\n+\n+    //! Clear unregisters every previously registered callback, erasing every\n+    //! map entry. After this call, the list may still contain callbacks that\n+    //! are currently executing, but it will be cleared when they are done\n+    //! executing.\n+    void Clear()\n+    {\n+        LOCK(m_mutex);\n+        for (auto it = m_list.begin(); it != m_list.end();) {\n+            it = --it->count == 0 ? m_list.erase(it) : std::next(it);\n+        }\n+        m_map.clear();\n+    }\n+\n+    template<typename F> void Iterate(F&& f)\n+    {\n+        WAIT_LOCK(m_mutex, lock);\n+        for (auto it(m_list.begin()), prev(m_list.end());; prev = it++) {",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403779135",
      "id" : 403779135,
      "in_reply_to_id" : 403777744,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc3OTEzNQ==",
      "original_commit_id" : "c3a471604b1ef263d32c7d90db27b2fcfadc7166",
      "original_line" : 79,
      "original_position" : 87,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : null,
      "pull_request_review_id" : 387879988,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403779135",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403782623"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403782623"
         }
      },
      "author_association" : "MEMBER",
      "body" : "I think these lines can be combined into `inserted.first->second = m_list.emplace(m_list.end());`.",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-06T00:46:39Z",
      "diff_hunk" : "@@ -16,36 +16,75 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n+//! The MainSignalsInstance manages a list of shared_ptr<CValidationInterface>\n+//! callbacks.\n+//!\n+//! A std::unordered_map is used to track what callbacks are currently\n+//! registered, and a std::list is to used to store the callbacks that are\n+//! currently registered as well as any callbacks that are just unregistered\n+//! and about to be deleted when they are done executing.\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n+    Mutex m_mutex;\n+    //! List entries consist of a callback pointer and reference count. The\n+    //! count is equal to the number of current executions of that entry, plus 1\n+    //! if it's registered. It cannot be 0 because that would imply it is\n+    //! unregistered and also not being executed (so shouldn't exist).\n+    struct ListEntry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<ListEntry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<ListEntry>::iterator> m_map GUARDED_BY(m_mutex);\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Register(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403782623",
      "id" : 403782623,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc4MjYyMw==",
      "original_commit_id" : "96176004a39c63fdd4ada1f07e55bc62ca0c447b",
      "original_line" : 48,
      "original_position" : 56,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : null,
      "pull_request_review_id" : 387883538,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403782623",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403783002"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403783002"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Do all of these member variables/types need to be public?",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-06T00:49:40Z",
      "diff_hunk" : "@@ -16,36 +16,75 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n+//! The MainSignalsInstance manages a list of shared_ptr<CValidationInterface>\n+//! callbacks.\n+//!\n+//! A std::unordered_map is used to track what callbacks are currently\n+//! registered, and a std::list is to used to store the callbacks that are\n+//! currently registered as well as any callbacks that are just unregistered\n+//! and about to be deleted when they are done executing.\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n+    Mutex m_mutex;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403783002",
      "id" : 403783002,
      "line" : 28,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzc4MzAwMg==",
      "original_commit_id" : "96176004a39c63fdd4ada1f07e55bc62ca0c447b",
      "original_line" : 28,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 35,
      "pull_request_review_id" : 387883875,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403783002",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "ACK 96176004a39c63fdd4ada1f07e55bc62ca0c447b",
      "created_at" : "2020-04-06T02:43:11Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#issuecomment-609537335",
      "id" : 609537335,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/18524",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDYwOTUzNzMzNQ==",
      "updated_at" : "2020-04-06T02:43:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/609537335",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/548488?v=4",
         "events_url" : "https://api.github.com/users/sipa/events{/privacy}",
         "followers_url" : "https://api.github.com/users/sipa/followers",
         "following_url" : "https://api.github.com/users/sipa/following{/other_user}",
         "gists_url" : "https://api.github.com/users/sipa/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/sipa",
         "id" : 548488,
         "login" : "sipa",
         "node_id" : "MDQ6VXNlcjU0ODQ4OA==",
         "organizations_url" : "https://api.github.com/users/sipa/orgs",
         "received_events_url" : "https://api.github.com/users/sipa/received_events",
         "repos_url" : "https://api.github.com/users/sipa/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/sipa/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/sipa/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/sipa"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403938401"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403938401"
         }
      },
      "author_association" : "MEMBER",
      "body" : "Personally I think these shouldn't be idempotent because makes sense to call just once. For instance `std::fstream::open` is not idempotent, fails if file is already opened. I'd rather fix unit tests. Just an opinion and should not prevent this change going forward.",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-06T09:07:44Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403938401",
      "id" : 403938401,
      "in_reply_to_id" : 403493465,
      "line" : 48,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkzODQwMQ==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 48,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 56,
      "pull_request_review_id" : 388062749,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:45:11Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/403938401",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/3534524?v=4",
         "events_url" : "https://api.github.com/users/promag/events{/privacy}",
         "followers_url" : "https://api.github.com/users/promag/followers",
         "following_url" : "https://api.github.com/users/promag/following{/other_user}",
         "gists_url" : "https://api.github.com/users/promag/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/promag",
         "id" : 3534524,
         "login" : "promag",
         "node_id" : "MDQ6VXNlcjM1MzQ1MjQ=",
         "organizations_url" : "https://api.github.com/users/promag/orgs",
         "received_events_url" : "https://api.github.com/users/promag/received_events",
         "repos_url" : "https://api.github.com/users/promag/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/promag/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/promag/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/promag"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r404046688"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/404046688"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403783002\r\n\r\n> Do all of these member variables/types need to be public?\r\n\r\nNo none do, added private/public sections",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-06T12:19:51Z",
      "diff_hunk" : "@@ -16,36 +16,75 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n+//! The MainSignalsInstance manages a list of shared_ptr<CValidationInterface>\n+//! callbacks.\n+//!\n+//! A std::unordered_map is used to track what callbacks are currently\n+//! registered, and a std::list is to used to store the callbacks that are\n+//! currently registered as well as any callbacks that are just unregistered\n+//! and about to be deleted when they are done executing.\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n+    Mutex m_mutex;",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r404046688",
      "id" : 404046688,
      "in_reply_to_id" : 403783002,
      "line" : 28,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA0NjY4OA==",
      "original_commit_id" : "96176004a39c63fdd4ada1f07e55bc62ca0c447b",
      "original_line" : 28,
      "original_position" : 34,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 35,
      "pull_request_review_id" : 388193470,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:53:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/404046688",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r404046788"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/404046788"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403938401\r\n\r\n> Personally I think these shouldn't be idempotent because makes sense to call just once. For instance `std::fstream::open` is not idempotent, fails if file is already opened. I'd rather fix unit tests. Just an opinion and should not prevent this change going forward.\r\n\r\nFeel free to open a followup. If I wanted to change calling code not to use the same pointer more than once, I would change these to return bool and have calling code assert that they return true, rather having these crash on cases they can reasonably handle and making assumptions about calling code. I do find API's like std::map's insert/erase that are idempotent convenient for avoiding boilerplate code, so that's another reason I like the keeping the boost behavior beyond not wanting to increase scope of this PR and not liking asserts across an api boundary",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-06T12:20:03Z",
      "diff_hunk" : "@@ -16,36 +16,59 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n+    Mutex m_mutex;\n+    struct Entry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<Entry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<Entry>::iterator> m_map GUARDED_BY(m_mutex);\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Add(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r404046788",
      "id" : 404046788,
      "in_reply_to_id" : 403493465,
      "line" : 48,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA0Njc4OA==",
      "original_commit_id" : "01639a21d12df54895d0214542b84335d7f58a94",
      "original_line" : 48,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : 56,
      "pull_request_review_id" : 388193470,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:53:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/404046788",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r404046859"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/404046859"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/18524#discussion_r403782623\r\n\r\n> I think these lines can be combined into `inserted.first->second = m_list.emplace(m_list.end());`.\r\n\r\nThanks, switched to this",
      "commit_id" : "d6815a2313158862d448733954a73520f223deb6",
      "created_at" : "2020-04-06T12:20:11Z",
      "diff_hunk" : "@@ -16,36 +16,75 @@\n #include <unordered_map>\n #include <utility>\n \n-#include <boost/signals2/signal.hpp>\n-\n-struct ValidationInterfaceConnections {\n-    boost::signals2::scoped_connection UpdatedBlockTip;\n-    boost::signals2::scoped_connection TransactionAddedToMempool;\n-    boost::signals2::scoped_connection BlockConnected;\n-    boost::signals2::scoped_connection BlockDisconnected;\n-    boost::signals2::scoped_connection TransactionRemovedFromMempool;\n-    boost::signals2::scoped_connection ChainStateFlushed;\n-    boost::signals2::scoped_connection BlockChecked;\n-    boost::signals2::scoped_connection NewPoWValidBlock;\n-};\n-\n+//! The MainSignalsInstance manages a list of shared_ptr<CValidationInterface>\n+//! callbacks.\n+//!\n+//! A std::unordered_map is used to track what callbacks are currently\n+//! registered, and a std::list is to used to store the callbacks that are\n+//! currently registered as well as any callbacks that are just unregistered\n+//! and about to be deleted when they are done executing.\n struct MainSignalsInstance {\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex)> BlockConnected;\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock>&, const CBlockIndex* pindex)> BlockDisconnected;\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionRemovedFromMempool;\n-    boost::signals2::signal<void (const CBlockLocator &)> ChainStateFlushed;\n-    boost::signals2::signal<void (const CBlock&, const BlockValidationState&)> BlockChecked;\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n-\n+    Mutex m_mutex;\n+    //! List entries consist of a callback pointer and reference count. The\n+    //! count is equal to the number of current executions of that entry, plus 1\n+    //! if it's registered. It cannot be 0 because that would imply it is\n+    //! unregistered and also not being executed (so shouldn't exist).\n+    struct ListEntry { std::shared_ptr<CValidationInterface> callbacks; int count = 1; };\n+    std::list<ListEntry> m_list GUARDED_BY(m_mutex);\n+    std::unordered_map<CValidationInterface*, std::list<ListEntry>::iterator> m_map GUARDED_BY(m_mutex);\n     // We are not allowed to assume the scheduler only runs in one thread,\n     // but must ensure all callbacks happen in-order, so we end up creating\n     // our own queue here :(\n     SingleThreadedSchedulerClient m_schedulerClient;\n-    std::unordered_map<CValidationInterface*, ValidationInterfaceConnections> m_connMainSignals;\n \n     explicit MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+\n+    void Register(std::shared_ptr<CValidationInterface> callbacks)\n+    {\n+        LOCK(m_mutex);\n+        auto inserted = m_map.emplace(callbacks.get(), m_list.end());\n+        if (inserted.second) {\n+            m_list.emplace_back();\n+            inserted.first->second = std::prev(m_list.end());",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/18524#discussion_r404046859",
      "id" : 404046859,
      "in_reply_to_id" : 403782623,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDA0Njg1OQ==",
      "original_commit_id" : "96176004a39c63fdd4ada1f07e55bc62ca0c447b",
      "original_line" : 48,
      "original_position" : 56,
      "original_start_line" : null,
      "path" : "src/validationinterface.cpp",
      "position" : null,
      "pull_request_review_id" : 388193470,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/18524",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-04-06T12:53:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/404046859",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   }
]
