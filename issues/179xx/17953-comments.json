[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17953#discussion_r368068122"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/368068122"
         }
      },
      "author_association" : "MEMBER",
      "body" : "for reviewers, what's the `sizeof(T)` trick here?",
      "commit_id" : "439583315ce0b9327c3a70eed96f1cc563d568b7",
      "created_at" : "2020-01-17T18:11:42Z",
      "diff_hunk" : "@@ -0,0 +1,159 @@\n+// Copyright (c) 2017-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_VARIANT_H\n+#define BITCOIN_VARIANT_H\n+\n+#include <utility>\n+\n+#include <boost/variant/get.hpp>\n+#include <boost/variant/variant.hpp>\n+\n+//! Substitute for C++17 std::variant\n+template <class... Types>\n+class Variant\n+{\n+private:\n+    boost::variant<Types...> m_var;\n+\n+public:\n+    Variant()\n+    {\n+        m_var = {};\n+    }\n+    Variant(const Variant& other)\n+    {\n+        m_var = other.m_var;\n+    }\n+    Variant(Variant& other)\n+    {\n+        m_var = other.m_var;\n+    }\n+    Variant(Variant&& other)\n+    {\n+        m_var = std::move(other.m_var);\n+    }\n+    template <class T>\n+    Variant(T& value)\n+    {\n+        m_var = value;\n+    }\n+    template <class T>\n+    Variant(const T& value)\n+    {\n+        m_var = value;\n+    }\n+    template <class T>\n+    Variant(T&& value)\n+    {\n+        m_var = std::move(value);\n+    }\n+\n+    int which() const\n+    {\n+        return m_var.which();\n+    }\n+\n+    template <class T>\n+    T* get_if()\n+    {\n+        return boost::get<T>(&m_var);\n+    }\n+    template <class T>\n+    const T* get_if() const\n+    {\n+        return boost::get<T>(&m_var);\n+    }\n+    template <class T>\n+    T& get()\n+    {\n+        return boost::get<T>(m_var);\n+    }\n+    template <class T>\n+    const T& get() const\n+    {\n+        return boost::get<T>(m_var);\n+    }\n+\n+    Variant& operator=(const Variant& other)\n+    {\n+        m_var = other.m_var;\n+        return *this;\n+    }\n+    Variant& operator=(Variant&& other)\n+    {\n+        m_var = std::move(other.m_var);\n+        return *this;\n+    }\n+\n+    // Allow support for boost::Variant\n+    template <class Visitor>\n+    typename Visitor::result_type apply_visitor(Visitor& visitor) const\n+    {\n+        return boost::apply_visitor(visitor, m_var);\n+    }\n+    template <class Visitor>\n+    typename Visitor::result_type apply_visitor(const Visitor& visitor) const\n+    {\n+        return boost::apply_visitor(visitor, m_var);\n+    }\n+\n+    bool operator==(const Variant& other) const\n+    {\n+        return m_var == other.m_var;\n+    }\n+    bool operator!=(const Variant& other) const\n+    {\n+        return m_var != other.m_var;\n+    }\n+    bool operator<(const Variant& other) const\n+    {\n+        return m_var < other.m_var;\n+    }\n+    bool operator>(const Variant& other) const\n+    {\n+        return m_var > other.m_var;\n+    }\n+    bool operator<=(const Variant& other) const\n+    {\n+        return m_var <= other.m_var;\n+    }\n+    bool operator>=(const Variant& other) const\n+    {\n+        return m_var >= other.m_var;\n+    }\n+    // This are here to prevent implicit conversion to Variant and throw a compile time error.\n+    template <typename T>\n+    void operator==(const T&) const\n+    {\n+        static_assert(false && sizeof(T), \"Compared a Variant directly with type T. this prevented an implicit conversion\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17953#discussion_r368068122",
      "id" : 368068122,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA2ODEyMg==",
      "original_commit_id" : "278dc53fa8a657e05b86ef2025f604891ca33571",
      "original_position" : 130,
      "path" : "src/variant.h",
      "position" : 130,
      "pull_request_review_id" : 344752818,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17953",
      "updated_at" : "2020-01-17T18:11:42Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/368068122",
      "user" : {
         "avatar_url" : "https://avatars0.githubusercontent.com/u/5767891?v=4",
         "events_url" : "https://api.github.com/users/instagibbs/events{/privacy}",
         "followers_url" : "https://api.github.com/users/instagibbs/followers",
         "following_url" : "https://api.github.com/users/instagibbs/following{/other_user}",
         "gists_url" : "https://api.github.com/users/instagibbs/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/instagibbs",
         "id" : 5767891,
         "login" : "instagibbs",
         "node_id" : "MDQ6VXNlcjU3Njc4OTE=",
         "organizations_url" : "https://api.github.com/users/instagibbs/orgs",
         "received_events_url" : "https://api.github.com/users/instagibbs/received_events",
         "repos_url" : "https://api.github.com/users/instagibbs/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/instagibbs/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/instagibbs/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/instagibbs"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/17953#discussion_r368070494"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17953"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/368070494"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "right forgot to mention that.\r\nif I just do `static_assert(false, msg)` it won't compile no matter what.\r\nnow because the `sizeof(T)` is here then it can't evaluate the expression without monomorphising the function so it can know what `T` is. so as long as this function is never called the compiler won't fail compilation because it will never be able to evaluate it.\r\n\r\nie without: https://godbolt.org/z/ZGAFQB (fail compilation even though it isn't being called)\r\nwith: https://godbolt.org/z/JCDeeM (doesn't fail because can't evaluate)\r\nwith and used: https://godbolt.org/z/KCfNSV (fail compilation) \r\n\r\nFYI I stole that trick from: https://www.boost.org/doc/libs/1_71_0/boost/variant/variant.hpp (see `BOOST_STATIC_ASSERT`)",
      "commit_id" : "439583315ce0b9327c3a70eed96f1cc563d568b7",
      "created_at" : "2020-01-17T18:17:33Z",
      "diff_hunk" : "@@ -0,0 +1,159 @@\n+// Copyright (c) 2017-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_VARIANT_H\n+#define BITCOIN_VARIANT_H\n+\n+#include <utility>\n+\n+#include <boost/variant/get.hpp>\n+#include <boost/variant/variant.hpp>\n+\n+//! Substitute for C++17 std::variant\n+template <class... Types>\n+class Variant\n+{\n+private:\n+    boost::variant<Types...> m_var;\n+\n+public:\n+    Variant()\n+    {\n+        m_var = {};\n+    }\n+    Variant(const Variant& other)\n+    {\n+        m_var = other.m_var;\n+    }\n+    Variant(Variant& other)\n+    {\n+        m_var = other.m_var;\n+    }\n+    Variant(Variant&& other)\n+    {\n+        m_var = std::move(other.m_var);\n+    }\n+    template <class T>\n+    Variant(T& value)\n+    {\n+        m_var = value;\n+    }\n+    template <class T>\n+    Variant(const T& value)\n+    {\n+        m_var = value;\n+    }\n+    template <class T>\n+    Variant(T&& value)\n+    {\n+        m_var = std::move(value);\n+    }\n+\n+    int which() const\n+    {\n+        return m_var.which();\n+    }\n+\n+    template <class T>\n+    T* get_if()\n+    {\n+        return boost::get<T>(&m_var);\n+    }\n+    template <class T>\n+    const T* get_if() const\n+    {\n+        return boost::get<T>(&m_var);\n+    }\n+    template <class T>\n+    T& get()\n+    {\n+        return boost::get<T>(m_var);\n+    }\n+    template <class T>\n+    const T& get() const\n+    {\n+        return boost::get<T>(m_var);\n+    }\n+\n+    Variant& operator=(const Variant& other)\n+    {\n+        m_var = other.m_var;\n+        return *this;\n+    }\n+    Variant& operator=(Variant&& other)\n+    {\n+        m_var = std::move(other.m_var);\n+        return *this;\n+    }\n+\n+    // Allow support for boost::Variant\n+    template <class Visitor>\n+    typename Visitor::result_type apply_visitor(Visitor& visitor) const\n+    {\n+        return boost::apply_visitor(visitor, m_var);\n+    }\n+    template <class Visitor>\n+    typename Visitor::result_type apply_visitor(const Visitor& visitor) const\n+    {\n+        return boost::apply_visitor(visitor, m_var);\n+    }\n+\n+    bool operator==(const Variant& other) const\n+    {\n+        return m_var == other.m_var;\n+    }\n+    bool operator!=(const Variant& other) const\n+    {\n+        return m_var != other.m_var;\n+    }\n+    bool operator<(const Variant& other) const\n+    {\n+        return m_var < other.m_var;\n+    }\n+    bool operator>(const Variant& other) const\n+    {\n+        return m_var > other.m_var;\n+    }\n+    bool operator<=(const Variant& other) const\n+    {\n+        return m_var <= other.m_var;\n+    }\n+    bool operator>=(const Variant& other) const\n+    {\n+        return m_var >= other.m_var;\n+    }\n+    // This are here to prevent implicit conversion to Variant and throw a compile time error.\n+    template <typename T>\n+    void operator==(const T&) const\n+    {\n+        static_assert(false && sizeof(T), \"Compared a Variant directly with type T. this prevented an implicit conversion\");",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/17953#discussion_r368070494",
      "id" : 368070494,
      "in_reply_to_id" : 368068122,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODA3MDQ5NA==",
      "original_commit_id" : "278dc53fa8a657e05b86ef2025f604891ca33571",
      "original_position" : 130,
      "path" : "src/variant.h",
      "position" : 130,
      "pull_request_review_id" : 344755861,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/17953",
      "updated_at" : "2020-01-17T18:18:01Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/368070494",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/2167860?v=4",
         "events_url" : "https://api.github.com/users/elichai/events{/privacy}",
         "followers_url" : "https://api.github.com/users/elichai/followers",
         "following_url" : "https://api.github.com/users/elichai/following{/other_user}",
         "gists_url" : "https://api.github.com/users/elichai/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/elichai",
         "id" : 2167860,
         "login" : "elichai",
         "node_id" : "MDQ6VXNlcjIxNjc4NjA=",
         "organizations_url" : "https://api.github.com/users/elichai/orgs",
         "received_events_url" : "https://api.github.com/users/elichai/received_events",
         "repos_url" : "https://api.github.com/users/elichai/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/elichai/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/elichai/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/elichai"
      }
   }
]
