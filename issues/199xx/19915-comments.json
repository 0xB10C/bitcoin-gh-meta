[
   {
      "author_association" : "CONTRIBUTOR",
      "body" : "## Review methodology\r\n`std::mutex` locks across a thread and _within_ a thread. i.e. if a `mutex` is locked in a call stack on a given thread, it can no longer be acquired on _any_ thread.\r\n\r\n`std::recursive_mutex` locks across a thread but not _within_ a thread. i.e. if a `recursive_mutex` is locked in a call stack on a given thread, it can still be re-acquired on the _same_ thread further in the call stack. `recursive_mutex` behaves similar to `mutex` across threads.\r\n\r\nSo when we change a `recursive_mutex` to a `mutex`, this reviewer sees the risk of a deadlock _within_ a given call stack as `mutex` is more restrictive. Reviewing each lock acquisition site and tracing backward to build a call graph, if we determine that the call graph is acyclic, and no other lock site is in the path, the conversion should be safe.\r\n\r\n@hebasto:\r\n- Would you agree with the review method? Am I missing something?\r\n- I started doing this manually with the results below for `cs_vSend`, but found way too many call sites for `CConnman::PushMessage()` to proceed manually. Do you think it'd be useful if I tried to spend some time building automation for such analysis (not sure how)? Could be re-usable across #19303 ?\r\n\r\n\r\n## Results from call tracing\r\n`cs_vSend` call site tracing:\r\n```\r\nsrc/net.cpp: CNode::copyStats()\r\n|-- src/net.cpp: CConnman:GetNodeStats()\r\n\t|-- src/interfaces/node.cpp: NodeImpl::getNodeStats()\r\n\t\t|-- src/qt/peertablemodel.cpp: PeerTablePriv::refreshPeers()\r\n\t\t\t|-- src/qt/peertablemodel.cpp: PeerTableModel::refresh()\r\n\t\t\t\t|-- src/qt/peertablemodel.cpp: PeerTableModel::PeerTableModel()\r\n\t\t\t\t\t|-- src/qt/clientmodel.cpp: ClientModel::ClientModel()\r\n\t\t\t\t\t\t|-- src/qt/bitcoin.cpp: BitcoinApplication::initializeResult()\r\n\t\t\t\t\t\t\t|-- src/qt/bitcoin.cpp: BitcoinApplication::startThread()\r\n\t\t\t\t\t\t\t\t|-- src/qt/bitcoin.cpp: BitcoinApplication::requestInitialize()\r\n\t\t\t\t\t\t\t\t\t|-- src/qt/bitcoin.cpp: GuiMain()\r\n\t\t\t\t\t\t\t\t\t\t|-- src/qt/main.cpp: main()\r\n\t\t\t\t\t\t\t\t|-- src/qt/bitcoin.cpp: BitcoinApplication::requestShutdown()()\r\n\t\t\t\t\t\t\t\t\t|-- src/qt/bitcoin.cpp: GuiMain()\r\n\t\t\t\t\t\t\t\t\t\t|-- src/qt/main.cpp: main()\r\n\t\t\t\t\t\t\t\r\n\t|-- src/rpc/net.cpp: getpeerinfo()\r\n\t\r\nsrc/net.cpp: CConnman::DisconnectNodes()\r\n\t|-- src/net.cpp: CConnman::ThreadSocketHandler()\r\n\t\t|-- src/net.cpp: CConnman::Start(): Spins up a `b-net` thread for `ThreadSocketHandler`\r\n\r\nsrc/net.cpp: CConnman::GenerateSelectSet()\r\n\t|-- src/net.cpp: CConnman::SocketEvents()\r\n\t\t|-- src/net.cpp: CConnman::SocketHandler() [IS LOCK SITE: lock is acquired after call to SocketEvents is complete]\r\n\t\t\t|-- src/net.cpp: CConnman::ThreadSocketHandler()\r\n\t\t\t\t|-- src/net.cpp: CConnman::Start(): Spins up a `b-net` thread for `ThreadSocketHandler`\r\n\r\nsrc/net.cpp: CConnman::SocketHandler()\r\n\t|-- src/net.cpp: CConnman::ThreadSocketHandler()\r\n\t\t|-- src/net.cpp: CConnman::Start(): Spins up a `b-net` thread for `ThreadSocketHandler`\r\n\r\nsrc/net.cpp: CConnman::PushMessage()\r\n|-- **55 different call sites in net_processing.cpp**\r\n```",
      "created_at" : "2020-09-16T06:16:17Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19915#issuecomment-693197596",
      "id" : 693197596,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19915",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5MzE5NzU5Ng==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-16T07:48:59Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/693197596",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/856960?v=4",
         "events_url" : "https://api.github.com/users/dhruv/events{/privacy}",
         "followers_url" : "https://api.github.com/users/dhruv/followers",
         "following_url" : "https://api.github.com/users/dhruv/following{/other_user}",
         "gists_url" : "https://api.github.com/users/dhruv/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/dhruv",
         "id" : 856960,
         "login" : "dhruv",
         "node_id" : "MDQ6VXNlcjg1Njk2MA==",
         "organizations_url" : "https://api.github.com/users/dhruv/orgs",
         "received_events_url" : "https://api.github.com/users/dhruv/received_events",
         "repos_url" : "https://api.github.com/users/dhruv/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/dhruv/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/dhruv"
      }
   },
   {
      "author_association" : "MEMBER",
      "body" : "@dhruv \r\n> `std::mutex` locks...\r\n> `std::recursive_mutex` locks...\r\n\r\nTBH, I don't think that \"customizing\" technical terms could be helpful. A mutex does not lock anything, but it could be locked by a thread.\r\n\r\n> So when we change a `recursive_mutex` to a `mutex`, this reviewer sees the risk of a deadlock _within_ a given call stack as `mutex` is more restrictive.\r\n\r\nI think that the transition from a `recursive_mutex` to a `mutex` cannot introduce new deadlocks as it does not change locking order. The real risk is the [undefined behavior](https://en.cppreference.com/w/cpp/thread/mutex/lock): \"If lock is called by a thread that already owns the mutex, the behavior is undefined: for example, the program _may_ deadlock\".\r\n\r\n> Reviewing each lock acquisition site and tracing backward to build a call graph, if we determine that the call graph is acyclic, and no other lock site is in the path, the conversion should be safe.\r\n\r\nTo be correct we need a call graph while a particular mutex is held. A cycle in the call graph means UB.\r\n\r\nLet's consider `cs_vSend`, for example:\r\n- `CNode::copyStats()`\r\n  - `LOCK(cs_vSend);` -- no other calls in the scope. It is safe\r\n- `CConnman::SocketSendData()`\r\n  - `GetSystemTimeInSeconds()` does not try to lock `cs_vSend`\r\n  - `CNode::CloseSocketDisconnect()` does not try to lock `cs_vSend`\r\n\r\n... and so on.\r\n",
      "created_at" : "2020-09-19T10:56:28Z",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19915#issuecomment-695198819",
      "id" : 695198819,
      "issue_url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/19915",
      "node_id" : "MDEyOklzc3VlQ29tbWVudDY5NTE5ODgxOQ==",
      "performed_via_github_app" : null,
      "updated_at" : "2020-09-19T10:56:28Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/issues/comments/695198819",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/32963518?v=4",
         "events_url" : "https://api.github.com/users/hebasto/events{/privacy}",
         "followers_url" : "https://api.github.com/users/hebasto/followers",
         "following_url" : "https://api.github.com/users/hebasto/following{/other_user}",
         "gists_url" : "https://api.github.com/users/hebasto/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/hebasto",
         "id" : 32963518,
         "login" : "hebasto",
         "node_id" : "MDQ6VXNlcjMyOTYzNTE4",
         "organizations_url" : "https://api.github.com/users/hebasto/orgs",
         "received_events_url" : "https://api.github.com/users/hebasto/received_events",
         "repos_url" : "https://api.github.com/users/hebasto/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/hebasto/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/hebasto/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/hebasto"
      }
   }
]
