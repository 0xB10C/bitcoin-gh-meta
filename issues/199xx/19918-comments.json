[
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r485066540"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/485066540"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "developer-notes currently recommends \"Combine annotations in function declarations with run-time asserts in function definitions\", think these recommendations are better off there, and certainly having conflicting recommendations is worse.\r\n\r\nI think the only case where it's useful for virtual methods is if the parent class doesn't need the lock, but the child class does -- in that case invoking `Parent* p = new Child(); p->func();` won't trigger compile-time warnings but you could at least catch it with a runtime check. But I think that pattern probably should be considered a mistake anyway.\r\n\r\nAs far as I know callbacks will need the `WeaklyAssertLockHeld` variant?",
      "commit_id" : "5c9eb2515a9e1d9ac58b29e5d8adb19748b39b17",
      "created_at" : "2020-09-08T16:58:10Z",
      "diff_hunk" : "@@ -70,13 +70,34 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n-#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n+\n+/**\n+ * Assert at compile time and run time that a mutex is locked. Has no effect\n+ * when EXCLUSIVE_LOCKS_REQUIRED annotations are enforced because the runtime\n+ * assertions will never trigger (analogous to asserting an unsigned int is\n+ * greator or equal to 0).\n+ *\n+ * Use of this macro is neither encouraged nor discouraged in new code. It was\n+ * historically used before compile time checks were available, but it may\n+ * still be be useful for virtual methods or std::function callbacks where\n+ * EXCLUSIVE_LOCKS_REQUIRED annotations are not enforced.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r485066540",
      "id" : 485066540,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA2NjU0MA==",
      "original_commit_id" : "070803dc7e741c9d43b076b06d9540c6911ee427",
      "original_line" : 89,
      "original_position" : 31,
      "original_start_line" : null,
      "path" : "src/sync.h",
      "position" : null,
      "pull_request_review_id" : 484329563,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T21:36:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/485066540",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r485102739"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/485102739"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe `LOCK_ALREADY_HELD(mutex)` would be better, comparable with `LOCK(mutex)`? This isn't a particularly weak assertion in anyway I can see, it's just one the compiler isn't able to verify at compile time.\r\n\r\n\"Assert that a mutex was already locked in any possible way this code could be reached. If DEBUG_LOCKORDER is defined, a runtime check that the mutex was actually locked by this thread will be made.\" ? Without DEBUG_LOCKORDER this does nothing at runtime.\r\n\r\nNote that ASSERT_EXCLUSIVE_LOCK has slightly weird scoping behaviour; if `x` requires mutex `m` then:\r\n\r\n```c++\r\n    if (1) { WeaklyAssertLockHeld(m); }\r\n    ++x;\r\n```\r\n\r\nworks fine, while\r\n\r\n```c++\r\n    extern int n;\r\n    if (n > 1) { WeaklyAssertLockHeld(m); }\r\n    ++x;\r\n```\r\ntells you you need to hold the mutex to do `++x`. I couldn't come up with a case where this results in missing a warning though; but I'm not super-confident in it, as compared to being tightly bounded by scopes the way `SCOPED_LOCKABLE` is.",
      "commit_id" : "5c9eb2515a9e1d9ac58b29e5d8adb19748b39b17",
      "created_at" : "2020-09-08T18:04:08Z",
      "diff_hunk" : "@@ -70,13 +70,34 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n-#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n+\n+/**\n+ * Assert at compile time and run time that a mutex is locked. Has no effect\n+ * when EXCLUSIVE_LOCKS_REQUIRED annotations are enforced because the runtime\n+ * assertions will never trigger (analogous to asserting an unsigned int is\n+ * greator or equal to 0).\n+ *\n+ * Use of this macro is neither encouraged nor discouraged in new code. It was\n+ * historically used before compile time checks were available, but it may\n+ * still be be useful for virtual methods or std::function callbacks where\n+ * EXCLUSIVE_LOCKS_REQUIRED annotations are not enforced.\n+ */\n+#define AssertLockHeld(mutex) [&]() EXCLUSIVE_LOCKS_REQUIRED(mutex) { AssertLockHeldInternal(#mutex, __FILE__, __LINE__, &mutex); }()\n+\n+/**\n+ * Assert at runtime that a mutex is locked. May be necessary to work around\n+ * EXCLUSIVE_LOCKS_REQUIRED errors when the compiler can't determine that a\n+ * mutex is locked.\n+ */\n+#define WeaklyAssertLockHeld(mutex) [&]() ASSERT_EXCLUSIVE_LOCK(mutex) { AssertLockHeldInternal(#mutex, __FILE__, __LINE__, &mutex); }()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r485102739",
      "id" : 485102739,
      "line" : 101,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTEwMjczOQ==",
      "original_commit_id" : "070803dc7e741c9d43b076b06d9540c6911ee427",
      "original_line" : 101,
      "original_position" : 40,
      "original_start_line" : null,
      "path" : "src/sync.h",
      "position" : 43,
      "pull_request_review_id" : 484329563,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T21:36:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/485102739",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r487716721"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/487716721"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "The compile time check is not an assertion (like `static_assert`), but is a warning. The code will get compiled with it if `--enable-werror` is not used during `./configure`. Maybe reword to:\r\n\r\n> Produce a compilation warning and assert at run time (only if `DEBUG_LOCKORDER` is defined) that a mutex is locked.",
      "commit_id" : "5c9eb2515a9e1d9ac58b29e5d8adb19748b39b17",
      "created_at" : "2020-09-14T07:50:02Z",
      "diff_hunk" : "@@ -70,13 +70,34 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n-#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n+\n+/**\n+ * Assert at compile time and run time that a mutex is locked. Has no effect\n+ * when EXCLUSIVE_LOCKS_REQUIRED annotations are enforced because the runtime\n+ * assertions will never trigger (analogous to asserting an unsigned int is\n+ * greator or equal to 0).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r487716721",
      "id" : 487716721,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcxNjcyMQ==",
      "original_commit_id" : "070803dc7e741c9d43b076b06d9540c6911ee427",
      "original_line" : 84,
      "original_position" : 26,
      "original_start_line" : 81,
      "path" : "src/sync.h",
      "position" : null,
      "pull_request_review_id" : 487500551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-09-14T21:36:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/487716721",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r487719492"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/487719492"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Maybe just drop the above paragraph as it contradicts with the developer nodes? IMO the latter is correct.",
      "commit_id" : "5c9eb2515a9e1d9ac58b29e5d8adb19748b39b17",
      "created_at" : "2020-09-14T07:54:53Z",
      "diff_hunk" : "@@ -70,13 +70,34 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n-#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n+\n+/**\n+ * Assert at compile time and run time that a mutex is locked. Has no effect\n+ * when EXCLUSIVE_LOCKS_REQUIRED annotations are enforced because the runtime\n+ * assertions will never trigger (analogous to asserting an unsigned int is\n+ * greator or equal to 0).\n+ *\n+ * Use of this macro is neither encouraged nor discouraged in new code. It was\n+ * historically used before compile time checks were available, but it may\n+ * still be be useful for virtual methods or std::function callbacks where\n+ * EXCLUSIVE_LOCKS_REQUIRED annotations are not enforced.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r487719492",
      "id" : 487719492,
      "in_reply_to_id" : 485066540,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcxOTQ5Mg==",
      "original_commit_id" : "070803dc7e741c9d43b076b06d9540c6911ee427",
      "original_line" : 89,
      "original_position" : 31,
      "original_start_line" : null,
      "path" : "src/sync.h",
      "position" : null,
      "pull_request_review_id" : 487500551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T21:36:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/487719492",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r487723681"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/487723681"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "In non-debug build a code like:\r\n\r\n```cpp\r\nWeaklyAssertLockHeld(mutex_required_for_x);\r\nx = 1;\r\n```\r\n\r\nwhere the mutex is not held will **not** produce a compilation warning and will **not** assert at runtime. So the unprotected access will actually happen. This is because `ASSERT_EXCLUSIVE_LOCK` tells the compiler we are going to check, but we actually don't check (in non-debug build). Maybe remove `ASSERT_EXCLUSIVE_LOCK` in non-debug builds, or at least clearly explain in the comment the dangers of using this.",
      "commit_id" : "5c9eb2515a9e1d9ac58b29e5d8adb19748b39b17",
      "created_at" : "2020-09-14T08:02:18Z",
      "diff_hunk" : "@@ -70,13 +70,34 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n-#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n+\n+/**\n+ * Assert at compile time and run time that a mutex is locked. Has no effect\n+ * when EXCLUSIVE_LOCKS_REQUIRED annotations are enforced because the runtime\n+ * assertions will never trigger (analogous to asserting an unsigned int is\n+ * greator or equal to 0).\n+ *\n+ * Use of this macro is neither encouraged nor discouraged in new code. It was\n+ * historically used before compile time checks were available, but it may\n+ * still be be useful for virtual methods or std::function callbacks where\n+ * EXCLUSIVE_LOCKS_REQUIRED annotations are not enforced.\n+ */\n+#define AssertLockHeld(mutex) [&]() EXCLUSIVE_LOCKS_REQUIRED(mutex) { AssertLockHeldInternal(#mutex, __FILE__, __LINE__, &mutex); }()\n+\n+/**\n+ * Assert at runtime that a mutex is locked. May be necessary to work around\n+ * EXCLUSIVE_LOCKS_REQUIRED errors when the compiler can't determine that a\n+ * mutex is locked.\n+ */\n+#define WeaklyAssertLockHeld(mutex) [&]() ASSERT_EXCLUSIVE_LOCK(mutex) { AssertLockHeldInternal(#mutex, __FILE__, __LINE__, &mutex); }()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r487723681",
      "id" : 487723681,
      "in_reply_to_id" : 485102739,
      "line" : 101,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyMzY4MQ==",
      "original_commit_id" : "070803dc7e741c9d43b076b06d9540c6911ee427",
      "original_line" : 101,
      "original_position" : 40,
      "original_start_line" : null,
      "path" : "src/sync.h",
      "position" : 43,
      "pull_request_review_id" : 487500551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T21:36:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/487723681",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r487727569"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/487727569"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "As above, maybe replace \"assert at compile time\" with \"warn at compile time\"?",
      "commit_id" : "5c9eb2515a9e1d9ac58b29e5d8adb19748b39b17",
      "created_at" : "2020-09-14T08:09:39Z",
      "diff_hunk" : "@@ -70,13 +70,34 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n-#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n+\n+/**\n+ * Assert at compile time and run time that a mutex is locked. Has no effect\n+ * when EXCLUSIVE_LOCKS_REQUIRED annotations are enforced because the runtime\n+ * assertions will never trigger (analogous to asserting an unsigned int is\n+ * greator or equal to 0).\n+ *\n+ * Use of this macro is neither encouraged nor discouraged in new code. It was\n+ * historically used before compile time checks were available, but it may\n+ * still be be useful for virtual methods or std::function callbacks where\n+ * EXCLUSIVE_LOCKS_REQUIRED annotations are not enforced.\n+ */\n+#define AssertLockHeld(mutex) [&]() EXCLUSIVE_LOCKS_REQUIRED(mutex) { AssertLockHeldInternal(#mutex, __FILE__, __LINE__, &mutex); }()\n+\n+/**\n+ * Assert at runtime that a mutex is locked. May be necessary to work around\n+ * EXCLUSIVE_LOCKS_REQUIRED errors when the compiler can't determine that a\n+ * mutex is locked.\n+ */\n+#define WeaklyAssertLockHeld(mutex) [&]() ASSERT_EXCLUSIVE_LOCK(mutex) { AssertLockHeldInternal(#mutex, __FILE__, __LINE__, &mutex); }()\n+\n+/** Assert at compile time and run time that a mutex is not locked. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r487727569",
      "id" : 487727569,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyNzU2OQ==",
      "original_commit_id" : "070803dc7e741c9d43b076b06d9540c6911ee427",
      "original_line" : 100,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/sync.h",
      "position" : null,
      "pull_request_review_id" : 487500551,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T21:36:26Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/487727569",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/266751?v=4",
         "events_url" : "https://api.github.com/users/vasild/events{/privacy}",
         "followers_url" : "https://api.github.com/users/vasild/followers",
         "following_url" : "https://api.github.com/users/vasild/following{/other_user}",
         "gists_url" : "https://api.github.com/users/vasild/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/vasild",
         "id" : 266751,
         "login" : "vasild",
         "node_id" : "MDQ6VXNlcjI2Njc1MQ==",
         "organizations_url" : "https://api.github.com/users/vasild/orgs",
         "received_events_url" : "https://api.github.com/users/vasild/received_events",
         "repos_url" : "https://api.github.com/users/vasild/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/vasild/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/vasild/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/vasild"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r488198264"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/488198264"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/19918#discussion_r487716721\r\n\r\n> The compile time check is not an assertion (like `static_assert`), but is a warning.\r\n\r\nThanks, on CI these trigger fatal build errors and that seems like the most important thing, but I added a note about varying build behavior.",
      "commit_id" : "5c9eb2515a9e1d9ac58b29e5d8adb19748b39b17",
      "created_at" : "2020-09-14T20:23:26Z",
      "diff_hunk" : "@@ -70,13 +70,34 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n-#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n+\n+/**\n+ * Assert at compile time and run time that a mutex is locked. Has no effect\n+ * when EXCLUSIVE_LOCKS_REQUIRED annotations are enforced because the runtime\n+ * assertions will never trigger (analogous to asserting an unsigned int is\n+ * greator or equal to 0).",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r488198264",
      "id" : 488198264,
      "in_reply_to_id" : 487716721,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE5ODI2NA==",
      "original_commit_id" : "070803dc7e741c9d43b076b06d9540c6911ee427",
      "original_line" : 84,
      "original_position" : 26,
      "original_start_line" : 81,
      "path" : "src/sync.h",
      "position" : null,
      "pull_request_review_id" : 488113228,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : "RIGHT",
      "updated_at" : "2020-09-14T21:53:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/488198264",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r488198378"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/488198378"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/19918#discussion_r485066540\r\n\r\n> developer-notes currently recommends \"Combine annotations in function declarations with run-time asserts in function definitions\", think these recommendations are better off there, and certainly having conflicting recommendations is worse.\r\n\r\nI don't love that recommendation, and the text doesn't give a rationale for following it, but  I dropped this paragraph. I wasn't aware of other guidance and didn't mean to conflict.\r\n\r\n> I think the only case where it's useful for virtual methods is if the parent class doesn't need the lock, but the child class does -- in that case invoking `Parent* p = new Child(); p->func();` won't trigger compile-time warnings but you could at least catch it with a runtime check. But I think that pattern probably should be considered a mistake anyway.\r\n> \r\n> As far as I know callbacks will need the `WeaklyAssertLockHeld` variant?\r\n\r\nre: \"pattern probably should be considered a mistake.\" IMO, the idea of having a compile time annotation whose only purpose at compile time is checking for the presence of a different compile-time annotation is a mistake. But given that, it makes sense to use `AssertLockHeld` instead of `WeaklyAssertLockHeld` to provide runtime checking inside a lambda annotated with `EXCLUSIVE_LOCKS_REQUIRED` called through a `std::function`, or inside an overridden virtual method annotated `EXCLUSIVE_LOCKS_REQUIRED` called through a base method which is not annotated.\r\n\r\nDeleted the comment, though, because I'm becoming convinced these asserts are hopeless to explain in detail. As long we're are going to reject #19865 and have these ubiquitous asserts, the most useful practical advice will probably be to prefer using `AssertLockHeld` wherever possible and just fall back to `WeaklyAssertLockHeld` when the compiler gives an error you don't understand.\r\n\r\nre: https://github.com/bitcoin/bitcoin/pull/19918#discussion_r487719492\r\n\r\n> Maybe just drop the above paragraph as it contradicts with the developer nodes? IMO the latter is correct.\r\n\r\nThanks, dropped.",
      "commit_id" : "5c9eb2515a9e1d9ac58b29e5d8adb19748b39b17",
      "created_at" : "2020-09-14T20:23:43Z",
      "diff_hunk" : "@@ -70,13 +70,34 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n-#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n+\n+/**\n+ * Assert at compile time and run time that a mutex is locked. Has no effect\n+ * when EXCLUSIVE_LOCKS_REQUIRED annotations are enforced because the runtime\n+ * assertions will never trigger (analogous to asserting an unsigned int is\n+ * greator or equal to 0).\n+ *\n+ * Use of this macro is neither encouraged nor discouraged in new code. It was\n+ * historically used before compile time checks were available, but it may\n+ * still be be useful for virtual methods or std::function callbacks where\n+ * EXCLUSIVE_LOCKS_REQUIRED annotations are not enforced.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r488198378",
      "id" : 488198378,
      "in_reply_to_id" : 485066540,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE5ODM3OA==",
      "original_commit_id" : "070803dc7e741c9d43b076b06d9540c6911ee427",
      "original_line" : 89,
      "original_position" : 31,
      "original_start_line" : null,
      "path" : "src/sync.h",
      "position" : null,
      "pull_request_review_id" : 488113228,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T21:53:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/488198378",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r488198543"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/488198543"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/19918#discussion_r485102739\r\n\r\n> Maybe `LOCK_ALREADY_HELD(mutex)` would be better, comparable with `LOCK(mutex)`? [...]\r\n\r\nThis seems like a brain dump and I can't figure out the suggestion. Is it to rename one macro or rename two macros?\r\n\r\nThe point of this PR is to be a fallback if #19865 is rejected. #19865 says there should only be one assert: `AssertLockHeld`, and you should never use it unless you need to call a EXCLUSIVE_LOCKS_REQUIRED function and the compiler doesn't know the mutex is locked, and you can't annotate the current function.\r\n\r\nBecause there has been pushback against #19865, this PR keeps both asserts, but makes them more consistent with each other and chooses names that contrasts the stronger, preferred assert with the weaker, less-preferred assert.\r\n\r\nre: https://github.com/bitcoin/bitcoin/pull/19918#discussion_r487723681\r\n\r\n> In non-debug build a code like:\r\n\r\nThanks for pointing it out, I added a note. To be sure, though, your build is different different from my build, and different from the CI builds used to verify changes.",
      "commit_id" : "5c9eb2515a9e1d9ac58b29e5d8adb19748b39b17",
      "created_at" : "2020-09-14T20:24:01Z",
      "diff_hunk" : "@@ -70,13 +70,34 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n-#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n+\n+/**\n+ * Assert at compile time and run time that a mutex is locked. Has no effect\n+ * when EXCLUSIVE_LOCKS_REQUIRED annotations are enforced because the runtime\n+ * assertions will never trigger (analogous to asserting an unsigned int is\n+ * greator or equal to 0).\n+ *\n+ * Use of this macro is neither encouraged nor discouraged in new code. It was\n+ * historically used before compile time checks were available, but it may\n+ * still be be useful for virtual methods or std::function callbacks where\n+ * EXCLUSIVE_LOCKS_REQUIRED annotations are not enforced.\n+ */\n+#define AssertLockHeld(mutex) [&]() EXCLUSIVE_LOCKS_REQUIRED(mutex) { AssertLockHeldInternal(#mutex, __FILE__, __LINE__, &mutex); }()\n+\n+/**\n+ * Assert at runtime that a mutex is locked. May be necessary to work around\n+ * EXCLUSIVE_LOCKS_REQUIRED errors when the compiler can't determine that a\n+ * mutex is locked.\n+ */\n+#define WeaklyAssertLockHeld(mutex) [&]() ASSERT_EXCLUSIVE_LOCK(mutex) { AssertLockHeldInternal(#mutex, __FILE__, __LINE__, &mutex); }()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r488198543",
      "id" : 488198543,
      "in_reply_to_id" : 485102739,
      "line" : 101,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE5ODU0Mw==",
      "original_commit_id" : "070803dc7e741c9d43b076b06d9540c6911ee427",
      "original_line" : 101,
      "original_position" : 40,
      "original_start_line" : null,
      "path" : "src/sync.h",
      "position" : 43,
      "pull_request_review_id" : 488113228,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T21:53:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/488198543",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r488198641"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/488198641"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "re: https://github.com/bitcoin/bitcoin/pull/19918#discussion_r487727569\r\n\r\n> As above, maybe replace \"assert at compile time\" with \"warn at compile time\"?\r\n\r\nThanks, added a note about build differences. Assert is in the name of the function and is the commonly used name for a correctness check which isn't supposed to affect normal behavior, so I didn't change the top description.",
      "commit_id" : "5c9eb2515a9e1d9ac58b29e5d8adb19748b39b17",
      "created_at" : "2020-09-14T20:24:12Z",
      "diff_hunk" : "@@ -70,13 +70,34 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n-#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n+\n+/**\n+ * Assert at compile time and run time that a mutex is locked. Has no effect\n+ * when EXCLUSIVE_LOCKS_REQUIRED annotations are enforced because the runtime\n+ * assertions will never trigger (analogous to asserting an unsigned int is\n+ * greator or equal to 0).\n+ *\n+ * Use of this macro is neither encouraged nor discouraged in new code. It was\n+ * historically used before compile time checks were available, but it may\n+ * still be be useful for virtual methods or std::function callbacks where\n+ * EXCLUSIVE_LOCKS_REQUIRED annotations are not enforced.\n+ */\n+#define AssertLockHeld(mutex) [&]() EXCLUSIVE_LOCKS_REQUIRED(mutex) { AssertLockHeldInternal(#mutex, __FILE__, __LINE__, &mutex); }()\n+\n+/**\n+ * Assert at runtime that a mutex is locked. May be necessary to work around\n+ * EXCLUSIVE_LOCKS_REQUIRED errors when the compiler can't determine that a\n+ * mutex is locked.\n+ */\n+#define WeaklyAssertLockHeld(mutex) [&]() ASSERT_EXCLUSIVE_LOCK(mutex) { AssertLockHeldInternal(#mutex, __FILE__, __LINE__, &mutex); }()\n+\n+/** Assert at compile time and run time that a mutex is not locked. */",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r488198641",
      "id" : 488198641,
      "in_reply_to_id" : 487727569,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODE5ODY0MQ==",
      "original_commit_id" : "070803dc7e741c9d43b076b06d9540c6911ee427",
      "original_line" : 100,
      "original_position" : 42,
      "original_start_line" : null,
      "path" : "src/sync.h",
      "position" : null,
      "pull_request_review_id" : 488113228,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T21:53:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/488198641",
      "user" : {
         "avatar_url" : "https://avatars2.githubusercontent.com/u/7133040?v=4",
         "events_url" : "https://api.github.com/users/ryanofsky/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ryanofsky/followers",
         "following_url" : "https://api.github.com/users/ryanofsky/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ryanofsky/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ryanofsky",
         "id" : 7133040,
         "login" : "ryanofsky",
         "node_id" : "MDQ6VXNlcjcxMzMwNDA=",
         "organizations_url" : "https://api.github.com/users/ryanofsky/orgs",
         "received_events_url" : "https://api.github.com/users/ryanofsky/received_events",
         "repos_url" : "https://api.github.com/users/ryanofsky/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ryanofsky/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ryanofsky"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r488279455"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/488279455"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> But given that, it makes sense to use `AssertLockHeld` instead of `WeaklyAssertLockHeld` to provide runtime checking inside a lambda annotated with `EXCLUSIVE_LOCKS_REQUIRED` called through a `std::function`\r\n\r\nBoth the current `LockAssertion` and your proposed `WeaklyAssertLockHeld` do runtime checking, so there's no advantage there.\r\n\r\nI don't think AssertLockHeld in lambdas ever makes much sense: there are two ways to use lambdas -- one where thread safety annotations work as expected, and one where they're broken because the lambda's a callback passed to an unannotated function. In the former case you're writing:\r\n\r\n```c++\r\n    LOCK(cs);\r\n    [&]() EXCLUSIVE_LOCKS_REQUIRED(cs) { ++foo; }();\r\n```\r\n\r\nwhere it's already obvious that `cs` is held when the lambda is called, and you're just adding the annotation to make the compiler happy.\r\n\r\nIn the latter case, you're writing:\r\n\r\n```c++\r\n    LOCK(cs_main);\r\n    connman->ForEachNode([&](CNode* pnode) {\r\n        WeaklyAssertLockHeld(cs_main);\r\n        ...\r\n    });\r\n```\r\nbecause you can't pass the fact that `cs_main` is still held through the un-annotated `ForEachNode`. \r\n\r\n> inside an overridden virtual method annotated `EXCLUSIVE_LOCKS_REQUIRED` called through a base method which is not annotated.\r\n\r\nI think that is something we should go out of our way to avoid. Either the base method should be annotated as requiring the lock, or the overriding method should acquire the lock itself -- with annotations, locking is part of the function signature, and you shouldn't change the signature when overriding a method. We don't have any code like this now, and I don't think there's any reason ever to, so I'm not sure it's worth addressing it explicitly, but if we are, better to discourage it outright.\r\n",
      "commit_id" : "5c9eb2515a9e1d9ac58b29e5d8adb19748b39b17",
      "created_at" : "2020-09-14T22:45:36Z",
      "diff_hunk" : "@@ -70,13 +70,34 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n-#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n+\n+/**\n+ * Assert at compile time and run time that a mutex is locked. Has no effect\n+ * when EXCLUSIVE_LOCKS_REQUIRED annotations are enforced because the runtime\n+ * assertions will never trigger (analogous to asserting an unsigned int is\n+ * greator or equal to 0).\n+ *\n+ * Use of this macro is neither encouraged nor discouraged in new code. It was\n+ * historically used before compile time checks were available, but it may\n+ * still be be useful for virtual methods or std::function callbacks where\n+ * EXCLUSIVE_LOCKS_REQUIRED annotations are not enforced.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r488279455",
      "id" : 488279455,
      "in_reply_to_id" : 485066540,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3OTQ1NQ==",
      "original_commit_id" : "070803dc7e741c9d43b076b06d9540c6911ee427",
      "original_line" : 89,
      "original_position" : 31,
      "original_start_line" : null,
      "path" : "src/sync.h",
      "position" : null,
      "pull_request_review_id" : 488206343,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T22:45:37Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/488279455",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r488282255"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/488282255"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "> This seems like a brain dump and I can't figure out the suggestion. Is it to rename one macro or rename two macros?\r\n\r\nJust to rename \"WeaklyAssertLockHeld\" to \"LOCK_ALREADY_HELD\" or similar.\r\n\r\nI don't think it's accurate to say one is \"less-preferred\" to the other -- they do different things, and are appropriate in different circumstances. Hopefully the circumstances where WeaklyAssertLockHeld is appropriate are more rare, is all.\r\n\r\n> \"Assert that a mutex was already locked in any possible way this code could be reached. If DEBUG_LOCKORDER is defined, a runtime check that the mutex was actually locked by this thread will be made.\"\r\n\r\nwas a suggestion regarding the code docs, since it only has any runtime effect when DEBUG_LOCKORDER is defined.",
      "commit_id" : "5c9eb2515a9e1d9ac58b29e5d8adb19748b39b17",
      "created_at" : "2020-09-14T22:53:44Z",
      "diff_hunk" : "@@ -70,13 +70,34 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n-#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n+\n+/**\n+ * Assert at compile time and run time that a mutex is locked. Has no effect\n+ * when EXCLUSIVE_LOCKS_REQUIRED annotations are enforced because the runtime\n+ * assertions will never trigger (analogous to asserting an unsigned int is\n+ * greator or equal to 0).\n+ *\n+ * Use of this macro is neither encouraged nor discouraged in new code. It was\n+ * historically used before compile time checks were available, but it may\n+ * still be be useful for virtual methods or std::function callbacks where\n+ * EXCLUSIVE_LOCKS_REQUIRED annotations are not enforced.\n+ */\n+#define AssertLockHeld(mutex) [&]() EXCLUSIVE_LOCKS_REQUIRED(mutex) { AssertLockHeldInternal(#mutex, __FILE__, __LINE__, &mutex); }()\n+\n+/**\n+ * Assert at runtime that a mutex is locked. May be necessary to work around\n+ * EXCLUSIVE_LOCKS_REQUIRED errors when the compiler can't determine that a\n+ * mutex is locked.\n+ */\n+#define WeaklyAssertLockHeld(mutex) [&]() ASSERT_EXCLUSIVE_LOCK(mutex) { AssertLockHeldInternal(#mutex, __FILE__, __LINE__, &mutex); }()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r488282255",
      "id" : 488282255,
      "in_reply_to_id" : 485102739,
      "line" : 101,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI4MjI1NQ==",
      "original_commit_id" : "070803dc7e741c9d43b076b06d9540c6911ee427",
      "original_line" : 101,
      "original_position" : 40,
      "original_start_line" : null,
      "path" : "src/sync.h",
      "position" : 43,
      "pull_request_review_id" : 488209652,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-14T22:53:44Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/488282255",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r489772952"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/489772952"
         }
      },
      "author_association" : "NONE",
      "body" : "Thread safety attributes sit on declarations and not on types, but we can check the virtual overriding case. I'll have to look into that. (Theoretically it should be part of the type, but that would interact with other language features like overloading, so it was decided not to put it there.)",
      "commit_id" : "5c9eb2515a9e1d9ac58b29e5d8adb19748b39b17",
      "created_at" : "2020-09-16T21:46:41Z",
      "diff_hunk" : "@@ -70,13 +70,34 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n-#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n+\n+/**\n+ * Assert at compile time and run time that a mutex is locked. Has no effect\n+ * when EXCLUSIVE_LOCKS_REQUIRED annotations are enforced because the runtime\n+ * assertions will never trigger (analogous to asserting an unsigned int is\n+ * greator or equal to 0).\n+ *\n+ * Use of this macro is neither encouraged nor discouraged in new code. It was\n+ * historically used before compile time checks were available, but it may\n+ * still be be useful for virtual methods or std::function callbacks where\n+ * EXCLUSIVE_LOCKS_REQUIRED annotations are not enforced.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r489772952",
      "id" : 489772952,
      "in_reply_to_id" : 485066540,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc3Mjk1Mg==",
      "original_commit_id" : "070803dc7e741c9d43b076b06d9540c6911ee427",
      "original_line" : 89,
      "original_position" : 31,
      "original_start_line" : null,
      "path" : "src/sync.h",
      "position" : null,
      "pull_request_review_id" : 490043272,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-16T21:46:41Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/489772952",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1453952?v=4",
         "events_url" : "https://api.github.com/users/aaronpuchert/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aaronpuchert/followers",
         "following_url" : "https://api.github.com/users/aaronpuchert/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aaronpuchert/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aaronpuchert",
         "id" : 1453952,
         "login" : "aaronpuchert",
         "node_id" : "MDQ6VXNlcjE0NTM5NTI=",
         "organizations_url" : "https://api.github.com/users/aaronpuchert/orgs",
         "received_events_url" : "https://api.github.com/users/aaronpuchert/received_events",
         "repos_url" : "https://api.github.com/users/aaronpuchert/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aaronpuchert/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aaronpuchert/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aaronpuchert"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r489780104"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/489780104"
         }
      },
      "author_association" : "NONE",
      "body" : "> Note that ASSERT_EXCLUSIVE_LOCK has slightly weird scoping behaviour [...]\r\n\r\nThis is unrelated to scopes, the capability is assumed to be held after the assertion, regardless of whether we leave any scopes. (Think about it, there is no destructor for the assertion, so why would the scope ending change anything?)\r\n\r\nThis analysis works on the source-level CFG. We can inspect this by passing `--analyze -Xanalyzer -analyzer-checker=debug.DumpCFG` to Clang. For the first example (using the [vocabulary from the documentation](https://clang.llvm.org/docs/ThreadSafetyAnalysis.html#mutex-h)):\r\n\r\n```\r\n [B4 (ENTRY)]\r\n   Succs (1): B3\r\n\r\n [B1]\r\n   1: x\r\n   2: ++[B1.1]\r\n   Preds (2): B2 B3(Unreachable)\r\n   Succs (1): B0\r\n\r\n [B2]\r\n   1: m\r\n   2: [B2.1].AssertHeld\r\n   3: [B2.2]()\r\n   Preds (1): B3\r\n   Succs (1): B1\r\n\r\n [B3]\r\n   1: 1\r\n   2: [B3.1] (ImplicitCastExpr, IntegralToBoolean, _Bool)\r\n   T: if [B3.2]\r\n   Preds (1): B4\r\n   Succs (2): B2 B1(Unreachable)\r\n\r\n [B0 (EXIT)]\r\n   Preds (1): B1\r\n```\r\n\r\nThe `if` is in `B3` and branches on a compile-time constant, thus we see that the branch to `B1` (where the increment happens) is unreachable. In your second example the branch condition is no longer a compile-time constant. (Try adding `const` or `constexpr`, then it should work.)\r\n\r\n> This is because `ASSERT_EXCLUSIVE_LOCK` tells the compiler we are going to check, but we actually don't check (in non-debug build).\r\n\r\nUsing `ASSERT_EXCLUSIVE_LOCK` even though you don't always check is fine. It would be strange if it wasn't, because that's how the standard [assert](https://en.cppreference.com/w/cpp/error/assert) behaves.\r\n\r\n> Maybe remove `ASSERT_EXCLUSIVE_LOCK` in non-debug builds, or at least clearly explain in the comment the dangers of using this.\r\n\r\nHaving static analysis depend on the build profile doesn't really make sense IMO. If you don't have the same annotations in all profiles you're just going to make your life harder.",
      "commit_id" : "5c9eb2515a9e1d9ac58b29e5d8adb19748b39b17",
      "created_at" : "2020-09-16T22:04:12Z",
      "diff_hunk" : "@@ -70,13 +70,34 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n-#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n+\n+/**\n+ * Assert at compile time and run time that a mutex is locked. Has no effect\n+ * when EXCLUSIVE_LOCKS_REQUIRED annotations are enforced because the runtime\n+ * assertions will never trigger (analogous to asserting an unsigned int is\n+ * greator or equal to 0).\n+ *\n+ * Use of this macro is neither encouraged nor discouraged in new code. It was\n+ * historically used before compile time checks were available, but it may\n+ * still be be useful for virtual methods or std::function callbacks where\n+ * EXCLUSIVE_LOCKS_REQUIRED annotations are not enforced.\n+ */\n+#define AssertLockHeld(mutex) [&]() EXCLUSIVE_LOCKS_REQUIRED(mutex) { AssertLockHeldInternal(#mutex, __FILE__, __LINE__, &mutex); }()\n+\n+/**\n+ * Assert at runtime that a mutex is locked. May be necessary to work around\n+ * EXCLUSIVE_LOCKS_REQUIRED errors when the compiler can't determine that a\n+ * mutex is locked.\n+ */\n+#define WeaklyAssertLockHeld(mutex) [&]() ASSERT_EXCLUSIVE_LOCK(mutex) { AssertLockHeldInternal(#mutex, __FILE__, __LINE__, &mutex); }()",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r489780104",
      "id" : 489780104,
      "in_reply_to_id" : 485102739,
      "line" : 101,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc4MDEwNA==",
      "original_commit_id" : "070803dc7e741c9d43b076b06d9540c6911ee427",
      "original_line" : 101,
      "original_position" : 40,
      "original_start_line" : null,
      "path" : "src/sync.h",
      "position" : 43,
      "pull_request_review_id" : 490051944,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-16T22:04:13Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/489780104",
      "user" : {
         "avatar_url" : "https://avatars1.githubusercontent.com/u/1453952?v=4",
         "events_url" : "https://api.github.com/users/aaronpuchert/events{/privacy}",
         "followers_url" : "https://api.github.com/users/aaronpuchert/followers",
         "following_url" : "https://api.github.com/users/aaronpuchert/following{/other_user}",
         "gists_url" : "https://api.github.com/users/aaronpuchert/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/aaronpuchert",
         "id" : 1453952,
         "login" : "aaronpuchert",
         "node_id" : "MDQ6VXNlcjE0NTM5NTI=",
         "organizations_url" : "https://api.github.com/users/aaronpuchert/orgs",
         "received_events_url" : "https://api.github.com/users/aaronpuchert/received_events",
         "repos_url" : "https://api.github.com/users/aaronpuchert/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/aaronpuchert/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/aaronpuchert/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/aaronpuchert"
      }
   },
   {
      "_links" : {
         "html" : {
            "href" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r489837659"
         },
         "pull_request" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918"
         },
         "self" : {
            "href" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/489837659"
         }
      },
      "author_association" : "CONTRIBUTOR",
      "body" : "Looking through the \"thread safety\" issues on bugzilla, this seems similar to the idea \"We could warn in -Wthread-safety-attributes if a declaration has attributes that weren't visible on an earlier declaration.\" from https://bugs.llvm.org/show_bug.cgi?id=42849 ",
      "commit_id" : "5c9eb2515a9e1d9ac58b29e5d8adb19748b39b17",
      "created_at" : "2020-09-17T01:01:22Z",
      "diff_hunk" : "@@ -70,13 +70,34 @@ inline void EnterCritical(const char* pszName, const char* pszFile, int nLine, v\n inline void LeaveCritical() {}\n inline void CheckLastCritical(void* cs, std::string& lockname, const char* guardname, const char* file, int line) {}\n template <typename MutexType>\n-inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(cs) {}\n+inline void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) {}\n template <typename MutexType>\n void AssertLockNotHeldInternal(const char* pszName, const char* pszFile, int nLine, MutexType* cs) EXCLUSIVE_LOCKS_REQUIRED(!cs) {}\n inline void DeleteLock(void* cs) {}\n inline bool LockStackEmpty() { return true; }\n #endif\n-#define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n+\n+/**\n+ * Assert at compile time and run time that a mutex is locked. Has no effect\n+ * when EXCLUSIVE_LOCKS_REQUIRED annotations are enforced because the runtime\n+ * assertions will never trigger (analogous to asserting an unsigned int is\n+ * greator or equal to 0).\n+ *\n+ * Use of this macro is neither encouraged nor discouraged in new code. It was\n+ * historically used before compile time checks were available, but it may\n+ * still be be useful for virtual methods or std::function callbacks where\n+ * EXCLUSIVE_LOCKS_REQUIRED annotations are not enforced.",
      "html_url" : "https://github.com/bitcoin/bitcoin/pull/19918#discussion_r489837659",
      "id" : 489837659,
      "in_reply_to_id" : 485066540,
      "line" : null,
      "node_id" : "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTgzNzY1OQ==",
      "original_commit_id" : "070803dc7e741c9d43b076b06d9540c6911ee427",
      "original_line" : 89,
      "original_position" : 31,
      "original_start_line" : null,
      "path" : "src/sync.h",
      "position" : null,
      "pull_request_review_id" : 490174281,
      "pull_request_url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/19918",
      "side" : "RIGHT",
      "start_line" : null,
      "start_side" : null,
      "updated_at" : "2020-09-17T01:01:22Z",
      "url" : "https://api.github.com/repos/bitcoin/bitcoin/pulls/comments/489837659",
      "user" : {
         "avatar_url" : "https://avatars3.githubusercontent.com/u/127186?v=4",
         "events_url" : "https://api.github.com/users/ajtowns/events{/privacy}",
         "followers_url" : "https://api.github.com/users/ajtowns/followers",
         "following_url" : "https://api.github.com/users/ajtowns/following{/other_user}",
         "gists_url" : "https://api.github.com/users/ajtowns/gists{/gist_id}",
         "gravatar_id" : "",
         "html_url" : "https://github.com/ajtowns",
         "id" : 127186,
         "login" : "ajtowns",
         "node_id" : "MDQ6VXNlcjEyNzE4Ng==",
         "organizations_url" : "https://api.github.com/users/ajtowns/orgs",
         "received_events_url" : "https://api.github.com/users/ajtowns/received_events",
         "repos_url" : "https://api.github.com/users/ajtowns/repos",
         "site_admin" : false,
         "starred_url" : "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
         "subscriptions_url" : "https://api.github.com/users/ajtowns/subscriptions",
         "type" : "User",
         "url" : "https://api.github.com/users/ajtowns"
      }
   }
]
